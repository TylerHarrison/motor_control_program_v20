
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002dc0  00002e54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dc0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f34  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f34  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fc0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00003000  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007182  00000000  00000000  000035b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ddd  00000000  00000000  0000a732  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003368  00000000  00000000  0000c50f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001090  00000000  00000000  0000f878  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a2a  00000000  00000000  00010908  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000046a3  00000000  00000000  00012332  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  000169d5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 47 0d 	jmp	0x1a8e	; 0x1a8e <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 b6 0c 	jmp	0x196c	; 0x196c <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 f7 0b 	jmp	0x17ee	; 0x17ee <__vector_16>
      44:	0c 94 36 11 	jmp	0x226c	; 0x226c <__vector_17>
      48:	0c 94 e7 0e 	jmp	0x1dce	; 0x1dce <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 e3 0a 	jmp	0x15c6	; 0x15c6 <__vector_21>
      58:	0c 94 c5 0a 	jmp	0x158a	; 0x158a <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 1c 0b 	jmp	0x1638	; 0x1638 <__vector_32>
      84:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	b9 0e       	add	r11, r25
      96:	be 0e       	add	r11, r30
      98:	c4 0e       	add	r12, r20
      9a:	ca 0e       	add	r12, r26
      9c:	d0 0e       	add	r13, r16
      9e:	d5 0e       	add	r13, r21
      a0:	db 0e       	add	r13, r27
      a2:	e1 0e       	add	r14, r17

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e0 ec       	ldi	r30, 0xC0	; 192
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <main>
      de:	0c 94 de 16 	jmp	0x2dbc	; 0x2dbc <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 be 16 	call	0x2d7c	; 0x2d7c <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 be 16 	call	0x2d7c	; 0x2d7c <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 be 16 	call	0x2d7c	; 0x2d7c <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	11 f0       	breq	.+4      	; 0x214 <actuator_pwm+0x8>
     210:	75 9a       	sbi	0x0e, 5	; 14
     212:	08 95       	ret
     214:	75 98       	cbi	0x0e, 5	; 14
     216:	08 95       	ret

00000218 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     218:	4f 92       	push	r4
     21a:	5f 92       	push	r5
     21c:	6f 92       	push	r6
     21e:	7f 92       	push	r7
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	ec 01       	movw	r28, r24
     238:	96 2e       	mov	r9, r22
     23a:	c6 01       	movw	r24, r12
     23c:	b5 01       	movw	r22, r10
			3) actuator_duty_cycle
			4) gear_status
*/

	//float kp = 3.8; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     23e:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     242:	87 01       	movw	r16, r14
     244:	06 1b       	sub	r16, r22
     246:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
     248:	b8 01       	movw	r22, r16
     24a:	01 2e       	mov	r0, r17
     24c:	00 0c       	add	r0, r0
     24e:	88 0b       	sbc	r24, r24
     250:	99 0b       	sbc	r25, r25
     252:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
     256:	2b 01       	movw	r4, r22
     258:	3c 01       	movw	r6, r24
     25a:	23 e3       	ldi	r18, 0x33	; 51
     25c:	33 e3       	ldi	r19, 0x33	; 51
     25e:	43 e7       	ldi	r20, 0x73	; 115
     260:	50 e4       	ldi	r21, 0x40	; 64
     262:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	45 e8       	ldi	r20, 0x85	; 133
     26c:	52 e4       	ldi	r21, 0x42	; 66
     26e:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     272:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     276:	6b 01       	movw	r12, r22
     278:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 ea       	ldi	r20, 0xA0	; 160
     280:	50 e4       	ldi	r21, 0x40	; 64
     282:	c3 01       	movw	r24, r6
     284:	b2 01       	movw	r22, r4
     286:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__cmpsf2>
     28a:	88 23       	and	r24, r24
     28c:	c4 f5       	brge	.+112    	; 0x2fe <actuator_set_position+0xe6>
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	40 ea       	ldi	r20, 0xA0	; 160
     294:	50 ec       	ldi	r21, 0xC0	; 192
     296:	c3 01       	movw	r24, r6
     298:	b2 01       	movw	r22, r4
     29a:	0e 94 26 13 	call	0x264c	; 0x264c <__gesf2>
     29e:	18 16       	cp	r1, r24
     2a0:	74 f5       	brge	.+92     	; 0x2fe <actuator_set_position+0xe6>
     2a2:	30 c0       	rjmp	.+96     	; 0x304 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2a4:	8c 81       	ldd	r24, Y+4	; 0x04
     2a6:	9d 81       	ldd	r25, Y+5	; 0x05
     2a8:	00 97       	sbiw	r24, 0x00	; 0
     2aa:	29 f0       	breq	.+10     	; 0x2b6 <actuator_set_position+0x9e>
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	89 f4       	brne	.+34     	; 0x2d2 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2b0:	1b 82       	std	Y+3, r1	; 0x03
     2b2:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2b4:	0e c0       	rjmp	.+28     	; 0x2d2 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2b6:	10 16       	cp	r1, r16
     2b8:	11 06       	cpc	r1, r17
     2ba:	2c f4       	brge	.+10     	; 0x2c6 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2c6:	11 23       	and	r17, r17
     2c8:	24 f4       	brge	.+8      	; 0x2d2 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2ca:	82 e0       	ldi	r24, 0x02	; 2
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	9b 83       	std	Y+3, r25	; 0x03
     2d0:	8a 83       	std	Y+2, r24	; 0x02
     2d2:	c6 01       	movw	r24, r12
     2d4:	83 38       	cpi	r24, 0x83	; 131
     2d6:	91 05       	cpc	r25, r1
     2d8:	14 f0       	brlt	.+4      	; 0x2de <actuator_set_position+0xc6>
     2da:	82 e8       	ldi	r24, 0x82	; 130
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	6c 01       	movw	r12, r24
     2e0:	99 23       	and	r25, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <actuator_set_position+0xd0>
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2e8:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2ec:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2f0:	db 86       	std	Y+11, r13	; 0x0b
     2f2:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2f4:	4e 82       	std	Y+6, r4	; 0x06
     2f6:	5f 82       	std	Y+7, r5	; 0x07
     2f8:	68 86       	std	Y+8, r6	; 0x08
     2fa:	79 86       	std	Y+9, r7	; 0x09
}
     2fc:	0c c0       	rjmp	.+24     	; 0x316 <actuator_set_position+0xfe>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		//new_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2fe:	1d 82       	std	Y+5, r1	; 0x05
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	d0 cf       	rjmp	.-96     	; 0x2a4 <actuator_set_position+0x8c>
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9d 83       	std	Y+5, r25	; 0x05
     30a:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     30c:	89 2d       	mov	r24, r9
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	99 83       	std	Y+1, r25	; 0x01
     312:	88 83       	st	Y, r24
     314:	c7 cf       	rjmp	.-114    	; 0x2a4 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	7f 90       	pop	r7
     32e:	6f 90       	pop	r6
     330:	5f 90       	pop	r5
     332:	4f 90       	pop	r4
     334:	08 95       	ret

00000336 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     336:	af 92       	push	r10
     338:	bf 92       	push	r11
     33a:	cf 92       	push	r12
     33c:	df 92       	push	r13
     33e:	ef 92       	push	r14
     340:	ff 92       	push	r15
     342:	0f 93       	push	r16
     344:	1f 93       	push	r17
     346:	fc 01       	movw	r30, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     348:	83 a1       	ldd	r24, Z+35	; 0x23
     34a:	94 a1       	ldd	r25, Z+36	; 0x24
     34c:	89 2b       	or	r24, r25
     34e:	09 f1       	breq	.+66     	; 0x392 <actuator_p_controller+0x5c>
	{
		//ACTUATOR: set actuator position based off current state
		switch(vals->gear_required)
     350:	83 ad       	ldd	r24, Z+59	; 0x3b
     352:	81 30       	cpi	r24, 0x01	; 1
     354:	39 f0       	breq	.+14     	; 0x364 <actuator_p_controller+0x2e>
     356:	18 f0       	brcs	.+6      	; 0x35e <actuator_p_controller+0x28>
     358:	82 30       	cpi	r24, 0x02	; 2
     35a:	39 f0       	breq	.+14     	; 0x36a <actuator_p_controller+0x34>
     35c:	09 c0       	rjmp	.+18     	; 0x370 <actuator_p_controller+0x3a>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     35e:	e4 a8       	ldd	r14, Z+52	; 0x34
     360:	f5 a8       	ldd	r15, Z+53	; 0x35
				break;
     362:	08 c0       	rjmp	.+16     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     364:	e6 a8       	ldd	r14, Z+54	; 0x36
     366:	f7 a8       	ldd	r15, Z+55	; 0x37
				break;
     368:	05 c0       	rjmp	.+10     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     36a:	e0 ac       	ldd	r14, Z+56	; 0x38
     36c:	f1 ac       	ldd	r15, Z+57	; 0x39
				break;
     36e:	02 c0       	rjmp	.+4      	; 0x374 <actuator_p_controller+0x3e>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     370:	e1 2c       	mov	r14, r1
     372:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     374:	a3 a4       	ldd	r10, Z+43	; 0x2b
     376:	b4 a4       	ldd	r11, Z+44	; 0x2c
     378:	c5 a4       	ldd	r12, Z+45	; 0x2d
     37a:	d6 a4       	ldd	r13, Z+46	; 0x2e
     37c:	07 a5       	ldd	r16, Z+47	; 0x2f
     37e:	27 a1       	ldd	r18, Z+39	; 0x27
     380:	30 a5       	ldd	r19, Z+40	; 0x28
     382:	41 a5       	ldd	r20, Z+41	; 0x29
     384:	52 a5       	ldd	r21, Z+42	; 0x2a
     386:	63 ad       	ldd	r22, Z+59	; 0x3b
     388:	10 e0       	ldi	r17, 0x00	; 0
     38a:	80 ee       	ldi	r24, 0xE0	; 224
     38c:	91 e0       	ldi	r25, 0x01	; 1
     38e:	44 df       	rcall	.-376    	; 0x218 <actuator_set_position>
     390:	10 c0       	rjmp	.+32     	; 0x3b2 <actuator_p_controller+0x7c>
		//}
		
	}else
	{
		//move with uart instruction
		target_position = vals->position_uart_instruction;
     392:	e2 a8       	ldd	r14, Z+50	; 0x32
     394:	f3 a8       	ldd	r15, Z+51	; 0x33
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     396:	a3 a4       	ldd	r10, Z+43	; 0x2b
     398:	b4 a4       	ldd	r11, Z+44	; 0x2c
     39a:	c5 a4       	ldd	r12, Z+45	; 0x2d
     39c:	d6 a4       	ldd	r13, Z+46	; 0x2e
     39e:	07 a5       	ldd	r16, Z+47	; 0x2f
     3a0:	27 a1       	ldd	r18, Z+39	; 0x27
     3a2:	30 a5       	ldd	r19, Z+40	; 0x28
     3a4:	41 a5       	ldd	r20, Z+41	; 0x29
     3a6:	52 a5       	ldd	r21, Z+42	; 0x2a
     3a8:	63 ad       	ldd	r22, Z+59	; 0x3b
     3aa:	10 e0       	ldi	r17, 0x00	; 0
     3ac:	80 ee       	ldi	r24, 0xE0	; 224
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	33 df       	rcall	.-410    	; 0x218 <actuator_set_position>

	}
}
     3b2:	1f 91       	pop	r17
     3b4:	0f 91       	pop	r16
     3b6:	ff 90       	pop	r15
     3b8:	ef 90       	pop	r14
     3ba:	df 90       	pop	r13
     3bc:	cf 90       	pop	r12
     3be:	bf 90       	pop	r11
     3c0:	af 90       	pop	r10
     3c2:	08 95       	ret

000003c4 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3c4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3c8:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3cc:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3d0:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3d4:	08 95       	ret

000003d6 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3d6:	68 2f       	mov	r22, r24
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
     3e2:	20 e0       	ldi	r18, 0x00	; 0
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	48 e4       	ldi	r20, 0x48	; 72
     3e8:	52 e4       	ldi	r21, 0x42	; 66
     3ea:	0e 94 72 11 	call	0x22e4	; 0x22e4 <__subsf3>
     3ee:	27 ed       	ldi	r18, 0xD7	; 215
     3f0:	33 ea       	ldi	r19, 0xA3	; 163
     3f2:	48 e8       	ldi	r20, 0x88	; 136
     3f4:	51 e4       	ldi	r21, 0x41	; 65
     3f6:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
     3fa:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     3fe:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     402:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     406:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     40a:	08 95       	ret

0000040c <controller>:
}

void controller(volatile ModuleValues_t *vals){
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     426:	8e 8d       	ldd	r24, Y+30	; 0x1e
     428:	82 30       	cpi	r24, 0x02	; 2
     42a:	21 f4       	brne	.+8      	; 0x434 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     42c:	68 8d       	ldd	r22, Y+24	; 0x18
     42e:	16 2f       	mov	r17, r22
     430:	11 95       	neg	r17
     432:	01 c0       	rjmp	.+2      	; 0x436 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     434:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     436:	8e 8d       	ldd	r24, Y+30	; 0x1e
     438:	81 30       	cpi	r24, 0x01	; 1
     43a:	09 f4       	brne	.+2      	; 0x43e <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     43c:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     43e:	89 a1       	ldd	r24, Y+33	; 0x21
     440:	81 11       	cpse	r24, r1
     442:	7b c0       	rjmp	.+246    	; 0x53a <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     444:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     448:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     44c:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     450:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     454:	20 e0       	ldi	r18, 0x00	; 0
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	4e eb       	ldi	r20, 0xBE	; 190
     45a:	52 e4       	ldi	r21, 0x42	; 66
     45c:	c7 01       	movw	r24, r14
     45e:	b6 01       	movw	r22, r12
     460:	0e 94 26 13 	call	0x264c	; 0x264c <__gesf2>
     464:	88 23       	and	r24, r24
     466:	54 f4       	brge	.+20     	; 0x47c <controller+0x70>
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	48 e4       	ldi	r20, 0x48	; 72
     46e:	52 e4       	ldi	r21, 0x42	; 66
     470:	c7 01       	movw	r24, r14
     472:	b6 01       	movw	r22, r12
     474:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__cmpsf2>
     478:	18 16       	cp	r1, r24
     47a:	6c f0       	brlt	.+26     	; 0x496 <controller+0x8a>
		{
			b_saturation = 1 ;
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     482:	61 2f       	mov	r22, r17
     484:	11 0f       	add	r17, r17
     486:	77 0b       	sbc	r23, r23
     488:	88 0b       	sbc	r24, r24
     48a:	99 0b       	sbc	r25, r25
     48c:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
     490:	6b 01       	movw	r12, r22
     492:	7c 01       	movw	r14, r24
     494:	25 c0       	rjmp	.+74     	; 0x4e0 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     496:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     49a:	61 2f       	mov	r22, r17
     49c:	11 0f       	add	r17, r17
     49e:	77 0b       	sbc	r23, r23
     4a0:	88 0b       	sbc	r24, r24
     4a2:	99 0b       	sbc	r25, r25
     4a4:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4ac:	2a e0       	ldi	r18, 0x0A	; 10
     4ae:	37 ed       	ldi	r19, 0xD7	; 215
     4b0:	43 ea       	ldi	r20, 0xA3	; 163
     4b2:	5b e3       	ldi	r21, 0x3B	; 59
     4b4:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     4b8:	9b 01       	movw	r18, r22
     4ba:	ac 01       	movw	r20, r24
     4bc:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4c0:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4c4:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4c8:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4cc:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     4d0:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4d4:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4d8:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     4dc:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     4e0:	27 ed       	ldi	r18, 0xD7	; 215
     4e2:	33 ea       	ldi	r19, 0xA3	; 163
     4e4:	48 e8       	ldi	r20, 0x88	; 136
     4e6:	51 e4       	ldi	r21, 0x41	; 65
     4e8:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4ec:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4f0:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4f4:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4f8:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     4fc:	4b 01       	movw	r8, r22
     4fe:	5c 01       	movw	r10, r24
     500:	27 e8       	ldi	r18, 0x87	; 135
     502:	3f eb       	ldi	r19, 0xBF	; 191
     504:	46 e2       	ldi	r20, 0x26	; 38
     506:	5e e3       	ldi	r21, 0x3E	; 62
     508:	c7 01       	movw	r24, r14
     50a:	b6 01       	movw	r22, r12
     50c:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     510:	9b 01       	movw	r18, r22
     512:	ac 01       	movw	r20, r24
     514:	c5 01       	movw	r24, r10
     516:	b4 01       	movw	r22, r8
     518:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 e4       	ldi	r20, 0x48	; 72
     522:	52 e4       	ldi	r21, 0x42	; 66
     524:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     528:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     52c:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     530:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     534:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     538:	11 c0       	rjmp	.+34     	; 0x55c <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     53a:	89 a1       	ldd	r24, Y+33	; 0x21
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	71 f4       	brne	.+28     	; 0x55c <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     540:	69 8d       	ldd	r22, Y+25	; 0x19
     542:	70 e0       	ldi	r23, 0x00	; 0
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     54c:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     550:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     554:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     558:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     55c:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     560:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     564:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     568:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     56c:	20 e0       	ldi	r18, 0x00	; 0
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	4e eb       	ldi	r20, 0xBE	; 190
     572:	52 e4       	ldi	r21, 0x42	; 66
     574:	c7 01       	movw	r24, r14
     576:	b6 01       	movw	r22, r12
     578:	0e 94 26 13 	call	0x264c	; 0x264c <__gesf2>
     57c:	18 16       	cp	r1, r24
     57e:	6c f4       	brge	.+26     	; 0x59a <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	ae eb       	ldi	r26, 0xBE	; 190
     586:	b2 e4       	ldi	r27, 0x42	; 66
     588:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     58c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     590:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     594:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     598:	16 c0       	rjmp	.+44     	; 0x5c6 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	48 e4       	ldi	r20, 0x48	; 72
     5a0:	52 e4       	ldi	r21, 0x42	; 66
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__cmpsf2>
     5aa:	88 23       	and	r24, r24
     5ac:	64 f4       	brge	.+24     	; 0x5c6 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	a8 e4       	ldi	r26, 0x48	; 72
     5b4:	b2 e4       	ldi	r27, 0x42	; 66
     5b6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5ba:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5be:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5c2:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5c6:	06 e9       	ldi	r16, 0x96	; 150
     5c8:	10 e0       	ldi	r17, 0x00	; 0
     5ca:	f8 01       	movw	r30, r16
     5cc:	e0 80       	ld	r14, Z
     5ce:	f1 80       	ldd	r15, Z+1	; 0x01
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	48 ec       	ldi	r20, 0xC8	; 200
     5d6:	52 e4       	ldi	r21, 0x42	; 66
     5d8:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5dc:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5e0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     5e4:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     5e8:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
     5ec:	4b 01       	movw	r8, r22
     5ee:	5c 01       	movw	r10, r24
     5f0:	b7 01       	movw	r22, r14
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	90 e0       	ldi	r25, 0x00	; 0
     5f6:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     5fa:	9b 01       	movw	r18, r22
     5fc:	ac 01       	movw	r20, r24
     5fe:	c5 01       	movw	r24, r10
     600:	b4 01       	movw	r22, r8
     602:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     606:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     60a:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     60e:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     612:	f8 01       	movw	r30, r16
     614:	60 81       	ld	r22, Z
     616:	71 81       	ldd	r23, Z+1	; 0x01
     618:	00 81       	ld	r16, Z
     61a:	11 81       	ldd	r17, Z+1	; 0x01
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     624:	6b 01       	movw	r12, r22
     626:	7c 01       	movw	r14, r24
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	48 ec       	ldi	r20, 0xC8	; 200
     62e:	52 e4       	ldi	r21, 0x42	; 66
     630:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     634:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     638:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     63c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     640:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
     644:	4b 01       	movw	r8, r22
     646:	5c 01       	movw	r10, r24
     648:	b8 01       	movw	r22, r16
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     652:	9b 01       	movw	r18, r22
     654:	ac 01       	movw	r20, r24
     656:	c5 01       	movw	r24, r10
     658:	b4 01       	movw	r22, r8
     65a:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     65e:	9b 01       	movw	r18, r22
     660:	ac 01       	movw	r20, r24
     662:	c7 01       	movw	r24, r14
     664:	b6 01       	movw	r22, r12
     666:	0e 94 72 11 	call	0x22e4	; 0x22e4 <__subsf3>
     66a:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     66e:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     672:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     676:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     67a:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     67e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     682:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     686:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
     68a:	69 8f       	std	Y+25, r22	; 0x19

}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	1f 91       	pop	r17
     692:	0f 91       	pop	r16
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14
     698:	df 90       	pop	r13
     69a:	cf 90       	pop	r12
     69c:	bf 90       	pop	r11
     69e:	af 90       	pop	r10
     6a0:	9f 90       	pop	r9
     6a2:	8f 90       	pop	r8
     6a4:	08 95       	ret

000006a6 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6a6:	53 9a       	sbi	0x0a, 3	; 10
     6a8:	08 95       	ret

000006aa <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	11 f4       	brne	.+4      	; 0x6b2 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6ae:	5b 9a       	sbi	0x0b, 3	; 11
     6b0:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6b2:	5b 98       	cbi	0x0b, 3	; 11
     6b4:	08 95       	ret

000006b6 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6bc:	6a ef       	ldi	r22, 0xFA	; 250
     6be:	71 e0       	ldi	r23, 0x01	; 1
     6c0:	80 e0       	ldi	r24, 0x00	; 0
     6c2:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6c6:	21 e0       	ldi	r18, 0x01	; 1
     6c8:	43 e0       	ldi	r20, 0x03	; 3
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	67 ef       	ldi	r22, 0xF7	; 247
     6ce:	71 e0       	ldi	r23, 0x01	; 1
     6d0:	8a ef       	ldi	r24, 0xFA	; 250
     6d2:	91 e0       	ldi	r25, 0x01	; 1
     6d4:	0e 94 12 11 	call	0x2224	; 0x2224 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6d8:	e7 ef       	ldi	r30, 0xF7	; 247
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	61 81       	ldd	r22, Z+1	; 0x01
     6de:	6f 71       	andi	r22, 0x1F	; 31
     6e0:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	76 2f       	mov	r23, r22
     6e6:	66 27       	eor	r22, r22
     6e8:	82 81       	ldd	r24, Z+2	; 0x02
     6ea:	68 2b       	or	r22, r24
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     6f4:	20 e0       	ldi	r18, 0x00	; 0
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	49 e8       	ldi	r20, 0x89	; 137
     6fa:	52 e4       	ldi	r21, 0x42	; 66
     6fc:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	40 e2       	ldi	r20, 0x20	; 32
     706:	51 e4       	ldi	r21, 0x41	; 65
     708:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     70c:	20 e0       	ldi	r18, 0x00	; 0
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	48 e8       	ldi	r20, 0x88	; 136
     712:	51 e4       	ldi	r21, 0x41	; 65
     714:	0e 94 72 11 	call	0x22e4	; 0x22e4 <__subsf3>
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     722:	68 83       	st	Y, r22
     724:	79 83       	std	Y+1, r23	; 0x01
     726:	8a 83       	std	Y+2, r24	; 0x02
     728:	9b 83       	std	Y+3, r25	; 0x03
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	08 95       	ret

00000730 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     736:	6a ef       	ldi	r22, 0xFA	; 250
     738:	71 e0       	ldi	r23, 0x01	; 1
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     740:	21 e0       	ldi	r18, 0x01	; 1
     742:	43 e0       	ldi	r20, 0x03	; 3
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	67 ef       	ldi	r22, 0xF7	; 247
     748:	71 e0       	ldi	r23, 0x01	; 1
     74a:	8a ef       	ldi	r24, 0xFA	; 250
     74c:	91 e0       	ldi	r25, 0x01	; 1
     74e:	0e 94 12 11 	call	0x2224	; 0x2224 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     752:	e7 ef       	ldi	r30, 0xF7	; 247
     754:	f1 e0       	ldi	r31, 0x01	; 1
     756:	61 81       	ldd	r22, Z+1	; 0x01
     758:	6f 71       	andi	r22, 0x1F	; 31
     75a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     75c:	70 e0       	ldi	r23, 0x00	; 0
     75e:	76 2f       	mov	r23, r22
     760:	66 27       	eor	r22, r22
     762:	82 81       	ldd	r24, Z+2	; 0x02
     764:	68 2b       	or	r22, r24
     766:	41 e0       	ldi	r20, 0x01	; 1
     768:	ce 01       	movw	r24, r28
     76a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <handle_current_sensor>
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	08 95       	ret

00000774 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     77a:	6a ef       	ldi	r22, 0xFA	; 250
     77c:	71 e0       	ldi	r23, 0x01	; 1
     77e:	84 e0       	ldi	r24, 0x04	; 4
     780:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     784:	21 e0       	ldi	r18, 0x01	; 1
     786:	43 e0       	ldi	r20, 0x03	; 3
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	67 ef       	ldi	r22, 0xF7	; 247
     78c:	71 e0       	ldi	r23, 0x01	; 1
     78e:	8a ef       	ldi	r24, 0xFA	; 250
     790:	91 e0       	ldi	r25, 0x01	; 1
     792:	0e 94 12 11 	call	0x2224	; 0x2224 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     796:	e7 ef       	ldi	r30, 0xF7	; 247
     798:	f1 e0       	ldi	r31, 0x01	; 1
     79a:	61 81       	ldd	r22, Z+1	; 0x01
     79c:	6f 71       	andi	r22, 0x1F	; 31
     79e:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7a0:	70 e0       	ldi	r23, 0x00	; 0
     7a2:	76 2f       	mov	r23, r22
     7a4:	66 27       	eor	r22, r22
     7a6:	82 81       	ldd	r24, Z+2	; 0x02
     7a8:	68 2b       	or	r22, r24
     7aa:	ce 01       	movw	r24, r28
     7ac:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <handle_temp_sensor>
}
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	08 95       	ret

000007b6 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7b6:	0f 93       	push	r16
     7b8:	1f 93       	push	r17
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	00 d0       	rcall	.+0      	; 0x7c0 <SPI_handler_6+0xa>
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <SPI_handler_6+0xc>
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
     7c6:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7c8:	6a ef       	ldi	r22, 0xFA	; 250
     7ca:	71 e0       	ldi	r23, 0x01	; 1
     7cc:	86 e0       	ldi	r24, 0x06	; 6
     7ce:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	43 e0       	ldi	r20, 0x03	; 3
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	67 ef       	ldi	r22, 0xF7	; 247
     7da:	71 e0       	ldi	r23, 0x01	; 1
     7dc:	8a ef       	ldi	r24, 0xFA	; 250
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	0e 94 12 11 	call	0x2224	; 0x2224 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7e4:	e7 ef       	ldi	r30, 0xF7	; 247
     7e6:	f1 e0       	ldi	r31, 0x01	; 1
     7e8:	61 81       	ldd	r22, Z+1	; 0x01
     7ea:	6f 71       	andi	r22, 0x1F	; 31
     7ec:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     7ee:	70 e0       	ldi	r23, 0x00	; 0
     7f0:	76 2f       	mov	r23, r22
     7f2:	66 27       	eor	r22, r22
     7f4:	82 81       	ldd	r24, Z+2	; 0x02
     7f6:	68 2b       	or	r22, r24
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     800:	20 e0       	ldi	r18, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	40 ea       	ldi	r20, 0xA0	; 160
     806:	50 e4       	ldi	r21, 0x40	; 64
     808:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     80c:	20 e0       	ldi	r18, 0x00	; 0
     80e:	30 e0       	ldi	r19, 0x00	; 0
     810:	40 e8       	ldi	r20, 0x80	; 128
     812:	59 e3       	ldi	r21, 0x39	; 57
     814:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     818:	69 83       	std	Y+1, r22	; 0x01
     81a:	7a 83       	std	Y+2, r23	; 0x02
     81c:	8b 83       	std	Y+3, r24	; 0x03
     81e:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     820:	69 81       	ldd	r22, Y+1	; 0x01
     822:	7a 81       	ldd	r23, Y+2	; 0x02
     824:	8b 81       	ldd	r24, Y+3	; 0x03
     826:	9c 81       	ldd	r25, Y+4	; 0x04
     828:	20 e0       	ldi	r18, 0x00	; 0
     82a:	30 e0       	ldi	r19, 0x00	; 0
     82c:	48 ec       	ldi	r20, 0xC8	; 200
     82e:	52 e4       	ldi	r21, 0x42	; 66
     830:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     834:	20 e0       	ldi	r18, 0x00	; 0
     836:	30 e0       	ldi	r19, 0x00	; 0
     838:	48 ec       	ldi	r20, 0xC8	; 200
     83a:	51 e4       	ldi	r21, 0x41	; 65
     83c:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
     840:	f8 01       	movw	r30, r16
     842:	60 83       	st	Z, r22
     844:	71 83       	std	Z+1, r23	; 0x01
     846:	82 83       	std	Z+2, r24	; 0x02
     848:	93 83       	std	Z+3, r25	; 0x03
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	0f 90       	pop	r0
     850:	0f 90       	pop	r0
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	08 95       	ret

0000085c <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     85c:	cf 93       	push	r28
     85e:	df 93       	push	r29
     860:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     862:	6a ef       	ldi	r22, 0xFA	; 250
     864:	71 e0       	ldi	r23, 0x01	; 1
     866:	87 e0       	ldi	r24, 0x07	; 7
     868:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     86c:	21 e0       	ldi	r18, 0x01	; 1
     86e:	43 e0       	ldi	r20, 0x03	; 3
     870:	50 e0       	ldi	r21, 0x00	; 0
     872:	67 ef       	ldi	r22, 0xF7	; 247
     874:	71 e0       	ldi	r23, 0x01	; 1
     876:	8a ef       	ldi	r24, 0xFA	; 250
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	0e 94 12 11 	call	0x2224	; 0x2224 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     87e:	e7 ef       	ldi	r30, 0xF7	; 247
     880:	f1 e0       	ldi	r31, 0x01	; 1
     882:	61 81       	ldd	r22, Z+1	; 0x01
     884:	6f 71       	andi	r22, 0x1F	; 31
     886:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	76 2f       	mov	r23, r22
     88c:	66 27       	eor	r22, r22
     88e:	82 81       	ldd	r24, Z+2	; 0x02
     890:	68 2b       	or	r22, r24
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	ce 01       	movw	r24, r28
     896:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <handle_current_sensor>
}
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	8c 01       	movw	r16, r24
     8aa:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8ac:	cb 01       	movw	r24, r22
     8ae:	0e 94 2d 10 	call	0x205a	; 0x205a <can_read_message_if_new>
     8b2:	88 23       	and	r24, r24
     8b4:	09 f4       	brne	.+2      	; 0x8b8 <handle_can+0x18>
     8b6:	46 c0       	rjmp	.+140    	; 0x944 <handle_can+0xa4>
     8b8:	f8 01       	movw	r30, r16
     8ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     8bc:	84 30       	cpi	r24, 0x04	; 4
     8be:	09 f4       	brne	.+2      	; 0x8c2 <handle_can+0x22>
     8c0:	41 c0       	rjmp	.+130    	; 0x944 <handle_can+0xa4>
		switch (rx->id){
     8c2:	88 81       	ld	r24, Y
     8c4:	99 81       	ldd	r25, Y+1	; 0x01
     8c6:	80 32       	cpi	r24, 0x20	; 32
     8c8:	f1 e0       	ldi	r31, 0x01	; 1
     8ca:	9f 07       	cpc	r25, r31
     8cc:	91 f1       	breq	.+100    	; 0x932 <handle_can+0x92>
     8ce:	80 33       	cpi	r24, 0x30	; 48
     8d0:	92 40       	sbci	r25, 0x02	; 2
     8d2:	c1 f5       	brne	.+112    	; 0x944 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	f8 01       	movw	r30, r16
     8d8:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     8da:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     8dc:	82 e3       	ldi	r24, 0x32	; 50
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	93 8f       	std	Z+27, r25	; 0x1b
     8e2:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     8e4:	8e 81       	ldd	r24, Y+6	; 0x06
     8e6:	89 30       	cpi	r24, 0x09	; 9
     8e8:	40 f0       	brcs	.+16     	; 0x8fa <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     8ea:	86 95       	lsr	r24
     8ec:	86 95       	lsr	r24
     8ee:	86 95       	lsr	r24
     8f0:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     8f2:	8e e1       	ldi	r24, 0x1E	; 30
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	95 8f       	std	Z+29, r25	; 0x1d
     8f8:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     8fa:	8f 81       	ldd	r24, Y+7	; 0x07
     8fc:	89 30       	cpi	r24, 0x09	; 9
     8fe:	88 f0       	brcs	.+34     	; 0x922 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     900:	8d 81       	ldd	r24, Y+5	; 0x05
     902:	9d ec       	ldi	r25, 0xCD	; 205
     904:	89 9f       	mul	r24, r25
     906:	81 2d       	mov	r24, r1
     908:	11 24       	eor	r1, r1
     90a:	86 95       	lsr	r24
     90c:	86 95       	lsr	r24
     90e:	86 95       	lsr	r24
     910:	f8 01       	movw	r30, r16
     912:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     914:	8e e1       	ldi	r24, 0x1E	; 30
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	95 8f       	std	Z+29, r25	; 0x1d
     91a:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     91c:	8f 81       	ldd	r24, Y+7	; 0x07
     91e:	89 30       	cpi	r24, 0x09	; 9
     920:	10 f4       	brcc	.+4      	; 0x926 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     922:	f8 01       	movw	r30, r16
     924:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     926:	8e 81       	ldd	r24, Y+6	; 0x06
     928:	89 30       	cpi	r24, 0x09	; 9
     92a:	60 f4       	brcc	.+24     	; 0x944 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     92c:	f8 01       	movw	r30, r16
     92e:	17 8a       	std	Z+23, r1	; 0x17
     930:	09 c0       	rjmp	.+18     	; 0x944 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	f8 01       	movw	r30, r16
     936:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	96 8b       	std	Z+22, r25	; 0x16
     93e:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     940:	8d 81       	ldd	r24, Y+5	; 0x05
     942:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	1f 91       	pop	r17
     94a:	0f 91       	pop	r16
     94c:	08 95       	ret

0000094e <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     94e:	0f 93       	push	r16
     950:	1f 93       	push	r17
     952:	cf 93       	push	r28
     954:	df 93       	push	r29
     956:	cd b7       	in	r28, 0x3d	; 61
     958:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     95a:	08 eb       	ldi	r16, 0xB8	; 184
     95c:	13 e0       	ldi	r17, 0x03	; 3
     95e:	80 e5       	ldi	r24, 0x50	; 80
     960:	92 e0       	ldi	r25, 0x02	; 2
     962:	f8 01       	movw	r30, r16
     964:	91 83       	std	Z+1, r25	; 0x01
     966:	80 83       	st	Z, r24
	txFrame.length = 8;
     968:	88 e0       	ldi	r24, 0x08	; 8
     96a:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     96c:	8d a1       	ldd	r24, Y+37	; 0x25
     96e:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     970:	69 85       	ldd	r22, Y+9	; 0x09
     972:	7a 85       	ldd	r23, Y+10	; 0x0a
     974:	8b 85       	ldd	r24, Y+11	; 0x0b
     976:	9c 85       	ldd	r25, Y+12	; 0x0c
     978:	20 e0       	ldi	r18, 0x00	; 0
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	40 e2       	ldi	r20, 0x20	; 32
     97e:	51 e4       	ldi	r21, 0x41	; 65
     980:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     984:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     988:	f8 01       	movw	r30, r16
     98a:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     98c:	69 89       	ldd	r22, Y+17	; 0x11
     98e:	7a 89       	ldd	r23, Y+18	; 0x12
     990:	8b 89       	ldd	r24, Y+19	; 0x13
     992:	9c 89       	ldd	r25, Y+20	; 0x14
     994:	20 e0       	ldi	r18, 0x00	; 0
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	40 e2       	ldi	r20, 0x20	; 32
     99a:	51 e4       	ldi	r21, 0x41	; 65
     99c:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     9a0:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
     9a4:	f8 01       	movw	r30, r16
     9a6:	76 83       	std	Z+6, r23	; 0x06
     9a8:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9aa:	6d 89       	ldd	r22, Y+21	; 0x15
     9ac:	7e 89       	ldd	r23, Y+22	; 0x16
     9ae:	8f 89       	ldd	r24, Y+23	; 0x17
     9b0:	98 8d       	ldd	r25, Y+24	; 0x18
     9b2:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     9b6:	07 2e       	mov	r0, r23
     9b8:	00 0c       	add	r0, r0
     9ba:	88 0b       	sbc	r24, r24
     9bc:	99 0b       	sbc	r25, r25
     9be:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	48 ec       	ldi	r20, 0xC8	; 200
     9c8:	52 e4       	ldi	r21, 0x42	; 66
     9ca:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
     9ce:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     9d2:	9b 01       	movw	r18, r22
     9d4:	77 23       	and	r23, r23
     9d6:	24 f4       	brge	.+8      	; 0x9e0 <handle_motor_status_can_msg+0x92>
     9d8:	22 27       	eor	r18, r18
     9da:	33 27       	eor	r19, r19
     9dc:	26 1b       	sub	r18, r22
     9de:	37 0b       	sbc	r19, r23
     9e0:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     9e4:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     9e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
     9ea:	7b 8d       	ldd	r23, Y+27	; 0x1b
     9ec:	08 eb       	ldi	r16, 0xB8	; 184
     9ee:	13 e0       	ldi	r17, 0x03	; 3
     9f0:	80 e0       	ldi	r24, 0x00	; 0
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
     9f8:	26 e6       	ldi	r18, 0x66	; 102
     9fa:	36 e6       	ldi	r19, 0x66	; 102
     9fc:	46 e6       	ldi	r20, 0x66	; 102
     9fe:	50 e4       	ldi	r21, 0x40	; 64
     a00:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     a04:	20 e0       	ldi	r18, 0x00	; 0
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	5f e3       	ldi	r21, 0x3F	; 63
     a0c:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
     a10:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
     a14:	f8 01       	movw	r30, r16
     a16:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a18:	89 8d       	ldd	r24, Y+25	; 0x19
     a1a:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a1c:	c8 01       	movw	r24, r16
     a1e:	0e 94 70 10 	call	0x20e0	; 0x20e0 <can_send_message>
}
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	08 95       	ret

00000a2c <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a34:	ed ea       	ldi	r30, 0xAD	; 173
     a36:	f3 e0       	ldi	r31, 0x03	; 3
     a38:	81 e5       	ldi	r24, 0x51	; 81
     a3a:	92 e0       	ldi	r25, 0x02	; 2
     a3c:	91 83       	std	Z+1, r25	; 0x01
     a3e:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a44:	21 96       	adiw	r28, 0x01	; 1
     a46:	8f ad       	ldd	r24, Y+63	; 0x3f
     a48:	21 97       	sbiw	r28, 0x01	; 1
     a4a:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a4c:	cf 01       	movw	r24, r30
     a4e:	0e 94 70 10 	call	0x20e0	; 0x20e0 <can_send_message>
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a58:	af 92       	push	r10
     a5a:	bf 92       	push	r11
     a5c:	cf 92       	push	r12
     a5e:	df 92       	push	r13
     a60:	ef 92       	push	r14
     a62:	ff 92       	push	r15
     a64:	0f 93       	push	r16
     a66:	1f 93       	push	r17
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	66 97       	sbiw	r28, 0x16	; 22
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     a7e:	fe 01       	movw	r30, r28
     a80:	31 96       	adiw	r30, 0x01	; 1
     a82:	96 e1       	ldi	r25, 0x16	; 22
     a84:	df 01       	movw	r26, r30
     a86:	1d 92       	st	X+, r1
     a88:	9a 95       	dec	r25
     a8a:	e9 f7       	brne	.-6      	; 0xa86 <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     a8c:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     a90:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     a94:	92 1b       	sub	r25, r18
     a96:	9f 71       	andi	r25, 0x1F	; 31
     a98:	09 f4       	brne	.+2      	; 0xa9c <receive_uart+0x44>
     a9a:	4e c1       	rjmp	.+668    	; 0xd38 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     a9c:	f6 01       	movw	r30, r12
     a9e:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     aa0:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     aa2:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     aa4:	66 e1       	ldi	r22, 0x16	; 22
     aa6:	ce 01       	movw	r24, r28
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	08 d5       	rcall	.+2576   	; 0x14bc <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     aac:	ce 01       	movw	r24, r28
     aae:	01 96       	adiw	r24, 0x01	; 1
     ab0:	0e 94 96 13 	call	0x272c	; 0x272c <atoi>
     ab4:	5c 01       	movw	r10, r24
     ab6:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ab8:	d6 01       	movw	r26, r12
     aba:	8d 91       	ld	r24, X+
     abc:	9c 91       	ld	r25, X
     abe:	89 2b       	or	r24, r25
     ac0:	71 f4       	brne	.+28     	; 0xade <receive_uart+0x86>
     ac2:	6f e4       	ldi	r22, 0x4F	; 79
     ac4:	71 e0       	ldi	r23, 0x01	; 1
     ac6:	ce 01       	movw	r24, r28
     ac8:	01 96       	adiw	r24, 0x01	; 1
     aca:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     ace:	89 2b       	or	r24, r25
     ad0:	31 f4       	brne	.+12     	; 0xade <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     ad2:	f6 01       	movw	r30, r12
     ad4:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	91 83       	std	Z+1, r25	; 0x01
     adc:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     ade:	d6 01       	movw	r26, r12
     ae0:	8d 91       	ld	r24, X+
     ae2:	9c 91       	ld	r25, X
     ae4:	89 2b       	or	r24, r25
     ae6:	71 f0       	breq	.+28     	; 0xb04 <receive_uart+0xac>
     ae8:	61 e6       	ldi	r22, 0x61	; 97
     aea:	71 e0       	ldi	r23, 0x01	; 1
     aec:	ce 01       	movw	r24, r28
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     af4:	89 2b       	or	r24, r25
     af6:	31 f4       	brne	.+12     	; 0xb04 <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     af8:	f6 01       	movw	r30, r12
     afa:	11 82       	std	Z+1, r1	; 0x01
     afc:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     afe:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b00:	15 8e       	std	Z+29, r1	; 0x1d
     b02:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b04:	62 e7       	ldi	r22, 0x72	; 114
     b06:	71 e0       	ldi	r23, 0x01	; 1
     b08:	ce 01       	movw	r24, r28
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     b10:	89 2b       	or	r24, r25
     b12:	11 f5       	brne	.+68     	; 0xb58 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b14:	d6 01       	movw	r26, r12
     b16:	94 96       	adiw	r26, 0x24	; 36
     b18:	1c 92       	st	X, r1
     b1a:	1e 92       	st	-X, r1
     b1c:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b1e:	da 96       	adiw	r26, 0x3a	; 58
     b20:	8c 91       	ld	r24, X
     b22:	81 30       	cpi	r24, 0x01	; 1
     b24:	51 f0       	breq	.+20     	; 0xb3a <receive_uart+0xe2>
     b26:	18 f0       	brcs	.+6      	; 0xb2e <receive_uart+0xd6>
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	89 f0       	breq	.+34     	; 0xb4e <receive_uart+0xf6>
     b2c:	15 c0       	rjmp	.+42     	; 0xb58 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b2e:	f6 01       	movw	r30, r12
     b30:	84 a9       	ldd	r24, Z+52	; 0x34
     b32:	95 a9       	ldd	r25, Z+53	; 0x35
     b34:	93 ab       	std	Z+51, r25	; 0x33
     b36:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b38:	0f c0       	rjmp	.+30     	; 0xb58 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b3a:	d6 01       	movw	r26, r12
     b3c:	d6 96       	adiw	r26, 0x36	; 54
     b3e:	8d 91       	ld	r24, X+
     b40:	9c 91       	ld	r25, X
     b42:	d7 97       	sbiw	r26, 0x37	; 55
     b44:	d3 96       	adiw	r26, 0x33	; 51
     b46:	9c 93       	st	X, r25
     b48:	8e 93       	st	-X, r24
     b4a:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b4c:	05 c0       	rjmp	.+10     	; 0xb58 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b4e:	f6 01       	movw	r30, r12
     b50:	80 ad       	ldd	r24, Z+56	; 0x38
     b52:	91 ad       	ldd	r25, Z+57	; 0x39
     b54:	93 ab       	std	Z+51, r25	; 0x33
     b56:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b58:	65 e8       	ldi	r22, 0x85	; 133
     b5a:	71 e0       	ldi	r23, 0x01	; 1
     b5c:	ce 01       	movw	r24, r28
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     b64:	89 2b       	or	r24, r25
     b66:	39 f4       	brne	.+14     	; 0xb76 <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	d6 01       	movw	r26, r12
     b6e:	94 96       	adiw	r26, 0x24	; 36
     b70:	9c 93       	st	X, r25
     b72:	8e 93       	st	-X, r24
     b74:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b76:	f6 01       	movw	r30, r12
     b78:	80 81       	ld	r24, Z
     b7a:	91 81       	ldd	r25, Z+1	; 0x01
     b7c:	89 2b       	or	r24, r25
     b7e:	39 f0       	breq	.+14     	; 0xb8e <receive_uart+0x136>
     b80:	c5 01       	movw	r24, r10
     b82:	0b 97       	sbiw	r24, 0x0b	; 11
     b84:	0a 97       	sbiw	r24, 0x0a	; 10
     b86:	18 f4       	brcc	.+6      	; 0xb8e <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     b88:	86 ef       	ldi	r24, 0xF6	; 246
     b8a:	8a 0d       	add	r24, r10
     b8c:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     b8e:	d6 01       	movw	r26, r12
     b90:	8d 91       	ld	r24, X+
     b92:	9c 91       	ld	r25, X
     b94:	11 97       	sbiw	r26, 0x01	; 1
     b96:	89 2b       	or	r24, r25
     b98:	39 f0       	breq	.+14     	; 0xba8 <receive_uart+0x150>
     b9a:	0a 30       	cpi	r16, 0x0A	; 10
     b9c:	11 05       	cpc	r17, r1
     b9e:	20 f4       	brcc	.+8      	; 0xba8 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     ba0:	8a e0       	ldi	r24, 0x0A	; 10
     ba2:	8a 19       	sub	r24, r10
     ba4:	58 96       	adiw	r26, 0x18	; 24
     ba6:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     ba8:	f6 01       	movw	r30, r12
     baa:	80 81       	ld	r24, Z
     bac:	91 81       	ldd	r25, Z+1	; 0x01
     bae:	89 2b       	or	r24, r25
     bb0:	31 f0       	breq	.+12     	; 0xbbe <receive_uart+0x166>
     bb2:	01 2b       	or	r16, r17
     bb4:	21 f4       	brne	.+8      	; 0xbbe <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bb6:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bb8:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bba:	82 e3       	ldi	r24, 0x32	; 50
     bbc:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bbe:	d6 01       	movw	r26, r12
     bc0:	93 96       	adiw	r26, 0x23	; 35
     bc2:	8d 91       	ld	r24, X+
     bc4:	9c 91       	ld	r25, X
     bc6:	94 97       	sbiw	r26, 0x24	; 36
     bc8:	01 97       	sbiw	r24, 0x01	; 1
     bca:	51 f4       	brne	.+20     	; 0xbe0 <receive_uart+0x188>
     bcc:	67 e9       	ldi	r22, 0x97	; 151
     bce:	71 e0       	ldi	r23, 0x01	; 1
     bd0:	ce 01       	movw	r24, r28
     bd2:	01 96       	adiw	r24, 0x01	; 1
     bd4:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     bd8:	89 2b       	or	r24, r25
     bda:	11 f4       	brne	.+4      	; 0xbe0 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     bdc:	f6 01       	movw	r30, r12
     bde:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     be0:	d6 01       	movw	r26, r12
     be2:	93 96       	adiw	r26, 0x23	; 35
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	94 97       	sbiw	r26, 0x24	; 36
     bea:	01 97       	sbiw	r24, 0x01	; 1
     bec:	59 f4       	brne	.+22     	; 0xc04 <receive_uart+0x1ac>
     bee:	69 e9       	ldi	r22, 0x99	; 153
     bf0:	71 e0       	ldi	r23, 0x01	; 1
     bf2:	ce 01       	movw	r24, r28
     bf4:	01 96       	adiw	r24, 0x01	; 1
     bf6:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     bfa:	89 2b       	or	r24, r25
     bfc:	19 f4       	brne	.+6      	; 0xc04 <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	f6 01       	movw	r30, r12
     c02:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c04:	d6 01       	movw	r26, r12
     c06:	93 96       	adiw	r26, 0x23	; 35
     c08:	8d 91       	ld	r24, X+
     c0a:	9c 91       	ld	r25, X
     c0c:	94 97       	sbiw	r26, 0x24	; 36
     c0e:	01 97       	sbiw	r24, 0x01	; 1
     c10:	59 f4       	brne	.+22     	; 0xc28 <receive_uart+0x1d0>
     c12:	65 eb       	ldi	r22, 0xB5	; 181
     c14:	71 e0       	ldi	r23, 0x01	; 1
     c16:	ce 01       	movw	r24, r28
     c18:	01 96       	adiw	r24, 0x01	; 1
     c1a:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     c1e:	89 2b       	or	r24, r25
     c20:	19 f4       	brne	.+6      	; 0xc28 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c22:	82 e0       	ldi	r24, 0x02	; 2
     c24:	f6 01       	movw	r30, r12
     c26:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c28:	d6 01       	movw	r26, r12
     c2a:	93 96       	adiw	r26, 0x23	; 35
     c2c:	8d 91       	ld	r24, X+
     c2e:	9c 91       	ld	r25, X
     c30:	94 97       	sbiw	r26, 0x24	; 36
     c32:	89 2b       	or	r24, r25
     c34:	59 f4       	brne	.+22     	; 0xc4c <receive_uart+0x1f4>
     c36:	6b e9       	ldi	r22, 0x9B	; 155
     c38:	71 e0       	ldi	r23, 0x01	; 1
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     c42:	89 2b       	or	r24, r25
     c44:	19 f4       	brne	.+6      	; 0xc4c <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	e0 da       	rcall	.-2624   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c4c:	f6 01       	movw	r30, r12
     c4e:	83 a1       	ldd	r24, Z+35	; 0x23
     c50:	94 a1       	ldd	r25, Z+36	; 0x24
     c52:	89 2b       	or	r24, r25
     c54:	59 f4       	brne	.+22     	; 0xc6c <receive_uart+0x214>
     c56:	63 ea       	ldi	r22, 0xA3	; 163
     c58:	71 e0       	ldi	r23, 0x01	; 1
     c5a:	ce 01       	movw	r24, r28
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     c62:	89 2b       	or	r24, r25
     c64:	19 f4       	brne	.+6      	; 0xc6c <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	d0 da       	rcall	.-2656   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c6c:	d6 01       	movw	r26, r12
     c6e:	93 96       	adiw	r26, 0x23	; 35
     c70:	8d 91       	ld	r24, X+
     c72:	9c 91       	ld	r25, X
     c74:	94 97       	sbiw	r26, 0x24	; 36
     c76:	89 2b       	or	r24, r25
     c78:	a9 f4       	brne	.+42     	; 0xca4 <receive_uart+0x24c>
     c7a:	69 ea       	ldi	r22, 0xA9	; 169
     c7c:	71 e0       	ldi	r23, 0x01	; 1
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     c86:	89 2b       	or	r24, r25
     c88:	69 f4       	brne	.+26     	; 0xca4 <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     c8a:	f6 01       	movw	r30, r12
     c8c:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     c8e:	e0 ac       	ldd	r14, Z+56	; 0x38
     c90:	f1 ac       	ldd	r15, Z+57	; 0x39
     c92:	06 a9       	ldd	r16, Z+54	; 0x36
     c94:	17 a9       	ldd	r17, Z+55	; 0x37
     c96:	24 a9       	ldd	r18, Z+52	; 0x34
     c98:	35 a9       	ldd	r19, Z+53	; 0x35
     c9a:	42 a9       	ldd	r20, Z+50	; 0x32
     c9c:	53 a9       	ldd	r21, Z+51	; 0x33
     c9e:	62 ad       	ldd	r22, Z+58	; 0x3a
     ca0:	83 ad       	ldd	r24, Z+59	; 0x3b
     ca2:	81 da       	rcall	.-2814   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     ca4:	d6 01       	movw	r26, r12
     ca6:	93 96       	adiw	r26, 0x23	; 35
     ca8:	8d 91       	ld	r24, X+
     caa:	9c 91       	ld	r25, X
     cac:	94 97       	sbiw	r26, 0x24	; 36
     cae:	89 2b       	or	r24, r25
     cb0:	b1 f4       	brne	.+44     	; 0xcde <receive_uart+0x286>
     cb2:	67 eb       	ldi	r22, 0xB7	; 183
     cb4:	71 e0       	ldi	r23, 0x01	; 1
     cb6:	ce 01       	movw	r24, r28
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     cbe:	89 2b       	or	r24, r25
     cc0:	71 f4       	brne	.+28     	; 0xcde <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	f6 01       	movw	r30, r12
     cc6:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cc8:	e0 ac       	ldd	r14, Z+56	; 0x38
     cca:	f1 ac       	ldd	r15, Z+57	; 0x39
     ccc:	06 a9       	ldd	r16, Z+54	; 0x36
     cce:	17 a9       	ldd	r17, Z+55	; 0x37
     cd0:	24 a9       	ldd	r18, Z+52	; 0x34
     cd2:	35 a9       	ldd	r19, Z+53	; 0x35
     cd4:	42 a9       	ldd	r20, Z+50	; 0x32
     cd6:	53 a9       	ldd	r21, Z+51	; 0x33
     cd8:	62 ad       	ldd	r22, Z+58	; 0x3a
     cda:	83 ad       	ldd	r24, Z+59	; 0x3b
     cdc:	64 da       	rcall	.-2872   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cde:	d6 01       	movw	r26, r12
     ce0:	93 96       	adiw	r26, 0x23	; 35
     ce2:	8d 91       	ld	r24, X+
     ce4:	9c 91       	ld	r25, X
     ce6:	94 97       	sbiw	r26, 0x24	; 36
     ce8:	89 2b       	or	r24, r25
     cea:	b1 f4       	brne	.+44     	; 0xd18 <receive_uart+0x2c0>
     cec:	67 ec       	ldi	r22, 0xC7	; 199
     cee:	71 e0       	ldi	r23, 0x01	; 1
     cf0:	ce 01       	movw	r24, r28
     cf2:	01 96       	adiw	r24, 0x01	; 1
     cf4:	0e 94 b3 13 	call	0x2766	; 0x2766 <strcmp>
     cf8:	89 2b       	or	r24, r25
     cfa:	71 f4       	brne	.+28     	; 0xd18 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     cfc:	82 e0       	ldi	r24, 0x02	; 2
     cfe:	f6 01       	movw	r30, r12
     d00:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d02:	e0 ac       	ldd	r14, Z+56	; 0x38
     d04:	f1 ac       	ldd	r15, Z+57	; 0x39
     d06:	06 a9       	ldd	r16, Z+54	; 0x36
     d08:	17 a9       	ldd	r17, Z+55	; 0x37
     d0a:	24 a9       	ldd	r18, Z+52	; 0x34
     d0c:	35 a9       	ldd	r19, Z+53	; 0x35
     d0e:	42 a9       	ldd	r20, Z+50	; 0x32
     d10:	53 a9       	ldd	r21, Z+51	; 0x33
     d12:	62 ad       	ldd	r22, Z+58	; 0x3a
     d14:	83 ad       	ldd	r24, Z+59	; 0x3b
     d16:	47 da       	rcall	.-2930   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d18:	d6 01       	movw	r26, r12
     d1a:	93 96       	adiw	r26, 0x23	; 35
     d1c:	8d 91       	ld	r24, X+
     d1e:	9c 91       	ld	r25, X
     d20:	94 97       	sbiw	r26, 0x24	; 36
     d22:	89 2b       	or	r24, r25
     d24:	41 f4       	brne	.+16     	; 0xd36 <receive_uart+0x2de>
     d26:	c5 01       	movw	r24, r10
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	87 3e       	cpi	r24, 0xE7	; 231
     d2c:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d2e:	18 f4       	brcc	.+6      	; 0xd36 <receive_uart+0x2de>
     d30:	f6 01       	movw	r30, r12
     d32:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d34:	a2 aa       	std	Z+50, r10	; 0x32
     d36:	78 d3       	rcall	.+1776   	; 0x1428 <uart0_flush>
	}
}
     d38:	66 96       	adiw	r28, 0x16	; 22
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	f8 94       	cli
     d3e:	de bf       	out	0x3e, r29	; 62
     d40:	0f be       	out	0x3f, r0	; 63
     d42:	cd bf       	out	0x3d, r28	; 61
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	bf 90       	pop	r11
     d56:	af 90       	pop	r10
     d58:	08 95       	ret

00000d5a <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d5a:	ef 92       	push	r14
     d5c:	ff 92       	push	r15
     d5e:	0f 93       	push	r16
     d60:	1f 93       	push	r17
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d6a:	88 ed       	ldi	r24, 0xD8	; 216
     d6c:	91 e0       	ldi	r25, 0x01	; 1
     d6e:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <puts>
	printf("%i", (int16_t)vals.actuator_in_position);
     d72:	8e a5       	ldd	r24, Y+46	; 0x2e
     d74:	9f a5       	ldd	r25, Y+47	; 0x2f
     d76:	9f 93       	push	r25
     d78:	8f 93       	push	r24
     d7a:	0f 2e       	mov	r0, r31
     d7c:	fa ed       	ldi	r31, 0xDA	; 218
     d7e:	ef 2e       	mov	r14, r31
     d80:	f1 e0       	ldi	r31, 0x01	; 1
     d82:	ff 2e       	mov	r15, r31
     d84:	f0 2d       	mov	r31, r0
     d86:	ff 92       	push	r15
     d88:	ef 92       	push	r14
     d8a:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     d8e:	8c e2       	ldi	r24, 0x2C	; 44
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u", vals.gear_required);
     d96:	25 96       	adiw	r28, 0x05	; 5
     d98:	8f ad       	ldd	r24, Y+63	; 0x3f
     d9a:	25 97       	sbiw	r28, 0x05	; 5
     d9c:	1f 92       	push	r1
     d9e:	8f 93       	push	r24
     da0:	0d ed       	ldi	r16, 0xDD	; 221
     da2:	11 e0       	ldi	r17, 0x01	; 1
     da4:	1f 93       	push	r17
     da6:	0f 93       	push	r16
     da8:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     dac:	8c e2       	ldi	r24, 0x2C	; 44
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.gear_status);
     db4:	24 96       	adiw	r28, 0x04	; 4
     db6:	8f ad       	ldd	r24, Y+63	; 0x3f
     db8:	24 97       	sbiw	r28, 0x04	; 4
     dba:	1f 92       	push	r1
     dbc:	8f 93       	push	r24
     dbe:	1f 93       	push	r17
     dc0:	0f 93       	push	r16
     dc2:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     dc6:	8c e2       	ldi	r24, 0x2C	; 44
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u", vals.motor_status);
     dce:	8f a1       	ldd	r24, Y+39	; 0x27
     dd0:	1f 92       	push	r1
     dd2:	8f 93       	push	r24
     dd4:	1f 93       	push	r17
     dd6:	0f 93       	push	r16
     dd8:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     ddc:	8c e2       	ldi	r24, 0x2C	; 44
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.message_mode);
     de4:	88 a5       	ldd	r24, Y+40	; 0x28
     de6:	1f 92       	push	r1
     de8:	8f 93       	push	r24
     dea:	1f 93       	push	r17
     dec:	0f 93       	push	r16
     dee:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     df2:	8c e2       	ldi	r24, 0x2C	; 44
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.u8_duty_cycle);
     dfa:	8a a1       	ldd	r24, Y+34	; 0x22
     dfc:	1f 92       	push	r1
     dfe:	8f 93       	push	r24
     e00:	1f 93       	push	r17
     e02:	0f 93       	push	r16
     e04:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e08:	8c e2       	ldi	r24, 0x2C	; 44
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e10:	6b 89       	ldd	r22, Y+19	; 0x13
     e12:	7c 89       	ldd	r23, Y+20	; 0x14
     e14:	8d 89       	ldd	r24, Y+21	; 0x15
     e16:	9e 89       	ldd	r25, Y+22	; 0x16
     e18:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     e1c:	7f 93       	push	r23
     e1e:	6f 93       	push	r22
     e20:	ff 92       	push	r15
     e22:	ef 92       	push	r14
     e24:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e28:	8c e2       	ldi	r24, 0x2C	; 44
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e30:	6c a9       	ldd	r22, Y+52	; 0x34
     e32:	7d a9       	ldd	r23, Y+53	; 0x35
     e34:	8e a9       	ldd	r24, Y+54	; 0x36
     e36:	9f a9       	ldd	r25, Y+55	; 0x37
     e38:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     e3c:	7f 93       	push	r23
     e3e:	6f 93       	push	r22
     e40:	ff 92       	push	r15
     e42:	ef 92       	push	r14
     e44:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e48:	0f b6       	in	r0, 0x3f	; 63
     e4a:	f8 94       	cli
     e4c:	de bf       	out	0x3e, r29	; 62
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	cd bf       	out	0x3d, r28	; 61
     e52:	8c e2       	ldi	r24, 0x2C	; 44
     e54:	90 e0       	ldi	r25, 0x00	; 0
     e56:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e5a:	89 85       	ldd	r24, Y+9	; 0x09
     e5c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e5e:	9f 93       	push	r25
     e60:	8f 93       	push	r24
     e62:	ff 92       	push	r15
     e64:	ef 92       	push	r14
     e66:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e6a:	8c e2       	ldi	r24, 0x2C	; 44
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%i",vals.clutch_enabled);
     e72:	8c a5       	ldd	r24, Y+44	; 0x2c
     e74:	9d a5       	ldd	r25, Y+45	; 0x2d
     e76:	9f 93       	push	r25
     e78:	8f 93       	push	r24
     e7a:	ff 92       	push	r15
     e7c:	ef 92       	push	r14
     e7e:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e82:	8c e2       	ldi	r24, 0x2C	; 44
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.position_neutral);
     e8a:	8d ad       	ldd	r24, Y+61	; 0x3d
     e8c:	9e ad       	ldd	r25, Y+62	; 0x3e
     e8e:	9f 93       	push	r25
     e90:	8f 93       	push	r24
     e92:	1f 93       	push	r17
     e94:	0f 93       	push	r16
     e96:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     e9a:	8c e2       	ldi	r24, 0x2C	; 44
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.position_gear_1);
     ea2:	21 96       	adiw	r28, 0x01	; 1
     ea4:	8e ad       	ldd	r24, Y+62	; 0x3e
     ea6:	9f ad       	ldd	r25, Y+63	; 0x3f
     ea8:	21 97       	sbiw	r28, 0x01	; 1
     eaa:	9f 93       	push	r25
     eac:	8f 93       	push	r24
     eae:	1f 93       	push	r17
     eb0:	0f 93       	push	r16
     eb2:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     eb6:	8c e2       	ldi	r24, 0x2C	; 44
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%u",vals.position_gear_2);	
     ebe:	23 96       	adiw	r28, 0x03	; 3
     ec0:	8e ad       	ldd	r24, Y+62	; 0x3e
     ec2:	9f ad       	ldd	r25, Y+63	; 0x3f
     ec4:	23 97       	sbiw	r28, 0x03	; 3
     ec6:	9f 93       	push	r25
     ec8:	8f 93       	push	r24
     eca:	1f 93       	push	r17
     ecc:	0f 93       	push	r16
     ece:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     ed2:	8c e2       	ldi	r24, 0x2C	; 44
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     eda:	88 ad       	ldd	r24, Y+56	; 0x38
     edc:	1f 92       	push	r1
     ede:	8f 93       	push	r24
     ee0:	ff 92       	push	r15
     ee2:	ef 92       	push	r14
     ee4:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	printf(",");
     ee8:	8c e2       	ldi	r24, 0x2C	; 44
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	0e 94 d7 13 	call	0x27ae	; 0x27ae <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     ef0:	68 a9       	ldd	r22, Y+48	; 0x30
     ef2:	79 a9       	ldd	r23, Y+49	; 0x31
     ef4:	8a a9       	ldd	r24, Y+50	; 0x32
     ef6:	9b a9       	ldd	r25, Y+51	; 0x33
     ef8:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
     efc:	7f 93       	push	r23
     efe:	6f 93       	push	r22
     f00:	ff 92       	push	r15
     f02:	ef 92       	push	r14
     f04:	0e 94 c4 13 	call	0x2788	; 0x2788 <printf>
	
}
     f08:	0f b6       	in	r0, 0x3f	; 63
     f0a:	f8 94       	cli
     f0c:	de bf       	out	0x3e, r29	; 62
     f0e:	0f be       	out	0x3f, r0	; 63
     f10:	cd bf       	out	0x3d, r28	; 61
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	08 95       	ret

00000f20 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f28:	8b a1       	ldd	r24, Y+35	; 0x23
     f2a:	82 30       	cpi	r24, 0x02	; 2
     f2c:	91 f1       	breq	.+100    	; 0xf92 <manage_LEDs+0x72>
     f2e:	28 f4       	brcc	.+10     	; 0xf3a <manage_LEDs+0x1a>
     f30:	88 23       	and	r24, r24
     f32:	49 f0       	breq	.+18     	; 0xf46 <manage_LEDs+0x26>
     f34:	81 30       	cpi	r24, 0x01	; 1
     f36:	19 f1       	breq	.+70     	; 0xf7e <manage_LEDs+0x5e>
     f38:	49 c0       	rjmp	.+146    	; 0xfcc <manage_LEDs+0xac>
     f3a:	84 30       	cpi	r24, 0x04	; 4
     f3c:	f1 f1       	breq	.+124    	; 0xfba <manage_LEDs+0x9a>
     f3e:	98 f1       	brcs	.+102    	; 0xfa6 <manage_LEDs+0x86>
     f40:	85 30       	cpi	r24, 0x05	; 5
     f42:	99 f0       	breq	.+38     	; 0xf6a <manage_LEDs+0x4a>
     f44:	43 c0       	rjmp	.+134    	; 0xfcc <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f46:	80 e4       	ldi	r24, 0x40	; 64
     f48:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f4c:	80 e8       	ldi	r24, 0x80	; 128
     f4e:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f52:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f54:	98 a1       	ldd	r25, Y+32	; 0x20
     f56:	89 2b       	or	r24, r25
     f58:	21 f4       	brne	.+8      	; 0xf62 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f5a:	80 e2       	ldi	r24, 0x20	; 32
     f5c:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
     f60:	35 c0       	rjmp	.+106    	; 0xfcc <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f62:	80 e2       	ldi	r24, 0x20	; 32
     f64:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
     f68:	31 c0       	rjmp	.+98     	; 0xfcc <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f6a:	80 e2       	ldi	r24, 0x20	; 32
     f6c:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f70:	80 e4       	ldi	r24, 0x40	; 64
     f72:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     f76:	80 e8       	ldi	r24, 0x80	; 128
     f78:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
		break ;
     f7c:	27 c0       	rjmp	.+78     	; 0xfcc <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     f7e:	80 e2       	ldi	r24, 0x20	; 32
     f80:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f84:	80 e8       	ldi	r24, 0x80	; 128
     f86:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     f8a:	80 e4       	ldi	r24, 0x40	; 64
     f8c:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_toggle>
		break;
     f90:	1d c0       	rjmp	.+58     	; 0xfcc <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     f92:	80 e8       	ldi	r24, 0x80	; 128
     f94:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     f98:	80 e4       	ldi	r24, 0x40	; 64
     f9a:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_toggle>
			rgbled_toggle(LED_RED);
     f9e:	80 e2       	ldi	r24, 0x20	; 32
     fa0:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_toggle>
		break;
     fa4:	13 c0       	rjmp	.+38     	; 0xfcc <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     fa6:	80 e2       	ldi	r24, 0x20	; 32
     fa8:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fac:	80 e8       	ldi	r24, 0x80	; 128
     fae:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fb2:	80 e4       	ldi	r24, 0x40	; 64
     fb4:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
		break;
     fb8:	09 c0       	rjmp	.+18     	; 0xfcc <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     fba:	80 e4       	ldi	r24, 0x40	; 64
     fbc:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fc0:	80 e8       	ldi	r24, 0x80	; 128
     fc2:	0e 94 ee 10 	call	0x21dc	; 0x21dc <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     fc6:	80 e2       	ldi	r24, 0x20	; 32
     fc8:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <rgbled_turn_on>
		break;
	}
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	08 95       	ret

00000fd2 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     fd2:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     fd4:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     fd6:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     fd8:	e9 e6       	ldi	r30, 0x69	; 105
     fda:	f0 e0       	ldi	r31, 0x00	; 0
     fdc:	80 81       	ld	r24, Z
     fde:	84 60       	ori	r24, 0x04	; 4
     fe0:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
     fe2:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
     fe4:	e9 9a       	sbi	0x1d, 1	; 29
     fe6:	08 95       	ret

00000fe8 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
     fe8:	0f 93       	push	r16
     fea:	1f 93       	push	r17
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
	
	if (*u16_counter > 70)
     ff0:	fb 01       	movw	r30, r22
     ff2:	20 81       	ld	r18, Z
     ff4:	31 81       	ldd	r19, Z+1	; 0x01
     ff6:	27 34       	cpi	r18, 0x47	; 71
     ff8:	31 05       	cpc	r19, r1
     ffa:	b8 f0       	brcs	.+46     	; 0x102a <handle_speed_sensor+0x42>
     ffc:	eb 01       	movw	r28, r22
     ffe:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    1000:	60 81       	ld	r22, Z
    1002:	71 81       	ldd	r23, Z+1	; 0x01
    1004:	80 e0       	ldi	r24, 0x00	; 0
    1006:	90 e0       	ldi	r25, 0x00	; 0
    1008:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
    100c:	9b 01       	movw	r18, r22
    100e:	ac 01       	movw	r20, r24
    1010:	60 e0       	ldi	r22, 0x00	; 0
    1012:	76 e7       	ldi	r23, 0x76	; 118
    1014:	88 e8       	ldi	r24, 0x88	; 136
    1016:	96 e4       	ldi	r25, 0x46	; 70
    1018:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
    101c:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
    1020:	f8 01       	movw	r30, r16
    1022:	71 83       	std	Z+1, r23	; 0x01
    1024:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    1026:	19 82       	std	Y+1, r1	; 0x01
    1028:	18 82       	st	Y, r1
	}	
}
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	1f 91       	pop	r17
    1030:	0f 91       	pop	r16
    1032:	08 95       	ret

00001034 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    1034:	cf 92       	push	r12
    1036:	df 92       	push	r13
    1038:	ef 92       	push	r14
    103a:	ff 92       	push	r15
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	1f 92       	push	r1
    1042:	cd b7       	in	r28, 0x3d	; 61
    1044:	de b7       	in	r29, 0x3e	; 62
    1046:	89 83       	std	Y+1, r24	; 0x01
    1048:	69 01       	movw	r12, r18
    104a:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    104c:	61 30       	cpi	r22, 0x01	; 1
    104e:	19 f5       	brne	.+70     	; 0x1096 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    1050:	69 81       	ldd	r22, Y+1	; 0x01
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
    105c:	22 e1       	ldi	r18, 0x12	; 18
    105e:	35 e8       	ldi	r19, 0x85	; 133
    1060:	41 e6       	ldi	r20, 0x61	; 97
    1062:	5e e3       	ldi	r21, 0x3E	; 62
    1064:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    1068:	a7 01       	movw	r20, r14
    106a:	96 01       	movw	r18, r12
    106c:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	48 ec       	ldi	r20, 0xC8	; 200
    1076:	52 e4       	ldi	r21, 0x42	; 66
    1078:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    107c:	20 e0       	ldi	r18, 0x00	; 0
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	48 e4       	ldi	r20, 0x48	; 72
    1082:	52 e4       	ldi	r21, 0x42	; 66
    1084:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
    1088:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
    108c:	86 2f       	mov	r24, r22
		if (Duty == 50)
    108e:	62 33       	cpi	r22, 0x32	; 50
    1090:	29 f5       	brne	.+74     	; 0x10dc <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
    1092:	84 e3       	ldi	r24, 0x34	; 52
    1094:	23 c0       	rjmp	.+70     	; 0x10dc <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    1096:	62 30       	cpi	r22, 0x02	; 2
    1098:	01 f5       	brne	.+64     	; 0x10da <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    109a:	69 81       	ldd	r22, Y+1	; 0x01
    109c:	70 e0       	ldi	r23, 0x00	; 0
    109e:	80 e0       	ldi	r24, 0x00	; 0
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	0e 94 76 12 	call	0x24ec	; 0x24ec <__floatsisf>
    10a6:	23 ee       	ldi	r18, 0xE3	; 227
    10a8:	3e ee       	ldi	r19, 0xEE	; 238
    10aa:	4b e3       	ldi	r20, 0x3B	; 59
    10ac:	5e e3       	ldi	r21, 0x3E	; 62
    10ae:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    10b2:	a7 01       	movw	r20, r14
    10b4:	96 01       	movw	r18, r12
    10b6:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__divsf3>
    10ba:	20 e0       	ldi	r18, 0x00	; 0
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	48 ec       	ldi	r20, 0xC8	; 200
    10c0:	52 e4       	ldi	r21, 0x42	; 66
    10c2:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    10c6:	20 e0       	ldi	r18, 0x00	; 0
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	48 e4       	ldi	r20, 0x48	; 72
    10cc:	52 e4       	ldi	r21, 0x42	; 66
    10ce:	0e 94 73 11 	call	0x22e6	; 0x22e6 <__addsf3>
    10d2:	0e 94 48 12 	call	0x2490	; 0x2490 <__fixunssfsi>
    10d6:	86 2f       	mov	r24, r22
    10d8:	01 c0       	rjmp	.+2      	; 0x10dc <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    10da:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    10dc:	0f 90       	pop	r0
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	ff 90       	pop	r15
    10e4:	ef 90       	pop	r14
    10e6:	df 90       	pop	r13
    10e8:	cf 90       	pop	r12
    10ea:	08 95       	ret

000010ec <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
    10f0:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    10f2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    10f4:	81 11       	cpse	r24, r1
    10f6:	08 c0       	rjmp	.+16     	; 0x1108 <__stack+0x9>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    10f8:	82 e3       	ldi	r24, 0x32	; 50
    10fa:	90 e0       	ldi	r25, 0x00	; 0
    10fc:	9b 8f       	std	Y+27, r25	; 0x1b
    10fe:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    1100:	8e e1       	ldi	r24, 0x1E	; 30
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	9d 8f       	std	Y+29, r25	; 0x1d
    1106:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1108:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    110c:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    1110:	00 97       	sbiw	r24, 0x00	; 0
    1112:	31 f0       	breq	.+12     	; 0x1120 <__stack+0x21>
	{
		fault_timeout -- ;
    1114:	01 97       	sbiw	r24, 0x01	; 1
    1116:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    111a:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    111e:	05 c0       	rjmp	.+10     	; 0x112a <__stack+0x2b>
	}else if(b_major_fault && fault_clear_count < 3){
    1120:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1124:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1126:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    112a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    112c:	82 30       	cpi	r24, 0x02	; 2
    112e:	09 f4       	brne	.+2      	; 0x1132 <__stack+0x33>
    1130:	b7 c0       	rjmp	.+366    	; 0x12a0 <__stack+0x1a1>
    1132:	30 f4       	brcc	.+12     	; 0x1140 <__stack+0x41>
    1134:	88 23       	and	r24, r24
    1136:	61 f0       	breq	.+24     	; 0x1150 <__stack+0x51>
    1138:	81 30       	cpi	r24, 0x01	; 1
    113a:	09 f4       	brne	.+2      	; 0x113e <__stack+0x3f>
    113c:	8f c0       	rjmp	.+286    	; 0x125c <__stack+0x15d>
    113e:	e1 c0       	rjmp	.+450    	; 0x1302 <__stack+0x203>
    1140:	84 30       	cpi	r24, 0x04	; 4
    1142:	09 f4       	brne	.+2      	; 0x1146 <__stack+0x47>
    1144:	cf c0       	rjmp	.+414    	; 0x12e4 <__stack+0x1e5>
    1146:	a0 f0       	brcs	.+40     	; 0x1170 <__stack+0x71>
    1148:	85 30       	cpi	r24, 0x05	; 5
    114a:	09 f4       	brne	.+2      	; 0x114e <__stack+0x4f>
    114c:	51 c0       	rjmp	.+162    	; 0x11f0 <__stack+0xf1>
    114e:	d9 c0       	rjmp	.+434    	; 0x1302 <__stack+0x203>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    1150:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1152:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1154:	89 2b       	or	r24, r25
    1156:	11 f0       	breq	.+4      	; 0x115c <__stack+0x5d>
			{
				vals->motor_status = IDLE;
    1158:	83 e0       	ldi	r24, 0x03	; 3
    115a:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    115c:	80 e0       	ldi	r24, 0x00	; 0
    115e:	a5 da       	rcall	.-2742   	; 0x6aa <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    1160:	18 a2       	std	Y+32, r1	; 0x20
    1162:	30 d9       	rcall	.-3488   	; 0x3c4 <reset_I>
			vals->u8_brake_cmd = 0;
    1164:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    1166:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    1168:	82 e3       	ldi	r24, 0x32	; 50
    116a:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    116c:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    116e:	c9 c0       	rjmp	.+402    	; 0x1302 <__stack+0x203>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    1170:	8a a1       	ldd	r24, Y+34	; 0x22
    1172:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    1174:	24 c0       	rjmp	.+72     	; 0x11be <__stack+0xbf>
    1176:	99 da       	rcall	.-2766   	; 0x6aa <drivers>
				reset_I();
    1178:	25 d9       	rcall	.-3510   	; 0x3c4 <reset_I>
    117a:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    117c:	89 8f       	std	Y+25, r24	; 0x19
    117e:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    1180:	88 23       	and	r24, r24
    1182:	69 f0       	breq	.+26     	; 0x119e <__stack+0x9f>
    1184:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    1186:	3b 85       	ldd	r19, Y+11	; 0x0b
    1188:	4c 85       	ldd	r20, Y+12	; 0x0c
    118a:	5d 85       	ldd	r21, Y+13	; 0x0d
    118c:	8b 89       	ldd	r24, Y+19	; 0x13
    118e:	9c 89       	ldd	r25, Y+20	; 0x14
    1190:	62 e0       	ldi	r22, 0x02	; 2
    1192:	50 df       	rcall	.-352    	; 0x1034 <compute_synch_duty>
    1194:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    1196:	89 8d       	ldd	r24, Y+25	; 0x19
    1198:	1e d9       	rcall	.-3524   	; 0x3d6 <set_I>
    119a:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    119c:	8e 8f       	std	Y+30, r24	; 0x1e
    119e:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11a0:	88 23       	and	r24, r24
    11a2:	69 f0       	breq	.+26     	; 0x11be <__stack+0xbf>
    11a4:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11a6:	3b 85       	ldd	r19, Y+11	; 0x0b
    11a8:	4c 85       	ldd	r20, Y+12	; 0x0c
    11aa:	5d 85       	ldd	r21, Y+13	; 0x0d
    11ac:	8b 89       	ldd	r24, Y+19	; 0x13
    11ae:	9c 89       	ldd	r25, Y+20	; 0x14
    11b0:	62 e0       	ldi	r22, 0x02	; 2
    11b2:	40 df       	rcall	.-384    	; 0x1034 <compute_synch_duty>
    11b4:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11b6:	89 8d       	ldd	r24, Y+25	; 0x19
    11b8:	0e d9       	rcall	.-3556   	; 0x3d6 <set_I>
    11ba:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    11bc:	8e 8f       	std	Y+30, r24	; 0x1e
    11be:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    11c0:	81 30       	cpi	r24, 0x01	; 1
    11c2:	09 f0       	breq	.+2      	; 0x11c6 <__stack+0xc7>
    11c4:	9e c0       	rjmp	.+316    	; 0x1302 <__stack+0x203>
    11c6:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    11c8:	81 11       	cpse	r24, r1
    11ca:	03 c0       	rjmp	.+6      	; 0x11d2 <__stack+0xd3>
    11cc:	88 8d       	ldd	r24, Y+24	; 0x18
    11ce:	88 23       	and	r24, r24
    11d0:	41 f0       	breq	.+16     	; 0x11e2 <__stack+0xe3>
    11d2:	8a ad       	ldd	r24, Y+58	; 0x3a
    11d4:	81 11       	cpse	r24, r1
    11d6:	05 c0       	rjmp	.+10     	; 0x11e2 <__stack+0xe3>
				{
					vals->motor_status = ENGAGE;
    11d8:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    11da:	8e 8f       	std	Y+30, r24	; 0x1e
    11dc:	81 e0       	ldi	r24, 0x01	; 1
    11de:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	62 da       	rcall	.-2876   	; 0x6aa <drivers>
				vals->gear_required = NEUTRAL ;
    11e6:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    11e8:	ed d8       	rcall	.-3622   	; 0x3c4 <reset_I>
    11ea:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    11ec:	89 8f       	std	Y+25, r24	; 0x19
    11ee:	89 c0       	rjmp	.+274    	; 0x1302 <__stack+0x203>
    11f0:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    11f2:	8b af       	std	Y+59, r24	; 0x3b
    11f4:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    11f8:	88 23       	and	r24, r24
    11fa:	69 f0       	breq	.+26     	; 0x1216 <__stack+0x117>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    11fc:	2a 85       	ldd	r18, Y+10	; 0x0a
    11fe:	3b 85       	ldd	r19, Y+11	; 0x0b
    1200:	4c 85       	ldd	r20, Y+12	; 0x0c
    1202:	5d 85       	ldd	r21, Y+13	; 0x0d
    1204:	6b ad       	ldd	r22, Y+59	; 0x3b
    1206:	8b 89       	ldd	r24, Y+19	; 0x13
    1208:	9c 89       	ldd	r25, Y+20	; 0x14
    120a:	14 df       	rcall	.-472    	; 0x1034 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    120c:	89 8f       	std	Y+25, r24	; 0x19
    120e:	89 8d       	ldd	r24, Y+25	; 0x19
    1210:	e2 d8       	rcall	.-3644   	; 0x3d6 <set_I>
				starting_engage = 0;
    1212:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    121a:	ce 01       	movw	r24, r28
    121c:	f7 d8       	rcall	.-3602   	; 0x40c <controller>
    121e:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1220:	44 da       	rcall	.-2936   	; 0x6aa <drivers>
    1222:	88 8d       	ldd	r24, Y+24	; 0x18
    1224:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1226:	29 f0       	breq	.+10     	; 0x1232 <__stack+0x133>
    1228:	8a ad       	ldd	r24, Y+58	; 0x3a
    122a:	81 30       	cpi	r24, 0x01	; 1
    122c:	11 f4       	brne	.+4      	; 0x1232 <__stack+0x133>
    122e:	82 e0       	ldi	r24, 0x02	; 2
    1230:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    1232:	8f 89       	ldd	r24, Y+23	; 0x17
    1234:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1236:	21 f0       	breq	.+8      	; 0x1240 <__stack+0x141>
    1238:	8a ad       	ldd	r24, Y+58	; 0x3a
    123a:	81 30       	cpi	r24, 0x01	; 1
    123c:	09 f4       	brne	.+2      	; 0x1240 <__stack+0x141>
    123e:	8e 8f       	std	Y+30, r24	; 0x1e
    1240:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    1242:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1244:	5e c0       	rjmp	.+188    	; 0x1302 <__stack+0x203>
    1246:	88 8d       	ldd	r24, Y+24	; 0x18
    1248:	81 11       	cpse	r24, r1
    124a:	5b c0       	rjmp	.+182    	; 0x1302 <__stack+0x203>
    124c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    124e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1250:	89 2b       	or	r24, r25
    1252:	09 f0       	breq	.+2      	; 0x1256 <__stack+0x157>
    1254:	56 c0       	rjmp	.+172    	; 0x1302 <__stack+0x203>
			{
				vals->motor_status = IDLE;
    1256:	83 e0       	ldi	r24, 0x03	; 3
    1258:	8e 8f       	std	Y+30, r24	; 0x1e
    125a:	53 c0       	rjmp	.+166    	; 0x1302 <__stack+0x203>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    125c:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    125e:	ce 01       	movw	r24, r28
    1260:	d5 d8       	rcall	.-3670   	; 0x40c <controller>
    1262:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1264:	22 da       	rcall	.-3004   	; 0x6aa <drivers>
    1266:	8f 89       	ldd	r24, Y+23	; 0x17
    1268:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    126a:	06 c0       	rjmp	.+12     	; 0x1278 <__stack+0x179>
    126c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    126e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1270:	89 2b       	or	r24, r25
    1272:	11 f4       	brne	.+4      	; 0x1278 <__stack+0x179>
    1274:	83 e0       	ldi	r24, 0x03	; 3
    1276:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1278:	8a a1       	ldd	r24, Y+34	; 0x22
    127a:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    127c:	41 f4       	brne	.+16     	; 0x128e <__stack+0x18f>
    127e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1280:	81 11       	cpse	r24, r1
    1282:	05 c0       	rjmp	.+10     	; 0x128e <__stack+0x18f>
    1284:	85 e0       	ldi	r24, 0x05	; 5
    1286:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    1288:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    128a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    128e:	88 8d       	ldd	r24, Y+24	; 0x18
    1290:	88 23       	and	r24, r24
    1292:	b9 f1       	breq	.+110    	; 0x1302 <__stack+0x203>
    1294:	8f 89       	ldd	r24, Y+23	; 0x17
    1296:	81 11       	cpse	r24, r1
    1298:	34 c0       	rjmp	.+104    	; 0x1302 <__stack+0x203>
			{
				vals->motor_status = BRAKE;
    129a:	82 e0       	ldi	r24, 0x02	; 2
    129c:	8e 8f       	std	Y+30, r24	; 0x1e
    129e:	31 c0       	rjmp	.+98     	; 0x1302 <__stack+0x203>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12a0:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12a2:	ce 01       	movw	r24, r28
    12a4:	b3 d8       	rcall	.-3738   	; 0x40c <controller>
    12a6:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12a8:	00 da       	rcall	.-3072   	; 0x6aa <drivers>
    12aa:	88 8d       	ldd	r24, Y+24	; 0x18
    12ac:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12ae:	06 c0       	rjmp	.+12     	; 0x12bc <__stack+0x1bd>
    12b0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12b2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12b4:	89 2b       	or	r24, r25
    12b6:	11 f4       	brne	.+4      	; 0x12bc <__stack+0x1bd>
    12b8:	83 e0       	ldi	r24, 0x03	; 3
    12ba:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12bc:	8a a1       	ldd	r24, Y+34	; 0x22
    12be:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12c0:	41 f4       	brne	.+16     	; 0x12d2 <__stack+0x1d3>
    12c2:	8a ad       	ldd	r24, Y+58	; 0x3a
    12c4:	81 11       	cpse	r24, r1
    12c6:	05 c0       	rjmp	.+10     	; 0x12d2 <__stack+0x1d3>
    12c8:	85 e0       	ldi	r24, 0x05	; 5
    12ca:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    12d2:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    12d4:	81 11       	cpse	r24, r1
    12d6:	15 c0       	rjmp	.+42     	; 0x1302 <__stack+0x203>
    12d8:	8f 89       	ldd	r24, Y+23	; 0x17
    12da:	88 23       	and	r24, r24
    12dc:	91 f0       	breq	.+36     	; 0x1302 <__stack+0x203>
			{
				vals->motor_status = ACCEL;
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	8e 8f       	std	Y+30, r24	; 0x1e
    12e2:	0f c0       	rjmp	.+30     	; 0x1302 <__stack+0x203>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    12e4:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    12e8:	81 11       	cpse	r24, r1
    12ea:	02 c0       	rjmp	.+4      	; 0x12f0 <__stack+0x1f1>
			{
				vals->motor_status = IDLE;
    12ec:	83 e0       	ldi	r24, 0x03	; 3
    12ee:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	db d9       	rcall	.-3146   	; 0x6aa <drivers>
    12f4:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    12f6:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    12f8:	65 d8       	rcall	.-3894   	; 0x3c4 <reset_I>
			reset_I(); //reset integrator
    12fa:	18 8e       	std	Y+24, r1	; 0x18
    12fc:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    12fe:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    1300:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    1302:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1304:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1306:	49 f0       	breq	.+18     	; 0x131a <__stack+0x21b>
    1308:	8e 8d       	ldd	r24, Y+30	; 0x1e
    130a:	81 30       	cpi	r24, 0x01	; 1
    130c:	31 f0       	breq	.+12     	; 0x131a <__stack+0x21b>
    130e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1310:	82 30       	cpi	r24, 0x02	; 2
    1312:	19 f0       	breq	.+6      	; 0x131a <__stack+0x21b>
    1314:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1316:	85 30       	cpi	r24, 0x05	; 5
    1318:	29 f4       	brne	.+10     	; 0x1324 <__stack+0x225>
    131a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    131c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    131e:	89 2b       	or	r24, r25
    1320:	09 f4       	brne	.+2      	; 0x1324 <__stack+0x225>
    1322:	1e 8e       	std	Y+30, r1	; 0x1e
    1324:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1326:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1328:	08 95       	ret

0000132a <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    132e:	8e b1       	in	r24, 0x0e	; 14
    1330:	87 7c       	andi	r24, 0xC7	; 199
    1332:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1334:	8d b1       	in	r24, 0x0d	; 13
    1336:	88 63       	ori	r24, 0x38	; 56
    1338:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    133a:	a1 e9       	ldi	r26, 0x91	; 145
    133c:	b0 e0       	ldi	r27, 0x00	; 0
    133e:	8c 91       	ld	r24, X
    1340:	80 61       	ori	r24, 0x10	; 16
    1342:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    1344:	8c 91       	ld	r24, X
    1346:	87 7f       	andi	r24, 0xF7	; 247
    1348:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    134a:	e0 e9       	ldi	r30, 0x90	; 144
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	80 81       	ld	r24, Z
    1350:	82 60       	ori	r24, 0x02	; 2
    1352:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    1354:	80 81       	ld	r24, Z
    1356:	8e 7f       	andi	r24, 0xFE	; 254
    1358:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    135a:	80 81       	ld	r24, Z
    135c:	80 68       	ori	r24, 0x80	; 128
    135e:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    1360:	80 81       	ld	r24, Z
    1362:	8f 7b       	andi	r24, 0xBF	; 191
    1364:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    1366:	80 81       	ld	r24, Z
    1368:	80 62       	ori	r24, 0x20	; 32
    136a:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    136c:	80 81       	ld	r24, Z
    136e:	8f 7e       	andi	r24, 0xEF	; 239
    1370:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    1372:	80 81       	ld	r24, Z
    1374:	88 60       	ori	r24, 0x08	; 8
    1376:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    1378:	80 81       	ld	r24, Z
    137a:	8b 7f       	andi	r24, 0xFB	; 251
    137c:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    137e:	8c 91       	ld	r24, X
    1380:	81 60       	ori	r24, 0x01	; 1
    1382:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    1384:	8c 91       	ld	r24, X
    1386:	89 7f       	andi	r24, 0xF9	; 249
    1388:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    138a:	c6 e9       	ldi	r28, 0x96	; 150
    138c:	d0 e0       	ldi	r29, 0x00	; 0
    138e:	85 e8       	ldi	r24, 0x85	; 133
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	99 83       	std	Y+1, r25	; 0x01
    1394:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    1396:	68 81       	ld	r22, Y
    1398:	79 81       	ldd	r23, Y+1	; 0x01
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
    13a2:	20 e0       	ldi	r18, 0x00	; 0
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	40 e0       	ldi	r20, 0x00	; 0
    13a8:	5f e3       	ldi	r21, 0x3F	; 63
    13aa:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    13ae:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
    13b2:	e8 e9       	ldi	r30, 0x98	; 152
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	71 83       	std	Z+1, r23	; 0x01
    13b8:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    13ba:	88 81       	ld	r24, Y
    13bc:	99 81       	ldd	r25, Y+1	; 0x01
    13be:	20 81       	ld	r18, Z
    13c0:	31 81       	ldd	r19, Z+1	; 0x01
    13c2:	82 1b       	sub	r24, r18
    13c4:	93 0b       	sbc	r25, r19
    13c6:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    13ca:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    13ce:	68 81       	ld	r22, Y
    13d0:	79 81       	ldd	r23, Y+1	; 0x01
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	0e 94 74 12 	call	0x24e8	; 0x24e8 <__floatunsisf>
    13da:	20 e0       	ldi	r18, 0x00	; 0
    13dc:	30 e0       	ldi	r19, 0x00	; 0
    13de:	40 e0       	ldi	r20, 0x00	; 0
    13e0:	5f e3       	ldi	r21, 0x3F	; 63
    13e2:	0e 94 2a 13 	call	0x2654	; 0x2654 <__mulsf3>
    13e6:	0e 94 43 12 	call	0x2486	; 0x2486 <__fixsfsi>
    13ea:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    13ee:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    13f2:	df 91       	pop	r29
    13f4:	cf 91       	pop	r28
    13f6:	08 95       	ret

000013f8 <uart0_putc>:
    13f8:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    13fc:	9f 5f       	subi	r25, 0xFF	; 255
    13fe:	9f 71       	andi	r25, 0x1F	; 31
    1400:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1404:	92 17       	cp	r25, r18
    1406:	e1 f3       	breq	.-8      	; 0x1400 <uart0_putc+0x8>
    1408:	e9 2f       	mov	r30, r25
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	e5 5d       	subi	r30, 0xD5	; 213
    140e:	fb 4f       	sbci	r31, 0xFB	; 251
    1410:	80 83       	st	Z, r24
    1412:	2f b7       	in	r18, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    141a:	e1 ec       	ldi	r30, 0xC1	; 193
    141c:	f0 e0       	ldi	r31, 0x00	; 0
    141e:	80 81       	ld	r24, Z
    1420:	80 62       	ori	r24, 0x20	; 32
    1422:	80 83       	st	Z, r24
    1424:	2f bf       	out	0x3f, r18	; 63
    1426:	08 95       	ret

00001428 <uart0_flush>:
    1428:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    142c:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    1430:	98 13       	cpse	r25, r24
    1432:	fa cf       	rjmp	.-12     	; 0x1428 <uart0_flush>
    1434:	08 95       	ret

00001436 <uart1_putc>:
    1436:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    143a:	9f 5f       	subi	r25, 0xFF	; 255
    143c:	9f 71       	andi	r25, 0x1F	; 31
    143e:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    1442:	92 17       	cp	r25, r18
    1444:	e1 f3       	breq	.-8      	; 0x143e <uart1_putc+0x8>
    1446:	e9 2f       	mov	r30, r25
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	ea 51       	subi	r30, 0x1A	; 26
    144c:	fc 4f       	sbci	r31, 0xFC	; 252
    144e:	80 83       	st	Z, r24
    1450:	2f b7       	in	r18, 0x3f	; 63
    1452:	f8 94       	cli
    1454:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    1458:	e9 ec       	ldi	r30, 0xC9	; 201
    145a:	f0 e0       	ldi	r31, 0x00	; 0
    145c:	80 81       	ld	r24, Z
    145e:	80 62       	ori	r24, 0x20	; 32
    1460:	80 83       	st	Z, r24
    1462:	2f bf       	out	0x3f, r18	; 63
    1464:	08 95       	ret

00001466 <uart_putchar>:
    1466:	cf 93       	push	r28
    1468:	c8 2f       	mov	r28, r24
    146a:	fb 01       	movw	r30, r22
    146c:	84 85       	ldd	r24, Z+12	; 0x0c
    146e:	95 85       	ldd	r25, Z+13	; 0x0d
    1470:	01 97       	sbiw	r24, 0x01	; 1
    1472:	39 f0       	breq	.+14     	; 0x1482 <uart_putchar+0x1c>
    1474:	ca 30       	cpi	r28, 0x0A	; 10
    1476:	11 f4       	brne	.+4      	; 0x147c <uart_putchar+0x16>
    1478:	8d e0       	ldi	r24, 0x0D	; 13
    147a:	be df       	rcall	.-132    	; 0x13f8 <uart0_putc>
    147c:	8c 2f       	mov	r24, r28
    147e:	bc df       	rcall	.-136    	; 0x13f8 <uart0_putc>
    1480:	06 c0       	rjmp	.+12     	; 0x148e <uart_putchar+0x28>
    1482:	ca 30       	cpi	r28, 0x0A	; 10
    1484:	11 f4       	brne	.+4      	; 0x148a <uart_putchar+0x24>
    1486:	8d e0       	ldi	r24, 0x0D	; 13
    1488:	d6 df       	rcall	.-84     	; 0x1436 <uart1_putc>
    148a:	8c 2f       	mov	r24, r28
    148c:	d4 df       	rcall	.-88     	; 0x1436 <uart1_putc>
    148e:	80 e0       	ldi	r24, 0x00	; 0
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	cf 91       	pop	r28
    1494:	08 95       	ret

00001496 <uart0_getc>:
    1496:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    149a:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    149e:	89 17       	cp	r24, r25
    14a0:	59 f0       	breq	.+22     	; 0x14b8 <uart0_getc+0x22>
    14a2:	8f 5f       	subi	r24, 0xFF	; 255
    14a4:	98 2f       	mov	r25, r24
    14a6:	9f 71       	andi	r25, 0x1F	; 31
    14a8:	e9 2f       	mov	r30, r25
    14aa:	f0 e0       	ldi	r31, 0x00	; 0
    14ac:	ed 53       	subi	r30, 0x3D	; 61
    14ae:	fc 4f       	sbci	r31, 0xFC	; 252
    14b0:	80 81       	ld	r24, Z
    14b2:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    14b6:	08 95       	ret
    14b8:	80 e0       	ldi	r24, 0x00	; 0
    14ba:	08 95       	ret

000014bc <uart0_getln>:
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	cf 93       	push	r28
    14c2:	df 93       	push	r29
    14c4:	ec 01       	movw	r28, r24
    14c6:	61 30       	cpi	r22, 0x01	; 1
    14c8:	b1 f0       	breq	.+44     	; 0x14f6 <uart0_getln+0x3a>
    14ca:	62 50       	subi	r22, 0x02	; 2
    14cc:	06 2f       	mov	r16, r22
    14ce:	10 e0       	ldi	r17, 0x00	; 0
    14d0:	0f 5f       	subi	r16, 0xFF	; 255
    14d2:	1f 4f       	sbci	r17, 0xFF	; 255
    14d4:	08 0f       	add	r16, r24
    14d6:	19 1f       	adc	r17, r25
    14d8:	de df       	rcall	.-68     	; 0x1496 <uart0_getc>
    14da:	88 83       	st	Y, r24
    14dc:	88 23       	and	r24, r24
    14de:	e1 f3       	breq	.-8      	; 0x14d8 <uart0_getln+0x1c>
    14e0:	8d 30       	cpi	r24, 0x0D	; 13
    14e2:	21 f4       	brne	.+8      	; 0x14ec <uart0_getln+0x30>
    14e4:	d8 df       	rcall	.-80     	; 0x1496 <uart0_getc>
    14e6:	88 23       	and	r24, r24
    14e8:	e9 f3       	breq	.-6      	; 0x14e4 <uart0_getln+0x28>
    14ea:	05 c0       	rjmp	.+10     	; 0x14f6 <uart0_getln+0x3a>
    14ec:	21 96       	adiw	r28, 0x01	; 1
    14ee:	c0 17       	cp	r28, r16
    14f0:	d1 07       	cpc	r29, r17
    14f2:	91 f7       	brne	.-28     	; 0x14d8 <uart0_getln+0x1c>
    14f4:	e8 01       	movw	r28, r16
    14f6:	18 82       	st	Y, r1
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	08 95       	ret

00001502 <uart0_getData>:
    1502:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1506:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    150a:	89 17       	cp	r24, r25
    150c:	61 f0       	breq	.+24     	; 0x1526 <uart0_getData+0x24>
    150e:	8f 5f       	subi	r24, 0xFF	; 255
    1510:	8f 71       	andi	r24, 0x1F	; 31
    1512:	e8 2f       	mov	r30, r24
    1514:	f0 e0       	ldi	r31, 0x00	; 0
    1516:	ed 53       	subi	r30, 0x3D	; 61
    1518:	fc 4f       	sbci	r31, 0xFC	; 252
    151a:	90 81       	ld	r25, Z
    151c:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    1520:	89 2f       	mov	r24, r25
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	08 95       	ret
    1526:	8f ef       	ldi	r24, 0xFF	; 255
    1528:	9f ef       	ldi	r25, 0xFF	; 255
    152a:	08 95       	ret

0000152c <uart1_getData>:
    152c:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    1530:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1534:	89 17       	cp	r24, r25
    1536:	61 f0       	breq	.+24     	; 0x1550 <uart1_getData+0x24>
    1538:	8f 5f       	subi	r24, 0xFF	; 255
    153a:	8f 71       	andi	r24, 0x1F	; 31
    153c:	e8 2f       	mov	r30, r24
    153e:	f0 e0       	ldi	r31, 0x00	; 0
    1540:	e9 5f       	subi	r30, 0xF9	; 249
    1542:	fb 4f       	sbci	r31, 0xFB	; 251
    1544:	90 81       	ld	r25, Z
    1546:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    154a:	89 2f       	mov	r24, r25
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	08 95       	ret
    1550:	8f ef       	ldi	r24, 0xFF	; 255
    1552:	9f ef       	ldi	r25, 0xFF	; 255
    1554:	08 95       	ret

00001556 <uart_getchar>:
    1556:	cf 93       	push	r28
    1558:	df 93       	push	r29
    155a:	fc 01       	movw	r30, r24
    155c:	84 85       	ldd	r24, Z+12	; 0x0c
    155e:	95 85       	ldd	r25, Z+13	; 0x0d
    1560:	01 97       	sbiw	r24, 0x01	; 1
    1562:	41 f0       	breq	.+16     	; 0x1574 <uart_getchar+0x1e>
    1564:	ce df       	rcall	.-100    	; 0x1502 <uart0_getData>
    1566:	ec 01       	movw	r28, r24
    1568:	99 23       	and	r25, r25
    156a:	e4 f3       	brlt	.-8      	; 0x1564 <uart_getchar+0xe>
    156c:	45 df       	rcall	.-374    	; 0x13f8 <uart0_putc>
    156e:	ce 01       	movw	r24, r28
    1570:	99 27       	eor	r25, r25
    1572:	07 c0       	rjmp	.+14     	; 0x1582 <uart_getchar+0x2c>
    1574:	db df       	rcall	.-74     	; 0x152c <uart1_getData>
    1576:	ec 01       	movw	r28, r24
    1578:	99 23       	and	r25, r25
    157a:	e4 f3       	brlt	.-8      	; 0x1574 <uart_getchar+0x1e>
    157c:	5c df       	rcall	.-328    	; 0x1436 <uart1_putc>
    157e:	ce 01       	movw	r24, r28
    1580:	99 27       	eor	r25, r25
    1582:	99 27       	eor	r25, r25
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	08 95       	ret

0000158a <__vector_22>:
    158a:	0f 93       	push	r16
    158c:	0f b7       	in	r16, 0x3f	; 63
    158e:	ef 93       	push	r30
    1590:	ff 93       	push	r31
    1592:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    1596:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    159a:	e3 95       	inc	r30
    159c:	ef 71       	andi	r30, 0x1F	; 31
    159e:	ef 13       	cpse	r30, r31
    15a0:	05 c0       	rjmp	.+10     	; 0x15ac <USART0_TX_CONTINUE>
    15a2:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15a6:	ff 7d       	andi	r31, 0xDF	; 223
    15a8:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015ac <USART0_TX_CONTINUE>:
    15ac:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    15b0:	f0 e0       	ldi	r31, 0x00	; 0
    15b2:	e5 5d       	subi	r30, 0xD5	; 213
    15b4:	fb 4f       	sbci	r31, 0xFB	; 251
    15b6:	e0 81       	ld	r30, Z
    15b8:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

000015bc <USART0_TX_EXIT>:
    15bc:	ff 91       	pop	r31
    15be:	ef 91       	pop	r30
    15c0:	0f bf       	out	0x3f, r16	; 63
    15c2:	0f 91       	pop	r16
    15c4:	18 95       	reti

000015c6 <__vector_21>:
    15c6:	0f 93       	push	r16
    15c8:	0f b7       	in	r16, 0x3f	; 63
    15ca:	9f 93       	push	r25
    15cc:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    15d0:	ef 93       	push	r30
    15d2:	ff 93       	push	r31
    15d4:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    15d8:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    15dc:	e3 95       	inc	r30
    15de:	ef 71       	andi	r30, 0x1F	; 31
    15e0:	fe 17       	cp	r31, r30
    15e2:	31 f0       	breq	.+12     	; 0x15f0 <USART0_RX_EXIT>
    15e4:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    15e8:	f0 e0       	ldi	r31, 0x00	; 0
    15ea:	ed 53       	subi	r30, 0x3D	; 61
    15ec:	fc 4f       	sbci	r31, 0xFC	; 252
    15ee:	90 83       	st	Z, r25

000015f0 <USART0_RX_EXIT>:
    15f0:	ff 91       	pop	r31
    15f2:	ef 91       	pop	r30
    15f4:	9f 91       	pop	r25
    15f6:	0f bf       	out	0x3f, r16	; 63
    15f8:	0f 91       	pop	r16
    15fa:	18 95       	reti

000015fc <__vector_33>:
    15fc:	0f 93       	push	r16
    15fe:	0f b7       	in	r16, 0x3f	; 63
    1600:	ef 93       	push	r30
    1602:	ff 93       	push	r31
    1604:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1608:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    160c:	e3 95       	inc	r30
    160e:	ef 71       	andi	r30, 0x1F	; 31
    1610:	ef 13       	cpse	r30, r31
    1612:	05 c0       	rjmp	.+10     	; 0x161e <USART1_TX_CONTINUE>
    1614:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1618:	ff 7d       	andi	r31, 0xDF	; 223
    161a:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

0000161e <USART1_TX_CONTINUE>:
    161e:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    1622:	f0 e0       	ldi	r31, 0x00	; 0
    1624:	ea 51       	subi	r30, 0x1A	; 26
    1626:	fc 4f       	sbci	r31, 0xFC	; 252
    1628:	e0 81       	ld	r30, Z
    162a:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

0000162e <USART1_TX_EXIT>:
    162e:	ff 91       	pop	r31
    1630:	ef 91       	pop	r30
    1632:	0f bf       	out	0x3f, r16	; 63
    1634:	0f 91       	pop	r16
    1636:	18 95       	reti

00001638 <__vector_32>:
    1638:	0f 93       	push	r16
    163a:	0f b7       	in	r16, 0x3f	; 63
    163c:	9f 93       	push	r25
    163e:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1642:	ef 93       	push	r30
    1644:	ff 93       	push	r31
    1646:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    164a:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    164e:	e3 95       	inc	r30
    1650:	ef 71       	andi	r30, 0x1F	; 31
    1652:	fe 17       	cp	r31, r30
    1654:	31 f0       	breq	.+12     	; 0x1662 <USART1_RX_EXIT>
    1656:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    165a:	f0 e0       	ldi	r31, 0x00	; 0
    165c:	e9 5f       	subi	r30, 0xF9	; 249
    165e:	fb 4f       	sbci	r31, 0xFB	; 251
    1660:	90 83       	st	Z, r25

00001662 <USART1_RX_EXIT>:
    1662:	ff 91       	pop	r31
    1664:	ef 91       	pop	r30
    1666:	9f 91       	pop	r25
    1668:	0f bf       	out	0x3f, r16	; 63
    166a:	0f 91       	pop	r16
    166c:	18 95       	reti

0000166e <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    166e:	e1 e8       	ldi	r30, 0x81	; 129
    1670:	f0 e0       	ldi	r31, 0x00	; 0
    1672:	80 81       	ld	r24, Z
    1674:	83 60       	ori	r24, 0x03	; 3
    1676:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    1678:	80 81       	ld	r24, Z
    167a:	88 60       	ori	r24, 0x08	; 8
    167c:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    167e:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    1682:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    1686:	ef e6       	ldi	r30, 0x6F	; 111
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	80 81       	ld	r24, Z
    168c:	82 60       	ori	r24, 0x02	; 2
    168e:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    1690:	8d e7       	ldi	r24, 0x7D	; 125
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1698:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    169c:	08 95       	ret

0000169e <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    169e:	84 b5       	in	r24, 0x24	; 36
    16a0:	85 60       	ori	r24, 0x05	; 5
    16a2:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16a4:	84 b5       	in	r24, 0x24	; 36
    16a6:	88 60       	ori	r24, 0x08	; 8
    16a8:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16aa:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16ac:	ee e6       	ldi	r30, 0x6E	; 110
    16ae:	f0 e0       	ldi	r31, 0x00	; 0
    16b0:	80 81       	ld	r24, Z
    16b2:	82 60       	ori	r24, 0x02	; 2
    16b4:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    16b6:	87 e2       	ldi	r24, 0x27	; 39
    16b8:	87 bd       	out	0x27, r24	; 39
    16ba:	08 95       	ret

000016bc <main>:
};


int main(void)	
{
	cli();
    16bc:	f8 94       	cli
	rgbled_init();
    16be:	92 d5       	rcall	.+2852   	; 0x21e4 <rgbled_init>
	DWC_init();
    16c0:	11 d2       	rcall	.+1058   	; 0x1ae4 <DWC_init>
	pwm_init();
    16c2:	33 de       	rcall	.-922    	; 0x132a <pwm_init>
    16c4:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    16c6:	70 e0       	ldi	r23, 0x00	; 0
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    16cc:	71 d4       	rcall	.+2274   	; 0x1fb0 <can_init>
	timer0_init_ts();
    16ce:	cf df       	rcall	.-98     	; 0x166e <timer1_init_ts>
    16d0:	e6 df       	rcall	.-52     	; 0x169e <timer0_init_ts>
	speed_init();
    16d2:	7f dc       	rcall	.-1794   	; 0xfd2 <speed_init>
    16d4:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    16d6:	95 d5       	rcall	.+2858   	; 0x2202 <spi_init>
    16d8:	82 e1       	ldi	r24, 0x12	; 18
    16da:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    16dc:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    16e0:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    16e4:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    16e8:	88 e9       	ldi	r24, 0x98	; 152
    16ea:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    16ee:	eb e4       	ldi	r30, 0x4B	; 75
    16f0:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    16f2:	84 e0       	ldi	r24, 0x04	; 4
    16f4:	91 e0       	ldi	r25, 0x01	; 1
    16f6:	93 83       	std	Z+3, r25	; 0x03
    16f8:	82 83       	std	Z+2, r24	; 0x02
    16fa:	91 83       	std	Z+1, r25	; 0x01
    16fc:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    16fe:	0e 94 53 03 	call	0x6a6	; 0x6a6 <drivers_init>
	drivers_init();
    1702:	80 e0       	ldi	r24, 0x00	; 0
    1704:	0e 94 55 03 	call	0x6aa	; 0x6aa <drivers>
	drivers(0);
    1708:	78 94       	sei
	sei();
    170a:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    170c:	67 e9       	ldi	r22, 0x97	; 151
    170e:	73 e0       	ldi	r23, 0x03	; 3
    1710:	82 e1       	ldi	r24, 0x12	; 18
    1712:	91 e0       	ldi	r25, 0x01	; 1
    1714:	c5 d8       	rcall	.-3702   	; 0x8a0 <handle_can>
    1716:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1718:	91 e0       	ldi	r25, 0x01	; 1
    171a:	9e d9       	rcall	.-3268   	; 0xa58 <receive_uart>
    171c:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1720:	88 23       	and	r24, r24
    1722:	09 f4       	brne	.+2      	; 0x1726 <main+0x6a>
    1724:	41 c0       	rjmp	.+130    	; 0x17a8 <main+0xec>
    1726:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    172a:	88 23       	and	r24, r24
    172c:	f1 f0       	breq	.+60     	; 0x176a <main+0xae>
    172e:	8d b7       	in	r24, 0x3d	; 61
    1730:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    1732:	cd 97       	sbiw	r24, 0x3d	; 61
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	9e bf       	out	0x3e, r25	; 62
    173a:	0f be       	out	0x3f, r0	; 63
    173c:	8d bf       	out	0x3d, r24	; 61
    173e:	ad b7       	in	r26, 0x3d	; 61
    1740:	be b7       	in	r27, 0x3e	; 62
    1742:	11 96       	adiw	r26, 0x01	; 1
    1744:	8d e3       	ldi	r24, 0x3D	; 61
    1746:	e2 e1       	ldi	r30, 0x12	; 18
    1748:	f1 e0       	ldi	r31, 0x01	; 1
    174a:	01 90       	ld	r0, Z+
    174c:	0d 92       	st	X+, r0
    174e:	8a 95       	dec	r24
    1750:	e1 f7       	brne	.-8      	; 0x174a <main+0x8e>
    1752:	fd d8       	rcall	.-3590   	; 0x94e <handle_motor_status_can_msg>
    1754:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    1758:	8d b7       	in	r24, 0x3d	; 61
    175a:	9e b7       	in	r25, 0x3e	; 62
    175c:	cd 96       	adiw	r24, 0x3d	; 61
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	9e bf       	out	0x3e, r25	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	8d bf       	out	0x3d, r24	; 61
    1768:	1d c0       	rjmp	.+58     	; 0x17a4 <main+0xe8>
    176a:	8d b7       	in	r24, 0x3d	; 61
    176c:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    176e:	cd 97       	sbiw	r24, 0x3d	; 61
    1770:	0f b6       	in	r0, 0x3f	; 63
    1772:	f8 94       	cli
    1774:	9e bf       	out	0x3e, r25	; 62
    1776:	0f be       	out	0x3f, r0	; 63
    1778:	8d bf       	out	0x3d, r24	; 61
    177a:	ad b7       	in	r26, 0x3d	; 61
    177c:	be b7       	in	r27, 0x3e	; 62
    177e:	11 96       	adiw	r26, 0x01	; 1
    1780:	8d e3       	ldi	r24, 0x3D	; 61
    1782:	e2 e1       	ldi	r30, 0x12	; 18
    1784:	f1 e0       	ldi	r31, 0x01	; 1
    1786:	01 90       	ld	r0, Z+
    1788:	0d 92       	st	X+, r0
    178a:	8a 95       	dec	r24
    178c:	e1 f7       	brne	.-8      	; 0x1786 <main+0xca>
    178e:	4e d9       	rcall	.-3428   	; 0xa2c <handle_clutch_cmd_can_msg>
    1790:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    1794:	8d b7       	in	r24, 0x3d	; 61
    1796:	9e b7       	in	r25, 0x3e	; 62
    1798:	cd 96       	adiw	r24, 0x3d	; 61
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	9e bf       	out	0x3e, r25	; 62
    17a0:	0f be       	out	0x3f, r0	; 63
    17a2:	8d bf       	out	0x3d, r24	; 61
    17a4:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17a8:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17ac:	88 23       	and	r24, r24
    17ae:	09 f4       	brne	.+2      	; 0x17b2 <main+0xf6>
    17b0:	ad cf       	rjmp	.-166    	; 0x170c <main+0x50>
    17b2:	8d b7       	in	r24, 0x3d	; 61
    17b4:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    17b6:	cd 97       	sbiw	r24, 0x3d	; 61
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	f8 94       	cli
    17bc:	9e bf       	out	0x3e, r25	; 62
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	8d bf       	out	0x3d, r24	; 61
    17c2:	ad b7       	in	r26, 0x3d	; 61
    17c4:	be b7       	in	r27, 0x3e	; 62
    17c6:	11 96       	adiw	r26, 0x01	; 1
    17c8:	8d e3       	ldi	r24, 0x3D	; 61
    17ca:	e2 e1       	ldi	r30, 0x12	; 18
    17cc:	f1 e0       	ldi	r31, 0x01	; 1
    17ce:	01 90       	ld	r0, Z+
    17d0:	0d 92       	st	X+, r0
    17d2:	8a 95       	dec	r24
    17d4:	e1 f7       	brne	.-8      	; 0x17ce <main+0x112>
    17d6:	c1 da       	rcall	.-2686   	; 0xd5a <send_uart>
    17d8:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    17dc:	8d b7       	in	r24, 0x3d	; 61
    17de:	9e b7       	in	r25, 0x3e	; 62
    17e0:	cd 96       	adiw	r24, 0x3d	; 61
    17e2:	0f b6       	in	r0, 0x3f	; 63
    17e4:	f8 94       	cli
    17e6:	9e bf       	out	0x3e, r25	; 62
    17e8:	0f be       	out	0x3f, r0	; 63
    17ea:	8d bf       	out	0x3d, r24	; 61
    17ec:	8f cf       	rjmp	.-226    	; 0x170c <main+0x50>

000017ee <__vector_16>:
    17ee:	1f 92       	push	r1
    17f0:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	0f 92       	push	r0
    17f6:	11 24       	eor	r1, r1
    17f8:	0b b6       	in	r0, 0x3b	; 59
    17fa:	0f 92       	push	r0
    17fc:	ef 92       	push	r14
    17fe:	0f 93       	push	r16
    1800:	1f 93       	push	r17
    1802:	2f 93       	push	r18
    1804:	3f 93       	push	r19
    1806:	4f 93       	push	r20
    1808:	5f 93       	push	r21
    180a:	6f 93       	push	r22
    180c:	7f 93       	push	r23
    180e:	8f 93       	push	r24
    1810:	9f 93       	push	r25
    1812:	af 93       	push	r26
    1814:	bf 93       	push	r27
    1816:	ef 93       	push	r30
    1818:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    181a:	82 e1       	ldi	r24, 0x12	; 18
    181c:	91 e0       	ldi	r25, 0x01	; 1
    181e:	63 d1       	rcall	.+710    	; 0x1ae6 <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1820:	82 e1       	ldi	r24, 0x12	; 18
    1822:	91 e0       	ldi	r25, 0x01	; 1
    1824:	63 dc       	rcall	.-1850   	; 0x10ec <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    1826:	82 e1       	ldi	r24, 0x12	; 18
    1828:	91 e0       	ldi	r25, 0x01	; 1
    182a:	0e 94 9b 01 	call	0x336	; 0x336 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    182e:	82 e1       	ldi	r24, 0x12	; 18
    1830:	91 e0       	ldi	r25, 0x01	; 1
    1832:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    1836:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    183a:	87 30       	cpi	r24, 0x07	; 7
    183c:	09 f0       	breq	.+2      	; 0x1840 <__vector_16+0x52>
    183e:	51 c0       	rjmp	.+162    	; 0x18e2 <__vector_16+0xf4>
	{
		b_send_can = 1;
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    1846:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    184a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    184e:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    1852:	89 2b       	or	r24, r25
    1854:	b1 f0       	breq	.+44     	; 0x1882 <__vector_16+0x94>
    1856:	e2 e1       	ldi	r30, 0x12	; 18
    1858:	f1 e0       	ldi	r31, 0x01	; 1
    185a:	97 8d       	ldd	r25, Z+31	; 0x1f
    185c:	27 8d       	ldd	r18, Z+31	; 0x1f
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	91 30       	cpi	r25, 0x01	; 1
    1862:	09 f0       	breq	.+2      	; 0x1866 <__vector_16+0x78>
    1864:	80 e0       	ldi	r24, 0x00	; 0
    1866:	81 11       	cpse	r24, r1
    1868:	05 c0       	rjmp	.+10     	; 0x1874 <__vector_16+0x86>
    186a:	81 e0       	ldi	r24, 0x01	; 1
    186c:	21 11       	cpse	r18, r1
    186e:	80 e0       	ldi	r24, 0x00	; 0
    1870:	88 23       	and	r24, r24
    1872:	39 f0       	breq	.+14     	; 0x1882 <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    1874:	e2 e1       	ldi	r30, 0x12	; 18
    1876:	f1 e0       	ldi	r31, 0x01	; 1
    1878:	82 8d       	ldd	r24, Z+26	; 0x1a
    187a:	93 8d       	ldd	r25, Z+27	; 0x1b
    187c:	01 97       	sbiw	r24, 0x01	; 1
    187e:	93 8f       	std	Z+27, r25	; 0x1b
    1880:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1882:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    1886:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    188a:	89 2b       	or	r24, r25
    188c:	b1 f0       	breq	.+44     	; 0x18ba <__vector_16+0xcc>
    188e:	e2 e1       	ldi	r30, 0x12	; 18
    1890:	f1 e0       	ldi	r31, 0x01	; 1
    1892:	97 8d       	ldd	r25, Z+31	; 0x1f
    1894:	27 8d       	ldd	r18, Z+31	; 0x1f
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	91 30       	cpi	r25, 0x01	; 1
    189a:	09 f0       	breq	.+2      	; 0x189e <__vector_16+0xb0>
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	81 11       	cpse	r24, r1
    18a0:	05 c0       	rjmp	.+10     	; 0x18ac <__vector_16+0xbe>
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	21 11       	cpse	r18, r1
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	88 23       	and	r24, r24
    18aa:	39 f0       	breq	.+14     	; 0x18ba <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18ac:	e2 e1       	ldi	r30, 0x12	; 18
    18ae:	f1 e0       	ldi	r31, 0x01	; 1
    18b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    18b2:	95 8d       	ldd	r25, Z+29	; 0x1d
    18b4:	01 97       	sbiw	r24, 0x01	; 1
    18b6:	95 8f       	std	Z+29, r25	; 0x1d
    18b8:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    18ba:	e2 e1       	ldi	r30, 0x12	; 18
    18bc:	f1 e0       	ldi	r31, 0x01	; 1
    18be:	02 85       	ldd	r16, Z+10	; 0x0a
    18c0:	13 85       	ldd	r17, Z+11	; 0x0b
    18c2:	24 85       	ldd	r18, Z+12	; 0x0c
    18c4:	35 85       	ldd	r19, Z+13	; 0x0d
    18c6:	46 81       	ldd	r20, Z+6	; 0x06
    18c8:	57 81       	ldd	r21, Z+7	; 0x07
    18ca:	60 85       	ldd	r22, Z+8	; 0x08
    18cc:	71 85       	ldd	r23, Z+9	; 0x09
    18ce:	0f 2e       	mov	r0, r31
    18d0:	f9 e2       	ldi	r31, 0x29	; 41
    18d2:	ef 2e       	mov	r14, r31
    18d4:	f0 2d       	mov	r31, r0
    18d6:	80 e2       	ldi	r24, 0x20	; 32
    18d8:	91 e0       	ldi	r25, 0x01	; 1
    18da:	e6 d1       	rcall	.+972    	; 0x1ca8 <handle_joulemeter>
		systic_counter_fast = 0;
    18dc:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    18e0:	03 c0       	rjmp	.+6      	; 0x18e8 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    18e2:	8f 5f       	subi	r24, 0xFF	; 255
    18e4:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    18e8:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    18ec:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    18f0:	84 36       	cpi	r24, 0x64	; 100
    18f2:	91 05       	cpc	r25, r1
    18f4:	01 f5       	brne	.+64     	; 0x1936 <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    18f6:	8d b7       	in	r24, 0x3d	; 61
    18f8:	9e b7       	in	r25, 0x3e	; 62
    18fa:	cd 97       	sbiw	r24, 0x3d	; 61
    18fc:	0f b6       	in	r0, 0x3f	; 63
    18fe:	f8 94       	cli
    1900:	9e bf       	out	0x3e, r25	; 62
    1902:	0f be       	out	0x3f, r0	; 63
    1904:	8d bf       	out	0x3d, r24	; 61
    1906:	ad b7       	in	r26, 0x3d	; 61
    1908:	be b7       	in	r27, 0x3e	; 62
    190a:	11 96       	adiw	r26, 0x01	; 1
    190c:	8d e3       	ldi	r24, 0x3D	; 61
    190e:	e2 e1       	ldi	r30, 0x12	; 18
    1910:	f1 e0       	ldi	r31, 0x01	; 1
    1912:	01 90       	ld	r0, Z+
    1914:	0d 92       	st	X+, r0
    1916:	8a 95       	dec	r24
    1918:	e1 f7       	brne	.-8      	; 0x1912 <__vector_16+0x124>
    191a:	02 db       	rcall	.-2556   	; 0xf20 <manage_LEDs>
		systic_counter_slow = 0;
    191c:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1920:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    1924:	8d b7       	in	r24, 0x3d	; 61
    1926:	9e b7       	in	r25, 0x3e	; 62
    1928:	cd 96       	adiw	r24, 0x3d	; 61
    192a:	0f b6       	in	r0, 0x3f	; 63
    192c:	f8 94       	cli
    192e:	9e bf       	out	0x3e, r25	; 62
    1930:	0f be       	out	0x3f, r0	; 63
    1932:	8d bf       	out	0x3d, r24	; 61
    1934:	05 c0       	rjmp	.+10     	; 0x1940 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    1936:	01 96       	adiw	r24, 0x01	; 1
    1938:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    193c:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1940:	ff 91       	pop	r31
    1942:	ef 91       	pop	r30
    1944:	bf 91       	pop	r27
    1946:	af 91       	pop	r26
    1948:	9f 91       	pop	r25
    194a:	8f 91       	pop	r24
    194c:	7f 91       	pop	r23
    194e:	6f 91       	pop	r22
    1950:	5f 91       	pop	r21
    1952:	4f 91       	pop	r20
    1954:	3f 91       	pop	r19
    1956:	2f 91       	pop	r18
    1958:	1f 91       	pop	r17
    195a:	0f 91       	pop	r16
    195c:	ef 90       	pop	r14
    195e:	0f 90       	pop	r0
    1960:	0b be       	out	0x3b, r0	; 59
    1962:	0f 90       	pop	r0
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	0f 90       	pop	r0
    1968:	1f 90       	pop	r1
    196a:	18 95       	reti

0000196c <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    196c:	1f 92       	push	r1
    196e:	0f 92       	push	r0
    1970:	0f b6       	in	r0, 0x3f	; 63
    1972:	0f 92       	push	r0
    1974:	11 24       	eor	r1, r1
    1976:	0b b6       	in	r0, 0x3b	; 59
    1978:	0f 92       	push	r0
    197a:	2f 93       	push	r18
    197c:	3f 93       	push	r19
    197e:	4f 93       	push	r20
    1980:	5f 93       	push	r21
    1982:	6f 93       	push	r22
    1984:	7f 93       	push	r23
    1986:	8f 93       	push	r24
    1988:	9f 93       	push	r25
    198a:	af 93       	push	r26
    198c:	bf 93       	push	r27
    198e:	ef 93       	push	r30
    1990:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    1992:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    1996:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    199a:	80 3d       	cpi	r24, 0xD0	; 208
    199c:	97 40       	sbci	r25, 0x07	; 7
    199e:	50 f4       	brcc	.+20     	; 0x19b4 <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19a0:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19a4:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19a8:	01 96       	adiw	r24, 0x01	; 1
    19aa:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19ae:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19b2:	08 c0       	rjmp	.+16     	; 0x19c4 <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19b4:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    19b8:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    19bc:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    19c0:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    19c4:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19c8:	87 30       	cpi	r24, 0x07	; 7
    19ca:	41 f4       	brne	.+16     	; 0x19dc <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    19cc:	84 e1       	ldi	r24, 0x14	; 20
    19ce:	91 e0       	ldi	r25, 0x01	; 1
    19d0:	0e 94 2e 04 	call	0x85c	; 0x85c <SPI_handler_7>
		u8_SPI_count = 0 ;
    19d4:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    19d8:	80 e0       	ldi	r24, 0x00	; 0
    19da:	13 c0       	rjmp	.+38     	; 0x1a02 <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    19dc:	86 30       	cpi	r24, 0x06	; 6
    19de:	49 f4       	brne	.+18     	; 0x19f2 <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    19e0:	8d e3       	ldi	r24, 0x3D	; 61
    19e2:	91 e0       	ldi	r25, 0x01	; 1
    19e4:	0e 94 db 03 	call	0x7b6	; 0x7b6 <SPI_handler_6>
		u8_SPI_count ++ ;
    19e8:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19ec:	8f 5f       	subi	r24, 0xFF	; 255
    19ee:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    19f2:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19f6:	85 30       	cpi	r24, 0x05	; 5
    19f8:	21 f4       	brne	.+8      	; 0x1a02 <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    19fa:	86 e0       	ldi	r24, 0x06	; 6
    19fc:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a00:	13 c0       	rjmp	.+38     	; 0x1a28 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a02:	84 30       	cpi	r24, 0x04	; 4
    1a04:	49 f4       	brne	.+18     	; 0x1a18 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a06:	84 e2       	ldi	r24, 0x24	; 36
    1a08:	91 e0       	ldi	r25, 0x01	; 1
    1a0a:	0e 94 ba 03 	call	0x774	; 0x774 <SPI_handler_4>
		u8_SPI_count ++ ;
    1a0e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a12:	8f 5f       	subi	r24, 0xFF	; 255
    1a14:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a18:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a1c:	83 30       	cpi	r24, 0x03	; 3
    1a1e:	21 f4       	brne	.+8      	; 0x1a28 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a20:	84 e0       	ldi	r24, 0x04	; 4
    1a22:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a26:	13 c0       	rjmp	.+38     	; 0x1a4e <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a28:	82 30       	cpi	r24, 0x02	; 2
    1a2a:	21 f4       	brne	.+8      	; 0x1a34 <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a2c:	83 e0       	ldi	r24, 0x03	; 3
    1a2e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a32:	1a c0       	rjmp	.+52     	; 0x1a68 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a34:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	49 f4       	brne	.+18     	; 0x1a4e <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a3c:	88 e1       	ldi	r24, 0x18	; 24
    1a3e:	91 e0       	ldi	r25, 0x01	; 1
    1a40:	0e 94 98 03 	call	0x730	; 0x730 <SPI_handler_1>
		u8_SPI_count ++ ;
    1a44:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a4e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a52:	81 11       	cpse	r24, r1
    1a54:	09 c0       	rjmp	.+18     	; 0x1a68 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1a56:	8c e1       	ldi	r24, 0x1C	; 28
    1a58:	91 e0       	ldi	r25, 0x01	; 1
    1a5a:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <SPI_handler_0>
		u8_SPI_count ++ ;
    1a5e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1a68:	ff 91       	pop	r31
    1a6a:	ef 91       	pop	r30
    1a6c:	bf 91       	pop	r27
    1a6e:	af 91       	pop	r26
    1a70:	9f 91       	pop	r25
    1a72:	8f 91       	pop	r24
    1a74:	7f 91       	pop	r23
    1a76:	6f 91       	pop	r22
    1a78:	5f 91       	pop	r21
    1a7a:	4f 91       	pop	r20
    1a7c:	3f 91       	pop	r19
    1a7e:	2f 91       	pop	r18
    1a80:	0f 90       	pop	r0
    1a82:	0b be       	out	0x3b, r0	; 59
    1a84:	0f 90       	pop	r0
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	0f 90       	pop	r0
    1a8a:	1f 90       	pop	r1
    1a8c:	18 95       	reti

00001a8e <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1a8e:	1f 92       	push	r1
    1a90:	0f 92       	push	r0
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	0f 92       	push	r0
    1a96:	11 24       	eor	r1, r1
    1a98:	0b b6       	in	r0, 0x3b	; 59
    1a9a:	0f 92       	push	r0
    1a9c:	2f 93       	push	r18
    1a9e:	3f 93       	push	r19
    1aa0:	4f 93       	push	r20
    1aa2:	5f 93       	push	r21
    1aa4:	6f 93       	push	r22
    1aa6:	7f 93       	push	r23
    1aa8:	8f 93       	push	r24
    1aaa:	9f 93       	push	r25
    1aac:	af 93       	push	r26
    1aae:	bf 93       	push	r27
    1ab0:	ef 93       	push	r30
    1ab2:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	72 e0       	ldi	r23, 0x02	; 2
    1ab8:	85 e2       	ldi	r24, 0x25	; 37
    1aba:	91 e0       	ldi	r25, 0x01	; 1
    1abc:	95 da       	rcall	.-2774   	; 0xfe8 <handle_speed_sensor>
}
    1abe:	ff 91       	pop	r31
    1ac0:	ef 91       	pop	r30
    1ac2:	bf 91       	pop	r27
    1ac4:	af 91       	pop	r26
    1ac6:	9f 91       	pop	r25
    1ac8:	8f 91       	pop	r24
    1aca:	7f 91       	pop	r23
    1acc:	6f 91       	pop	r22
    1ace:	5f 91       	pop	r21
    1ad0:	4f 91       	pop	r20
    1ad2:	3f 91       	pop	r19
    1ad4:	2f 91       	pop	r18
    1ad6:	0f 90       	pop	r0
    1ad8:	0b be       	out	0x3b, r0	; 59
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63
    1ade:	0f 90       	pop	r0
    1ae0:	1f 90       	pop	r1
    1ae2:	18 95       	reti

00001ae4 <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1ae4:	08 95       	ret

00001ae6 <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1ae6:	7a 99       	sbic	0x0f, 2	; 15
    1ae8:	03 c0       	rjmp	.+6      	; 0x1af0 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1aea:	fc 01       	movw	r30, r24
    1aec:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1aee:	10 8e       	std	Z+24, r1	; 0x18
    1af0:	08 95       	ret

00001af2 <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1af2:	8f 92       	push	r8
    1af4:	9f 92       	push	r9
    1af6:	af 92       	push	r10
    1af8:	bf 92       	push	r11
    1afa:	cf 92       	push	r12
    1afc:	df 92       	push	r13
    1afe:	ef 92       	push	r14
    1b00:	ff 92       	push	r15
    1b02:	0f 93       	push	r16
    1b04:	1f 93       	push	r17
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	00 d0       	rcall	.+0      	; 0x1b0c <handle_current_sensor+0x1a>
    1b0c:	00 d0       	rcall	.+0      	; 0x1b0e <handle_current_sensor+0x1c>
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	8c 01       	movw	r16, r24
    1b14:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b16:	80 e0       	ldi	r24, 0x00	; 0
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	e6 d4       	rcall	.+2508   	; 0x24e8 <__floatunsisf>
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	40 ea       	ldi	r20, 0xA0	; 160
    1b22:	50 e4       	ldi	r21, 0x40	; 64
    1b24:	97 d5       	rcall	.+2862   	; 0x2654 <__mulsf3>
    1b26:	20 e0       	ldi	r18, 0x00	; 0
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	40 e8       	ldi	r20, 0x80	; 128
    1b2c:	59 e3       	ldi	r21, 0x39	; 57
    1b2e:	92 d5       	rcall	.+2852   	; 0x2654 <__mulsf3>
    1b30:	20 e0       	ldi	r18, 0x00	; 0
    1b32:	30 e0       	ldi	r19, 0x00	; 0
    1b34:	40 e0       	ldi	r20, 0x00	; 0
    1b36:	51 e4       	ldi	r21, 0x41	; 65
    1b38:	8d d5       	rcall	.+2842   	; 0x2654 <__mulsf3>
    1b3a:	20 e0       	ldi	r18, 0x00	; 0
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	40 ea       	ldi	r20, 0xA0	; 160
    1b40:	51 e4       	ldi	r21, 0x41	; 65
    1b42:	d0 d3       	rcall	.+1952   	; 0x22e4 <__subsf3>
    1b44:	69 83       	std	Y+1, r22	; 0x01
    1b46:	7a 83       	std	Y+2, r23	; 0x02
    1b48:	8b 83       	std	Y+3, r24	; 0x03
    1b4a:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b4c:	ff 20       	and	r15, r15
    1b4e:	49 f0       	breq	.+18     	; 0x1b62 <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	9a 81       	ldd	r25, Y+2	; 0x02
    1b54:	ab 81       	ldd	r26, Y+3	; 0x03
    1b56:	bc 81       	ldd	r27, Y+4	; 0x04
    1b58:	89 83       	std	Y+1, r24	; 0x01
    1b5a:	9a 83       	std	Y+2, r25	; 0x02
    1b5c:	ab 83       	std	Y+3, r26	; 0x03
    1b5e:	bc 83       	std	Y+4, r27	; 0x04
    1b60:	08 c0       	rjmp	.+16     	; 0x1b72 <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b62:	89 81       	ldd	r24, Y+1	; 0x01
    1b64:	9a 81       	ldd	r25, Y+2	; 0x02
    1b66:	ab 81       	ldd	r26, Y+3	; 0x03
    1b68:	bc 81       	ldd	r27, Y+4	; 0x04
    1b6a:	89 83       	std	Y+1, r24	; 0x01
    1b6c:	9a 83       	std	Y+2, r25	; 0x02
    1b6e:	ab 83       	std	Y+3, r26	; 0x03
    1b70:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1b72:	f8 01       	movw	r30, r16
    1b74:	60 81       	ld	r22, Z
    1b76:	71 81       	ldd	r23, Z+1	; 0x01
    1b78:	82 81       	ldd	r24, Z+2	; 0x02
    1b7a:	93 81       	ldd	r25, Z+3	; 0x03
    1b7c:	89 80       	ldd	r8, Y+1	; 0x01
    1b7e:	9a 80       	ldd	r9, Y+2	; 0x02
    1b80:	ab 80       	ldd	r10, Y+3	; 0x03
    1b82:	bc 80       	ldd	r11, Y+4	; 0x04
    1b84:	26 e6       	ldi	r18, 0x66	; 102
    1b86:	36 e6       	ldi	r19, 0x66	; 102
    1b88:	46 e6       	ldi	r20, 0x66	; 102
    1b8a:	5f e3       	ldi	r21, 0x3F	; 63
    1b8c:	63 d5       	rcall	.+2758   	; 0x2654 <__mulsf3>
    1b8e:	6b 01       	movw	r12, r22
    1b90:	7c 01       	movw	r14, r24
    1b92:	2d ec       	ldi	r18, 0xCD	; 205
    1b94:	3c ec       	ldi	r19, 0xCC	; 204
    1b96:	4c ec       	ldi	r20, 0xCC	; 204
    1b98:	5d e3       	ldi	r21, 0x3D	; 61
    1b9a:	c5 01       	movw	r24, r10
    1b9c:	b4 01       	movw	r22, r8
    1b9e:	5a d5       	rcall	.+2740   	; 0x2654 <__mulsf3>
    1ba0:	9b 01       	movw	r18, r22
    1ba2:	ac 01       	movw	r20, r24
    1ba4:	c7 01       	movw	r24, r14
    1ba6:	b6 01       	movw	r22, r12
    1ba8:	9e d3       	rcall	.+1852   	; 0x22e6 <__addsf3>
    1baa:	f8 01       	movw	r30, r16
    1bac:	60 83       	st	Z, r22
    1bae:	71 83       	std	Z+1, r23	; 0x01
    1bb0:	82 83       	std	Z+2, r24	; 0x02
    1bb2:	93 83       	std	Z+3, r25	; 0x03
}
    1bb4:	0f 90       	pop	r0
    1bb6:	0f 90       	pop	r0
    1bb8:	0f 90       	pop	r0
    1bba:	0f 90       	pop	r0
    1bbc:	df 91       	pop	r29
    1bbe:	cf 91       	pop	r28
    1bc0:	1f 91       	pop	r17
    1bc2:	0f 91       	pop	r16
    1bc4:	ff 90       	pop	r15
    1bc6:	ef 90       	pop	r14
    1bc8:	df 90       	pop	r13
    1bca:	cf 90       	pop	r12
    1bcc:	bf 90       	pop	r11
    1bce:	af 90       	pop	r10
    1bd0:	9f 90       	pop	r9
    1bd2:	8f 90       	pop	r8
    1bd4:	08 95       	ret

00001bd6 <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1bd6:	cf 92       	push	r12
    1bd8:	df 92       	push	r13
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	cf 93       	push	r28
    1be0:	df 93       	push	r29
    1be2:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	7f d4       	rcall	.+2302   	; 0x24e8 <__floatunsisf>
    1bea:	20 e0       	ldi	r18, 0x00	; 0
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	40 ea       	ldi	r20, 0xA0	; 160
    1bf0:	50 e4       	ldi	r21, 0x40	; 64
    1bf2:	30 d5       	rcall	.+2656   	; 0x2654 <__mulsf3>
    1bf4:	20 e0       	ldi	r18, 0x00	; 0
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	40 e8       	ldi	r20, 0x80	; 128
    1bfa:	59 e3       	ldi	r21, 0x39	; 57
    1bfc:	2b d5       	rcall	.+2646   	; 0x2654 <__mulsf3>
    1bfe:	6b 01       	movw	r12, r22
    1c00:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c02:	2d ec       	ldi	r18, 0xCD	; 205
    1c04:	3c ec       	ldi	r19, 0xCC	; 204
    1c06:	4c e6       	ldi	r20, 0x6C	; 108
    1c08:	50 e4       	ldi	r21, 0x40	; 64
    1c0a:	d1 d3       	rcall	.+1954   	; 0x23ae <__cmpsf2>
    1c0c:	18 16       	cp	r1, r24
    1c0e:	74 f0       	brlt	.+28     	; 0x1c2c <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c10:	20 e0       	ldi	r18, 0x00	; 0
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	40 ea       	ldi	r20, 0xA0	; 160
    1c16:	51 e4       	ldi	r21, 0x41	; 65
    1c18:	c7 01       	movw	r24, r14
    1c1a:	b6 01       	movw	r22, r12
    1c1c:	1b d5       	rcall	.+2614   	; 0x2654 <__mulsf3>
    1c1e:	20 e0       	ldi	r18, 0x00	; 0
    1c20:	30 e0       	ldi	r19, 0x00	; 0
    1c22:	40 eb       	ldi	r20, 0xB0	; 176
    1c24:	51 e4       	ldi	r21, 0x41	; 65
    1c26:	5e d3       	rcall	.+1724   	; 0x22e4 <__subsf3>
    1c28:	33 d4       	rcall	.+2150   	; 0x2490 <__fixunssfsi>
    1c2a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c2c:	26 e6       	ldi	r18, 0x66	; 102
    1c2e:	36 e6       	ldi	r19, 0x66	; 102
    1c30:	46 e9       	ldi	r20, 0x96	; 150
    1c32:	50 e4       	ldi	r21, 0x40	; 64
    1c34:	c7 01       	movw	r24, r14
    1c36:	b6 01       	movw	r22, r12
    1c38:	ba d3       	rcall	.+1908   	; 0x23ae <__cmpsf2>
    1c3a:	18 16       	cp	r1, r24
    1c3c:	bc f0       	brlt	.+46     	; 0x1c6c <handle_temp_sensor+0x96>
    1c3e:	2d ec       	ldi	r18, 0xCD	; 205
    1c40:	3c ec       	ldi	r19, 0xCC	; 204
    1c42:	4c e6       	ldi	r20, 0x6C	; 108
    1c44:	50 e4       	ldi	r21, 0x40	; 64
    1c46:	c7 01       	movw	r24, r14
    1c48:	b6 01       	movw	r22, r12
    1c4a:	00 d5       	rcall	.+2560   	; 0x264c <__gesf2>
    1c4c:	18 16       	cp	r1, r24
    1c4e:	74 f4       	brge	.+28     	; 0x1c6c <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c50:	20 e0       	ldi	r18, 0x00	; 0
    1c52:	30 e0       	ldi	r19, 0x00	; 0
    1c54:	4e e5       	ldi	r20, 0x5E	; 94
    1c56:	52 e4       	ldi	r21, 0x42	; 66
    1c58:	c7 01       	movw	r24, r14
    1c5a:	b6 01       	movw	r22, r12
    1c5c:	fb d4       	rcall	.+2550   	; 0x2654 <__mulsf3>
    1c5e:	20 e0       	ldi	r18, 0x00	; 0
    1c60:	30 e8       	ldi	r19, 0x80	; 128
    1c62:	4b e1       	ldi	r20, 0x1B	; 27
    1c64:	53 e4       	ldi	r21, 0x43	; 67
    1c66:	3e d3       	rcall	.+1660   	; 0x22e4 <__subsf3>
    1c68:	13 d4       	rcall	.+2086   	; 0x2490 <__fixunssfsi>
    1c6a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c6c:	26 e6       	ldi	r18, 0x66	; 102
    1c6e:	36 e6       	ldi	r19, 0x66	; 102
    1c70:	46 e9       	ldi	r20, 0x96	; 150
    1c72:	50 e4       	ldi	r21, 0x40	; 64
    1c74:	c7 01       	movw	r24, r14
    1c76:	b6 01       	movw	r22, r12
    1c78:	e9 d4       	rcall	.+2514   	; 0x264c <__gesf2>
    1c7a:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1c7c:	74 f4       	brge	.+28     	; 0x1c9a <handle_temp_sensor+0xc4>
    1c7e:	20 e0       	ldi	r18, 0x00	; 0
    1c80:	30 e0       	ldi	r19, 0x00	; 0
    1c82:	48 e4       	ldi	r20, 0x48	; 72
    1c84:	53 e4       	ldi	r21, 0x43	; 67
    1c86:	c7 01       	movw	r24, r14
    1c88:	b6 01       	movw	r22, r12
    1c8a:	e4 d4       	rcall	.+2504   	; 0x2654 <__mulsf3>
    1c8c:	20 e0       	ldi	r18, 0x00	; 0
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	42 e5       	ldi	r20, 0x52	; 82
    1c92:	54 e4       	ldi	r21, 0x44	; 68
    1c94:	27 d3       	rcall	.+1614   	; 0x22e4 <__subsf3>
    1c96:	fc d3       	rcall	.+2040   	; 0x2490 <__fixunssfsi>
    1c98:	68 83       	st	Y, r22
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
	}
}
    1c9e:	ff 90       	pop	r15
    1ca0:	ef 90       	pop	r14
    1ca2:	df 90       	pop	r13
    1ca4:	cf 90       	pop	r12
    1ca6:	08 95       	ret

00001ca8 <handle_joulemeter>:
    1ca8:	4f 92       	push	r4
    1caa:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cac:	6f 92       	push	r6
    1cae:	7f 92       	push	r7
    1cb0:	8f 92       	push	r8
    1cb2:	9f 92       	push	r9
    1cb4:	af 92       	push	r10
    1cb6:	bf 92       	push	r11
    1cb8:	cf 92       	push	r12
    1cba:	df 92       	push	r13
    1cbc:	ef 92       	push	r14
    1cbe:	0f 93       	push	r16
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	cd b7       	in	r28, 0x3d	; 61
    1cc8:	de b7       	in	r29, 0x3e	; 62
    1cca:	28 97       	sbiw	r28, 0x08	; 8
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	6c 01       	movw	r12, r24
    1cd8:	49 83       	std	Y+1, r20	; 0x01
    1cda:	5a 83       	std	Y+2, r21	; 0x02
    1cdc:	6b 83       	std	Y+3, r22	; 0x03
    1cde:	7c 83       	std	Y+4, r23	; 0x04
    1ce0:	0d 83       	std	Y+5, r16	; 0x05
    1ce2:	1e 83       	std	Y+6, r17	; 0x06
    1ce4:	2f 83       	std	Y+7, r18	; 0x07
    1ce6:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1ce8:	6d 81       	ldd	r22, Y+5	; 0x05
    1cea:	7e 81       	ldd	r23, Y+6	; 0x06
    1cec:	8f 81       	ldd	r24, Y+7	; 0x07
    1cee:	98 85       	ldd	r25, Y+8	; 0x08
    1cf0:	29 81       	ldd	r18, Y+1	; 0x01
    1cf2:	3a 81       	ldd	r19, Y+2	; 0x02
    1cf4:	4b 81       	ldd	r20, Y+3	; 0x03
    1cf6:	5c 81       	ldd	r21, Y+4	; 0x04
    1cf8:	f6 01       	movw	r30, r12
    1cfa:	80 80       	ld	r8, Z
    1cfc:	91 80       	ldd	r9, Z+1	; 0x01
    1cfe:	a2 80       	ldd	r10, Z+2	; 0x02
    1d00:	b3 80       	ldd	r11, Z+3	; 0x03
    1d02:	a8 d4       	rcall	.+2384   	; 0x2654 <__mulsf3>
    1d04:	2b 01       	movw	r4, r22
    1d06:	3c 01       	movw	r6, r24
    1d08:	6e 2d       	mov	r22, r14
    1d0a:	70 e0       	ldi	r23, 0x00	; 0
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	eb d3       	rcall	.+2006   	; 0x24e8 <__floatunsisf>
    1d12:	9b 01       	movw	r18, r22
    1d14:	ac 01       	movw	r20, r24
    1d16:	c3 01       	movw	r24, r6
    1d18:	b2 01       	movw	r22, r4
    1d1a:	9c d4       	rcall	.+2360   	; 0x2654 <__mulsf3>
    1d1c:	20 e0       	ldi	r18, 0x00	; 0
    1d1e:	30 e0       	ldi	r19, 0x00	; 0
    1d20:	4a e7       	ldi	r20, 0x7A	; 122
    1d22:	54 e4       	ldi	r21, 0x44	; 68
    1d24:	48 d3       	rcall	.+1680   	; 0x23b6 <__divsf3>
    1d26:	a5 01       	movw	r20, r10
    1d28:	94 01       	movw	r18, r8
    1d2a:	dd d2       	rcall	.+1466   	; 0x22e6 <__addsf3>
    1d2c:	f6 01       	movw	r30, r12
    1d2e:	60 83       	st	Z, r22
    1d30:	71 83       	std	Z+1, r23	; 0x01
    1d32:	82 83       	std	Z+2, r24	; 0x02
    1d34:	93 83       	std	Z+3, r25	; 0x03
}
    1d36:	28 96       	adiw	r28, 0x08	; 8
    1d38:	0f b6       	in	r0, 0x3f	; 63
    1d3a:	f8 94       	cli
    1d3c:	de bf       	out	0x3e, r29	; 62
    1d3e:	0f be       	out	0x3f, r0	; 63
    1d40:	cd bf       	out	0x3d, r28	; 61
    1d42:	df 91       	pop	r29
    1d44:	cf 91       	pop	r28
    1d46:	1f 91       	pop	r17
    1d48:	0f 91       	pop	r16
    1d4a:	ef 90       	pop	r14
    1d4c:	df 90       	pop	r13
    1d4e:	cf 90       	pop	r12
    1d50:	bf 90       	pop	r11
    1d52:	af 90       	pop	r10
    1d54:	9f 90       	pop	r9
    1d56:	8f 90       	pop	r8
    1d58:	7f 90       	pop	r7
    1d5a:	6f 90       	pop	r6
    1d5c:	5f 90       	pop	r5
    1d5e:	4f 90       	pop	r4
    1d60:	08 95       	ret

00001d62 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	88 30       	cpi	r24, 0x08	; 8
    1d66:	91 05       	cpc	r25, r1
    1d68:	88 f5       	brcc	.+98     	; 0x1dcc <Set_ADC_Channel_ext+0x6a>
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	e6 5b       	subi	r30, 0xB6	; 182
    1d6e:	ff 4f       	sbci	r31, 0xFF	; 255
    1d70:	d4 c4       	rjmp	.+2472   	; 0x271a <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d72:	86 e0       	ldi	r24, 0x06	; 6
    1d74:	fb 01       	movw	r30, r22
    1d76:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1d78:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d7a:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d7c:	86 e0       	ldi	r24, 0x06	; 6
    1d7e:	fb 01       	movw	r30, r22
    1d80:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1d82:	80 e4       	ldi	r24, 0x40	; 64
    1d84:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d86:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d88:	86 e0       	ldi	r24, 0x06	; 6
    1d8a:	fb 01       	movw	r30, r22
    1d8c:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1d8e:	80 e8       	ldi	r24, 0x80	; 128
    1d90:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d92:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1d94:	86 e0       	ldi	r24, 0x06	; 6
    1d96:	fb 01       	movw	r30, r22
    1d98:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1d9a:	80 ec       	ldi	r24, 0xC0	; 192
    1d9c:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d9e:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1da0:	87 e0       	ldi	r24, 0x07	; 7
    1da2:	fb 01       	movw	r30, r22
    1da4:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1da6:	11 82       	std	Z+1, r1	; 0x01
		break;
    1da8:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1daa:	87 e0       	ldi	r24, 0x07	; 7
    1dac:	fb 01       	movw	r30, r22
    1dae:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1db0:	80 e4       	ldi	r24, 0x40	; 64
    1db2:	81 83       	std	Z+1, r24	; 0x01
		break;
    1db4:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1db6:	87 e0       	ldi	r24, 0x07	; 7
    1db8:	fb 01       	movw	r30, r22
    1dba:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1dbc:	80 e8       	ldi	r24, 0x80	; 128
    1dbe:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dc0:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dc2:	87 e0       	ldi	r24, 0x07	; 7
    1dc4:	fb 01       	movw	r30, r22
    1dc6:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1dc8:	80 ec       	ldi	r24, 0xC0	; 192
    1dca:	81 83       	std	Z+1, r24	; 0x01
    1dcc:	08 95       	ret

00001dce <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1dce:	1f 92       	push	r1
    1dd0:	0f 92       	push	r0
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	0f 92       	push	r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	0b b6       	in	r0, 0x3b	; 59
    1dda:	0f 92       	push	r0
    1ddc:	2f 93       	push	r18
    1dde:	3f 93       	push	r19
    1de0:	4f 93       	push	r20
    1de2:	5f 93       	push	r21
    1de4:	6f 93       	push	r22
    1de6:	8f 93       	push	r24
    1de8:	9f 93       	push	r25
    1dea:	af 93       	push	r26
    1dec:	bf 93       	push	r27
    1dee:	ef 93       	push	r30
    1df0:	ff 93       	push	r31
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	1f 92       	push	r1
    1df8:	cd b7       	in	r28, 0x3d	; 61
    1dfa:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1dfc:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e00:	80 ff       	sbrs	r24, 0
    1e02:	47 c0       	rjmp	.+142    	; 0x1e92 <__vector_18+0xc4>
    1e04:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e08:	90 ff       	sbrs	r25, 0
    1e0a:	43 c0       	rjmp	.+134    	; 0x1e92 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e0c:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e10:	ee ee       	ldi	r30, 0xEE	; 238
    1e12:	f0 e0       	ldi	r31, 0x00	; 0
    1e14:	80 81       	ld	r24, Z
    1e16:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e18:	80 81       	ld	r24, Z
    1e1a:	8f 7b       	andi	r24, 0xBF	; 191
    1e1c:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e1e:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e22:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e26:	98 17       	cp	r25, r24
    1e28:	89 f1       	breq	.+98     	; 0x1e8c <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e2a:	8f 70       	andi	r24, 0x0F	; 15
    1e2c:	2b e0       	ldi	r18, 0x0B	; 11
    1e2e:	82 9f       	mul	r24, r18
    1e30:	c0 01       	movw	r24, r0
    1e32:	11 24       	eor	r1, r1
    1e34:	fc 01       	movw	r30, r24
    1e36:	e1 54       	subi	r30, 0x41	; 65
    1e38:	fd 4f       	sbci	r31, 0xFD	; 253
    1e3a:	20 81       	ld	r18, Z
    1e3c:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e40:	20 81       	ld	r18, Z
    1e42:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e46:	21 81       	ldd	r18, Z+1	; 0x01
    1e48:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e4c:	23 81       	ldd	r18, Z+3	; 0x03
    1e4e:	aa ef       	ldi	r26, 0xFA	; 250
    1e50:	b0 e0       	ldi	r27, 0x00	; 0
    1e52:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e54:	24 81       	ldd	r18, Z+4	; 0x04
    1e56:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1e58:	25 81       	ldd	r18, Z+5	; 0x05
    1e5a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e5c:	26 81       	ldd	r18, Z+6	; 0x06
    1e5e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e60:	27 81       	ldd	r18, Z+7	; 0x07
    1e62:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e64:	20 85       	ldd	r18, Z+8	; 0x08
    1e66:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e68:	21 85       	ldd	r18, Z+9	; 0x09
    1e6a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e6c:	22 85       	ldd	r18, Z+10	; 0x0a
    1e6e:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1e70:	fc 01       	movw	r30, r24
    1e72:	ef 53       	subi	r30, 0x3F	; 63
    1e74:	fd 4f       	sbci	r31, 0xFD	; 253
    1e76:	80 81       	ld	r24, Z
    1e78:	8f 70       	andi	r24, 0x0F	; 15
    1e7a:	80 64       	ori	r24, 0x40	; 64
    1e7c:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1e80:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e84:	8f 5f       	subi	r24, 0xFF	; 255
    1e86:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1e8a:	7d c0       	rjmp	.+250    	; 0x1f86 <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1e8c:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1e90:	7a c0       	rjmp	.+244    	; 0x1f86 <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1e92:	81 ff       	sbrs	r24, 1
    1e94:	78 c0       	rjmp	.+240    	; 0x1f86 <__vector_18+0x1b8>
    1e96:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e9a:	81 ff       	sbrs	r24, 1
    1e9c:	74 c0       	rjmp	.+232    	; 0x1f86 <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1e9e:	80 e1       	ldi	r24, 0x10	; 16
    1ea0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1ea4:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ea8:	28 2f       	mov	r18, r24
    1eaa:	30 e0       	ldi	r19, 0x00	; 0
    1eac:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1eb0:	29 1b       	sub	r18, r25
    1eb2:	31 09       	sbc	r19, r1
    1eb4:	2f 77       	andi	r18, 0x7F	; 127
    1eb6:	33 27       	eor	r19, r19
    1eb8:	20 31       	cpi	r18, 0x10	; 16
    1eba:	31 05       	cpc	r19, r1
    1ebc:	0c f0       	brlt	.+2      	; 0x1ec0 <__vector_18+0xf2>
    1ebe:	58 c0       	rjmp	.+176    	; 0x1f70 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1ec0:	e8 2f       	mov	r30, r24
    1ec2:	ef 70       	andi	r30, 0x0F	; 15
    1ec4:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1ec8:	2e 2f       	mov	r18, r30
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	4b e0       	ldi	r20, 0x0B	; 11
    1ece:	e4 9f       	mul	r30, r20
    1ed0:	f0 01       	movw	r30, r0
    1ed2:	11 24       	eor	r1, r1
    1ed4:	e1 5f       	subi	r30, 0xF1	; 241
    1ed6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ed8:	9f 70       	andi	r25, 0x0F	; 15
    1eda:	42 81       	ldd	r20, Z+2	; 0x02
    1edc:	40 7f       	andi	r20, 0xF0	; 240
    1ede:	94 2b       	or	r25, r20
    1ee0:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1ee2:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1ee6:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1eea:	40 7e       	andi	r20, 0xE0	; 224
    1eec:	97 70       	andi	r25, 0x07	; 7
    1eee:	94 2b       	or	r25, r20
    1ef0:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1ef2:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1ef6:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1ef8:	aa ef       	ldi	r26, 0xFA	; 250
    1efa:	b0 e0       	ldi	r27, 0x00	; 0
    1efc:	9c 91       	ld	r25, X
    1efe:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f00:	9c 91       	ld	r25, X
    1f02:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f04:	9c 91       	ld	r25, X
    1f06:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f08:	9c 91       	ld	r25, X
    1f0a:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f0c:	9c 91       	ld	r25, X
    1f0e:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f10:	9c 91       	ld	r25, X
    1f12:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f14:	9c 91       	ld	r25, X
    1f16:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f18:	9c 91       	ld	r25, X
    1f1a:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f1c:	8f 5f       	subi	r24, 0xFF	; 255
    1f1e:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f22:	40 81       	ld	r20, Z
    1f24:	42 95       	swap	r20
    1f26:	46 95       	lsr	r20
    1f28:	47 70       	andi	r20, 0x07	; 7
    1f2a:	51 81       	ldd	r21, Z+1	; 0x01
    1f2c:	65 2f       	mov	r22, r21
    1f2e:	66 0f       	add	r22, r22
    1f30:	66 0f       	add	r22, r22
    1f32:	66 0f       	add	r22, r22
    1f34:	86 2f       	mov	r24, r22
    1f36:	84 2b       	or	r24, r20
    1f38:	95 2f       	mov	r25, r21
    1f3a:	92 95       	swap	r25
    1f3c:	96 95       	lsr	r25
    1f3e:	97 70       	andi	r25, 0x07	; 7
    1f40:	89 2b       	or	r24, r25
    1f42:	b1 f4       	brne	.+44     	; 0x1f70 <__vector_18+0x1a2>
    1f44:	8b e0       	ldi	r24, 0x0B	; 11
    1f46:	82 9f       	mul	r24, r18
    1f48:	f0 01       	movw	r30, r0
    1f4a:	83 9f       	mul	r24, r19
    1f4c:	f0 0d       	add	r31, r0
    1f4e:	11 24       	eor	r1, r1
    1f50:	e1 5f       	subi	r30, 0xF1	; 241
    1f52:	fd 4f       	sbci	r31, 0xFD	; 253
    1f54:	83 81       	ldd	r24, Z+3	; 0x03
    1f56:	83 30       	cpi	r24, 0x03	; 3
    1f58:	59 f4       	brne	.+22     	; 0x1f70 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1f5a:	98 e0       	ldi	r25, 0x08	; 8
    1f5c:	88 e1       	ldi	r24, 0x18	; 24
    1f5e:	0f b6       	in	r0, 0x3f	; 63
    1f60:	f8 94       	cli
    1f62:	a8 95       	wdr
    1f64:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f68:	0f be       	out	0x3f, r0	; 63
    1f6a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f6e:	ff cf       	rjmp	.-2      	; 0x1f6e <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1f70:	ee ee       	ldi	r30, 0xEE	; 238
    1f72:	f0 e0       	ldi	r31, 0x00	; 0
    1f74:	80 81       	ld	r24, Z
    1f76:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1f78:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1f7a:	80 81       	ld	r24, Z
    1f7c:	8f 7d       	andi	r24, 0xDF	; 223
    1f7e:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1f80:	80 e8       	ldi	r24, 0x80	; 128
    1f82:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1f86:	0f 90       	pop	r0
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	ff 91       	pop	r31
    1f8e:	ef 91       	pop	r30
    1f90:	bf 91       	pop	r27
    1f92:	af 91       	pop	r26
    1f94:	9f 91       	pop	r25
    1f96:	8f 91       	pop	r24
    1f98:	6f 91       	pop	r22
    1f9a:	5f 91       	pop	r21
    1f9c:	4f 91       	pop	r20
    1f9e:	3f 91       	pop	r19
    1fa0:	2f 91       	pop	r18
    1fa2:	0f 90       	pop	r0
    1fa4:	0b be       	out	0x3b, r0	; 59
    1fa6:	0f 90       	pop	r0
    1fa8:	0f be       	out	0x3f, r0	; 63
    1faa:	0f 90       	pop	r0
    1fac:	1f 90       	pop	r1
    1fae:	18 95       	reti

00001fb0 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1fb0:	cf 93       	push	r28
    1fb2:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1fb4:	e8 ed       	ldi	r30, 0xD8	; 216
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	21 e0       	ldi	r18, 0x01	; 1
    1fba:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1fbc:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1fc0:	2c e0       	ldi	r18, 0x0C	; 12
    1fc2:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1fc6:	27 e3       	ldi	r18, 0x37	; 55
    1fc8:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1fcc:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1fd0:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1fd4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1fd8:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1fdc:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1fe0:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    1fe4:	cd ee       	ldi	r28, 0xED	; 237
    1fe6:	d0 e0       	ldi	r29, 0x00	; 0
    1fe8:	18 82       	st	Y, r1
	CANSTMOB = 0;
    1fea:	ae ee       	ldi	r26, 0xEE	; 238
    1fec:	b0 e0       	ldi	r27, 0x00	; 0
    1fee:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    1ff0:	20 e1       	ldi	r18, 0x10	; 16
    1ff2:	28 83       	st	Y, r18
	CANSTMOB = 0;
    1ff4:	1c 92       	st	X, r1
	CANIDM4 = 0;
    1ff6:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    1ffa:	28 2f       	mov	r18, r24
    1ffc:	22 95       	swap	r18
    1ffe:	22 0f       	add	r18, r18
    2000:	20 7e       	andi	r18, 0xE0	; 224
    2002:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    2006:	96 95       	lsr	r25
    2008:	87 95       	ror	r24
    200a:	96 95       	lsr	r25
    200c:	87 95       	ror	r24
    200e:	96 95       	lsr	r25
    2010:	87 95       	ror	r24
    2012:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    2016:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    201a:	86 2f       	mov	r24, r22
    201c:	82 95       	swap	r24
    201e:	88 0f       	add	r24, r24
    2020:	80 7e       	andi	r24, 0xE0	; 224
    2022:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    2026:	76 95       	lsr	r23
    2028:	67 95       	ror	r22
    202a:	76 95       	lsr	r23
    202c:	67 95       	ror	r22
    202e:	76 95       	lsr	r23
    2030:	67 95       	ror	r22
    2032:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    2036:	80 e8       	ldi	r24, 0x80	; 128
    2038:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    203c:	83 e0       	ldi	r24, 0x03	; 3
    203e:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    2042:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    2046:	80 eb       	ldi	r24, 0xB0	; 176
    2048:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    204c:	82 e0       	ldi	r24, 0x02	; 2
    204e:	80 83       	st	Z, r24

	reset = 0;
    2050:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    2054:	df 91       	pop	r29
    2056:	cf 91       	pop	r28
    2058:	08 95       	ret

0000205a <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    205a:	cf 93       	push	r28
    205c:	df 93       	push	r29
    205e:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    2060:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    2064:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    2068:	24 17       	cp	r18, r20
    206a:	89 f1       	breq	.+98     	; 0x20ce <can_read_message_if_new+0x74>
    206c:	a4 2f       	mov	r26, r20
    206e:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    2070:	8b e0       	ldi	r24, 0x0B	; 11
    2072:	a8 9f       	mul	r26, r24
    2074:	b0 01       	movw	r22, r0
    2076:	11 24       	eor	r1, r1
    2078:	fb 01       	movw	r30, r22
    207a:	e1 5f       	subi	r30, 0xF1	; 241
    207c:	fd 4f       	sbci	r31, 0xFD	; 253
    207e:	20 81       	ld	r18, Z
    2080:	22 95       	swap	r18
    2082:	26 95       	lsr	r18
    2084:	27 70       	andi	r18, 0x07	; 7
    2086:	31 81       	ldd	r19, Z+1	; 0x01
    2088:	53 2f       	mov	r21, r19
    208a:	55 0f       	add	r21, r21
    208c:	55 0f       	add	r21, r21
    208e:	55 0f       	add	r21, r21
    2090:	25 2b       	or	r18, r21
    2092:	32 95       	swap	r19
    2094:	36 95       	lsr	r19
    2096:	37 70       	andi	r19, 0x07	; 7
    2098:	28 83       	st	Y, r18
    209a:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    209c:	fb 01       	movw	r30, r22
    209e:	ef 5e       	subi	r30, 0xEF	; 239
    20a0:	fd 4f       	sbci	r31, 0xFD	; 253
    20a2:	20 81       	ld	r18, Z
    20a4:	2f 70       	andi	r18, 0x0F	; 15
    20a6:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20a8:	22 23       	and	r18, r18
    20aa:	99 f0       	breq	.+38     	; 0x20d2 <can_read_message_if_new+0x78>
    20ac:	db 01       	movw	r26, r22
    20ae:	ae 5e       	subi	r26, 0xEE	; 238
    20b0:	bd 4f       	sbci	r27, 0xFD	; 253
    20b2:	fe 01       	movw	r30, r28
    20b4:	33 96       	adiw	r30, 0x03	; 3
    20b6:	30 e0       	ldi	r19, 0x00	; 0
    20b8:	2d 5f       	subi	r18, 0xFD	; 253
    20ba:	3f 4f       	sbci	r19, 0xFF	; 255
    20bc:	ce 01       	movw	r24, r28
    20be:	82 0f       	add	r24, r18
    20c0:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    20c2:	2d 91       	ld	r18, X+
    20c4:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    20c6:	e8 17       	cp	r30, r24
    20c8:	f9 07       	cpc	r31, r25
    20ca:	d9 f7       	brne	.-10     	; 0x20c2 <can_read_message_if_new+0x68>
    20cc:	02 c0       	rjmp	.+4      	; 0x20d2 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	04 c0       	rjmp	.+8      	; 0x20da <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    20d2:	4f 5f       	subi	r20, 0xFF	; 255
    20d4:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    20d8:	81 e0       	ldi	r24, 0x01	; 1
}
    20da:	df 91       	pop	r29
    20dc:	cf 91       	pop	r28
    20de:	08 95       	ret

000020e0 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    20e0:	cf 93       	push	r28
    20e2:	df 93       	push	r29
    20e4:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    20e6:	ab ed       	ldi	r26, 0xDB	; 219
    20e8:	b0 e0       	ldi	r27, 0x00	; 0
    20ea:	8c 91       	ld	r24, X
    20ec:	8f 77       	andi	r24, 0x7F	; 127
    20ee:	8c 93       	st	X, r24

	if (!tx_busy) {
    20f0:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    20f4:	81 11       	cpse	r24, r1
    20f6:	27 c0       	rjmp	.+78     	; 0x2146 <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    20f8:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    20fc:	80 81       	ld	r24, Z
    20fe:	82 95       	swap	r24
    2100:	88 0f       	add	r24, r24
    2102:	80 7e       	andi	r24, 0xE0	; 224
    2104:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2108:	80 81       	ld	r24, Z
    210a:	91 81       	ldd	r25, Z+1	; 0x01
    210c:	96 95       	lsr	r25
    210e:	87 95       	ror	r24
    2110:	96 95       	lsr	r25
    2112:	87 95       	ror	r24
    2114:	96 95       	lsr	r25
    2116:	87 95       	ror	r24
    2118:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    211c:	df 01       	movw	r26, r30
    211e:	13 96       	adiw	r26, 0x03	; 3
    2120:	9f 01       	movw	r18, r30
    2122:	25 5f       	subi	r18, 0xF5	; 245
    2124:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    2126:	ca ef       	ldi	r28, 0xFA	; 250
    2128:	d0 e0       	ldi	r29, 0x00	; 0
    212a:	9d 91       	ld	r25, X+
    212c:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    212e:	a2 17       	cp	r26, r18
    2130:	b3 07       	cpc	r27, r19
    2132:	d9 f7       	brne	.-10     	; 0x212a <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    2134:	81 e0       	ldi	r24, 0x01	; 1
    2136:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    213a:	82 81       	ldd	r24, Z+2	; 0x02
    213c:	80 64       	ori	r24, 0x40	; 64
    213e:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	43 c0       	rjmp	.+134    	; 0x21cc <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    2146:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    214a:	82 2f       	mov	r24, r18
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    2152:	83 1b       	sub	r24, r19
    2154:	91 09       	sbc	r25, r1
    2156:	8f 77       	andi	r24, 0x7F	; 127
    2158:	99 27       	eor	r25, r25
    215a:	40 97       	sbiw	r24, 0x10	; 16
    215c:	b1 f1       	breq	.+108    	; 0x21ca <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    215e:	a2 2f       	mov	r26, r18
    2160:	af 70       	andi	r26, 0x0F	; 15
    2162:	8b e0       	ldi	r24, 0x0B	; 11
    2164:	a8 9f       	mul	r26, r24
    2166:	d0 01       	movw	r26, r0
    2168:	11 24       	eor	r1, r1
    216a:	ed 01       	movw	r28, r26
    216c:	c1 54       	subi	r28, 0x41	; 65
    216e:	dd 4f       	sbci	r29, 0xFD	; 253
    2170:	80 81       	ld	r24, Z
    2172:	98 2f       	mov	r25, r24
    2174:	92 95       	swap	r25
    2176:	99 0f       	add	r25, r25
    2178:	90 7e       	andi	r25, 0xE0	; 224
    217a:	88 81       	ld	r24, Y
    217c:	8f 71       	andi	r24, 0x1F	; 31
    217e:	89 2b       	or	r24, r25
    2180:	88 83       	st	Y, r24
    2182:	80 81       	ld	r24, Z
    2184:	98 2f       	mov	r25, r24
    2186:	96 95       	lsr	r25
    2188:	96 95       	lsr	r25
    218a:	96 95       	lsr	r25
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	80 7e       	andi	r24, 0xE0	; 224
    2190:	89 2b       	or	r24, r25
    2192:	89 83       	std	Y+1, r24	; 0x01
    2194:	91 81       	ldd	r25, Z+1	; 0x01
    2196:	92 95       	swap	r25
    2198:	99 0f       	add	r25, r25
    219a:	90 7e       	andi	r25, 0xE0	; 224
    219c:	8f 71       	andi	r24, 0x1F	; 31
    219e:	89 2b       	or	r24, r25
    21a0:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21a2:	82 81       	ldd	r24, Z+2	; 0x02
    21a4:	98 2f       	mov	r25, r24
    21a6:	9f 70       	andi	r25, 0x0F	; 15
    21a8:	8a 81       	ldd	r24, Y+2	; 0x02
    21aa:	80 7f       	andi	r24, 0xF0	; 240
    21ac:	89 2b       	or	r24, r25
    21ae:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21b0:	ae 53       	subi	r26, 0x3E	; 62
    21b2:	bd 4f       	sbci	r27, 0xFD	; 253
    21b4:	33 96       	adiw	r30, 0x03	; 3
    21b6:	88 e0       	ldi	r24, 0x08	; 8
    21b8:	01 90       	ld	r0, Z+
    21ba:	0d 92       	st	X+, r0
    21bc:	8a 95       	dec	r24
    21be:	e1 f7       	brne	.-8      	; 0x21b8 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    21c0:	2f 5f       	subi	r18, 0xFF	; 255
    21c2:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	01 c0       	rjmp	.+2      	; 0x21cc <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    21ca:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    21cc:	eb ed       	ldi	r30, 0xDB	; 219
    21ce:	f0 e0       	ldi	r31, 0x00	; 0
    21d0:	90 81       	ld	r25, Z
    21d2:	90 68       	ori	r25, 0x80	; 128
    21d4:	90 83       	st	Z, r25

	return result;
    21d6:	df 91       	pop	r29
    21d8:	cf 91       	pop	r28
    21da:	08 95       	ret

000021dc <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    21dc:	95 b1       	in	r25, 0x05	; 5
    21de:	89 2b       	or	r24, r25
    21e0:	85 b9       	out	0x05, r24	; 5
    21e2:	08 95       	ret

000021e4 <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    21e4:	84 b1       	in	r24, 0x04	; 4
    21e6:	80 6e       	ori	r24, 0xE0	; 224
    21e8:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    21ea:	80 ee       	ldi	r24, 0xE0	; 224
    21ec:	f7 cf       	rjmp	.-18     	; 0x21dc <rgbled_turn_off>
    21ee:	08 95       	ret

000021f0 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    21f0:	95 b1       	in	r25, 0x05	; 5
    21f2:	80 95       	com	r24
    21f4:	98 23       	and	r25, r24
    21f6:	95 b9       	out	0x05, r25	; 5
    21f8:	08 95       	ret

000021fa <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    21fa:	95 b1       	in	r25, 0x05	; 5
    21fc:	89 27       	eor	r24, r25
    21fe:	85 b9       	out	0x05, r24	; 5
    2200:	08 95       	ret

00002202 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    2202:	94 b1       	in	r25, 0x04	; 4
    2204:	97 60       	ori	r25, 0x07	; 7
    2206:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2208:	82 fb       	bst	r24, 2
    220a:	99 27       	eor	r25, r25
    220c:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    220e:	28 2f       	mov	r18, r24
    2210:	22 70       	andi	r18, 0x02	; 2
    2212:	81 70       	andi	r24, 0x01	; 1
    2214:	80 65       	ori	r24, 0x50	; 80
    2216:	82 2b       	or	r24, r18
    2218:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    221a:	8c b5       	in	r24, 0x2c	; 44
    221c:	83 7f       	andi	r24, 0xF3	; 243
    221e:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2220:	9d bd       	out	0x2d, r25	; 45
    2222:	08 95       	ret

00002224 <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    2224:	cf 93       	push	r28
    2226:	df 93       	push	r29
    2228:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    222a:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    222c:	41 15       	cp	r20, r1
    222e:	51 05       	cpc	r21, r1
    2230:	c1 f0       	breq	.+48     	; 0x2262 <spi_trancieve+0x3e>
    2232:	fb 01       	movw	r30, r22
    2234:	dc 01       	movw	r26, r24
    2236:	46 0f       	add	r20, r22
    2238:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    223a:	8f ef       	ldi	r24, 0xFF	; 255
    223c:	20 97       	sbiw	r28, 0x00	; 0
    223e:	11 f0       	breq	.+4      	; 0x2244 <spi_trancieve+0x20>
    2240:	9c 91       	ld	r25, X
    2242:	01 c0       	rjmp	.+2      	; 0x2246 <spi_trancieve+0x22>
    2244:	98 2f       	mov	r25, r24
    2246:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2248:	0d b4       	in	r0, 0x2d	; 45
    224a:	07 fe       	sbrs	r0, 7
    224c:	fd cf       	rjmp	.-6      	; 0x2248 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    224e:	61 15       	cp	r22, r1
    2250:	71 05       	cpc	r23, r1
    2252:	11 f0       	breq	.+4      	; 0x2258 <spi_trancieve+0x34>
    2254:	9e b5       	in	r25, 0x2e	; 46
    2256:	90 83       	st	Z, r25
    2258:	31 96       	adiw	r30, 0x01	; 1
    225a:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    225c:	e4 17       	cp	r30, r20
    225e:	f5 07       	cpc	r31, r21
    2260:	69 f7       	brne	.-38     	; 0x223c <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2262:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    2264:	28 9a       	sbi	0x05, 0	; 5
	}
}
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	08 95       	ret

0000226c <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    226c:	1f 92       	push	r1
    226e:	0f 92       	push	r0
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	0f 92       	push	r0
    2274:	11 24       	eor	r1, r1
    2276:	0b b6       	in	r0, 0x3b	; 59
    2278:	0f 92       	push	r0
    227a:	2f 93       	push	r18
    227c:	3f 93       	push	r19
    227e:	4f 93       	push	r20
    2280:	5f 93       	push	r21
    2282:	6f 93       	push	r22
    2284:	7f 93       	push	r23
    2286:	8f 93       	push	r24
    2288:	af 93       	push	r26
    228a:	bf 93       	push	r27
    228c:	ef 93       	push	r30
    228e:	ff 93       	push	r31
    2290:	af e8       	ldi	r26, 0x8F	; 143
    2292:	b3 e0       	ldi	r27, 0x03	; 3
    2294:	ef e6       	ldi	r30, 0x6F	; 111
    2296:	f3 e0       	ldi	r31, 0x03	; 3
    2298:	2f e8       	ldi	r18, 0x8F	; 143
    229a:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    229c:	8d 91       	ld	r24, X+
    229e:	88 23       	and	r24, r24
    22a0:	59 f0       	breq	.+22     	; 0x22b8 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22a2:	40 81       	ld	r20, Z
    22a4:	51 81       	ldd	r21, Z+1	; 0x01
    22a6:	62 81       	ldd	r22, Z+2	; 0x02
    22a8:	73 81       	ldd	r23, Z+3	; 0x03
    22aa:	50 5e       	subi	r21, 0xE0	; 224
    22ac:	6f 4f       	sbci	r22, 0xFF	; 255
    22ae:	7f 4f       	sbci	r23, 0xFF	; 255
    22b0:	40 83       	st	Z, r20
    22b2:	51 83       	std	Z+1, r21	; 0x01
    22b4:	62 83       	std	Z+2, r22	; 0x02
    22b6:	73 83       	std	Z+3, r23	; 0x03
    22b8:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    22ba:	e2 17       	cp	r30, r18
    22bc:	f3 07       	cpc	r31, r19
    22be:	71 f7       	brne	.-36     	; 0x229c <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    22c0:	ff 91       	pop	r31
    22c2:	ef 91       	pop	r30
    22c4:	bf 91       	pop	r27
    22c6:	af 91       	pop	r26
    22c8:	8f 91       	pop	r24
    22ca:	7f 91       	pop	r23
    22cc:	6f 91       	pop	r22
    22ce:	5f 91       	pop	r21
    22d0:	4f 91       	pop	r20
    22d2:	3f 91       	pop	r19
    22d4:	2f 91       	pop	r18
    22d6:	0f 90       	pop	r0
    22d8:	0b be       	out	0x3b, r0	; 59
    22da:	0f 90       	pop	r0
    22dc:	0f be       	out	0x3f, r0	; 63
    22de:	0f 90       	pop	r0
    22e0:	1f 90       	pop	r1
    22e2:	18 95       	reti

000022e4 <__subsf3>:
    22e4:	50 58       	subi	r21, 0x80	; 128

000022e6 <__addsf3>:
    22e6:	bb 27       	eor	r27, r27
    22e8:	aa 27       	eor	r26, r26
    22ea:	0e d0       	rcall	.+28     	; 0x2308 <__addsf3x>
    22ec:	75 c1       	rjmp	.+746    	; 0x25d8 <__fp_round>
    22ee:	66 d1       	rcall	.+716    	; 0x25bc <__fp_pscA>
    22f0:	30 f0       	brcs	.+12     	; 0x22fe <__addsf3+0x18>
    22f2:	6b d1       	rcall	.+726    	; 0x25ca <__fp_pscB>
    22f4:	20 f0       	brcs	.+8      	; 0x22fe <__addsf3+0x18>
    22f6:	31 f4       	brne	.+12     	; 0x2304 <__addsf3+0x1e>
    22f8:	9f 3f       	cpi	r25, 0xFF	; 255
    22fa:	11 f4       	brne	.+4      	; 0x2300 <__addsf3+0x1a>
    22fc:	1e f4       	brtc	.+6      	; 0x2304 <__addsf3+0x1e>
    22fe:	5b c1       	rjmp	.+694    	; 0x25b6 <__fp_nan>
    2300:	0e f4       	brtc	.+2      	; 0x2304 <__addsf3+0x1e>
    2302:	e0 95       	com	r30
    2304:	e7 fb       	bst	r30, 7
    2306:	51 c1       	rjmp	.+674    	; 0x25aa <__fp_inf>

00002308 <__addsf3x>:
    2308:	e9 2f       	mov	r30, r25
    230a:	77 d1       	rcall	.+750    	; 0x25fa <__fp_split3>
    230c:	80 f3       	brcs	.-32     	; 0x22ee <__addsf3+0x8>
    230e:	ba 17       	cp	r27, r26
    2310:	62 07       	cpc	r22, r18
    2312:	73 07       	cpc	r23, r19
    2314:	84 07       	cpc	r24, r20
    2316:	95 07       	cpc	r25, r21
    2318:	18 f0       	brcs	.+6      	; 0x2320 <__addsf3x+0x18>
    231a:	71 f4       	brne	.+28     	; 0x2338 <__addsf3x+0x30>
    231c:	9e f5       	brtc	.+102    	; 0x2384 <__addsf3x+0x7c>
    231e:	8f c1       	rjmp	.+798    	; 0x263e <__fp_zero>
    2320:	0e f4       	brtc	.+2      	; 0x2324 <__addsf3x+0x1c>
    2322:	e0 95       	com	r30
    2324:	0b 2e       	mov	r0, r27
    2326:	ba 2f       	mov	r27, r26
    2328:	a0 2d       	mov	r26, r0
    232a:	0b 01       	movw	r0, r22
    232c:	b9 01       	movw	r22, r18
    232e:	90 01       	movw	r18, r0
    2330:	0c 01       	movw	r0, r24
    2332:	ca 01       	movw	r24, r20
    2334:	a0 01       	movw	r20, r0
    2336:	11 24       	eor	r1, r1
    2338:	ff 27       	eor	r31, r31
    233a:	59 1b       	sub	r21, r25
    233c:	99 f0       	breq	.+38     	; 0x2364 <__addsf3x+0x5c>
    233e:	59 3f       	cpi	r21, 0xF9	; 249
    2340:	50 f4       	brcc	.+20     	; 0x2356 <__addsf3x+0x4e>
    2342:	50 3e       	cpi	r21, 0xE0	; 224
    2344:	68 f1       	brcs	.+90     	; 0x23a0 <__addsf3x+0x98>
    2346:	1a 16       	cp	r1, r26
    2348:	f0 40       	sbci	r31, 0x00	; 0
    234a:	a2 2f       	mov	r26, r18
    234c:	23 2f       	mov	r18, r19
    234e:	34 2f       	mov	r19, r20
    2350:	44 27       	eor	r20, r20
    2352:	58 5f       	subi	r21, 0xF8	; 248
    2354:	f3 cf       	rjmp	.-26     	; 0x233c <__addsf3x+0x34>
    2356:	46 95       	lsr	r20
    2358:	37 95       	ror	r19
    235a:	27 95       	ror	r18
    235c:	a7 95       	ror	r26
    235e:	f0 40       	sbci	r31, 0x00	; 0
    2360:	53 95       	inc	r21
    2362:	c9 f7       	brne	.-14     	; 0x2356 <__addsf3x+0x4e>
    2364:	7e f4       	brtc	.+30     	; 0x2384 <__addsf3x+0x7c>
    2366:	1f 16       	cp	r1, r31
    2368:	ba 0b       	sbc	r27, r26
    236a:	62 0b       	sbc	r22, r18
    236c:	73 0b       	sbc	r23, r19
    236e:	84 0b       	sbc	r24, r20
    2370:	ba f0       	brmi	.+46     	; 0x23a0 <__addsf3x+0x98>
    2372:	91 50       	subi	r25, 0x01	; 1
    2374:	a1 f0       	breq	.+40     	; 0x239e <__addsf3x+0x96>
    2376:	ff 0f       	add	r31, r31
    2378:	bb 1f       	adc	r27, r27
    237a:	66 1f       	adc	r22, r22
    237c:	77 1f       	adc	r23, r23
    237e:	88 1f       	adc	r24, r24
    2380:	c2 f7       	brpl	.-16     	; 0x2372 <__addsf3x+0x6a>
    2382:	0e c0       	rjmp	.+28     	; 0x23a0 <__addsf3x+0x98>
    2384:	ba 0f       	add	r27, r26
    2386:	62 1f       	adc	r22, r18
    2388:	73 1f       	adc	r23, r19
    238a:	84 1f       	adc	r24, r20
    238c:	48 f4       	brcc	.+18     	; 0x23a0 <__addsf3x+0x98>
    238e:	87 95       	ror	r24
    2390:	77 95       	ror	r23
    2392:	67 95       	ror	r22
    2394:	b7 95       	ror	r27
    2396:	f7 95       	ror	r31
    2398:	9e 3f       	cpi	r25, 0xFE	; 254
    239a:	08 f0       	brcs	.+2      	; 0x239e <__addsf3x+0x96>
    239c:	b3 cf       	rjmp	.-154    	; 0x2304 <__addsf3+0x1e>
    239e:	93 95       	inc	r25
    23a0:	88 0f       	add	r24, r24
    23a2:	08 f0       	brcs	.+2      	; 0x23a6 <__addsf3x+0x9e>
    23a4:	99 27       	eor	r25, r25
    23a6:	ee 0f       	add	r30, r30
    23a8:	97 95       	ror	r25
    23aa:	87 95       	ror	r24
    23ac:	08 95       	ret

000023ae <__cmpsf2>:
    23ae:	d9 d0       	rcall	.+434    	; 0x2562 <__fp_cmp>
    23b0:	08 f4       	brcc	.+2      	; 0x23b4 <__cmpsf2+0x6>
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	08 95       	ret

000023b6 <__divsf3>:
    23b6:	0c d0       	rcall	.+24     	; 0x23d0 <__divsf3x>
    23b8:	0f c1       	rjmp	.+542    	; 0x25d8 <__fp_round>
    23ba:	07 d1       	rcall	.+526    	; 0x25ca <__fp_pscB>
    23bc:	40 f0       	brcs	.+16     	; 0x23ce <__divsf3+0x18>
    23be:	fe d0       	rcall	.+508    	; 0x25bc <__fp_pscA>
    23c0:	30 f0       	brcs	.+12     	; 0x23ce <__divsf3+0x18>
    23c2:	21 f4       	brne	.+8      	; 0x23cc <__divsf3+0x16>
    23c4:	5f 3f       	cpi	r21, 0xFF	; 255
    23c6:	19 f0       	breq	.+6      	; 0x23ce <__divsf3+0x18>
    23c8:	f0 c0       	rjmp	.+480    	; 0x25aa <__fp_inf>
    23ca:	51 11       	cpse	r21, r1
    23cc:	39 c1       	rjmp	.+626    	; 0x2640 <__fp_szero>
    23ce:	f3 c0       	rjmp	.+486    	; 0x25b6 <__fp_nan>

000023d0 <__divsf3x>:
    23d0:	14 d1       	rcall	.+552    	; 0x25fa <__fp_split3>
    23d2:	98 f3       	brcs	.-26     	; 0x23ba <__divsf3+0x4>

000023d4 <__divsf3_pse>:
    23d4:	99 23       	and	r25, r25
    23d6:	c9 f3       	breq	.-14     	; 0x23ca <__divsf3+0x14>
    23d8:	55 23       	and	r21, r21
    23da:	b1 f3       	breq	.-20     	; 0x23c8 <__divsf3+0x12>
    23dc:	95 1b       	sub	r25, r21
    23de:	55 0b       	sbc	r21, r21
    23e0:	bb 27       	eor	r27, r27
    23e2:	aa 27       	eor	r26, r26
    23e4:	62 17       	cp	r22, r18
    23e6:	73 07       	cpc	r23, r19
    23e8:	84 07       	cpc	r24, r20
    23ea:	38 f0       	brcs	.+14     	; 0x23fa <__divsf3_pse+0x26>
    23ec:	9f 5f       	subi	r25, 0xFF	; 255
    23ee:	5f 4f       	sbci	r21, 0xFF	; 255
    23f0:	22 0f       	add	r18, r18
    23f2:	33 1f       	adc	r19, r19
    23f4:	44 1f       	adc	r20, r20
    23f6:	aa 1f       	adc	r26, r26
    23f8:	a9 f3       	breq	.-22     	; 0x23e4 <__divsf3_pse+0x10>
    23fa:	33 d0       	rcall	.+102    	; 0x2462 <__divsf3_pse+0x8e>
    23fc:	0e 2e       	mov	r0, r30
    23fe:	3a f0       	brmi	.+14     	; 0x240e <__divsf3_pse+0x3a>
    2400:	e0 e8       	ldi	r30, 0x80	; 128
    2402:	30 d0       	rcall	.+96     	; 0x2464 <__divsf3_pse+0x90>
    2404:	91 50       	subi	r25, 0x01	; 1
    2406:	50 40       	sbci	r21, 0x00	; 0
    2408:	e6 95       	lsr	r30
    240a:	00 1c       	adc	r0, r0
    240c:	ca f7       	brpl	.-14     	; 0x2400 <__divsf3_pse+0x2c>
    240e:	29 d0       	rcall	.+82     	; 0x2462 <__divsf3_pse+0x8e>
    2410:	fe 2f       	mov	r31, r30
    2412:	27 d0       	rcall	.+78     	; 0x2462 <__divsf3_pse+0x8e>
    2414:	66 0f       	add	r22, r22
    2416:	77 1f       	adc	r23, r23
    2418:	88 1f       	adc	r24, r24
    241a:	bb 1f       	adc	r27, r27
    241c:	26 17       	cp	r18, r22
    241e:	37 07       	cpc	r19, r23
    2420:	48 07       	cpc	r20, r24
    2422:	ab 07       	cpc	r26, r27
    2424:	b0 e8       	ldi	r27, 0x80	; 128
    2426:	09 f0       	breq	.+2      	; 0x242a <__divsf3_pse+0x56>
    2428:	bb 0b       	sbc	r27, r27
    242a:	80 2d       	mov	r24, r0
    242c:	bf 01       	movw	r22, r30
    242e:	ff 27       	eor	r31, r31
    2430:	93 58       	subi	r25, 0x83	; 131
    2432:	5f 4f       	sbci	r21, 0xFF	; 255
    2434:	2a f0       	brmi	.+10     	; 0x2440 <__divsf3_pse+0x6c>
    2436:	9e 3f       	cpi	r25, 0xFE	; 254
    2438:	51 05       	cpc	r21, r1
    243a:	68 f0       	brcs	.+26     	; 0x2456 <__divsf3_pse+0x82>
    243c:	b6 c0       	rjmp	.+364    	; 0x25aa <__fp_inf>
    243e:	00 c1       	rjmp	.+512    	; 0x2640 <__fp_szero>
    2440:	5f 3f       	cpi	r21, 0xFF	; 255
    2442:	ec f3       	brlt	.-6      	; 0x243e <__divsf3_pse+0x6a>
    2444:	98 3e       	cpi	r25, 0xE8	; 232
    2446:	dc f3       	brlt	.-10     	; 0x243e <__divsf3_pse+0x6a>
    2448:	86 95       	lsr	r24
    244a:	77 95       	ror	r23
    244c:	67 95       	ror	r22
    244e:	b7 95       	ror	r27
    2450:	f7 95       	ror	r31
    2452:	9f 5f       	subi	r25, 0xFF	; 255
    2454:	c9 f7       	brne	.-14     	; 0x2448 <__divsf3_pse+0x74>
    2456:	88 0f       	add	r24, r24
    2458:	91 1d       	adc	r25, r1
    245a:	96 95       	lsr	r25
    245c:	87 95       	ror	r24
    245e:	97 f9       	bld	r25, 7
    2460:	08 95       	ret
    2462:	e1 e0       	ldi	r30, 0x01	; 1
    2464:	66 0f       	add	r22, r22
    2466:	77 1f       	adc	r23, r23
    2468:	88 1f       	adc	r24, r24
    246a:	bb 1f       	adc	r27, r27
    246c:	62 17       	cp	r22, r18
    246e:	73 07       	cpc	r23, r19
    2470:	84 07       	cpc	r24, r20
    2472:	ba 07       	cpc	r27, r26
    2474:	20 f0       	brcs	.+8      	; 0x247e <__divsf3_pse+0xaa>
    2476:	62 1b       	sub	r22, r18
    2478:	73 0b       	sbc	r23, r19
    247a:	84 0b       	sbc	r24, r20
    247c:	ba 0b       	sbc	r27, r26
    247e:	ee 1f       	adc	r30, r30
    2480:	88 f7       	brcc	.-30     	; 0x2464 <__divsf3_pse+0x90>
    2482:	e0 95       	com	r30
    2484:	08 95       	ret

00002486 <__fixsfsi>:
    2486:	04 d0       	rcall	.+8      	; 0x2490 <__fixunssfsi>
    2488:	68 94       	set
    248a:	b1 11       	cpse	r27, r1
    248c:	d9 c0       	rjmp	.+434    	; 0x2640 <__fp_szero>
    248e:	08 95       	ret

00002490 <__fixunssfsi>:
    2490:	bc d0       	rcall	.+376    	; 0x260a <__fp_splitA>
    2492:	88 f0       	brcs	.+34     	; 0x24b6 <__fixunssfsi+0x26>
    2494:	9f 57       	subi	r25, 0x7F	; 127
    2496:	90 f0       	brcs	.+36     	; 0x24bc <__fixunssfsi+0x2c>
    2498:	b9 2f       	mov	r27, r25
    249a:	99 27       	eor	r25, r25
    249c:	b7 51       	subi	r27, 0x17	; 23
    249e:	a0 f0       	brcs	.+40     	; 0x24c8 <__fixunssfsi+0x38>
    24a0:	d1 f0       	breq	.+52     	; 0x24d6 <__fixunssfsi+0x46>
    24a2:	66 0f       	add	r22, r22
    24a4:	77 1f       	adc	r23, r23
    24a6:	88 1f       	adc	r24, r24
    24a8:	99 1f       	adc	r25, r25
    24aa:	1a f0       	brmi	.+6      	; 0x24b2 <__fixunssfsi+0x22>
    24ac:	ba 95       	dec	r27
    24ae:	c9 f7       	brne	.-14     	; 0x24a2 <__fixunssfsi+0x12>
    24b0:	12 c0       	rjmp	.+36     	; 0x24d6 <__fixunssfsi+0x46>
    24b2:	b1 30       	cpi	r27, 0x01	; 1
    24b4:	81 f0       	breq	.+32     	; 0x24d6 <__fixunssfsi+0x46>
    24b6:	c3 d0       	rcall	.+390    	; 0x263e <__fp_zero>
    24b8:	b1 e0       	ldi	r27, 0x01	; 1
    24ba:	08 95       	ret
    24bc:	c0 c0       	rjmp	.+384    	; 0x263e <__fp_zero>
    24be:	67 2f       	mov	r22, r23
    24c0:	78 2f       	mov	r23, r24
    24c2:	88 27       	eor	r24, r24
    24c4:	b8 5f       	subi	r27, 0xF8	; 248
    24c6:	39 f0       	breq	.+14     	; 0x24d6 <__fixunssfsi+0x46>
    24c8:	b9 3f       	cpi	r27, 0xF9	; 249
    24ca:	cc f3       	brlt	.-14     	; 0x24be <__fixunssfsi+0x2e>
    24cc:	86 95       	lsr	r24
    24ce:	77 95       	ror	r23
    24d0:	67 95       	ror	r22
    24d2:	b3 95       	inc	r27
    24d4:	d9 f7       	brne	.-10     	; 0x24cc <__fixunssfsi+0x3c>
    24d6:	3e f4       	brtc	.+14     	; 0x24e6 <__fixunssfsi+0x56>
    24d8:	90 95       	com	r25
    24da:	80 95       	com	r24
    24dc:	70 95       	com	r23
    24de:	61 95       	neg	r22
    24e0:	7f 4f       	sbci	r23, 0xFF	; 255
    24e2:	8f 4f       	sbci	r24, 0xFF	; 255
    24e4:	9f 4f       	sbci	r25, 0xFF	; 255
    24e6:	08 95       	ret

000024e8 <__floatunsisf>:
    24e8:	e8 94       	clt
    24ea:	09 c0       	rjmp	.+18     	; 0x24fe <__floatsisf+0x12>

000024ec <__floatsisf>:
    24ec:	97 fb       	bst	r25, 7
    24ee:	3e f4       	brtc	.+14     	; 0x24fe <__floatsisf+0x12>
    24f0:	90 95       	com	r25
    24f2:	80 95       	com	r24
    24f4:	70 95       	com	r23
    24f6:	61 95       	neg	r22
    24f8:	7f 4f       	sbci	r23, 0xFF	; 255
    24fa:	8f 4f       	sbci	r24, 0xFF	; 255
    24fc:	9f 4f       	sbci	r25, 0xFF	; 255
    24fe:	99 23       	and	r25, r25
    2500:	a9 f0       	breq	.+42     	; 0x252c <__floatsisf+0x40>
    2502:	f9 2f       	mov	r31, r25
    2504:	96 e9       	ldi	r25, 0x96	; 150
    2506:	bb 27       	eor	r27, r27
    2508:	93 95       	inc	r25
    250a:	f6 95       	lsr	r31
    250c:	87 95       	ror	r24
    250e:	77 95       	ror	r23
    2510:	67 95       	ror	r22
    2512:	b7 95       	ror	r27
    2514:	f1 11       	cpse	r31, r1
    2516:	f8 cf       	rjmp	.-16     	; 0x2508 <__floatsisf+0x1c>
    2518:	fa f4       	brpl	.+62     	; 0x2558 <__floatsisf+0x6c>
    251a:	bb 0f       	add	r27, r27
    251c:	11 f4       	brne	.+4      	; 0x2522 <__floatsisf+0x36>
    251e:	60 ff       	sbrs	r22, 0
    2520:	1b c0       	rjmp	.+54     	; 0x2558 <__floatsisf+0x6c>
    2522:	6f 5f       	subi	r22, 0xFF	; 255
    2524:	7f 4f       	sbci	r23, 0xFF	; 255
    2526:	8f 4f       	sbci	r24, 0xFF	; 255
    2528:	9f 4f       	sbci	r25, 0xFF	; 255
    252a:	16 c0       	rjmp	.+44     	; 0x2558 <__floatsisf+0x6c>
    252c:	88 23       	and	r24, r24
    252e:	11 f0       	breq	.+4      	; 0x2534 <__floatsisf+0x48>
    2530:	96 e9       	ldi	r25, 0x96	; 150
    2532:	11 c0       	rjmp	.+34     	; 0x2556 <__floatsisf+0x6a>
    2534:	77 23       	and	r23, r23
    2536:	21 f0       	breq	.+8      	; 0x2540 <__floatsisf+0x54>
    2538:	9e e8       	ldi	r25, 0x8E	; 142
    253a:	87 2f       	mov	r24, r23
    253c:	76 2f       	mov	r23, r22
    253e:	05 c0       	rjmp	.+10     	; 0x254a <__floatsisf+0x5e>
    2540:	66 23       	and	r22, r22
    2542:	71 f0       	breq	.+28     	; 0x2560 <__floatsisf+0x74>
    2544:	96 e8       	ldi	r25, 0x86	; 134
    2546:	86 2f       	mov	r24, r22
    2548:	70 e0       	ldi	r23, 0x00	; 0
    254a:	60 e0       	ldi	r22, 0x00	; 0
    254c:	2a f0       	brmi	.+10     	; 0x2558 <__floatsisf+0x6c>
    254e:	9a 95       	dec	r25
    2550:	66 0f       	add	r22, r22
    2552:	77 1f       	adc	r23, r23
    2554:	88 1f       	adc	r24, r24
    2556:	da f7       	brpl	.-10     	; 0x254e <__floatsisf+0x62>
    2558:	88 0f       	add	r24, r24
    255a:	96 95       	lsr	r25
    255c:	87 95       	ror	r24
    255e:	97 f9       	bld	r25, 7
    2560:	08 95       	ret

00002562 <__fp_cmp>:
    2562:	99 0f       	add	r25, r25
    2564:	00 08       	sbc	r0, r0
    2566:	55 0f       	add	r21, r21
    2568:	aa 0b       	sbc	r26, r26
    256a:	e0 e8       	ldi	r30, 0x80	; 128
    256c:	fe ef       	ldi	r31, 0xFE	; 254
    256e:	16 16       	cp	r1, r22
    2570:	17 06       	cpc	r1, r23
    2572:	e8 07       	cpc	r30, r24
    2574:	f9 07       	cpc	r31, r25
    2576:	c0 f0       	brcs	.+48     	; 0x25a8 <__fp_cmp+0x46>
    2578:	12 16       	cp	r1, r18
    257a:	13 06       	cpc	r1, r19
    257c:	e4 07       	cpc	r30, r20
    257e:	f5 07       	cpc	r31, r21
    2580:	98 f0       	brcs	.+38     	; 0x25a8 <__fp_cmp+0x46>
    2582:	62 1b       	sub	r22, r18
    2584:	73 0b       	sbc	r23, r19
    2586:	84 0b       	sbc	r24, r20
    2588:	95 0b       	sbc	r25, r21
    258a:	39 f4       	brne	.+14     	; 0x259a <__fp_cmp+0x38>
    258c:	0a 26       	eor	r0, r26
    258e:	61 f0       	breq	.+24     	; 0x25a8 <__fp_cmp+0x46>
    2590:	23 2b       	or	r18, r19
    2592:	24 2b       	or	r18, r20
    2594:	25 2b       	or	r18, r21
    2596:	21 f4       	brne	.+8      	; 0x25a0 <__fp_cmp+0x3e>
    2598:	08 95       	ret
    259a:	0a 26       	eor	r0, r26
    259c:	09 f4       	brne	.+2      	; 0x25a0 <__fp_cmp+0x3e>
    259e:	a1 40       	sbci	r26, 0x01	; 1
    25a0:	a6 95       	lsr	r26
    25a2:	8f ef       	ldi	r24, 0xFF	; 255
    25a4:	81 1d       	adc	r24, r1
    25a6:	81 1d       	adc	r24, r1
    25a8:	08 95       	ret

000025aa <__fp_inf>:
    25aa:	97 f9       	bld	r25, 7
    25ac:	9f 67       	ori	r25, 0x7F	; 127
    25ae:	80 e8       	ldi	r24, 0x80	; 128
    25b0:	70 e0       	ldi	r23, 0x00	; 0
    25b2:	60 e0       	ldi	r22, 0x00	; 0
    25b4:	08 95       	ret

000025b6 <__fp_nan>:
    25b6:	9f ef       	ldi	r25, 0xFF	; 255
    25b8:	80 ec       	ldi	r24, 0xC0	; 192
    25ba:	08 95       	ret

000025bc <__fp_pscA>:
    25bc:	00 24       	eor	r0, r0
    25be:	0a 94       	dec	r0
    25c0:	16 16       	cp	r1, r22
    25c2:	17 06       	cpc	r1, r23
    25c4:	18 06       	cpc	r1, r24
    25c6:	09 06       	cpc	r0, r25
    25c8:	08 95       	ret

000025ca <__fp_pscB>:
    25ca:	00 24       	eor	r0, r0
    25cc:	0a 94       	dec	r0
    25ce:	12 16       	cp	r1, r18
    25d0:	13 06       	cpc	r1, r19
    25d2:	14 06       	cpc	r1, r20
    25d4:	05 06       	cpc	r0, r21
    25d6:	08 95       	ret

000025d8 <__fp_round>:
    25d8:	09 2e       	mov	r0, r25
    25da:	03 94       	inc	r0
    25dc:	00 0c       	add	r0, r0
    25de:	11 f4       	brne	.+4      	; 0x25e4 <__fp_round+0xc>
    25e0:	88 23       	and	r24, r24
    25e2:	52 f0       	brmi	.+20     	; 0x25f8 <__fp_round+0x20>
    25e4:	bb 0f       	add	r27, r27
    25e6:	40 f4       	brcc	.+16     	; 0x25f8 <__fp_round+0x20>
    25e8:	bf 2b       	or	r27, r31
    25ea:	11 f4       	brne	.+4      	; 0x25f0 <__fp_round+0x18>
    25ec:	60 ff       	sbrs	r22, 0
    25ee:	04 c0       	rjmp	.+8      	; 0x25f8 <__fp_round+0x20>
    25f0:	6f 5f       	subi	r22, 0xFF	; 255
    25f2:	7f 4f       	sbci	r23, 0xFF	; 255
    25f4:	8f 4f       	sbci	r24, 0xFF	; 255
    25f6:	9f 4f       	sbci	r25, 0xFF	; 255
    25f8:	08 95       	ret

000025fa <__fp_split3>:
    25fa:	57 fd       	sbrc	r21, 7
    25fc:	90 58       	subi	r25, 0x80	; 128
    25fe:	44 0f       	add	r20, r20
    2600:	55 1f       	adc	r21, r21
    2602:	59 f0       	breq	.+22     	; 0x261a <__fp_splitA+0x10>
    2604:	5f 3f       	cpi	r21, 0xFF	; 255
    2606:	71 f0       	breq	.+28     	; 0x2624 <__fp_splitA+0x1a>
    2608:	47 95       	ror	r20

0000260a <__fp_splitA>:
    260a:	88 0f       	add	r24, r24
    260c:	97 fb       	bst	r25, 7
    260e:	99 1f       	adc	r25, r25
    2610:	61 f0       	breq	.+24     	; 0x262a <__fp_splitA+0x20>
    2612:	9f 3f       	cpi	r25, 0xFF	; 255
    2614:	79 f0       	breq	.+30     	; 0x2634 <__fp_splitA+0x2a>
    2616:	87 95       	ror	r24
    2618:	08 95       	ret
    261a:	12 16       	cp	r1, r18
    261c:	13 06       	cpc	r1, r19
    261e:	14 06       	cpc	r1, r20
    2620:	55 1f       	adc	r21, r21
    2622:	f2 cf       	rjmp	.-28     	; 0x2608 <__fp_split3+0xe>
    2624:	46 95       	lsr	r20
    2626:	f1 df       	rcall	.-30     	; 0x260a <__fp_splitA>
    2628:	08 c0       	rjmp	.+16     	; 0x263a <__fp_splitA+0x30>
    262a:	16 16       	cp	r1, r22
    262c:	17 06       	cpc	r1, r23
    262e:	18 06       	cpc	r1, r24
    2630:	99 1f       	adc	r25, r25
    2632:	f1 cf       	rjmp	.-30     	; 0x2616 <__fp_splitA+0xc>
    2634:	86 95       	lsr	r24
    2636:	71 05       	cpc	r23, r1
    2638:	61 05       	cpc	r22, r1
    263a:	08 94       	sec
    263c:	08 95       	ret

0000263e <__fp_zero>:
    263e:	e8 94       	clt

00002640 <__fp_szero>:
    2640:	bb 27       	eor	r27, r27
    2642:	66 27       	eor	r22, r22
    2644:	77 27       	eor	r23, r23
    2646:	cb 01       	movw	r24, r22
    2648:	97 f9       	bld	r25, 7
    264a:	08 95       	ret

0000264c <__gesf2>:
    264c:	8a df       	rcall	.-236    	; 0x2562 <__fp_cmp>
    264e:	08 f4       	brcc	.+2      	; 0x2652 <__gesf2+0x6>
    2650:	8f ef       	ldi	r24, 0xFF	; 255
    2652:	08 95       	ret

00002654 <__mulsf3>:
    2654:	0b d0       	rcall	.+22     	; 0x266c <__mulsf3x>
    2656:	c0 cf       	rjmp	.-128    	; 0x25d8 <__fp_round>
    2658:	b1 df       	rcall	.-158    	; 0x25bc <__fp_pscA>
    265a:	28 f0       	brcs	.+10     	; 0x2666 <__mulsf3+0x12>
    265c:	b6 df       	rcall	.-148    	; 0x25ca <__fp_pscB>
    265e:	18 f0       	brcs	.+6      	; 0x2666 <__mulsf3+0x12>
    2660:	95 23       	and	r25, r21
    2662:	09 f0       	breq	.+2      	; 0x2666 <__mulsf3+0x12>
    2664:	a2 cf       	rjmp	.-188    	; 0x25aa <__fp_inf>
    2666:	a7 cf       	rjmp	.-178    	; 0x25b6 <__fp_nan>
    2668:	11 24       	eor	r1, r1
    266a:	ea cf       	rjmp	.-44     	; 0x2640 <__fp_szero>

0000266c <__mulsf3x>:
    266c:	c6 df       	rcall	.-116    	; 0x25fa <__fp_split3>
    266e:	a0 f3       	brcs	.-24     	; 0x2658 <__mulsf3+0x4>

00002670 <__mulsf3_pse>:
    2670:	95 9f       	mul	r25, r21
    2672:	d1 f3       	breq	.-12     	; 0x2668 <__mulsf3+0x14>
    2674:	95 0f       	add	r25, r21
    2676:	50 e0       	ldi	r21, 0x00	; 0
    2678:	55 1f       	adc	r21, r21
    267a:	62 9f       	mul	r22, r18
    267c:	f0 01       	movw	r30, r0
    267e:	72 9f       	mul	r23, r18
    2680:	bb 27       	eor	r27, r27
    2682:	f0 0d       	add	r31, r0
    2684:	b1 1d       	adc	r27, r1
    2686:	63 9f       	mul	r22, r19
    2688:	aa 27       	eor	r26, r26
    268a:	f0 0d       	add	r31, r0
    268c:	b1 1d       	adc	r27, r1
    268e:	aa 1f       	adc	r26, r26
    2690:	64 9f       	mul	r22, r20
    2692:	66 27       	eor	r22, r22
    2694:	b0 0d       	add	r27, r0
    2696:	a1 1d       	adc	r26, r1
    2698:	66 1f       	adc	r22, r22
    269a:	82 9f       	mul	r24, r18
    269c:	22 27       	eor	r18, r18
    269e:	b0 0d       	add	r27, r0
    26a0:	a1 1d       	adc	r26, r1
    26a2:	62 1f       	adc	r22, r18
    26a4:	73 9f       	mul	r23, r19
    26a6:	b0 0d       	add	r27, r0
    26a8:	a1 1d       	adc	r26, r1
    26aa:	62 1f       	adc	r22, r18
    26ac:	83 9f       	mul	r24, r19
    26ae:	a0 0d       	add	r26, r0
    26b0:	61 1d       	adc	r22, r1
    26b2:	22 1f       	adc	r18, r18
    26b4:	74 9f       	mul	r23, r20
    26b6:	33 27       	eor	r19, r19
    26b8:	a0 0d       	add	r26, r0
    26ba:	61 1d       	adc	r22, r1
    26bc:	23 1f       	adc	r18, r19
    26be:	84 9f       	mul	r24, r20
    26c0:	60 0d       	add	r22, r0
    26c2:	21 1d       	adc	r18, r1
    26c4:	82 2f       	mov	r24, r18
    26c6:	76 2f       	mov	r23, r22
    26c8:	6a 2f       	mov	r22, r26
    26ca:	11 24       	eor	r1, r1
    26cc:	9f 57       	subi	r25, 0x7F	; 127
    26ce:	50 40       	sbci	r21, 0x00	; 0
    26d0:	8a f0       	brmi	.+34     	; 0x26f4 <__mulsf3_pse+0x84>
    26d2:	e1 f0       	breq	.+56     	; 0x270c <__mulsf3_pse+0x9c>
    26d4:	88 23       	and	r24, r24
    26d6:	4a f0       	brmi	.+18     	; 0x26ea <__mulsf3_pse+0x7a>
    26d8:	ee 0f       	add	r30, r30
    26da:	ff 1f       	adc	r31, r31
    26dc:	bb 1f       	adc	r27, r27
    26de:	66 1f       	adc	r22, r22
    26e0:	77 1f       	adc	r23, r23
    26e2:	88 1f       	adc	r24, r24
    26e4:	91 50       	subi	r25, 0x01	; 1
    26e6:	50 40       	sbci	r21, 0x00	; 0
    26e8:	a9 f7       	brne	.-22     	; 0x26d4 <__mulsf3_pse+0x64>
    26ea:	9e 3f       	cpi	r25, 0xFE	; 254
    26ec:	51 05       	cpc	r21, r1
    26ee:	70 f0       	brcs	.+28     	; 0x270c <__mulsf3_pse+0x9c>
    26f0:	5c cf       	rjmp	.-328    	; 0x25aa <__fp_inf>
    26f2:	a6 cf       	rjmp	.-180    	; 0x2640 <__fp_szero>
    26f4:	5f 3f       	cpi	r21, 0xFF	; 255
    26f6:	ec f3       	brlt	.-6      	; 0x26f2 <__mulsf3_pse+0x82>
    26f8:	98 3e       	cpi	r25, 0xE8	; 232
    26fa:	dc f3       	brlt	.-10     	; 0x26f2 <__mulsf3_pse+0x82>
    26fc:	86 95       	lsr	r24
    26fe:	77 95       	ror	r23
    2700:	67 95       	ror	r22
    2702:	b7 95       	ror	r27
    2704:	f7 95       	ror	r31
    2706:	e7 95       	ror	r30
    2708:	9f 5f       	subi	r25, 0xFF	; 255
    270a:	c1 f7       	brne	.-16     	; 0x26fc <__mulsf3_pse+0x8c>
    270c:	fe 2b       	or	r31, r30
    270e:	88 0f       	add	r24, r24
    2710:	91 1d       	adc	r25, r1
    2712:	96 95       	lsr	r25
    2714:	87 95       	ror	r24
    2716:	97 f9       	bld	r25, 7
    2718:	08 95       	ret

0000271a <__tablejump2__>:
    271a:	ee 0f       	add	r30, r30
    271c:	ff 1f       	adc	r31, r31
    271e:	00 24       	eor	r0, r0
    2720:	00 1c       	adc	r0, r0
    2722:	0b be       	out	0x3b, r0	; 59
    2724:	07 90       	elpm	r0, Z+
    2726:	f6 91       	elpm	r31, Z
    2728:	e0 2d       	mov	r30, r0
    272a:	09 94       	ijmp

0000272c <atoi>:
    272c:	fc 01       	movw	r30, r24
    272e:	88 27       	eor	r24, r24
    2730:	99 27       	eor	r25, r25
    2732:	e8 94       	clt
    2734:	21 91       	ld	r18, Z+
    2736:	20 32       	cpi	r18, 0x20	; 32
    2738:	e9 f3       	breq	.-6      	; 0x2734 <atoi+0x8>
    273a:	29 30       	cpi	r18, 0x09	; 9
    273c:	10 f0       	brcs	.+4      	; 0x2742 <atoi+0x16>
    273e:	2e 30       	cpi	r18, 0x0E	; 14
    2740:	c8 f3       	brcs	.-14     	; 0x2734 <atoi+0x8>
    2742:	2b 32       	cpi	r18, 0x2B	; 43
    2744:	39 f0       	breq	.+14     	; 0x2754 <atoi+0x28>
    2746:	2d 32       	cpi	r18, 0x2D	; 45
    2748:	31 f4       	brne	.+12     	; 0x2756 <atoi+0x2a>
    274a:	68 94       	set
    274c:	03 c0       	rjmp	.+6      	; 0x2754 <atoi+0x28>
    274e:	14 d0       	rcall	.+40     	; 0x2778 <__mulhi_const_10>
    2750:	82 0f       	add	r24, r18
    2752:	91 1d       	adc	r25, r1
    2754:	21 91       	ld	r18, Z+
    2756:	20 53       	subi	r18, 0x30	; 48
    2758:	2a 30       	cpi	r18, 0x0A	; 10
    275a:	c8 f3       	brcs	.-14     	; 0x274e <atoi+0x22>
    275c:	1e f4       	brtc	.+6      	; 0x2764 <atoi+0x38>
    275e:	90 95       	com	r25
    2760:	81 95       	neg	r24
    2762:	9f 4f       	sbci	r25, 0xFF	; 255
    2764:	08 95       	ret

00002766 <strcmp>:
    2766:	fb 01       	movw	r30, r22
    2768:	dc 01       	movw	r26, r24
    276a:	8d 91       	ld	r24, X+
    276c:	01 90       	ld	r0, Z+
    276e:	80 19       	sub	r24, r0
    2770:	01 10       	cpse	r0, r1
    2772:	d9 f3       	breq	.-10     	; 0x276a <strcmp+0x4>
    2774:	99 0b       	sbc	r25, r25
    2776:	08 95       	ret

00002778 <__mulhi_const_10>:
    2778:	7a e0       	ldi	r23, 0x0A	; 10
    277a:	97 9f       	mul	r25, r23
    277c:	90 2d       	mov	r25, r0
    277e:	87 9f       	mul	r24, r23
    2780:	80 2d       	mov	r24, r0
    2782:	91 0d       	add	r25, r1
    2784:	11 24       	eor	r1, r1
    2786:	08 95       	ret

00002788 <printf>:
    2788:	cf 93       	push	r28
    278a:	df 93       	push	r29
    278c:	cd b7       	in	r28, 0x3d	; 61
    278e:	de b7       	in	r29, 0x3e	; 62
    2790:	ae 01       	movw	r20, r28
    2792:	4b 5f       	subi	r20, 0xFB	; 251
    2794:	5f 4f       	sbci	r21, 0xFF	; 255
    2796:	fa 01       	movw	r30, r20
    2798:	61 91       	ld	r22, Z+
    279a:	71 91       	ld	r23, Z+
    279c:	af 01       	movw	r20, r30
    279e:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27a2:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27a6:	38 d0       	rcall	.+112    	; 0x2818 <vfprintf>
    27a8:	df 91       	pop	r29
    27aa:	cf 91       	pop	r28
    27ac:	08 95       	ret

000027ae <putchar>:
    27ae:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27b2:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27b6:	43 c2       	rjmp	.+1158   	; 0x2c3e <fputc>

000027b8 <puts>:
    27b8:	0f 93       	push	r16
    27ba:	1f 93       	push	r17
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    27c4:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    27c8:	23 81       	ldd	r18, Z+3	; 0x03
    27ca:	21 ff       	sbrs	r18, 1
    27cc:	1b c0       	rjmp	.+54     	; 0x2804 <puts+0x4c>
    27ce:	8c 01       	movw	r16, r24
    27d0:	d0 e0       	ldi	r29, 0x00	; 0
    27d2:	c0 e0       	ldi	r28, 0x00	; 0
    27d4:	f8 01       	movw	r30, r16
    27d6:	81 91       	ld	r24, Z+
    27d8:	8f 01       	movw	r16, r30
    27da:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27de:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27e2:	db 01       	movw	r26, r22
    27e4:	18 96       	adiw	r26, 0x08	; 8
    27e6:	ed 91       	ld	r30, X+
    27e8:	fc 91       	ld	r31, X
    27ea:	19 97       	sbiw	r26, 0x09	; 9
    27ec:	88 23       	and	r24, r24
    27ee:	31 f0       	breq	.+12     	; 0x27fc <puts+0x44>
    27f0:	09 95       	icall
    27f2:	89 2b       	or	r24, r25
    27f4:	79 f3       	breq	.-34     	; 0x27d4 <puts+0x1c>
    27f6:	df ef       	ldi	r29, 0xFF	; 255
    27f8:	cf ef       	ldi	r28, 0xFF	; 255
    27fa:	ec cf       	rjmp	.-40     	; 0x27d4 <puts+0x1c>
    27fc:	8a e0       	ldi	r24, 0x0A	; 10
    27fe:	09 95       	icall
    2800:	89 2b       	or	r24, r25
    2802:	19 f0       	breq	.+6      	; 0x280a <puts+0x52>
    2804:	8f ef       	ldi	r24, 0xFF	; 255
    2806:	9f ef       	ldi	r25, 0xFF	; 255
    2808:	02 c0       	rjmp	.+4      	; 0x280e <puts+0x56>
    280a:	8d 2f       	mov	r24, r29
    280c:	9c 2f       	mov	r25, r28
    280e:	df 91       	pop	r29
    2810:	cf 91       	pop	r28
    2812:	1f 91       	pop	r17
    2814:	0f 91       	pop	r16
    2816:	08 95       	ret

00002818 <vfprintf>:
    2818:	2f 92       	push	r2
    281a:	3f 92       	push	r3
    281c:	4f 92       	push	r4
    281e:	5f 92       	push	r5
    2820:	6f 92       	push	r6
    2822:	7f 92       	push	r7
    2824:	8f 92       	push	r8
    2826:	9f 92       	push	r9
    2828:	af 92       	push	r10
    282a:	bf 92       	push	r11
    282c:	cf 92       	push	r12
    282e:	df 92       	push	r13
    2830:	ef 92       	push	r14
    2832:	ff 92       	push	r15
    2834:	0f 93       	push	r16
    2836:	1f 93       	push	r17
    2838:	cf 93       	push	r28
    283a:	df 93       	push	r29
    283c:	cd b7       	in	r28, 0x3d	; 61
    283e:	de b7       	in	r29, 0x3e	; 62
    2840:	2b 97       	sbiw	r28, 0x0b	; 11
    2842:	0f b6       	in	r0, 0x3f	; 63
    2844:	f8 94       	cli
    2846:	de bf       	out	0x3e, r29	; 62
    2848:	0f be       	out	0x3f, r0	; 63
    284a:	cd bf       	out	0x3d, r28	; 61
    284c:	6c 01       	movw	r12, r24
    284e:	7b 01       	movw	r14, r22
    2850:	8a 01       	movw	r16, r20
    2852:	fc 01       	movw	r30, r24
    2854:	17 82       	std	Z+7, r1	; 0x07
    2856:	16 82       	std	Z+6, r1	; 0x06
    2858:	83 81       	ldd	r24, Z+3	; 0x03
    285a:	81 ff       	sbrs	r24, 1
    285c:	bf c1       	rjmp	.+894    	; 0x2bdc <vfprintf+0x3c4>
    285e:	ce 01       	movw	r24, r28
    2860:	01 96       	adiw	r24, 0x01	; 1
    2862:	3c 01       	movw	r6, r24
    2864:	f6 01       	movw	r30, r12
    2866:	93 81       	ldd	r25, Z+3	; 0x03
    2868:	f7 01       	movw	r30, r14
    286a:	93 fd       	sbrc	r25, 3
    286c:	85 91       	lpm	r24, Z+
    286e:	93 ff       	sbrs	r25, 3
    2870:	81 91       	ld	r24, Z+
    2872:	7f 01       	movw	r14, r30
    2874:	88 23       	and	r24, r24
    2876:	09 f4       	brne	.+2      	; 0x287a <vfprintf+0x62>
    2878:	ad c1       	rjmp	.+858    	; 0x2bd4 <vfprintf+0x3bc>
    287a:	85 32       	cpi	r24, 0x25	; 37
    287c:	39 f4       	brne	.+14     	; 0x288c <vfprintf+0x74>
    287e:	93 fd       	sbrc	r25, 3
    2880:	85 91       	lpm	r24, Z+
    2882:	93 ff       	sbrs	r25, 3
    2884:	81 91       	ld	r24, Z+
    2886:	7f 01       	movw	r14, r30
    2888:	85 32       	cpi	r24, 0x25	; 37
    288a:	21 f4       	brne	.+8      	; 0x2894 <vfprintf+0x7c>
    288c:	b6 01       	movw	r22, r12
    288e:	90 e0       	ldi	r25, 0x00	; 0
    2890:	d6 d1       	rcall	.+940    	; 0x2c3e <fputc>
    2892:	e8 cf       	rjmp	.-48     	; 0x2864 <vfprintf+0x4c>
    2894:	91 2c       	mov	r9, r1
    2896:	21 2c       	mov	r2, r1
    2898:	31 2c       	mov	r3, r1
    289a:	ff e1       	ldi	r31, 0x1F	; 31
    289c:	f3 15       	cp	r31, r3
    289e:	d8 f0       	brcs	.+54     	; 0x28d6 <vfprintf+0xbe>
    28a0:	8b 32       	cpi	r24, 0x2B	; 43
    28a2:	79 f0       	breq	.+30     	; 0x28c2 <vfprintf+0xaa>
    28a4:	38 f4       	brcc	.+14     	; 0x28b4 <vfprintf+0x9c>
    28a6:	80 32       	cpi	r24, 0x20	; 32
    28a8:	79 f0       	breq	.+30     	; 0x28c8 <vfprintf+0xb0>
    28aa:	83 32       	cpi	r24, 0x23	; 35
    28ac:	a1 f4       	brne	.+40     	; 0x28d6 <vfprintf+0xbe>
    28ae:	23 2d       	mov	r18, r3
    28b0:	20 61       	ori	r18, 0x10	; 16
    28b2:	1d c0       	rjmp	.+58     	; 0x28ee <vfprintf+0xd6>
    28b4:	8d 32       	cpi	r24, 0x2D	; 45
    28b6:	61 f0       	breq	.+24     	; 0x28d0 <vfprintf+0xb8>
    28b8:	80 33       	cpi	r24, 0x30	; 48
    28ba:	69 f4       	brne	.+26     	; 0x28d6 <vfprintf+0xbe>
    28bc:	23 2d       	mov	r18, r3
    28be:	21 60       	ori	r18, 0x01	; 1
    28c0:	16 c0       	rjmp	.+44     	; 0x28ee <vfprintf+0xd6>
    28c2:	83 2d       	mov	r24, r3
    28c4:	82 60       	ori	r24, 0x02	; 2
    28c6:	38 2e       	mov	r3, r24
    28c8:	e3 2d       	mov	r30, r3
    28ca:	e4 60       	ori	r30, 0x04	; 4
    28cc:	3e 2e       	mov	r3, r30
    28ce:	2a c0       	rjmp	.+84     	; 0x2924 <vfprintf+0x10c>
    28d0:	f3 2d       	mov	r31, r3
    28d2:	f8 60       	ori	r31, 0x08	; 8
    28d4:	1d c0       	rjmp	.+58     	; 0x2910 <vfprintf+0xf8>
    28d6:	37 fc       	sbrc	r3, 7
    28d8:	2d c0       	rjmp	.+90     	; 0x2934 <vfprintf+0x11c>
    28da:	20 ed       	ldi	r18, 0xD0	; 208
    28dc:	28 0f       	add	r18, r24
    28de:	2a 30       	cpi	r18, 0x0A	; 10
    28e0:	40 f0       	brcs	.+16     	; 0x28f2 <vfprintf+0xda>
    28e2:	8e 32       	cpi	r24, 0x2E	; 46
    28e4:	b9 f4       	brne	.+46     	; 0x2914 <vfprintf+0xfc>
    28e6:	36 fc       	sbrc	r3, 6
    28e8:	75 c1       	rjmp	.+746    	; 0x2bd4 <vfprintf+0x3bc>
    28ea:	23 2d       	mov	r18, r3
    28ec:	20 64       	ori	r18, 0x40	; 64
    28ee:	32 2e       	mov	r3, r18
    28f0:	19 c0       	rjmp	.+50     	; 0x2924 <vfprintf+0x10c>
    28f2:	36 fe       	sbrs	r3, 6
    28f4:	06 c0       	rjmp	.+12     	; 0x2902 <vfprintf+0xea>
    28f6:	8a e0       	ldi	r24, 0x0A	; 10
    28f8:	98 9e       	mul	r9, r24
    28fa:	20 0d       	add	r18, r0
    28fc:	11 24       	eor	r1, r1
    28fe:	92 2e       	mov	r9, r18
    2900:	11 c0       	rjmp	.+34     	; 0x2924 <vfprintf+0x10c>
    2902:	ea e0       	ldi	r30, 0x0A	; 10
    2904:	2e 9e       	mul	r2, r30
    2906:	20 0d       	add	r18, r0
    2908:	11 24       	eor	r1, r1
    290a:	22 2e       	mov	r2, r18
    290c:	f3 2d       	mov	r31, r3
    290e:	f0 62       	ori	r31, 0x20	; 32
    2910:	3f 2e       	mov	r3, r31
    2912:	08 c0       	rjmp	.+16     	; 0x2924 <vfprintf+0x10c>
    2914:	8c 36       	cpi	r24, 0x6C	; 108
    2916:	21 f4       	brne	.+8      	; 0x2920 <vfprintf+0x108>
    2918:	83 2d       	mov	r24, r3
    291a:	80 68       	ori	r24, 0x80	; 128
    291c:	38 2e       	mov	r3, r24
    291e:	02 c0       	rjmp	.+4      	; 0x2924 <vfprintf+0x10c>
    2920:	88 36       	cpi	r24, 0x68	; 104
    2922:	41 f4       	brne	.+16     	; 0x2934 <vfprintf+0x11c>
    2924:	f7 01       	movw	r30, r14
    2926:	93 fd       	sbrc	r25, 3
    2928:	85 91       	lpm	r24, Z+
    292a:	93 ff       	sbrs	r25, 3
    292c:	81 91       	ld	r24, Z+
    292e:	7f 01       	movw	r14, r30
    2930:	81 11       	cpse	r24, r1
    2932:	b3 cf       	rjmp	.-154    	; 0x289a <vfprintf+0x82>
    2934:	98 2f       	mov	r25, r24
    2936:	9f 7d       	andi	r25, 0xDF	; 223
    2938:	95 54       	subi	r25, 0x45	; 69
    293a:	93 30       	cpi	r25, 0x03	; 3
    293c:	28 f4       	brcc	.+10     	; 0x2948 <vfprintf+0x130>
    293e:	0c 5f       	subi	r16, 0xFC	; 252
    2940:	1f 4f       	sbci	r17, 0xFF	; 255
    2942:	9f e3       	ldi	r25, 0x3F	; 63
    2944:	99 83       	std	Y+1, r25	; 0x01
    2946:	0d c0       	rjmp	.+26     	; 0x2962 <vfprintf+0x14a>
    2948:	83 36       	cpi	r24, 0x63	; 99
    294a:	31 f0       	breq	.+12     	; 0x2958 <vfprintf+0x140>
    294c:	83 37       	cpi	r24, 0x73	; 115
    294e:	71 f0       	breq	.+28     	; 0x296c <vfprintf+0x154>
    2950:	83 35       	cpi	r24, 0x53	; 83
    2952:	09 f0       	breq	.+2      	; 0x2956 <vfprintf+0x13e>
    2954:	55 c0       	rjmp	.+170    	; 0x2a00 <vfprintf+0x1e8>
    2956:	20 c0       	rjmp	.+64     	; 0x2998 <vfprintf+0x180>
    2958:	f8 01       	movw	r30, r16
    295a:	80 81       	ld	r24, Z
    295c:	89 83       	std	Y+1, r24	; 0x01
    295e:	0e 5f       	subi	r16, 0xFE	; 254
    2960:	1f 4f       	sbci	r17, 0xFF	; 255
    2962:	88 24       	eor	r8, r8
    2964:	83 94       	inc	r8
    2966:	91 2c       	mov	r9, r1
    2968:	53 01       	movw	r10, r6
    296a:	12 c0       	rjmp	.+36     	; 0x2990 <vfprintf+0x178>
    296c:	28 01       	movw	r4, r16
    296e:	f2 e0       	ldi	r31, 0x02	; 2
    2970:	4f 0e       	add	r4, r31
    2972:	51 1c       	adc	r5, r1
    2974:	f8 01       	movw	r30, r16
    2976:	a0 80       	ld	r10, Z
    2978:	b1 80       	ldd	r11, Z+1	; 0x01
    297a:	36 fe       	sbrs	r3, 6
    297c:	03 c0       	rjmp	.+6      	; 0x2984 <vfprintf+0x16c>
    297e:	69 2d       	mov	r22, r9
    2980:	70 e0       	ldi	r23, 0x00	; 0
    2982:	02 c0       	rjmp	.+4      	; 0x2988 <vfprintf+0x170>
    2984:	6f ef       	ldi	r22, 0xFF	; 255
    2986:	7f ef       	ldi	r23, 0xFF	; 255
    2988:	c5 01       	movw	r24, r10
    298a:	4e d1       	rcall	.+668    	; 0x2c28 <strnlen>
    298c:	4c 01       	movw	r8, r24
    298e:	82 01       	movw	r16, r4
    2990:	f3 2d       	mov	r31, r3
    2992:	ff 77       	andi	r31, 0x7F	; 127
    2994:	3f 2e       	mov	r3, r31
    2996:	15 c0       	rjmp	.+42     	; 0x29c2 <vfprintf+0x1aa>
    2998:	28 01       	movw	r4, r16
    299a:	22 e0       	ldi	r18, 0x02	; 2
    299c:	42 0e       	add	r4, r18
    299e:	51 1c       	adc	r5, r1
    29a0:	f8 01       	movw	r30, r16
    29a2:	a0 80       	ld	r10, Z
    29a4:	b1 80       	ldd	r11, Z+1	; 0x01
    29a6:	36 fe       	sbrs	r3, 6
    29a8:	03 c0       	rjmp	.+6      	; 0x29b0 <vfprintf+0x198>
    29aa:	69 2d       	mov	r22, r9
    29ac:	70 e0       	ldi	r23, 0x00	; 0
    29ae:	02 c0       	rjmp	.+4      	; 0x29b4 <vfprintf+0x19c>
    29b0:	6f ef       	ldi	r22, 0xFF	; 255
    29b2:	7f ef       	ldi	r23, 0xFF	; 255
    29b4:	c5 01       	movw	r24, r10
    29b6:	2d d1       	rcall	.+602    	; 0x2c12 <strnlen_P>
    29b8:	4c 01       	movw	r8, r24
    29ba:	f3 2d       	mov	r31, r3
    29bc:	f0 68       	ori	r31, 0x80	; 128
    29be:	3f 2e       	mov	r3, r31
    29c0:	82 01       	movw	r16, r4
    29c2:	33 fc       	sbrc	r3, 3
    29c4:	19 c0       	rjmp	.+50     	; 0x29f8 <vfprintf+0x1e0>
    29c6:	82 2d       	mov	r24, r2
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	88 16       	cp	r8, r24
    29cc:	99 06       	cpc	r9, r25
    29ce:	a0 f4       	brcc	.+40     	; 0x29f8 <vfprintf+0x1e0>
    29d0:	b6 01       	movw	r22, r12
    29d2:	80 e2       	ldi	r24, 0x20	; 32
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	33 d1       	rcall	.+614    	; 0x2c3e <fputc>
    29d8:	2a 94       	dec	r2
    29da:	f5 cf       	rjmp	.-22     	; 0x29c6 <vfprintf+0x1ae>
    29dc:	f5 01       	movw	r30, r10
    29de:	37 fc       	sbrc	r3, 7
    29e0:	85 91       	lpm	r24, Z+
    29e2:	37 fe       	sbrs	r3, 7
    29e4:	81 91       	ld	r24, Z+
    29e6:	5f 01       	movw	r10, r30
    29e8:	b6 01       	movw	r22, r12
    29ea:	90 e0       	ldi	r25, 0x00	; 0
    29ec:	28 d1       	rcall	.+592    	; 0x2c3e <fputc>
    29ee:	21 10       	cpse	r2, r1
    29f0:	2a 94       	dec	r2
    29f2:	21 e0       	ldi	r18, 0x01	; 1
    29f4:	82 1a       	sub	r8, r18
    29f6:	91 08       	sbc	r9, r1
    29f8:	81 14       	cp	r8, r1
    29fa:	91 04       	cpc	r9, r1
    29fc:	79 f7       	brne	.-34     	; 0x29dc <vfprintf+0x1c4>
    29fe:	e1 c0       	rjmp	.+450    	; 0x2bc2 <vfprintf+0x3aa>
    2a00:	84 36       	cpi	r24, 0x64	; 100
    2a02:	11 f0       	breq	.+4      	; 0x2a08 <vfprintf+0x1f0>
    2a04:	89 36       	cpi	r24, 0x69	; 105
    2a06:	39 f5       	brne	.+78     	; 0x2a56 <vfprintf+0x23e>
    2a08:	f8 01       	movw	r30, r16
    2a0a:	37 fe       	sbrs	r3, 7
    2a0c:	07 c0       	rjmp	.+14     	; 0x2a1c <vfprintf+0x204>
    2a0e:	60 81       	ld	r22, Z
    2a10:	71 81       	ldd	r23, Z+1	; 0x01
    2a12:	82 81       	ldd	r24, Z+2	; 0x02
    2a14:	93 81       	ldd	r25, Z+3	; 0x03
    2a16:	0c 5f       	subi	r16, 0xFC	; 252
    2a18:	1f 4f       	sbci	r17, 0xFF	; 255
    2a1a:	08 c0       	rjmp	.+16     	; 0x2a2c <vfprintf+0x214>
    2a1c:	60 81       	ld	r22, Z
    2a1e:	71 81       	ldd	r23, Z+1	; 0x01
    2a20:	07 2e       	mov	r0, r23
    2a22:	00 0c       	add	r0, r0
    2a24:	88 0b       	sbc	r24, r24
    2a26:	99 0b       	sbc	r25, r25
    2a28:	0e 5f       	subi	r16, 0xFE	; 254
    2a2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2a2c:	f3 2d       	mov	r31, r3
    2a2e:	ff 76       	andi	r31, 0x6F	; 111
    2a30:	3f 2e       	mov	r3, r31
    2a32:	97 ff       	sbrs	r25, 7
    2a34:	09 c0       	rjmp	.+18     	; 0x2a48 <vfprintf+0x230>
    2a36:	90 95       	com	r25
    2a38:	80 95       	com	r24
    2a3a:	70 95       	com	r23
    2a3c:	61 95       	neg	r22
    2a3e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a40:	8f 4f       	sbci	r24, 0xFF	; 255
    2a42:	9f 4f       	sbci	r25, 0xFF	; 255
    2a44:	f0 68       	ori	r31, 0x80	; 128
    2a46:	3f 2e       	mov	r3, r31
    2a48:	2a e0       	ldi	r18, 0x0A	; 10
    2a4a:	30 e0       	ldi	r19, 0x00	; 0
    2a4c:	a3 01       	movw	r20, r6
    2a4e:	33 d1       	rcall	.+614    	; 0x2cb6 <__ultoa_invert>
    2a50:	88 2e       	mov	r8, r24
    2a52:	86 18       	sub	r8, r6
    2a54:	44 c0       	rjmp	.+136    	; 0x2ade <vfprintf+0x2c6>
    2a56:	85 37       	cpi	r24, 0x75	; 117
    2a58:	31 f4       	brne	.+12     	; 0x2a66 <vfprintf+0x24e>
    2a5a:	23 2d       	mov	r18, r3
    2a5c:	2f 7e       	andi	r18, 0xEF	; 239
    2a5e:	b2 2e       	mov	r11, r18
    2a60:	2a e0       	ldi	r18, 0x0A	; 10
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	25 c0       	rjmp	.+74     	; 0x2ab0 <vfprintf+0x298>
    2a66:	93 2d       	mov	r25, r3
    2a68:	99 7f       	andi	r25, 0xF9	; 249
    2a6a:	b9 2e       	mov	r11, r25
    2a6c:	8f 36       	cpi	r24, 0x6F	; 111
    2a6e:	c1 f0       	breq	.+48     	; 0x2aa0 <vfprintf+0x288>
    2a70:	18 f4       	brcc	.+6      	; 0x2a78 <vfprintf+0x260>
    2a72:	88 35       	cpi	r24, 0x58	; 88
    2a74:	79 f0       	breq	.+30     	; 0x2a94 <vfprintf+0x27c>
    2a76:	ae c0       	rjmp	.+348    	; 0x2bd4 <vfprintf+0x3bc>
    2a78:	80 37       	cpi	r24, 0x70	; 112
    2a7a:	19 f0       	breq	.+6      	; 0x2a82 <vfprintf+0x26a>
    2a7c:	88 37       	cpi	r24, 0x78	; 120
    2a7e:	21 f0       	breq	.+8      	; 0x2a88 <vfprintf+0x270>
    2a80:	a9 c0       	rjmp	.+338    	; 0x2bd4 <vfprintf+0x3bc>
    2a82:	e9 2f       	mov	r30, r25
    2a84:	e0 61       	ori	r30, 0x10	; 16
    2a86:	be 2e       	mov	r11, r30
    2a88:	b4 fe       	sbrs	r11, 4
    2a8a:	0d c0       	rjmp	.+26     	; 0x2aa6 <vfprintf+0x28e>
    2a8c:	fb 2d       	mov	r31, r11
    2a8e:	f4 60       	ori	r31, 0x04	; 4
    2a90:	bf 2e       	mov	r11, r31
    2a92:	09 c0       	rjmp	.+18     	; 0x2aa6 <vfprintf+0x28e>
    2a94:	34 fe       	sbrs	r3, 4
    2a96:	0a c0       	rjmp	.+20     	; 0x2aac <vfprintf+0x294>
    2a98:	29 2f       	mov	r18, r25
    2a9a:	26 60       	ori	r18, 0x06	; 6
    2a9c:	b2 2e       	mov	r11, r18
    2a9e:	06 c0       	rjmp	.+12     	; 0x2aac <vfprintf+0x294>
    2aa0:	28 e0       	ldi	r18, 0x08	; 8
    2aa2:	30 e0       	ldi	r19, 0x00	; 0
    2aa4:	05 c0       	rjmp	.+10     	; 0x2ab0 <vfprintf+0x298>
    2aa6:	20 e1       	ldi	r18, 0x10	; 16
    2aa8:	30 e0       	ldi	r19, 0x00	; 0
    2aaa:	02 c0       	rjmp	.+4      	; 0x2ab0 <vfprintf+0x298>
    2aac:	20 e1       	ldi	r18, 0x10	; 16
    2aae:	32 e0       	ldi	r19, 0x02	; 2
    2ab0:	f8 01       	movw	r30, r16
    2ab2:	b7 fe       	sbrs	r11, 7
    2ab4:	07 c0       	rjmp	.+14     	; 0x2ac4 <vfprintf+0x2ac>
    2ab6:	60 81       	ld	r22, Z
    2ab8:	71 81       	ldd	r23, Z+1	; 0x01
    2aba:	82 81       	ldd	r24, Z+2	; 0x02
    2abc:	93 81       	ldd	r25, Z+3	; 0x03
    2abe:	0c 5f       	subi	r16, 0xFC	; 252
    2ac0:	1f 4f       	sbci	r17, 0xFF	; 255
    2ac2:	06 c0       	rjmp	.+12     	; 0x2ad0 <vfprintf+0x2b8>
    2ac4:	60 81       	ld	r22, Z
    2ac6:	71 81       	ldd	r23, Z+1	; 0x01
    2ac8:	80 e0       	ldi	r24, 0x00	; 0
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	0e 5f       	subi	r16, 0xFE	; 254
    2ace:	1f 4f       	sbci	r17, 0xFF	; 255
    2ad0:	a3 01       	movw	r20, r6
    2ad2:	f1 d0       	rcall	.+482    	; 0x2cb6 <__ultoa_invert>
    2ad4:	88 2e       	mov	r8, r24
    2ad6:	86 18       	sub	r8, r6
    2ad8:	fb 2d       	mov	r31, r11
    2ada:	ff 77       	andi	r31, 0x7F	; 127
    2adc:	3f 2e       	mov	r3, r31
    2ade:	36 fe       	sbrs	r3, 6
    2ae0:	0d c0       	rjmp	.+26     	; 0x2afc <vfprintf+0x2e4>
    2ae2:	23 2d       	mov	r18, r3
    2ae4:	2e 7f       	andi	r18, 0xFE	; 254
    2ae6:	a2 2e       	mov	r10, r18
    2ae8:	89 14       	cp	r8, r9
    2aea:	58 f4       	brcc	.+22     	; 0x2b02 <vfprintf+0x2ea>
    2aec:	34 fe       	sbrs	r3, 4
    2aee:	0b c0       	rjmp	.+22     	; 0x2b06 <vfprintf+0x2ee>
    2af0:	32 fc       	sbrc	r3, 2
    2af2:	09 c0       	rjmp	.+18     	; 0x2b06 <vfprintf+0x2ee>
    2af4:	83 2d       	mov	r24, r3
    2af6:	8e 7e       	andi	r24, 0xEE	; 238
    2af8:	a8 2e       	mov	r10, r24
    2afa:	05 c0       	rjmp	.+10     	; 0x2b06 <vfprintf+0x2ee>
    2afc:	b8 2c       	mov	r11, r8
    2afe:	a3 2c       	mov	r10, r3
    2b00:	03 c0       	rjmp	.+6      	; 0x2b08 <vfprintf+0x2f0>
    2b02:	b8 2c       	mov	r11, r8
    2b04:	01 c0       	rjmp	.+2      	; 0x2b08 <vfprintf+0x2f0>
    2b06:	b9 2c       	mov	r11, r9
    2b08:	a4 fe       	sbrs	r10, 4
    2b0a:	0f c0       	rjmp	.+30     	; 0x2b2a <vfprintf+0x312>
    2b0c:	fe 01       	movw	r30, r28
    2b0e:	e8 0d       	add	r30, r8
    2b10:	f1 1d       	adc	r31, r1
    2b12:	80 81       	ld	r24, Z
    2b14:	80 33       	cpi	r24, 0x30	; 48
    2b16:	21 f4       	brne	.+8      	; 0x2b20 <vfprintf+0x308>
    2b18:	9a 2d       	mov	r25, r10
    2b1a:	99 7e       	andi	r25, 0xE9	; 233
    2b1c:	a9 2e       	mov	r10, r25
    2b1e:	09 c0       	rjmp	.+18     	; 0x2b32 <vfprintf+0x31a>
    2b20:	a2 fe       	sbrs	r10, 2
    2b22:	06 c0       	rjmp	.+12     	; 0x2b30 <vfprintf+0x318>
    2b24:	b3 94       	inc	r11
    2b26:	b3 94       	inc	r11
    2b28:	04 c0       	rjmp	.+8      	; 0x2b32 <vfprintf+0x31a>
    2b2a:	8a 2d       	mov	r24, r10
    2b2c:	86 78       	andi	r24, 0x86	; 134
    2b2e:	09 f0       	breq	.+2      	; 0x2b32 <vfprintf+0x31a>
    2b30:	b3 94       	inc	r11
    2b32:	a3 fc       	sbrc	r10, 3
    2b34:	10 c0       	rjmp	.+32     	; 0x2b56 <vfprintf+0x33e>
    2b36:	a0 fe       	sbrs	r10, 0
    2b38:	06 c0       	rjmp	.+12     	; 0x2b46 <vfprintf+0x32e>
    2b3a:	b2 14       	cp	r11, r2
    2b3c:	80 f4       	brcc	.+32     	; 0x2b5e <vfprintf+0x346>
    2b3e:	28 0c       	add	r2, r8
    2b40:	92 2c       	mov	r9, r2
    2b42:	9b 18       	sub	r9, r11
    2b44:	0d c0       	rjmp	.+26     	; 0x2b60 <vfprintf+0x348>
    2b46:	b2 14       	cp	r11, r2
    2b48:	58 f4       	brcc	.+22     	; 0x2b60 <vfprintf+0x348>
    2b4a:	b6 01       	movw	r22, r12
    2b4c:	80 e2       	ldi	r24, 0x20	; 32
    2b4e:	90 e0       	ldi	r25, 0x00	; 0
    2b50:	76 d0       	rcall	.+236    	; 0x2c3e <fputc>
    2b52:	b3 94       	inc	r11
    2b54:	f8 cf       	rjmp	.-16     	; 0x2b46 <vfprintf+0x32e>
    2b56:	b2 14       	cp	r11, r2
    2b58:	18 f4       	brcc	.+6      	; 0x2b60 <vfprintf+0x348>
    2b5a:	2b 18       	sub	r2, r11
    2b5c:	02 c0       	rjmp	.+4      	; 0x2b62 <vfprintf+0x34a>
    2b5e:	98 2c       	mov	r9, r8
    2b60:	21 2c       	mov	r2, r1
    2b62:	a4 fe       	sbrs	r10, 4
    2b64:	0f c0       	rjmp	.+30     	; 0x2b84 <vfprintf+0x36c>
    2b66:	b6 01       	movw	r22, r12
    2b68:	80 e3       	ldi	r24, 0x30	; 48
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	68 d0       	rcall	.+208    	; 0x2c3e <fputc>
    2b6e:	a2 fe       	sbrs	r10, 2
    2b70:	16 c0       	rjmp	.+44     	; 0x2b9e <vfprintf+0x386>
    2b72:	a1 fc       	sbrc	r10, 1
    2b74:	03 c0       	rjmp	.+6      	; 0x2b7c <vfprintf+0x364>
    2b76:	88 e7       	ldi	r24, 0x78	; 120
    2b78:	90 e0       	ldi	r25, 0x00	; 0
    2b7a:	02 c0       	rjmp	.+4      	; 0x2b80 <vfprintf+0x368>
    2b7c:	88 e5       	ldi	r24, 0x58	; 88
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	b6 01       	movw	r22, r12
    2b82:	0c c0       	rjmp	.+24     	; 0x2b9c <vfprintf+0x384>
    2b84:	8a 2d       	mov	r24, r10
    2b86:	86 78       	andi	r24, 0x86	; 134
    2b88:	51 f0       	breq	.+20     	; 0x2b9e <vfprintf+0x386>
    2b8a:	a1 fe       	sbrs	r10, 1
    2b8c:	02 c0       	rjmp	.+4      	; 0x2b92 <vfprintf+0x37a>
    2b8e:	8b e2       	ldi	r24, 0x2B	; 43
    2b90:	01 c0       	rjmp	.+2      	; 0x2b94 <vfprintf+0x37c>
    2b92:	80 e2       	ldi	r24, 0x20	; 32
    2b94:	a7 fc       	sbrc	r10, 7
    2b96:	8d e2       	ldi	r24, 0x2D	; 45
    2b98:	b6 01       	movw	r22, r12
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	50 d0       	rcall	.+160    	; 0x2c3e <fputc>
    2b9e:	89 14       	cp	r8, r9
    2ba0:	30 f4       	brcc	.+12     	; 0x2bae <vfprintf+0x396>
    2ba2:	b6 01       	movw	r22, r12
    2ba4:	80 e3       	ldi	r24, 0x30	; 48
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	4a d0       	rcall	.+148    	; 0x2c3e <fputc>
    2baa:	9a 94       	dec	r9
    2bac:	f8 cf       	rjmp	.-16     	; 0x2b9e <vfprintf+0x386>
    2bae:	8a 94       	dec	r8
    2bb0:	f3 01       	movw	r30, r6
    2bb2:	e8 0d       	add	r30, r8
    2bb4:	f1 1d       	adc	r31, r1
    2bb6:	80 81       	ld	r24, Z
    2bb8:	b6 01       	movw	r22, r12
    2bba:	90 e0       	ldi	r25, 0x00	; 0
    2bbc:	40 d0       	rcall	.+128    	; 0x2c3e <fputc>
    2bbe:	81 10       	cpse	r8, r1
    2bc0:	f6 cf       	rjmp	.-20     	; 0x2bae <vfprintf+0x396>
    2bc2:	22 20       	and	r2, r2
    2bc4:	09 f4       	brne	.+2      	; 0x2bc8 <vfprintf+0x3b0>
    2bc6:	4e ce       	rjmp	.-868    	; 0x2864 <vfprintf+0x4c>
    2bc8:	b6 01       	movw	r22, r12
    2bca:	80 e2       	ldi	r24, 0x20	; 32
    2bcc:	90 e0       	ldi	r25, 0x00	; 0
    2bce:	37 d0       	rcall	.+110    	; 0x2c3e <fputc>
    2bd0:	2a 94       	dec	r2
    2bd2:	f7 cf       	rjmp	.-18     	; 0x2bc2 <vfprintf+0x3aa>
    2bd4:	f6 01       	movw	r30, r12
    2bd6:	86 81       	ldd	r24, Z+6	; 0x06
    2bd8:	97 81       	ldd	r25, Z+7	; 0x07
    2bda:	02 c0       	rjmp	.+4      	; 0x2be0 <vfprintf+0x3c8>
    2bdc:	8f ef       	ldi	r24, 0xFF	; 255
    2bde:	9f ef       	ldi	r25, 0xFF	; 255
    2be0:	2b 96       	adiw	r28, 0x0b	; 11
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	f8 94       	cli
    2be6:	de bf       	out	0x3e, r29	; 62
    2be8:	0f be       	out	0x3f, r0	; 63
    2bea:	cd bf       	out	0x3d, r28	; 61
    2bec:	df 91       	pop	r29
    2bee:	cf 91       	pop	r28
    2bf0:	1f 91       	pop	r17
    2bf2:	0f 91       	pop	r16
    2bf4:	ff 90       	pop	r15
    2bf6:	ef 90       	pop	r14
    2bf8:	df 90       	pop	r13
    2bfa:	cf 90       	pop	r12
    2bfc:	bf 90       	pop	r11
    2bfe:	af 90       	pop	r10
    2c00:	9f 90       	pop	r9
    2c02:	8f 90       	pop	r8
    2c04:	7f 90       	pop	r7
    2c06:	6f 90       	pop	r6
    2c08:	5f 90       	pop	r5
    2c0a:	4f 90       	pop	r4
    2c0c:	3f 90       	pop	r3
    2c0e:	2f 90       	pop	r2
    2c10:	08 95       	ret

00002c12 <strnlen_P>:
    2c12:	fc 01       	movw	r30, r24
    2c14:	05 90       	lpm	r0, Z+
    2c16:	61 50       	subi	r22, 0x01	; 1
    2c18:	70 40       	sbci	r23, 0x00	; 0
    2c1a:	01 10       	cpse	r0, r1
    2c1c:	d8 f7       	brcc	.-10     	; 0x2c14 <strnlen_P+0x2>
    2c1e:	80 95       	com	r24
    2c20:	90 95       	com	r25
    2c22:	8e 0f       	add	r24, r30
    2c24:	9f 1f       	adc	r25, r31
    2c26:	08 95       	ret

00002c28 <strnlen>:
    2c28:	fc 01       	movw	r30, r24
    2c2a:	61 50       	subi	r22, 0x01	; 1
    2c2c:	70 40       	sbci	r23, 0x00	; 0
    2c2e:	01 90       	ld	r0, Z+
    2c30:	01 10       	cpse	r0, r1
    2c32:	d8 f7       	brcc	.-10     	; 0x2c2a <strnlen+0x2>
    2c34:	80 95       	com	r24
    2c36:	90 95       	com	r25
    2c38:	8e 0f       	add	r24, r30
    2c3a:	9f 1f       	adc	r25, r31
    2c3c:	08 95       	ret

00002c3e <fputc>:
    2c3e:	0f 93       	push	r16
    2c40:	1f 93       	push	r17
    2c42:	cf 93       	push	r28
    2c44:	df 93       	push	r29
    2c46:	fb 01       	movw	r30, r22
    2c48:	23 81       	ldd	r18, Z+3	; 0x03
    2c4a:	21 fd       	sbrc	r18, 1
    2c4c:	03 c0       	rjmp	.+6      	; 0x2c54 <fputc+0x16>
    2c4e:	8f ef       	ldi	r24, 0xFF	; 255
    2c50:	9f ef       	ldi	r25, 0xFF	; 255
    2c52:	2c c0       	rjmp	.+88     	; 0x2cac <fputc+0x6e>
    2c54:	22 ff       	sbrs	r18, 2
    2c56:	16 c0       	rjmp	.+44     	; 0x2c84 <fputc+0x46>
    2c58:	46 81       	ldd	r20, Z+6	; 0x06
    2c5a:	57 81       	ldd	r21, Z+7	; 0x07
    2c5c:	24 81       	ldd	r18, Z+4	; 0x04
    2c5e:	35 81       	ldd	r19, Z+5	; 0x05
    2c60:	42 17       	cp	r20, r18
    2c62:	53 07       	cpc	r21, r19
    2c64:	44 f4       	brge	.+16     	; 0x2c76 <fputc+0x38>
    2c66:	a0 81       	ld	r26, Z
    2c68:	b1 81       	ldd	r27, Z+1	; 0x01
    2c6a:	9d 01       	movw	r18, r26
    2c6c:	2f 5f       	subi	r18, 0xFF	; 255
    2c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c70:	31 83       	std	Z+1, r19	; 0x01
    2c72:	20 83       	st	Z, r18
    2c74:	8c 93       	st	X, r24
    2c76:	26 81       	ldd	r18, Z+6	; 0x06
    2c78:	37 81       	ldd	r19, Z+7	; 0x07
    2c7a:	2f 5f       	subi	r18, 0xFF	; 255
    2c7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c7e:	37 83       	std	Z+7, r19	; 0x07
    2c80:	26 83       	std	Z+6, r18	; 0x06
    2c82:	14 c0       	rjmp	.+40     	; 0x2cac <fputc+0x6e>
    2c84:	8b 01       	movw	r16, r22
    2c86:	ec 01       	movw	r28, r24
    2c88:	fb 01       	movw	r30, r22
    2c8a:	00 84       	ldd	r0, Z+8	; 0x08
    2c8c:	f1 85       	ldd	r31, Z+9	; 0x09
    2c8e:	e0 2d       	mov	r30, r0
    2c90:	09 95       	icall
    2c92:	89 2b       	or	r24, r25
    2c94:	e1 f6       	brne	.-72     	; 0x2c4e <fputc+0x10>
    2c96:	d8 01       	movw	r26, r16
    2c98:	16 96       	adiw	r26, 0x06	; 6
    2c9a:	8d 91       	ld	r24, X+
    2c9c:	9c 91       	ld	r25, X
    2c9e:	17 97       	sbiw	r26, 0x07	; 7
    2ca0:	01 96       	adiw	r24, 0x01	; 1
    2ca2:	17 96       	adiw	r26, 0x07	; 7
    2ca4:	9c 93       	st	X, r25
    2ca6:	8e 93       	st	-X, r24
    2ca8:	16 97       	sbiw	r26, 0x06	; 6
    2caa:	ce 01       	movw	r24, r28
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	1f 91       	pop	r17
    2cb2:	0f 91       	pop	r16
    2cb4:	08 95       	ret

00002cb6 <__ultoa_invert>:
    2cb6:	fa 01       	movw	r30, r20
    2cb8:	aa 27       	eor	r26, r26
    2cba:	28 30       	cpi	r18, 0x08	; 8
    2cbc:	51 f1       	breq	.+84     	; 0x2d12 <__ultoa_invert+0x5c>
    2cbe:	20 31       	cpi	r18, 0x10	; 16
    2cc0:	81 f1       	breq	.+96     	; 0x2d22 <__ultoa_invert+0x6c>
    2cc2:	e8 94       	clt
    2cc4:	6f 93       	push	r22
    2cc6:	6e 7f       	andi	r22, 0xFE	; 254
    2cc8:	6e 5f       	subi	r22, 0xFE	; 254
    2cca:	7f 4f       	sbci	r23, 0xFF	; 255
    2ccc:	8f 4f       	sbci	r24, 0xFF	; 255
    2cce:	9f 4f       	sbci	r25, 0xFF	; 255
    2cd0:	af 4f       	sbci	r26, 0xFF	; 255
    2cd2:	b1 e0       	ldi	r27, 0x01	; 1
    2cd4:	3e d0       	rcall	.+124    	; 0x2d52 <__ultoa_invert+0x9c>
    2cd6:	b4 e0       	ldi	r27, 0x04	; 4
    2cd8:	3c d0       	rcall	.+120    	; 0x2d52 <__ultoa_invert+0x9c>
    2cda:	67 0f       	add	r22, r23
    2cdc:	78 1f       	adc	r23, r24
    2cde:	89 1f       	adc	r24, r25
    2ce0:	9a 1f       	adc	r25, r26
    2ce2:	a1 1d       	adc	r26, r1
    2ce4:	68 0f       	add	r22, r24
    2ce6:	79 1f       	adc	r23, r25
    2ce8:	8a 1f       	adc	r24, r26
    2cea:	91 1d       	adc	r25, r1
    2cec:	a1 1d       	adc	r26, r1
    2cee:	6a 0f       	add	r22, r26
    2cf0:	71 1d       	adc	r23, r1
    2cf2:	81 1d       	adc	r24, r1
    2cf4:	91 1d       	adc	r25, r1
    2cf6:	a1 1d       	adc	r26, r1
    2cf8:	20 d0       	rcall	.+64     	; 0x2d3a <__ultoa_invert+0x84>
    2cfa:	09 f4       	brne	.+2      	; 0x2cfe <__ultoa_invert+0x48>
    2cfc:	68 94       	set
    2cfe:	3f 91       	pop	r19
    2d00:	2a e0       	ldi	r18, 0x0A	; 10
    2d02:	26 9f       	mul	r18, r22
    2d04:	11 24       	eor	r1, r1
    2d06:	30 19       	sub	r19, r0
    2d08:	30 5d       	subi	r19, 0xD0	; 208
    2d0a:	31 93       	st	Z+, r19
    2d0c:	de f6       	brtc	.-74     	; 0x2cc4 <__ultoa_invert+0xe>
    2d0e:	cf 01       	movw	r24, r30
    2d10:	08 95       	ret
    2d12:	46 2f       	mov	r20, r22
    2d14:	47 70       	andi	r20, 0x07	; 7
    2d16:	40 5d       	subi	r20, 0xD0	; 208
    2d18:	41 93       	st	Z+, r20
    2d1a:	b3 e0       	ldi	r27, 0x03	; 3
    2d1c:	0f d0       	rcall	.+30     	; 0x2d3c <__ultoa_invert+0x86>
    2d1e:	c9 f7       	brne	.-14     	; 0x2d12 <__ultoa_invert+0x5c>
    2d20:	f6 cf       	rjmp	.-20     	; 0x2d0e <__ultoa_invert+0x58>
    2d22:	46 2f       	mov	r20, r22
    2d24:	4f 70       	andi	r20, 0x0F	; 15
    2d26:	40 5d       	subi	r20, 0xD0	; 208
    2d28:	4a 33       	cpi	r20, 0x3A	; 58
    2d2a:	18 f0       	brcs	.+6      	; 0x2d32 <__ultoa_invert+0x7c>
    2d2c:	49 5d       	subi	r20, 0xD9	; 217
    2d2e:	31 fd       	sbrc	r19, 1
    2d30:	40 52       	subi	r20, 0x20	; 32
    2d32:	41 93       	st	Z+, r20
    2d34:	02 d0       	rcall	.+4      	; 0x2d3a <__ultoa_invert+0x84>
    2d36:	a9 f7       	brne	.-22     	; 0x2d22 <__ultoa_invert+0x6c>
    2d38:	ea cf       	rjmp	.-44     	; 0x2d0e <__ultoa_invert+0x58>
    2d3a:	b4 e0       	ldi	r27, 0x04	; 4
    2d3c:	a6 95       	lsr	r26
    2d3e:	97 95       	ror	r25
    2d40:	87 95       	ror	r24
    2d42:	77 95       	ror	r23
    2d44:	67 95       	ror	r22
    2d46:	ba 95       	dec	r27
    2d48:	c9 f7       	brne	.-14     	; 0x2d3c <__ultoa_invert+0x86>
    2d4a:	00 97       	sbiw	r24, 0x00	; 0
    2d4c:	61 05       	cpc	r22, r1
    2d4e:	71 05       	cpc	r23, r1
    2d50:	08 95       	ret
    2d52:	9b 01       	movw	r18, r22
    2d54:	ac 01       	movw	r20, r24
    2d56:	0a 2e       	mov	r0, r26
    2d58:	06 94       	lsr	r0
    2d5a:	57 95       	ror	r21
    2d5c:	47 95       	ror	r20
    2d5e:	37 95       	ror	r19
    2d60:	27 95       	ror	r18
    2d62:	ba 95       	dec	r27
    2d64:	c9 f7       	brne	.-14     	; 0x2d58 <__ultoa_invert+0xa2>
    2d66:	62 0f       	add	r22, r18
    2d68:	73 1f       	adc	r23, r19
    2d6a:	84 1f       	adc	r24, r20
    2d6c:	95 1f       	adc	r25, r21
    2d6e:	a0 1d       	adc	r26, r0
    2d70:	08 95       	ret

00002d72 <eeprom_read_word>:
    2d72:	a8 e1       	ldi	r26, 0x18	; 24
    2d74:	b0 e0       	ldi	r27, 0x00	; 0
    2d76:	42 e0       	ldi	r20, 0x02	; 2
    2d78:	50 e0       	ldi	r21, 0x00	; 0
    2d7a:	05 c0       	rjmp	.+10     	; 0x2d86 <eeprom_read_blraw>

00002d7c <eeprom_write_word>:
    2d7c:	12 d0       	rcall	.+36     	; 0x2da2 <eeprom_write_byte>
    2d7e:	27 2f       	mov	r18, r23
    2d80:	11 c0       	rjmp	.+34     	; 0x2da4 <eeprom_write_r18>

00002d82 <eeprom_read_block>:
    2d82:	dc 01       	movw	r26, r24
    2d84:	cb 01       	movw	r24, r22

00002d86 <eeprom_read_blraw>:
    2d86:	fc 01       	movw	r30, r24
    2d88:	f9 99       	sbic	0x1f, 1	; 31
    2d8a:	fe cf       	rjmp	.-4      	; 0x2d88 <eeprom_read_blraw+0x2>
    2d8c:	06 c0       	rjmp	.+12     	; 0x2d9a <eeprom_read_blraw+0x14>
    2d8e:	f2 bd       	out	0x22, r31	; 34
    2d90:	e1 bd       	out	0x21, r30	; 33
    2d92:	f8 9a       	sbi	0x1f, 0	; 31
    2d94:	31 96       	adiw	r30, 0x01	; 1
    2d96:	00 b4       	in	r0, 0x20	; 32
    2d98:	0d 92       	st	X+, r0
    2d9a:	41 50       	subi	r20, 0x01	; 1
    2d9c:	50 40       	sbci	r21, 0x00	; 0
    2d9e:	b8 f7       	brcc	.-18     	; 0x2d8e <eeprom_read_blraw+0x8>
    2da0:	08 95       	ret

00002da2 <eeprom_write_byte>:
    2da2:	26 2f       	mov	r18, r22

00002da4 <eeprom_write_r18>:
    2da4:	f9 99       	sbic	0x1f, 1	; 31
    2da6:	fe cf       	rjmp	.-4      	; 0x2da4 <eeprom_write_r18>
    2da8:	92 bd       	out	0x22, r25	; 34
    2daa:	81 bd       	out	0x21, r24	; 33
    2dac:	20 bd       	out	0x20, r18	; 32
    2dae:	0f b6       	in	r0, 0x3f	; 63
    2db0:	f8 94       	cli
    2db2:	fa 9a       	sbi	0x1f, 2	; 31
    2db4:	f9 9a       	sbi	0x1f, 1	; 31
    2db6:	0f be       	out	0x3f, r0	; 63
    2db8:	01 96       	adiw	r24, 0x01	; 1
    2dba:	08 95       	ret

00002dbc <_exit>:
    2dbc:	f8 94       	cli

00002dbe <__stop_program>:
    2dbe:	ff cf       	rjmp	.-2      	; 0x2dbe <__stop_program>
