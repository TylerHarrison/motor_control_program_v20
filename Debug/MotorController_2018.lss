
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002d18  00002dac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002e8c  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002e8c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002f18  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00002f58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000070a9  00000000  00000000  00003508  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ddd  00000000  00000000  0000a5b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000331a  00000000  00000000  0000c38e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001084  00000000  00000000  0000f6a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a2a  00000000  00000000  0001072c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004689  00000000  00000000  00012156  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  000167df  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 f3 0c 	jmp	0x19e6	; 0x19e6 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 62 0c 	jmp	0x18c4	; 0x18c4 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 a3 0b 	jmp	0x1746	; 0x1746 <__vector_16>
      44:	0c 94 e2 10 	jmp	0x21c4	; 0x21c4 <__vector_17>
      48:	0c 94 93 0e 	jmp	0x1d26	; 0x1d26 <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 91 0a 	jmp	0x1522	; 0x1522 <__vector_21>
      58:	0c 94 73 0a 	jmp	0x14e6	; 0x14e6 <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 ca 0a 	jmp	0x1594	; 0x1594 <__vector_32>
      84:	0c 94 ac 0a 	jmp	0x1558	; 0x1558 <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	65 0e       	add	r6, r21
      96:	6a 0e       	add	r6, r26
      98:	70 0e       	add	r7, r16
      9a:	76 0e       	add	r7, r22
      9c:	7c 0e       	add	r7, r28
      9e:	81 0e       	add	r8, r17
      a0:	87 0e       	add	r8, r23
      a2:	8d 0e       	add	r8, r29

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e8 e1       	ldi	r30, 0x18	; 24
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 0c 0b 	call	0x1618	; 0x1618 <main>
      de:	0c 94 8a 16 	jmp	0x2d14	; 0x2d14 <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 65 16 	call	0x2cca	; 0x2cca <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 65 16 	call	0x2cca	; 0x2cca <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 65 16 	call	0x2cca	; 0x2cca <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	11 f0       	breq	.+4      	; 0x214 <actuator_pwm+0x8>
     210:	75 9a       	sbi	0x0e, 5	; 14
     212:	08 95       	ret
     214:	75 98       	cbi	0x0e, 5	; 14
     216:	08 95       	ret

00000218 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     218:	4f 92       	push	r4
     21a:	5f 92       	push	r5
     21c:	6f 92       	push	r6
     21e:	7f 92       	push	r7
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	ec 01       	movw	r28, r24
     238:	96 2e       	mov	r9, r22
     23a:	c6 01       	movw	r24, r12
     23c:	b5 01       	movw	r22, r10
			3) actuator_duty_cycle
			4) gear_status
*/

	//float kp = 3.8; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     23e:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     242:	87 01       	movw	r16, r14
     244:	06 1b       	sub	r16, r22
     246:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
     248:	b8 01       	movw	r22, r16
     24a:	01 2e       	mov	r0, r17
     24c:	00 0c       	add	r0, r0
     24e:	88 0b       	sbc	r24, r24
     250:	99 0b       	sbc	r25, r25
     252:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     256:	2b 01       	movw	r4, r22
     258:	3c 01       	movw	r6, r24
     25a:	23 e3       	ldi	r18, 0x33	; 51
     25c:	33 e3       	ldi	r19, 0x33	; 51
     25e:	43 e7       	ldi	r20, 0x73	; 115
     260:	50 e4       	ldi	r21, 0x40	; 64
     262:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	45 e8       	ldi	r20, 0x85	; 133
     26c:	52 e4       	ldi	r21, 0x42	; 66
     26e:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     272:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     276:	6b 01       	movw	r12, r22
     278:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 ea       	ldi	r20, 0xA0	; 160
     280:	50 e4       	ldi	r21, 0x40	; 64
     282:	c3 01       	movw	r24, r6
     284:	b2 01       	movw	r22, r4
     286:	0e 94 83 11 	call	0x2306	; 0x2306 <__cmpsf2>
     28a:	88 23       	and	r24, r24
     28c:	c4 f5       	brge	.+112    	; 0x2fe <actuator_set_position+0xe6>
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	40 ea       	ldi	r20, 0xA0	; 160
     294:	50 ec       	ldi	r21, 0xC0	; 192
     296:	c3 01       	movw	r24, r6
     298:	b2 01       	movw	r22, r4
     29a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <__gesf2>
     29e:	18 16       	cp	r1, r24
     2a0:	74 f5       	brge	.+92     	; 0x2fe <actuator_set_position+0xe6>
     2a2:	30 c0       	rjmp	.+96     	; 0x304 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2a4:	8c 81       	ldd	r24, Y+4	; 0x04
     2a6:	9d 81       	ldd	r25, Y+5	; 0x05
     2a8:	00 97       	sbiw	r24, 0x00	; 0
     2aa:	29 f0       	breq	.+10     	; 0x2b6 <actuator_set_position+0x9e>
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	89 f4       	brne	.+34     	; 0x2d2 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2b0:	1b 82       	std	Y+3, r1	; 0x03
     2b2:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2b4:	0e c0       	rjmp	.+28     	; 0x2d2 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2b6:	10 16       	cp	r1, r16
     2b8:	11 06       	cpc	r1, r17
     2ba:	2c f4       	brge	.+10     	; 0x2c6 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2c6:	11 23       	and	r17, r17
     2c8:	24 f4       	brge	.+8      	; 0x2d2 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2ca:	82 e0       	ldi	r24, 0x02	; 2
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	9b 83       	std	Y+3, r25	; 0x03
     2d0:	8a 83       	std	Y+2, r24	; 0x02
     2d2:	c6 01       	movw	r24, r12
     2d4:	83 38       	cpi	r24, 0x83	; 131
     2d6:	91 05       	cpc	r25, r1
     2d8:	14 f0       	brlt	.+4      	; 0x2de <actuator_set_position+0xc6>
     2da:	82 e8       	ldi	r24, 0x82	; 130
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	6c 01       	movw	r12, r24
     2e0:	99 23       	and	r25, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <actuator_set_position+0xd0>
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2e8:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2ec:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2f0:	db 86       	std	Y+11, r13	; 0x0b
     2f2:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2f4:	4e 82       	std	Y+6, r4	; 0x06
     2f6:	5f 82       	std	Y+7, r5	; 0x07
     2f8:	68 86       	std	Y+8, r6	; 0x08
     2fa:	79 86       	std	Y+9, r7	; 0x09
}
     2fc:	0c c0       	rjmp	.+24     	; 0x316 <actuator_set_position+0xfe>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		//new_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2fe:	1d 82       	std	Y+5, r1	; 0x05
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	d0 cf       	rjmp	.-96     	; 0x2a4 <actuator_set_position+0x8c>
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9d 83       	std	Y+5, r25	; 0x05
     30a:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     30c:	89 2d       	mov	r24, r9
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	99 83       	std	Y+1, r25	; 0x01
     312:	88 83       	st	Y, r24
     314:	c7 cf       	rjmp	.-114    	; 0x2a4 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	7f 90       	pop	r7
     32e:	6f 90       	pop	r6
     330:	5f 90       	pop	r5
     332:	4f 90       	pop	r4
     334:	08 95       	ret

00000336 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     336:	af 92       	push	r10
     338:	bf 92       	push	r11
     33a:	cf 92       	push	r12
     33c:	df 92       	push	r13
     33e:	ef 92       	push	r14
     340:	ff 92       	push	r15
     342:	0f 93       	push	r16
     344:	1f 93       	push	r17
     346:	fc 01       	movw	r30, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     348:	83 a1       	ldd	r24, Z+35	; 0x23
     34a:	94 a1       	ldd	r25, Z+36	; 0x24
     34c:	89 2b       	or	r24, r25
     34e:	09 f1       	breq	.+66     	; 0x392 <actuator_p_controller+0x5c>
	{
		//ACTUATOR: set actuator position based off current state
		switch(vals->gear_required)
     350:	83 ad       	ldd	r24, Z+59	; 0x3b
     352:	81 30       	cpi	r24, 0x01	; 1
     354:	39 f0       	breq	.+14     	; 0x364 <actuator_p_controller+0x2e>
     356:	18 f0       	brcs	.+6      	; 0x35e <actuator_p_controller+0x28>
     358:	82 30       	cpi	r24, 0x02	; 2
     35a:	39 f0       	breq	.+14     	; 0x36a <actuator_p_controller+0x34>
     35c:	09 c0       	rjmp	.+18     	; 0x370 <actuator_p_controller+0x3a>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     35e:	e4 a8       	ldd	r14, Z+52	; 0x34
     360:	f5 a8       	ldd	r15, Z+53	; 0x35
				break;
     362:	08 c0       	rjmp	.+16     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     364:	e6 a8       	ldd	r14, Z+54	; 0x36
     366:	f7 a8       	ldd	r15, Z+55	; 0x37
				break;
     368:	05 c0       	rjmp	.+10     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     36a:	e0 ac       	ldd	r14, Z+56	; 0x38
     36c:	f1 ac       	ldd	r15, Z+57	; 0x39
				break;
     36e:	02 c0       	rjmp	.+4      	; 0x374 <actuator_p_controller+0x3e>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     370:	e1 2c       	mov	r14, r1
     372:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     374:	a3 a4       	ldd	r10, Z+43	; 0x2b
     376:	b4 a4       	ldd	r11, Z+44	; 0x2c
     378:	c5 a4       	ldd	r12, Z+45	; 0x2d
     37a:	d6 a4       	ldd	r13, Z+46	; 0x2e
     37c:	07 a5       	ldd	r16, Z+47	; 0x2f
     37e:	27 a1       	ldd	r18, Z+39	; 0x27
     380:	30 a5       	ldd	r19, Z+40	; 0x28
     382:	41 a5       	ldd	r20, Z+41	; 0x29
     384:	52 a5       	ldd	r21, Z+42	; 0x2a
     386:	63 ad       	ldd	r22, Z+59	; 0x3b
     388:	10 e0       	ldi	r17, 0x00	; 0
     38a:	80 ee       	ldi	r24, 0xE0	; 224
     38c:	91 e0       	ldi	r25, 0x01	; 1
     38e:	44 df       	rcall	.-376    	; 0x218 <actuator_set_position>
     390:	10 c0       	rjmp	.+32     	; 0x3b2 <actuator_p_controller+0x7c>
		target_position = vals->position_uart_instruction;
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);

	}
}

     392:	e2 a8       	ldd	r14, Z+50	; 0x32
     394:	f3 a8       	ldd	r15, Z+51	; 0x33

     396:	a3 a4       	ldd	r10, Z+43	; 0x2b
     398:	b4 a4       	ldd	r11, Z+44	; 0x2c
     39a:	c5 a4       	ldd	r12, Z+45	; 0x2d
     39c:	d6 a4       	ldd	r13, Z+46	; 0x2e
     39e:	07 a5       	ldd	r16, Z+47	; 0x2f
     3a0:	27 a1       	ldd	r18, Z+39	; 0x27
     3a2:	30 a5       	ldd	r19, Z+40	; 0x28
     3a4:	41 a5       	ldd	r20, Z+41	; 0x29
     3a6:	52 a5       	ldd	r21, Z+42	; 0x2a
     3a8:	63 ad       	ldd	r22, Z+59	; 0x3b
     3aa:	10 e0       	ldi	r17, 0x00	; 0
     3ac:	80 ee       	ldi	r24, 0xE0	; 224
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	33 df       	rcall	.-410    	; 0x218 <actuator_set_position>
     3b2:	1f 91       	pop	r17
     3b4:	0f 91       	pop	r16
     3b6:	ff 90       	pop	r15
     3b8:	ef 90       	pop	r14
     3ba:	df 90       	pop	r13
     3bc:	cf 90       	pop	r12
     3be:	bf 90       	pop	r11
     3c0:	af 90       	pop	r10
     3c2:	08 95       	ret

000003c4 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3c4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3c8:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3cc:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3d0:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3d4:	08 95       	ret

000003d6 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3d6:	68 2f       	mov	r22, r24
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     3e2:	20 e0       	ldi	r18, 0x00	; 0
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	48 e4       	ldi	r20, 0x48	; 72
     3e8:	52 e4       	ldi	r21, 0x42	; 66
     3ea:	0e 94 1e 11 	call	0x223c	; 0x223c <__subsf3>
     3ee:	27 ed       	ldi	r18, 0xD7	; 215
     3f0:	33 ea       	ldi	r19, 0xA3	; 163
     3f2:	48 e8       	ldi	r20, 0x88	; 136
     3f4:	51 e4       	ldi	r21, 0x41	; 65
     3f6:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     3fa:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     3fe:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     402:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     406:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     40a:	08 95       	ret

0000040c <controller>:
}

void controller(volatile ModuleValues_t *vals){
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     426:	8e 8d       	ldd	r24, Y+30	; 0x1e
     428:	82 30       	cpi	r24, 0x02	; 2
     42a:	21 f4       	brne	.+8      	; 0x434 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     42c:	68 8d       	ldd	r22, Y+24	; 0x18
     42e:	16 2f       	mov	r17, r22
     430:	11 95       	neg	r17
     432:	01 c0       	rjmp	.+2      	; 0x436 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     434:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     436:	8e 8d       	ldd	r24, Y+30	; 0x1e
     438:	81 30       	cpi	r24, 0x01	; 1
     43a:	09 f4       	brne	.+2      	; 0x43e <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     43c:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     43e:	89 a1       	ldd	r24, Y+33	; 0x21
     440:	81 11       	cpse	r24, r1
     442:	7b c0       	rjmp	.+246    	; 0x53a <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     444:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     448:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     44c:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     450:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     454:	20 e0       	ldi	r18, 0x00	; 0
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	4e eb       	ldi	r20, 0xBE	; 190
     45a:	52 e4       	ldi	r21, 0x42	; 66
     45c:	c7 01       	movw	r24, r14
     45e:	b6 01       	movw	r22, r12
     460:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <__gesf2>
     464:	88 23       	and	r24, r24
     466:	54 f4       	brge	.+20     	; 0x47c <controller+0x70>
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	48 e4       	ldi	r20, 0x48	; 72
     46e:	52 e4       	ldi	r21, 0x42	; 66
     470:	c7 01       	movw	r24, r14
     472:	b6 01       	movw	r22, r12
     474:	0e 94 83 11 	call	0x2306	; 0x2306 <__cmpsf2>
     478:	18 16       	cp	r1, r24
     47a:	6c f0       	brlt	.+26     	; 0x496 <controller+0x8a>
		{
			b_saturation = 1 ;
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     482:	61 2f       	mov	r22, r17
     484:	11 0f       	add	r17, r17
     486:	77 0b       	sbc	r23, r23
     488:	88 0b       	sbc	r24, r24
     48a:	99 0b       	sbc	r25, r25
     48c:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     490:	6b 01       	movw	r12, r22
     492:	7c 01       	movw	r14, r24
     494:	25 c0       	rjmp	.+74     	; 0x4e0 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     496:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     49a:	61 2f       	mov	r22, r17
     49c:	11 0f       	add	r17, r17
     49e:	77 0b       	sbc	r23, r23
     4a0:	88 0b       	sbc	r24, r24
     4a2:	99 0b       	sbc	r25, r25
     4a4:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4ac:	2a e0       	ldi	r18, 0x0A	; 10
     4ae:	37 ed       	ldi	r19, 0xD7	; 215
     4b0:	43 ea       	ldi	r20, 0xA3	; 163
     4b2:	5b e3       	ldi	r21, 0x3B	; 59
     4b4:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     4b8:	9b 01       	movw	r18, r22
     4ba:	ac 01       	movw	r20, r24
     4bc:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4c0:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4c4:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4c8:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4cc:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     4d0:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4d4:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4d8:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     4dc:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     4e0:	27 ed       	ldi	r18, 0xD7	; 215
     4e2:	33 ea       	ldi	r19, 0xA3	; 163
     4e4:	48 e8       	ldi	r20, 0x88	; 136
     4e6:	51 e4       	ldi	r21, 0x41	; 65
     4e8:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4ec:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4f0:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4f4:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4f8:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     4fc:	4b 01       	movw	r8, r22
     4fe:	5c 01       	movw	r10, r24
     500:	27 e8       	ldi	r18, 0x87	; 135
     502:	3f eb       	ldi	r19, 0xBF	; 191
     504:	46 e2       	ldi	r20, 0x26	; 38
     506:	5e e3       	ldi	r21, 0x3E	; 62
     508:	c7 01       	movw	r24, r14
     50a:	b6 01       	movw	r22, r12
     50c:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     510:	9b 01       	movw	r18, r22
     512:	ac 01       	movw	r20, r24
     514:	c5 01       	movw	r24, r10
     516:	b4 01       	movw	r22, r8
     518:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 e4       	ldi	r20, 0x48	; 72
     522:	52 e4       	ldi	r21, 0x42	; 66
     524:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     528:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     52c:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     530:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     534:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     538:	11 c0       	rjmp	.+34     	; 0x55c <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     53a:	89 a1       	ldd	r24, Y+33	; 0x21
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	71 f4       	brne	.+28     	; 0x55c <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     540:	69 8d       	ldd	r22, Y+25	; 0x19
     542:	70 e0       	ldi	r23, 0x00	; 0
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     54c:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     550:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     554:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     558:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     55c:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     560:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     564:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     568:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     56c:	20 e0       	ldi	r18, 0x00	; 0
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	4e eb       	ldi	r20, 0xBE	; 190
     572:	52 e4       	ldi	r21, 0x42	; 66
     574:	c7 01       	movw	r24, r14
     576:	b6 01       	movw	r22, r12
     578:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <__gesf2>
     57c:	18 16       	cp	r1, r24
     57e:	6c f4       	brge	.+26     	; 0x59a <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	ae eb       	ldi	r26, 0xBE	; 190
     586:	b2 e4       	ldi	r27, 0x42	; 66
     588:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     58c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     590:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     594:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     598:	16 c0       	rjmp	.+44     	; 0x5c6 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	48 e4       	ldi	r20, 0x48	; 72
     5a0:	52 e4       	ldi	r21, 0x42	; 66
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 83 11 	call	0x2306	; 0x2306 <__cmpsf2>
     5aa:	88 23       	and	r24, r24
     5ac:	64 f4       	brge	.+24     	; 0x5c6 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	a8 e4       	ldi	r26, 0x48	; 72
     5b4:	b2 e4       	ldi	r27, 0x42	; 66
     5b6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5ba:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5be:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5c2:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5c6:	06 e9       	ldi	r16, 0x96	; 150
     5c8:	10 e0       	ldi	r17, 0x00	; 0
     5ca:	f8 01       	movw	r30, r16
     5cc:	e0 80       	ld	r14, Z
     5ce:	f1 80       	ldd	r15, Z+1	; 0x01
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	48 ec       	ldi	r20, 0xC8	; 200
     5d6:	52 e4       	ldi	r21, 0x42	; 66
     5d8:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5dc:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5e0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     5e4:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     5e8:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     5ec:	4b 01       	movw	r8, r22
     5ee:	5c 01       	movw	r10, r24
     5f0:	b7 01       	movw	r22, r14
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	90 e0       	ldi	r25, 0x00	; 0
     5f6:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     5fa:	9b 01       	movw	r18, r22
     5fc:	ac 01       	movw	r20, r24
     5fe:	c5 01       	movw	r24, r10
     600:	b4 01       	movw	r22, r8
     602:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     606:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     60a:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     60e:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     612:	f8 01       	movw	r30, r16
     614:	60 81       	ld	r22, Z
     616:	71 81       	ldd	r23, Z+1	; 0x01
     618:	00 81       	ld	r16, Z
     61a:	11 81       	ldd	r17, Z+1	; 0x01
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     624:	6b 01       	movw	r12, r22
     626:	7c 01       	movw	r14, r24
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	48 ec       	ldi	r20, 0xC8	; 200
     62e:	52 e4       	ldi	r21, 0x42	; 66
     630:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     634:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     638:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     63c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     640:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     644:	4b 01       	movw	r8, r22
     646:	5c 01       	movw	r10, r24
     648:	b8 01       	movw	r22, r16
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     652:	9b 01       	movw	r18, r22
     654:	ac 01       	movw	r20, r24
     656:	c5 01       	movw	r24, r10
     658:	b4 01       	movw	r22, r8
     65a:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     65e:	9b 01       	movw	r18, r22
     660:	ac 01       	movw	r20, r24
     662:	c7 01       	movw	r24, r14
     664:	b6 01       	movw	r22, r12
     666:	0e 94 1e 11 	call	0x223c	; 0x223c <__subsf3>
     66a:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     66e:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     672:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     676:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     67a:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     67e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     682:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     686:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
     68a:	69 8f       	std	Y+25, r22	; 0x19

}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	1f 91       	pop	r17
     692:	0f 91       	pop	r16
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14
     698:	df 90       	pop	r13
     69a:	cf 90       	pop	r12
     69c:	bf 90       	pop	r11
     69e:	af 90       	pop	r10
     6a0:	9f 90       	pop	r9
     6a2:	8f 90       	pop	r8
     6a4:	08 95       	ret

000006a6 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6a6:	53 9a       	sbi	0x0a, 3	; 10
     6a8:	08 95       	ret

000006aa <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	11 f4       	brne	.+4      	; 0x6b2 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6ae:	5b 9a       	sbi	0x0b, 3	; 11
     6b0:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6b2:	5b 98       	cbi	0x0b, 3	; 11
     6b4:	08 95       	ret

000006b6 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6bc:	6a ef       	ldi	r22, 0xFA	; 250
     6be:	71 e0       	ldi	r23, 0x01	; 1
     6c0:	80 e0       	ldi	r24, 0x00	; 0
     6c2:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6c6:	21 e0       	ldi	r18, 0x01	; 1
     6c8:	43 e0       	ldi	r20, 0x03	; 3
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	67 ef       	ldi	r22, 0xF7	; 247
     6ce:	71 e0       	ldi	r23, 0x01	; 1
     6d0:	8a ef       	ldi	r24, 0xFA	; 250
     6d2:	91 e0       	ldi	r25, 0x01	; 1
     6d4:	0e 94 be 10 	call	0x217c	; 0x217c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6d8:	e7 ef       	ldi	r30, 0xF7	; 247
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	61 81       	ldd	r22, Z+1	; 0x01
     6de:	6f 71       	andi	r22, 0x1F	; 31
     6e0:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	76 2f       	mov	r23, r22
     6e6:	66 27       	eor	r22, r22
     6e8:	82 81       	ldd	r24, Z+2	; 0x02
     6ea:	68 2b       	or	r22, r24
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     6f4:	20 e0       	ldi	r18, 0x00	; 0
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	49 e8       	ldi	r20, 0x89	; 137
     6fa:	52 e4       	ldi	r21, 0x42	; 66
     6fc:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	40 e2       	ldi	r20, 0x20	; 32
     706:	51 e4       	ldi	r21, 0x41	; 65
     708:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     70c:	20 e0       	ldi	r18, 0x00	; 0
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	48 e8       	ldi	r20, 0x88	; 136
     712:	51 e4       	ldi	r21, 0x41	; 65
     714:	0e 94 1e 11 	call	0x223c	; 0x223c <__subsf3>
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     722:	68 83       	st	Y, r22
     724:	79 83       	std	Y+1, r23	; 0x01
     726:	8a 83       	std	Y+2, r24	; 0x02
     728:	9b 83       	std	Y+3, r25	; 0x03
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	08 95       	ret

00000730 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     736:	6a ef       	ldi	r22, 0xFA	; 250
     738:	71 e0       	ldi	r23, 0x01	; 1
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     740:	21 e0       	ldi	r18, 0x01	; 1
     742:	43 e0       	ldi	r20, 0x03	; 3
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	67 ef       	ldi	r22, 0xF7	; 247
     748:	71 e0       	ldi	r23, 0x01	; 1
     74a:	8a ef       	ldi	r24, 0xFA	; 250
     74c:	91 e0       	ldi	r25, 0x01	; 1
     74e:	0e 94 be 10 	call	0x217c	; 0x217c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     752:	e7 ef       	ldi	r30, 0xF7	; 247
     754:	f1 e0       	ldi	r31, 0x01	; 1
     756:	61 81       	ldd	r22, Z+1	; 0x01
     758:	6f 71       	andi	r22, 0x1F	; 31
     75a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     75c:	70 e0       	ldi	r23, 0x00	; 0
     75e:	76 2f       	mov	r23, r22
     760:	66 27       	eor	r22, r22
     762:	82 81       	ldd	r24, Z+2	; 0x02
     764:	68 2b       	or	r22, r24
     766:	41 e0       	ldi	r20, 0x01	; 1
     768:	ce 01       	movw	r24, r28
     76a:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <handle_current_sensor>
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	08 95       	ret

00000774 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     77a:	6a ef       	ldi	r22, 0xFA	; 250
     77c:	71 e0       	ldi	r23, 0x01	; 1
     77e:	84 e0       	ldi	r24, 0x04	; 4
     780:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     784:	21 e0       	ldi	r18, 0x01	; 1
     786:	43 e0       	ldi	r20, 0x03	; 3
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	67 ef       	ldi	r22, 0xF7	; 247
     78c:	71 e0       	ldi	r23, 0x01	; 1
     78e:	8a ef       	ldi	r24, 0xFA	; 250
     790:	91 e0       	ldi	r25, 0x01	; 1
     792:	0e 94 be 10 	call	0x217c	; 0x217c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     796:	e7 ef       	ldi	r30, 0xF7	; 247
     798:	f1 e0       	ldi	r31, 0x01	; 1
     79a:	61 81       	ldd	r22, Z+1	; 0x01
     79c:	6f 71       	andi	r22, 0x1F	; 31
     79e:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7a0:	70 e0       	ldi	r23, 0x00	; 0
     7a2:	76 2f       	mov	r23, r22
     7a4:	66 27       	eor	r22, r22
     7a6:	82 81       	ldd	r24, Z+2	; 0x02
     7a8:	68 2b       	or	r22, r24
     7aa:	ce 01       	movw	r24, r28
     7ac:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <handle_temp_sensor>
}
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	08 95       	ret

000007b6 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7b6:	0f 93       	push	r16
     7b8:	1f 93       	push	r17
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	00 d0       	rcall	.+0      	; 0x7c0 <SPI_handler_6+0xa>
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <SPI_handler_6+0xc>
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
     7c6:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7c8:	6a ef       	ldi	r22, 0xFA	; 250
     7ca:	71 e0       	ldi	r23, 0x01	; 1
     7cc:	86 e0       	ldi	r24, 0x06	; 6
     7ce:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	43 e0       	ldi	r20, 0x03	; 3
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	67 ef       	ldi	r22, 0xF7	; 247
     7da:	71 e0       	ldi	r23, 0x01	; 1
     7dc:	8a ef       	ldi	r24, 0xFA	; 250
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	0e 94 be 10 	call	0x217c	; 0x217c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7e4:	e7 ef       	ldi	r30, 0xF7	; 247
     7e6:	f1 e0       	ldi	r31, 0x01	; 1
     7e8:	61 81       	ldd	r22, Z+1	; 0x01
     7ea:	6f 71       	andi	r22, 0x1F	; 31
     7ec:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     7ee:	70 e0       	ldi	r23, 0x00	; 0
     7f0:	76 2f       	mov	r23, r22
     7f2:	66 27       	eor	r22, r22
     7f4:	82 81       	ldd	r24, Z+2	; 0x02
     7f6:	68 2b       	or	r22, r24
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     800:	20 e0       	ldi	r18, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	40 ea       	ldi	r20, 0xA0	; 160
     806:	50 e4       	ldi	r21, 0x40	; 64
     808:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     80c:	20 e0       	ldi	r18, 0x00	; 0
     80e:	30 e0       	ldi	r19, 0x00	; 0
     810:	40 e8       	ldi	r20, 0x80	; 128
     812:	59 e3       	ldi	r21, 0x39	; 57
     814:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     818:	69 83       	std	Y+1, r22	; 0x01
     81a:	7a 83       	std	Y+2, r23	; 0x02
     81c:	8b 83       	std	Y+3, r24	; 0x03
     81e:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     820:	69 81       	ldd	r22, Y+1	; 0x01
     822:	7a 81       	ldd	r23, Y+2	; 0x02
     824:	8b 81       	ldd	r24, Y+3	; 0x03
     826:	9c 81       	ldd	r25, Y+4	; 0x04
     828:	20 e0       	ldi	r18, 0x00	; 0
     82a:	30 e0       	ldi	r19, 0x00	; 0
     82c:	48 ec       	ldi	r20, 0xC8	; 200
     82e:	52 e4       	ldi	r21, 0x42	; 66
     830:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     834:	20 e0       	ldi	r18, 0x00	; 0
     836:	30 e0       	ldi	r19, 0x00	; 0
     838:	48 ec       	ldi	r20, 0xC8	; 200
     83a:	51 e4       	ldi	r21, 0x41	; 65
     83c:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     840:	f8 01       	movw	r30, r16
     842:	60 83       	st	Z, r22
     844:	71 83       	std	Z+1, r23	; 0x01
     846:	82 83       	std	Z+2, r24	; 0x02
     848:	93 83       	std	Z+3, r25	; 0x03
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	0f 90       	pop	r0
     850:	0f 90       	pop	r0
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	08 95       	ret

0000085c <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     85c:	cf 93       	push	r28
     85e:	df 93       	push	r29
     860:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     862:	6a ef       	ldi	r22, 0xFA	; 250
     864:	71 e0       	ldi	r23, 0x01	; 1
     866:	87 e0       	ldi	r24, 0x07	; 7
     868:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     86c:	21 e0       	ldi	r18, 0x01	; 1
     86e:	43 e0       	ldi	r20, 0x03	; 3
     870:	50 e0       	ldi	r21, 0x00	; 0
     872:	67 ef       	ldi	r22, 0xF7	; 247
     874:	71 e0       	ldi	r23, 0x01	; 1
     876:	8a ef       	ldi	r24, 0xFA	; 250
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	0e 94 be 10 	call	0x217c	; 0x217c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     87e:	e7 ef       	ldi	r30, 0xF7	; 247
     880:	f1 e0       	ldi	r31, 0x01	; 1
     882:	61 81       	ldd	r22, Z+1	; 0x01
     884:	6f 71       	andi	r22, 0x1F	; 31
     886:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	76 2f       	mov	r23, r22
     88c:	66 27       	eor	r22, r22
     88e:	82 81       	ldd	r24, Z+2	; 0x02
     890:	68 2b       	or	r22, r24
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	ce 01       	movw	r24, r28
     896:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <handle_current_sensor>
}
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	8c 01       	movw	r16, r24
     8aa:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8ac:	cb 01       	movw	r24, r22
     8ae:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <can_read_message_if_new>
     8b2:	88 23       	and	r24, r24
     8b4:	09 f4       	brne	.+2      	; 0x8b8 <handle_can+0x18>
     8b6:	46 c0       	rjmp	.+140    	; 0x944 <handle_can+0xa4>
     8b8:	f8 01       	movw	r30, r16
     8ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     8bc:	84 30       	cpi	r24, 0x04	; 4
     8be:	09 f4       	brne	.+2      	; 0x8c2 <handle_can+0x22>
     8c0:	41 c0       	rjmp	.+130    	; 0x944 <handle_can+0xa4>
		switch (rx->id){
     8c2:	88 81       	ld	r24, Y
     8c4:	99 81       	ldd	r25, Y+1	; 0x01
     8c6:	80 32       	cpi	r24, 0x20	; 32
     8c8:	f1 e0       	ldi	r31, 0x01	; 1
     8ca:	9f 07       	cpc	r25, r31
     8cc:	91 f1       	breq	.+100    	; 0x932 <handle_can+0x92>
     8ce:	80 33       	cpi	r24, 0x30	; 48
     8d0:	92 40       	sbci	r25, 0x02	; 2
     8d2:	c1 f5       	brne	.+112    	; 0x944 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	f8 01       	movw	r30, r16
     8d8:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     8da:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     8dc:	82 e3       	ldi	r24, 0x32	; 50
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	93 8f       	std	Z+27, r25	; 0x1b
     8e2:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     8e4:	8e 81       	ldd	r24, Y+6	; 0x06
     8e6:	89 30       	cpi	r24, 0x09	; 9
     8e8:	40 f0       	brcs	.+16     	; 0x8fa <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     8ea:	86 95       	lsr	r24
     8ec:	86 95       	lsr	r24
     8ee:	86 95       	lsr	r24
     8f0:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     8f2:	8e e1       	ldi	r24, 0x1E	; 30
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	95 8f       	std	Z+29, r25	; 0x1d
     8f8:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     8fa:	8f 81       	ldd	r24, Y+7	; 0x07
     8fc:	89 30       	cpi	r24, 0x09	; 9
     8fe:	88 f0       	brcs	.+34     	; 0x922 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     900:	8d 81       	ldd	r24, Y+5	; 0x05
     902:	9d ec       	ldi	r25, 0xCD	; 205
     904:	89 9f       	mul	r24, r25
     906:	81 2d       	mov	r24, r1
     908:	11 24       	eor	r1, r1
     90a:	86 95       	lsr	r24
     90c:	86 95       	lsr	r24
     90e:	86 95       	lsr	r24
     910:	f8 01       	movw	r30, r16
     912:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     914:	8e e1       	ldi	r24, 0x1E	; 30
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	95 8f       	std	Z+29, r25	; 0x1d
     91a:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     91c:	8f 81       	ldd	r24, Y+7	; 0x07
     91e:	89 30       	cpi	r24, 0x09	; 9
     920:	10 f4       	brcc	.+4      	; 0x926 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     922:	f8 01       	movw	r30, r16
     924:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     926:	8e 81       	ldd	r24, Y+6	; 0x06
     928:	89 30       	cpi	r24, 0x09	; 9
     92a:	60 f4       	brcc	.+24     	; 0x944 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     92c:	f8 01       	movw	r30, r16
     92e:	17 8a       	std	Z+23, r1	; 0x17
     930:	09 c0       	rjmp	.+18     	; 0x944 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	f8 01       	movw	r30, r16
     936:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	96 8b       	std	Z+22, r25	; 0x16
     93e:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     940:	8d 81       	ldd	r24, Y+5	; 0x05
     942:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	1f 91       	pop	r17
     94a:	0f 91       	pop	r16
     94c:	08 95       	ret

0000094e <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     94e:	0f 93       	push	r16
     950:	1f 93       	push	r17
     952:	cf 93       	push	r28
     954:	df 93       	push	r29
     956:	cd b7       	in	r28, 0x3d	; 61
     958:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     95a:	08 eb       	ldi	r16, 0xB8	; 184
     95c:	13 e0       	ldi	r17, 0x03	; 3
     95e:	80 e5       	ldi	r24, 0x50	; 80
     960:	92 e0       	ldi	r25, 0x02	; 2
     962:	f8 01       	movw	r30, r16
     964:	91 83       	std	Z+1, r25	; 0x01
     966:	80 83       	st	Z, r24
	txFrame.length = 8;
     968:	88 e0       	ldi	r24, 0x08	; 8
     96a:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     96c:	8d a1       	ldd	r24, Y+37	; 0x25
     96e:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     970:	69 85       	ldd	r22, Y+9	; 0x09
     972:	7a 85       	ldd	r23, Y+10	; 0x0a
     974:	8b 85       	ldd	r24, Y+11	; 0x0b
     976:	9c 85       	ldd	r25, Y+12	; 0x0c
     978:	20 e0       	ldi	r18, 0x00	; 0
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	40 e2       	ldi	r20, 0x20	; 32
     97e:	51 e4       	ldi	r21, 0x41	; 65
     980:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     984:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     988:	f8 01       	movw	r30, r16
     98a:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     98c:	69 89       	ldd	r22, Y+17	; 0x11
     98e:	7a 89       	ldd	r23, Y+18	; 0x12
     990:	8b 89       	ldd	r24, Y+19	; 0x13
     992:	9c 89       	ldd	r25, Y+20	; 0x14
     994:	20 e0       	ldi	r18, 0x00	; 0
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	40 e2       	ldi	r20, 0x20	; 32
     99a:	51 e4       	ldi	r21, 0x41	; 65
     99c:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     9a0:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
     9a4:	f8 01       	movw	r30, r16
     9a6:	76 83       	std	Z+6, r23	; 0x06
     9a8:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9aa:	6d 89       	ldd	r22, Y+21	; 0x15
     9ac:	7e 89       	ldd	r23, Y+22	; 0x16
     9ae:	8f 89       	ldd	r24, Y+23	; 0x17
     9b0:	98 8d       	ldd	r25, Y+24	; 0x18
     9b2:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     9b6:	07 2e       	mov	r0, r23
     9b8:	00 0c       	add	r0, r0
     9ba:	88 0b       	sbc	r24, r24
     9bc:	99 0b       	sbc	r25, r25
     9be:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	48 ec       	ldi	r20, 0xC8	; 200
     9c8:	52 e4       	ldi	r21, 0x42	; 66
     9ca:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     9ce:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     9d2:	9b 01       	movw	r18, r22
     9d4:	77 23       	and	r23, r23
     9d6:	24 f4       	brge	.+8      	; 0x9e0 <handle_motor_status_can_msg+0x92>
     9d8:	22 27       	eor	r18, r18
     9da:	33 27       	eor	r19, r19
     9dc:	26 1b       	sub	r18, r22
     9de:	37 0b       	sbc	r19, r23
     9e0:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     9e4:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     9e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
     9ea:	7b 8d       	ldd	r23, Y+27	; 0x1b
     9ec:	08 eb       	ldi	r16, 0xB8	; 184
     9ee:	13 e0       	ldi	r17, 0x03	; 3
     9f0:	80 e0       	ldi	r24, 0x00	; 0
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     9f8:	26 e6       	ldi	r18, 0x66	; 102
     9fa:	36 e6       	ldi	r19, 0x66	; 102
     9fc:	46 e6       	ldi	r20, 0x66	; 102
     9fe:	50 e4       	ldi	r21, 0x40	; 64
     a00:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     a04:	20 e0       	ldi	r18, 0x00	; 0
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	5f e3       	ldi	r21, 0x3F	; 63
     a0c:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     a10:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
     a14:	f8 01       	movw	r30, r16
     a16:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a18:	89 8d       	ldd	r24, Y+25	; 0x19
     a1a:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a1c:	c8 01       	movw	r24, r16
     a1e:	0e 94 1c 10 	call	0x2038	; 0x2038 <can_send_message>
}
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	08 95       	ret

00000a2c <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a34:	ed ea       	ldi	r30, 0xAD	; 173
     a36:	f3 e0       	ldi	r31, 0x03	; 3
     a38:	81 e5       	ldi	r24, 0x51	; 81
     a3a:	92 e0       	ldi	r25, 0x02	; 2
     a3c:	91 83       	std	Z+1, r25	; 0x01
     a3e:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a44:	21 96       	adiw	r28, 0x01	; 1
     a46:	8f ad       	ldd	r24, Y+63	; 0x3f
     a48:	21 97       	sbiw	r28, 0x01	; 1
     a4a:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a4c:	cf 01       	movw	r24, r30
     a4e:	0e 94 1c 10 	call	0x2038	; 0x2038 <can_send_message>
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a58:	af 92       	push	r10
     a5a:	bf 92       	push	r11
     a5c:	cf 92       	push	r12
     a5e:	df 92       	push	r13
     a60:	ef 92       	push	r14
     a62:	ff 92       	push	r15
     a64:	0f 93       	push	r16
     a66:	1f 93       	push	r17
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	66 97       	sbiw	r28, 0x16	; 22
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     a7e:	fe 01       	movw	r30, r28
     a80:	31 96       	adiw	r30, 0x01	; 1
     a82:	96 e1       	ldi	r25, 0x16	; 22
     a84:	df 01       	movw	r26, r30
     a86:	1d 92       	st	X+, r1
     a88:	9a 95       	dec	r25
     a8a:	e9 f7       	brne	.-6      	; 0xa86 <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     a8c:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     a90:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     a94:	92 1b       	sub	r25, r18
     a96:	9f 71       	andi	r25, 0x1F	; 31
     a98:	09 f4       	brne	.+2      	; 0xa9c <receive_uart+0x44>
     a9a:	4e c1       	rjmp	.+668    	; 0xd38 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     a9c:	f6 01       	movw	r30, r12
     a9e:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     aa0:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     aa2:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     aa4:	66 e1       	ldi	r22, 0x16	; 22
     aa6:	ce 01       	movw	r24, r28
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	b6 d4       	rcall	.+2412   	; 0x1418 <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     aac:	ce 01       	movw	r24, r28
     aae:	01 96       	adiw	r24, 0x01	; 1
     ab0:	0e 94 42 13 	call	0x2684	; 0x2684 <atoi>
     ab4:	5c 01       	movw	r10, r24
     ab6:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ab8:	d6 01       	movw	r26, r12
     aba:	8d 91       	ld	r24, X+
     abc:	9c 91       	ld	r25, X
     abe:	89 2b       	or	r24, r25
     ac0:	71 f4       	brne	.+28     	; 0xade <receive_uart+0x86>
     ac2:	6f e4       	ldi	r22, 0x4F	; 79
     ac4:	71 e0       	ldi	r23, 0x01	; 1
     ac6:	ce 01       	movw	r24, r28
     ac8:	01 96       	adiw	r24, 0x01	; 1
     aca:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     ace:	89 2b       	or	r24, r25
     ad0:	31 f4       	brne	.+12     	; 0xade <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     ad2:	f6 01       	movw	r30, r12
     ad4:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	91 83       	std	Z+1, r25	; 0x01
     adc:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     ade:	d6 01       	movw	r26, r12
     ae0:	8d 91       	ld	r24, X+
     ae2:	9c 91       	ld	r25, X
     ae4:	89 2b       	or	r24, r25
     ae6:	71 f0       	breq	.+28     	; 0xb04 <receive_uart+0xac>
     ae8:	61 e6       	ldi	r22, 0x61	; 97
     aea:	71 e0       	ldi	r23, 0x01	; 1
     aec:	ce 01       	movw	r24, r28
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     af4:	89 2b       	or	r24, r25
     af6:	31 f4       	brne	.+12     	; 0xb04 <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     af8:	f6 01       	movw	r30, r12
     afa:	11 82       	std	Z+1, r1	; 0x01
     afc:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     afe:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b00:	15 8e       	std	Z+29, r1	; 0x1d
     b02:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b04:	62 e7       	ldi	r22, 0x72	; 114
     b06:	71 e0       	ldi	r23, 0x01	; 1
     b08:	ce 01       	movw	r24, r28
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     b10:	89 2b       	or	r24, r25
     b12:	11 f5       	brne	.+68     	; 0xb58 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b14:	d6 01       	movw	r26, r12
     b16:	94 96       	adiw	r26, 0x24	; 36
     b18:	1c 92       	st	X, r1
     b1a:	1e 92       	st	-X, r1
     b1c:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b1e:	da 96       	adiw	r26, 0x3a	; 58
     b20:	8c 91       	ld	r24, X
     b22:	81 30       	cpi	r24, 0x01	; 1
     b24:	51 f0       	breq	.+20     	; 0xb3a <receive_uart+0xe2>
     b26:	18 f0       	brcs	.+6      	; 0xb2e <receive_uart+0xd6>
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	89 f0       	breq	.+34     	; 0xb4e <receive_uart+0xf6>
     b2c:	15 c0       	rjmp	.+42     	; 0xb58 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b2e:	f6 01       	movw	r30, r12
     b30:	84 a9       	ldd	r24, Z+52	; 0x34
     b32:	95 a9       	ldd	r25, Z+53	; 0x35
     b34:	93 ab       	std	Z+51, r25	; 0x33
     b36:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b38:	0f c0       	rjmp	.+30     	; 0xb58 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b3a:	d6 01       	movw	r26, r12
     b3c:	d6 96       	adiw	r26, 0x36	; 54
     b3e:	8d 91       	ld	r24, X+
     b40:	9c 91       	ld	r25, X
     b42:	d7 97       	sbiw	r26, 0x37	; 55
     b44:	d3 96       	adiw	r26, 0x33	; 51
     b46:	9c 93       	st	X, r25
     b48:	8e 93       	st	-X, r24
     b4a:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b4c:	05 c0       	rjmp	.+10     	; 0xb58 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b4e:	f6 01       	movw	r30, r12
     b50:	80 ad       	ldd	r24, Z+56	; 0x38
     b52:	91 ad       	ldd	r25, Z+57	; 0x39
     b54:	93 ab       	std	Z+51, r25	; 0x33
     b56:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b58:	65 e8       	ldi	r22, 0x85	; 133
     b5a:	71 e0       	ldi	r23, 0x01	; 1
     b5c:	ce 01       	movw	r24, r28
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     b64:	89 2b       	or	r24, r25
     b66:	39 f4       	brne	.+14     	; 0xb76 <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	d6 01       	movw	r26, r12
     b6e:	94 96       	adiw	r26, 0x24	; 36
     b70:	9c 93       	st	X, r25
     b72:	8e 93       	st	-X, r24
     b74:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b76:	f6 01       	movw	r30, r12
     b78:	80 81       	ld	r24, Z
     b7a:	91 81       	ldd	r25, Z+1	; 0x01
     b7c:	89 2b       	or	r24, r25
     b7e:	39 f0       	breq	.+14     	; 0xb8e <receive_uart+0x136>
     b80:	c5 01       	movw	r24, r10
     b82:	0b 97       	sbiw	r24, 0x0b	; 11
     b84:	0a 97       	sbiw	r24, 0x0a	; 10
     b86:	18 f4       	brcc	.+6      	; 0xb8e <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     b88:	86 ef       	ldi	r24, 0xF6	; 246
     b8a:	8a 0d       	add	r24, r10
     b8c:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     b8e:	d6 01       	movw	r26, r12
     b90:	8d 91       	ld	r24, X+
     b92:	9c 91       	ld	r25, X
     b94:	11 97       	sbiw	r26, 0x01	; 1
     b96:	89 2b       	or	r24, r25
     b98:	39 f0       	breq	.+14     	; 0xba8 <receive_uart+0x150>
     b9a:	0a 30       	cpi	r16, 0x0A	; 10
     b9c:	11 05       	cpc	r17, r1
     b9e:	20 f4       	brcc	.+8      	; 0xba8 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     ba0:	8a e0       	ldi	r24, 0x0A	; 10
     ba2:	8a 19       	sub	r24, r10
     ba4:	58 96       	adiw	r26, 0x18	; 24
     ba6:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     ba8:	f6 01       	movw	r30, r12
     baa:	80 81       	ld	r24, Z
     bac:	91 81       	ldd	r25, Z+1	; 0x01
     bae:	89 2b       	or	r24, r25
     bb0:	31 f0       	breq	.+12     	; 0xbbe <receive_uart+0x166>
     bb2:	01 2b       	or	r16, r17
     bb4:	21 f4       	brne	.+8      	; 0xbbe <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bb6:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bb8:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bba:	82 e3       	ldi	r24, 0x32	; 50
     bbc:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bbe:	d6 01       	movw	r26, r12
     bc0:	93 96       	adiw	r26, 0x23	; 35
     bc2:	8d 91       	ld	r24, X+
     bc4:	9c 91       	ld	r25, X
     bc6:	94 97       	sbiw	r26, 0x24	; 36
     bc8:	01 97       	sbiw	r24, 0x01	; 1
     bca:	51 f4       	brne	.+20     	; 0xbe0 <receive_uart+0x188>
     bcc:	67 e9       	ldi	r22, 0x97	; 151
     bce:	71 e0       	ldi	r23, 0x01	; 1
     bd0:	ce 01       	movw	r24, r28
     bd2:	01 96       	adiw	r24, 0x01	; 1
     bd4:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     bd8:	89 2b       	or	r24, r25
     bda:	11 f4       	brne	.+4      	; 0xbe0 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     bdc:	f6 01       	movw	r30, r12
     bde:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     be0:	d6 01       	movw	r26, r12
     be2:	93 96       	adiw	r26, 0x23	; 35
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	94 97       	sbiw	r26, 0x24	; 36
     bea:	01 97       	sbiw	r24, 0x01	; 1
     bec:	59 f4       	brne	.+22     	; 0xc04 <receive_uart+0x1ac>
     bee:	69 e9       	ldi	r22, 0x99	; 153
     bf0:	71 e0       	ldi	r23, 0x01	; 1
     bf2:	ce 01       	movw	r24, r28
     bf4:	01 96       	adiw	r24, 0x01	; 1
     bf6:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     bfa:	89 2b       	or	r24, r25
     bfc:	19 f4       	brne	.+6      	; 0xc04 <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	f6 01       	movw	r30, r12
     c02:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c04:	d6 01       	movw	r26, r12
     c06:	93 96       	adiw	r26, 0x23	; 35
     c08:	8d 91       	ld	r24, X+
     c0a:	9c 91       	ld	r25, X
     c0c:	94 97       	sbiw	r26, 0x24	; 36
     c0e:	01 97       	sbiw	r24, 0x01	; 1
     c10:	59 f4       	brne	.+22     	; 0xc28 <receive_uart+0x1d0>
     c12:	65 eb       	ldi	r22, 0xB5	; 181
     c14:	71 e0       	ldi	r23, 0x01	; 1
     c16:	ce 01       	movw	r24, r28
     c18:	01 96       	adiw	r24, 0x01	; 1
     c1a:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     c1e:	89 2b       	or	r24, r25
     c20:	19 f4       	brne	.+6      	; 0xc28 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c22:	82 e0       	ldi	r24, 0x02	; 2
     c24:	f6 01       	movw	r30, r12
     c26:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c28:	d6 01       	movw	r26, r12
     c2a:	93 96       	adiw	r26, 0x23	; 35
     c2c:	8d 91       	ld	r24, X+
     c2e:	9c 91       	ld	r25, X
     c30:	94 97       	sbiw	r26, 0x24	; 36
     c32:	89 2b       	or	r24, r25
     c34:	59 f4       	brne	.+22     	; 0xc4c <receive_uart+0x1f4>
     c36:	6b e9       	ldi	r22, 0x9B	; 155
     c38:	71 e0       	ldi	r23, 0x01	; 1
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     c42:	89 2b       	or	r24, r25
     c44:	19 f4       	brne	.+6      	; 0xc4c <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	e0 da       	rcall	.-2624   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c4c:	f6 01       	movw	r30, r12
     c4e:	83 a1       	ldd	r24, Z+35	; 0x23
     c50:	94 a1       	ldd	r25, Z+36	; 0x24
     c52:	89 2b       	or	r24, r25
     c54:	59 f4       	brne	.+22     	; 0xc6c <receive_uart+0x214>
     c56:	63 ea       	ldi	r22, 0xA3	; 163
     c58:	71 e0       	ldi	r23, 0x01	; 1
     c5a:	ce 01       	movw	r24, r28
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     c62:	89 2b       	or	r24, r25
     c64:	19 f4       	brne	.+6      	; 0xc6c <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	d0 da       	rcall	.-2656   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c6c:	d6 01       	movw	r26, r12
     c6e:	93 96       	adiw	r26, 0x23	; 35
     c70:	8d 91       	ld	r24, X+
     c72:	9c 91       	ld	r25, X
     c74:	94 97       	sbiw	r26, 0x24	; 36
     c76:	89 2b       	or	r24, r25
     c78:	a9 f4       	brne	.+42     	; 0xca4 <receive_uart+0x24c>
     c7a:	69 ea       	ldi	r22, 0xA9	; 169
     c7c:	71 e0       	ldi	r23, 0x01	; 1
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     c86:	89 2b       	or	r24, r25
     c88:	69 f4       	brne	.+26     	; 0xca4 <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     c8a:	f6 01       	movw	r30, r12
     c8c:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     c8e:	e0 ac       	ldd	r14, Z+56	; 0x38
     c90:	f1 ac       	ldd	r15, Z+57	; 0x39
     c92:	06 a9       	ldd	r16, Z+54	; 0x36
     c94:	17 a9       	ldd	r17, Z+55	; 0x37
     c96:	24 a9       	ldd	r18, Z+52	; 0x34
     c98:	35 a9       	ldd	r19, Z+53	; 0x35
     c9a:	42 a9       	ldd	r20, Z+50	; 0x32
     c9c:	53 a9       	ldd	r21, Z+51	; 0x33
     c9e:	62 ad       	ldd	r22, Z+58	; 0x3a
     ca0:	83 ad       	ldd	r24, Z+59	; 0x3b
     ca2:	81 da       	rcall	.-2814   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     ca4:	d6 01       	movw	r26, r12
     ca6:	93 96       	adiw	r26, 0x23	; 35
     ca8:	8d 91       	ld	r24, X+
     caa:	9c 91       	ld	r25, X
     cac:	94 97       	sbiw	r26, 0x24	; 36
     cae:	89 2b       	or	r24, r25
     cb0:	b1 f4       	brne	.+44     	; 0xcde <receive_uart+0x286>
     cb2:	67 eb       	ldi	r22, 0xB7	; 183
     cb4:	71 e0       	ldi	r23, 0x01	; 1
     cb6:	ce 01       	movw	r24, r28
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     cbe:	89 2b       	or	r24, r25
     cc0:	71 f4       	brne	.+28     	; 0xcde <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	f6 01       	movw	r30, r12
     cc6:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cc8:	e0 ac       	ldd	r14, Z+56	; 0x38
     cca:	f1 ac       	ldd	r15, Z+57	; 0x39
     ccc:	06 a9       	ldd	r16, Z+54	; 0x36
     cce:	17 a9       	ldd	r17, Z+55	; 0x37
     cd0:	24 a9       	ldd	r18, Z+52	; 0x34
     cd2:	35 a9       	ldd	r19, Z+53	; 0x35
     cd4:	42 a9       	ldd	r20, Z+50	; 0x32
     cd6:	53 a9       	ldd	r21, Z+51	; 0x33
     cd8:	62 ad       	ldd	r22, Z+58	; 0x3a
     cda:	83 ad       	ldd	r24, Z+59	; 0x3b
     cdc:	64 da       	rcall	.-2872   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cde:	d6 01       	movw	r26, r12
     ce0:	93 96       	adiw	r26, 0x23	; 35
     ce2:	8d 91       	ld	r24, X+
     ce4:	9c 91       	ld	r25, X
     ce6:	94 97       	sbiw	r26, 0x24	; 36
     ce8:	89 2b       	or	r24, r25
     cea:	b1 f4       	brne	.+44     	; 0xd18 <receive_uart+0x2c0>
     cec:	67 ec       	ldi	r22, 0xC7	; 199
     cee:	71 e0       	ldi	r23, 0x01	; 1
     cf0:	ce 01       	movw	r24, r28
     cf2:	01 96       	adiw	r24, 0x01	; 1
     cf4:	0e 94 5f 13 	call	0x26be	; 0x26be <strcmp>
     cf8:	89 2b       	or	r24, r25
     cfa:	71 f4       	brne	.+28     	; 0xd18 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     cfc:	82 e0       	ldi	r24, 0x02	; 2
     cfe:	f6 01       	movw	r30, r12
     d00:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d02:	e0 ac       	ldd	r14, Z+56	; 0x38
     d04:	f1 ac       	ldd	r15, Z+57	; 0x39
     d06:	06 a9       	ldd	r16, Z+54	; 0x36
     d08:	17 a9       	ldd	r17, Z+55	; 0x37
     d0a:	24 a9       	ldd	r18, Z+52	; 0x34
     d0c:	35 a9       	ldd	r19, Z+53	; 0x35
     d0e:	42 a9       	ldd	r20, Z+50	; 0x32
     d10:	53 a9       	ldd	r21, Z+51	; 0x33
     d12:	62 ad       	ldd	r22, Z+58	; 0x3a
     d14:	83 ad       	ldd	r24, Z+59	; 0x3b
     d16:	47 da       	rcall	.-2930   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d18:	d6 01       	movw	r26, r12
     d1a:	93 96       	adiw	r26, 0x23	; 35
     d1c:	8d 91       	ld	r24, X+
     d1e:	9c 91       	ld	r25, X
     d20:	94 97       	sbiw	r26, 0x24	; 36
     d22:	89 2b       	or	r24, r25
     d24:	41 f4       	brne	.+16     	; 0xd36 <receive_uart+0x2de>
     d26:	c5 01       	movw	r24, r10
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	87 3e       	cpi	r24, 0xE7	; 231
     d2c:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d2e:	18 f4       	brcc	.+6      	; 0xd36 <receive_uart+0x2de>
     d30:	f6 01       	movw	r30, r12
     d32:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d34:	a2 aa       	std	Z+50, r10	; 0x32
     d36:	26 d3       	rcall	.+1612   	; 0x1384 <uart0_flush>
	}
}
     d38:	66 96       	adiw	r28, 0x16	; 22
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	f8 94       	cli
     d3e:	de bf       	out	0x3e, r29	; 62
     d40:	0f be       	out	0x3f, r0	; 63
     d42:	cd bf       	out	0x3d, r28	; 61
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	bf 90       	pop	r11
     d56:	af 90       	pop	r10
     d58:	08 95       	ret

00000d5a <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d5a:	0f 93       	push	r16
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	cd b7       	in	r28, 0x3d	; 61
     d64:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d66:	88 ed       	ldi	r24, 0xD8	; 216
     d68:	91 e0       	ldi	r25, 0x01	; 1
     d6a:	0e 94 88 13 	call	0x2710	; 0x2710 <puts>
	//printf(",");
	//printf("%u", vals.gear_required);
	//printf(",");
	//printf("%u",vals.gear_status);
	//printf(",");
	printf("%u", vals.motor_status);
     d6e:	8d a1       	ldd	r24, Y+37	; 0x25
     d70:	1f 92       	push	r1
     d72:	8f 93       	push	r24
     d74:	0a ed       	ldi	r16, 0xDA	; 218
     d76:	11 e0       	ldi	r17, 0x01	; 1
     d78:	1f 93       	push	r17
     d7a:	0f 93       	push	r16
     d7c:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     d80:	8c e2       	ldi	r24, 0x2C	; 44
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	printf("%u",vals.message_mode);
     d88:	8e a1       	ldd	r24, Y+38	; 0x26
     d8a:	1f 92       	push	r1
     d8c:	8f 93       	push	r24
     d8e:	1f 93       	push	r17
     d90:	0f 93       	push	r16
     d92:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     d96:	8c e2       	ldi	r24, 0x2C	; 44
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	printf("%u",vals.u8_duty_cycle);
     d9e:	88 a1       	ldd	r24, Y+32	; 0x20
     da0:	1f 92       	push	r1
     da2:	8f 93       	push	r24
     da4:	1f 93       	push	r17
     da6:	0f 93       	push	r16
     da8:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     dac:	8c e2       	ldi	r24, 0x2C	; 44
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     db4:	69 89       	ldd	r22, Y+17	; 0x11
     db6:	7a 89       	ldd	r23, Y+18	; 0x12
     db8:	8b 89       	ldd	r24, Y+19	; 0x13
     dba:	9c 89       	ldd	r25, Y+20	; 0x14
     dbc:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     dc0:	7f 93       	push	r23
     dc2:	6f 93       	push	r22
     dc4:	0d ed       	ldi	r16, 0xDD	; 221
     dc6:	11 e0       	ldi	r17, 0x01	; 1
     dc8:	1f 93       	push	r17
     dca:	0f 93       	push	r16
     dcc:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     dd0:	8c e2       	ldi	r24, 0x2C	; 44
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	printf("%i",(int16_t)(vals.f32_motor_current*1000));
     dd8:	69 85       	ldd	r22, Y+9	; 0x09
     dda:	7a 85       	ldd	r23, Y+10	; 0x0a
     ddc:	8b 85       	ldd	r24, Y+11	; 0x0b
     dde:	9c 85       	ldd	r25, Y+12	; 0x0c
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	4a e7       	ldi	r20, 0x7A	; 122
     de6:	54 e4       	ldi	r21, 0x44	; 68
     de8:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     dec:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     df0:	7f 93       	push	r23
     df2:	6f 93       	push	r22
     df4:	1f 93       	push	r17
     df6:	0f 93       	push	r16
     df8:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(","); 
     dfc:	8c e2       	ldi	r24, 0x2C	; 44
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	printf("%i",(int16_t)(vals.f32_batt_current*1000));
     e04:	6d 85       	ldd	r22, Y+13	; 0x0d
     e06:	7e 85       	ldd	r23, Y+14	; 0x0e
     e08:	8f 85       	ldd	r24, Y+15	; 0x0f
     e0a:	98 89       	ldd	r25, Y+16	; 0x10
     e0c:	20 e0       	ldi	r18, 0x00	; 0
     e0e:	30 e0       	ldi	r19, 0x00	; 0
     e10:	4a e7       	ldi	r20, 0x7A	; 122
     e12:	54 e4       	ldi	r21, 0x44	; 68
     e14:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     e18:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     e1c:	7f 93       	push	r23
     e1e:	6f 93       	push	r22
     e20:	1f 93       	push	r17
     e22:	0f 93       	push	r16
     e24:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     e28:	8c e2       	ldi	r24, 0x2C	; 44
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e30:	6a a9       	ldd	r22, Y+50	; 0x32
     e32:	7b a9       	ldd	r23, Y+51	; 0x33
     e34:	8c a9       	ldd	r24, Y+52	; 0x34
     e36:	9d a9       	ldd	r25, Y+53	; 0x35
     e38:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
     e3c:	7f 93       	push	r23
     e3e:	6f 93       	push	r22
     e40:	1f 93       	push	r17
     e42:	0f 93       	push	r16
     e44:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     e48:	8c e2       	ldi	r24, 0x2C	; 44
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e50:	8f 81       	ldd	r24, Y+7	; 0x07
     e52:	98 85       	ldd	r25, Y+8	; 0x08
     e54:	9f 93       	push	r25
     e56:	8f 93       	push	r24
     e58:	1f 93       	push	r17
     e5a:	0f 93       	push	r16
     e5c:	0e 94 70 13 	call	0x26e0	; 0x26e0 <printf>
	printf(",");
     e60:	0f b6       	in	r0, 0x3f	; 63
     e62:	f8 94       	cli
     e64:	de bf       	out	0x3e, r29	; 62
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	cd bf       	out	0x3d, r28	; 61
     e6a:	8c e2       	ldi	r24, 0x2C	; 44
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 83 13 	call	0x2706	; 0x2706 <putchar>
	//printf(",");
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	//printf("%i", (int16_t)vals.uart_debug);
	
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	1f 91       	pop	r17
     e78:	0f 91       	pop	r16
     e7a:	08 95       	ret

00000e7c <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     e84:	8b a1       	ldd	r24, Y+35	; 0x23
     e86:	82 30       	cpi	r24, 0x02	; 2
     e88:	91 f1       	breq	.+100    	; 0xeee <manage_LEDs+0x72>
     e8a:	28 f4       	brcc	.+10     	; 0xe96 <manage_LEDs+0x1a>
     e8c:	88 23       	and	r24, r24
     e8e:	49 f0       	breq	.+18     	; 0xea2 <manage_LEDs+0x26>
     e90:	81 30       	cpi	r24, 0x01	; 1
     e92:	19 f1       	breq	.+70     	; 0xeda <manage_LEDs+0x5e>
     e94:	49 c0       	rjmp	.+146    	; 0xf28 <manage_LEDs+0xac>
     e96:	84 30       	cpi	r24, 0x04	; 4
     e98:	f1 f1       	breq	.+124    	; 0xf16 <manage_LEDs+0x9a>
     e9a:	98 f1       	brcs	.+102    	; 0xf02 <manage_LEDs+0x86>
     e9c:	85 30       	cpi	r24, 0x05	; 5
     e9e:	99 f0       	breq	.+38     	; 0xec6 <manage_LEDs+0x4a>
     ea0:	43 c0       	rjmp	.+134    	; 0xf28 <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     ea2:	80 e4       	ldi	r24, 0x40	; 64
     ea4:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     ea8:	80 e8       	ldi	r24, 0x80	; 128
     eaa:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     eae:	8f 8d       	ldd	r24, Y+31	; 0x1f
     eb0:	98 a1       	ldd	r25, Y+32	; 0x20
     eb2:	89 2b       	or	r24, r25
     eb4:	21 f4       	brne	.+8      	; 0xebe <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     eb6:	80 e2       	ldi	r24, 0x20	; 32
     eb8:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
     ebc:	35 c0       	rjmp	.+106    	; 0xf28 <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     ebe:	80 e2       	ldi	r24, 0x20	; 32
     ec0:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
     ec4:	31 c0       	rjmp	.+98     	; 0xf28 <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     ec6:	80 e2       	ldi	r24, 0x20	; 32
     ec8:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     ecc:	80 e4       	ldi	r24, 0x40	; 64
     ece:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     ed2:	80 e8       	ldi	r24, 0x80	; 128
     ed4:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
		break ;
     ed8:	27 c0       	rjmp	.+78     	; 0xf28 <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     eda:	80 e2       	ldi	r24, 0x20	; 32
     edc:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     ee0:	80 e8       	ldi	r24, 0x80	; 128
     ee2:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     ee6:	80 e4       	ldi	r24, 0x40	; 64
     ee8:	0e 94 a9 10 	call	0x2152	; 0x2152 <rgbled_toggle>
		break;
     eec:	1d c0       	rjmp	.+58     	; 0xf28 <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     eee:	80 e8       	ldi	r24, 0x80	; 128
     ef0:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     ef4:	80 e4       	ldi	r24, 0x40	; 64
     ef6:	0e 94 a9 10 	call	0x2152	; 0x2152 <rgbled_toggle>
			rgbled_toggle(LED_RED);
     efa:	80 e2       	ldi	r24, 0x20	; 32
     efc:	0e 94 a9 10 	call	0x2152	; 0x2152 <rgbled_toggle>
		break;
     f00:	13 c0       	rjmp	.+38     	; 0xf28 <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     f02:	80 e2       	ldi	r24, 0x20	; 32
     f04:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f08:	80 e8       	ldi	r24, 0x80	; 128
     f0a:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f0e:	80 e4       	ldi	r24, 0x40	; 64
     f10:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
		break;
     f14:	09 c0       	rjmp	.+18     	; 0xf28 <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     f16:	80 e4       	ldi	r24, 0x40	; 64
     f18:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f1c:	80 e8       	ldi	r24, 0x80	; 128
     f1e:	0e 94 9a 10 	call	0x2134	; 0x2134 <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     f22:	80 e2       	ldi	r24, 0x20	; 32
     f24:	0e 94 a4 10 	call	0x2148	; 0x2148 <rgbled_turn_on>
		break;
	}
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	08 95       	ret

00000f2e <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     f2e:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     f30:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     f32:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     f34:	e9 e6       	ldi	r30, 0x69	; 105
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	84 60       	ori	r24, 0x04	; 4
     f3c:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
     f3e:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
     f40:	e9 9a       	sbi	0x1d, 1	; 29
     f42:	08 95       	ret

00000f44 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
     f44:	0f 93       	push	r16
     f46:	1f 93       	push	r17
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
	
	if (*u16_counter > 70)
     f4c:	fb 01       	movw	r30, r22
     f4e:	20 81       	ld	r18, Z
     f50:	31 81       	ldd	r19, Z+1	; 0x01
     f52:	27 34       	cpi	r18, 0x47	; 71
     f54:	31 05       	cpc	r19, r1
     f56:	b8 f0       	brcs	.+46     	; 0xf86 <handle_speed_sensor+0x42>
     f58:	eb 01       	movw	r28, r22
     f5a:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
     f5c:	60 81       	ld	r22, Z
     f5e:	71 81       	ldd	r23, Z+1	; 0x01
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
     f68:	9b 01       	movw	r18, r22
     f6a:	ac 01       	movw	r20, r24
     f6c:	60 e0       	ldi	r22, 0x00	; 0
     f6e:	76 e7       	ldi	r23, 0x76	; 118
     f70:	88 e8       	ldi	r24, 0x88	; 136
     f72:	96 e4       	ldi	r25, 0x46	; 70
     f74:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     f78:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
     f7c:	f8 01       	movw	r30, r16
     f7e:	71 83       	std	Z+1, r23	; 0x01
     f80:	60 83       	st	Z, r22
		*u16_counter = 0 ;
     f82:	19 82       	std	Y+1, r1	; 0x01
     f84:	18 82       	st	Y, r1
	}	
}
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	1f 91       	pop	r17
     f8c:	0f 91       	pop	r16
     f8e:	08 95       	ret

00000f90 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
     f90:	cf 92       	push	r12
     f92:	df 92       	push	r13
     f94:	ef 92       	push	r14
     f96:	ff 92       	push	r15
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	1f 92       	push	r1
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
     fa2:	89 83       	std	Y+1, r24	; 0x01
     fa4:	69 01       	movw	r12, r18
     fa6:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
     fa8:	61 30       	cpi	r22, 0x01	; 1
     faa:	19 f5       	brne	.+70     	; 0xff2 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
     fac:	69 81       	ldd	r22, Y+1	; 0x01
     fae:	70 e0       	ldi	r23, 0x00	; 0
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
     fb8:	22 e1       	ldi	r18, 0x12	; 18
     fba:	35 e8       	ldi	r19, 0x85	; 133
     fbc:	41 e6       	ldi	r20, 0x61	; 97
     fbe:	5e e3       	ldi	r21, 0x3E	; 62
     fc0:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     fc4:	a7 01       	movw	r20, r14
     fc6:	96 01       	movw	r18, r12
     fc8:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
     fcc:	20 e0       	ldi	r18, 0x00	; 0
     fce:	30 e0       	ldi	r19, 0x00	; 0
     fd0:	48 ec       	ldi	r20, 0xC8	; 200
     fd2:	52 e4       	ldi	r21, 0x42	; 66
     fd4:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	48 e4       	ldi	r20, 0x48	; 72
     fde:	52 e4       	ldi	r21, 0x42	; 66
     fe0:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
     fe4:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
     fe8:	86 2f       	mov	r24, r22
		if (Duty == 50)
     fea:	62 33       	cpi	r22, 0x32	; 50
     fec:	29 f5       	brne	.+74     	; 0x1038 <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
     fee:	84 e3       	ldi	r24, 0x34	; 52
     ff0:	23 c0       	rjmp	.+70     	; 0x1038 <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
     ff2:	62 30       	cpi	r22, 0x02	; 2
     ff4:	01 f5       	brne	.+64     	; 0x1036 <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
     ff6:	69 81       	ldd	r22, Y+1	; 0x01
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0e 94 22 12 	call	0x2444	; 0x2444 <__floatsisf>
    1002:	23 ee       	ldi	r18, 0xE3	; 227
    1004:	3e ee       	ldi	r19, 0xEE	; 238
    1006:	4b e3       	ldi	r20, 0x3B	; 59
    1008:	5e e3       	ldi	r21, 0x3E	; 62
    100a:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
    100e:	a7 01       	movw	r20, r14
    1010:	96 01       	movw	r18, r12
    1012:	0e 94 87 11 	call	0x230e	; 0x230e <__divsf3>
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	48 ec       	ldi	r20, 0xC8	; 200
    101c:	52 e4       	ldi	r21, 0x42	; 66
    101e:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	48 e4       	ldi	r20, 0x48	; 72
    1028:	52 e4       	ldi	r21, 0x42	; 66
    102a:	0e 94 1f 11 	call	0x223e	; 0x223e <__addsf3>
    102e:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__fixunssfsi>
    1032:	86 2f       	mov	r24, r22
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    1036:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    1038:	0f 90       	pop	r0
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	ff 90       	pop	r15
    1040:	ef 90       	pop	r14
    1042:	df 90       	pop	r13
    1044:	cf 90       	pop	r12
    1046:	08 95       	ret

00001048 <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    104e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1050:	81 11       	cpse	r24, r1
    1052:	08 c0       	rjmp	.+16     	; 0x1064 <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    1054:	82 e3       	ldi	r24, 0x32	; 50
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	9b 8f       	std	Y+27, r25	; 0x1b
    105a:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    105c:	8e e1       	ldi	r24, 0x1E	; 30
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	9d 8f       	std	Y+29, r25	; 0x1d
    1062:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1064:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    1068:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    106c:	00 97       	sbiw	r24, 0x00	; 0
    106e:	31 f0       	breq	.+12     	; 0x107c <state_handler+0x34>
	{
		fault_timeout -- ;
    1070:	01 97       	sbiw	r24, 0x01	; 1
    1072:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    1076:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    107a:	05 c0       	rjmp	.+10     	; 0x1086 <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    107c:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1080:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1082:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    1086:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1088:	82 30       	cpi	r24, 0x02	; 2
    108a:	09 f4       	brne	.+2      	; 0x108e <state_handler+0x46>
    108c:	b7 c0       	rjmp	.+366    	; 0x11fc <__stack+0xfd>
    108e:	30 f4       	brcc	.+12     	; 0x109c <state_handler+0x54>
    1090:	88 23       	and	r24, r24
    1092:	61 f0       	breq	.+24     	; 0x10ac <state_handler+0x64>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	09 f4       	brne	.+2      	; 0x109a <state_handler+0x52>
    1098:	8f c0       	rjmp	.+286    	; 0x11b8 <__stack+0xb9>
    109a:	e1 c0       	rjmp	.+450    	; 0x125e <__stack+0x15f>
    109c:	84 30       	cpi	r24, 0x04	; 4
    109e:	09 f4       	brne	.+2      	; 0x10a2 <state_handler+0x5a>
    10a0:	cf c0       	rjmp	.+414    	; 0x1240 <__stack+0x141>
    10a2:	a0 f0       	brcs	.+40     	; 0x10cc <state_handler+0x84>
    10a4:	85 30       	cpi	r24, 0x05	; 5
    10a6:	09 f4       	brne	.+2      	; 0x10aa <state_handler+0x62>
    10a8:	51 c0       	rjmp	.+162    	; 0x114c <__stack+0x4d>
    10aa:	d9 c0       	rjmp	.+434    	; 0x125e <__stack+0x15f>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    10ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10b0:	89 2b       	or	r24, r25
    10b2:	11 f0       	breq	.+4      	; 0x10b8 <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    10b4:	83 e0       	ldi	r24, 0x03	; 3
    10b6:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	f7 da       	rcall	.-2578   	; 0x6aa <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    10bc:	18 a2       	std	Y+32, r1	; 0x20
    10be:	82 d9       	rcall	.-3324   	; 0x3c4 <reset_I>
			vals->u8_brake_cmd = 0;
    10c0:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    10c2:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    10c4:	82 e3       	ldi	r24, 0x32	; 50
    10c6:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    10c8:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    10ca:	c9 c0       	rjmp	.+402    	; 0x125e <__stack+0x15f>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    10cc:	8a a1       	ldd	r24, Y+34	; 0x22
    10ce:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    10d0:	24 c0       	rjmp	.+72     	; 0x111a <__stack+0x1b>
    10d2:	eb da       	rcall	.-2602   	; 0x6aa <drivers>
				reset_I();
    10d4:	77 d9       	rcall	.-3346   	; 0x3c4 <reset_I>
    10d6:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    10d8:	89 8f       	std	Y+25, r24	; 0x19
    10da:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    10dc:	88 23       	and	r24, r24
    10de:	69 f0       	breq	.+26     	; 0x10fa <state_handler+0xb2>
    10e0:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    10e2:	3b 85       	ldd	r19, Y+11	; 0x0b
    10e4:	4c 85       	ldd	r20, Y+12	; 0x0c
    10e6:	5d 85       	ldd	r21, Y+13	; 0x0d
    10e8:	8b 89       	ldd	r24, Y+19	; 0x13
    10ea:	9c 89       	ldd	r25, Y+20	; 0x14
    10ec:	62 e0       	ldi	r22, 0x02	; 2
    10ee:	50 df       	rcall	.-352    	; 0xf90 <compute_synch_duty>
    10f0:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    10f2:	89 8d       	ldd	r24, Y+25	; 0x19
    10f4:	70 d9       	rcall	.-3360   	; 0x3d6 <set_I>
    10f6:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    10f8:	8e 8f       	std	Y+30, r24	; 0x1e
    10fa:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    10fc:	88 23       	and	r24, r24
    10fe:	69 f0       	breq	.+26     	; 0x111a <__stack+0x1b>
    1100:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    1102:	3b 85       	ldd	r19, Y+11	; 0x0b
    1104:	4c 85       	ldd	r20, Y+12	; 0x0c
    1106:	5d 85       	ldd	r21, Y+13	; 0x0d
    1108:	8b 89       	ldd	r24, Y+19	; 0x13
    110a:	9c 89       	ldd	r25, Y+20	; 0x14
    110c:	62 e0       	ldi	r22, 0x02	; 2
    110e:	40 df       	rcall	.-384    	; 0xf90 <compute_synch_duty>
    1110:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    1112:	89 8d       	ldd	r24, Y+25	; 0x19
    1114:	60 d9       	rcall	.-3392   	; 0x3d6 <set_I>
    1116:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    1118:	8e 8f       	std	Y+30, r24	; 0x1e
    111a:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    111c:	81 30       	cpi	r24, 0x01	; 1
    111e:	09 f0       	breq	.+2      	; 0x1122 <__stack+0x23>
    1120:	9e c0       	rjmp	.+316    	; 0x125e <__stack+0x15f>
    1122:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    1124:	81 11       	cpse	r24, r1
    1126:	03 c0       	rjmp	.+6      	; 0x112e <__stack+0x2f>
    1128:	88 8d       	ldd	r24, Y+24	; 0x18
    112a:	88 23       	and	r24, r24
    112c:	41 f0       	breq	.+16     	; 0x113e <__stack+0x3f>
    112e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1130:	81 11       	cpse	r24, r1
    1132:	05 c0       	rjmp	.+10     	; 0x113e <__stack+0x3f>
				{
					vals->motor_status = ENGAGE;
    1134:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    1136:	8e 8f       	std	Y+30, r24	; 0x1e
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    113e:	80 e0       	ldi	r24, 0x00	; 0
    1140:	b4 da       	rcall	.-2712   	; 0x6aa <drivers>
				vals->gear_required = NEUTRAL ;
    1142:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    1144:	3f d9       	rcall	.-3458   	; 0x3c4 <reset_I>
    1146:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1148:	89 8f       	std	Y+25, r24	; 0x19
    114a:	89 c0       	rjmp	.+274    	; 0x125e <__stack+0x15f>
    114c:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    114e:	8b af       	std	Y+59, r24	; 0x3b
    1150:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    1154:	88 23       	and	r24, r24
    1156:	69 f0       	breq	.+26     	; 0x1172 <__stack+0x73>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    1158:	2a 85       	ldd	r18, Y+10	; 0x0a
    115a:	3b 85       	ldd	r19, Y+11	; 0x0b
    115c:	4c 85       	ldd	r20, Y+12	; 0x0c
    115e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1160:	6b ad       	ldd	r22, Y+59	; 0x3b
    1162:	8b 89       	ldd	r24, Y+19	; 0x13
    1164:	9c 89       	ldd	r25, Y+20	; 0x14
    1166:	14 df       	rcall	.-472    	; 0xf90 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    1168:	89 8f       	std	Y+25, r24	; 0x19
    116a:	89 8d       	ldd	r24, Y+25	; 0x19
    116c:	34 d9       	rcall	.-3480   	; 0x3d6 <set_I>
				starting_engage = 0;
    116e:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    1176:	ce 01       	movw	r24, r28
    1178:	49 d9       	rcall	.-3438   	; 0x40c <controller>
    117a:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    117c:	96 da       	rcall	.-2772   	; 0x6aa <drivers>
    117e:	88 8d       	ldd	r24, Y+24	; 0x18
    1180:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1182:	29 f0       	breq	.+10     	; 0x118e <__stack+0x8f>
    1184:	8a ad       	ldd	r24, Y+58	; 0x3a
    1186:	81 30       	cpi	r24, 0x01	; 1
    1188:	11 f4       	brne	.+4      	; 0x118e <__stack+0x8f>
    118a:	82 e0       	ldi	r24, 0x02	; 2
    118c:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    118e:	8f 89       	ldd	r24, Y+23	; 0x17
    1190:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1192:	21 f0       	breq	.+8      	; 0x119c <__stack+0x9d>
    1194:	8a ad       	ldd	r24, Y+58	; 0x3a
    1196:	81 30       	cpi	r24, 0x01	; 1
    1198:	09 f4       	brne	.+2      	; 0x119c <__stack+0x9d>
    119a:	8e 8f       	std	Y+30, r24	; 0x1e
    119c:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    119e:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    11a0:	5e c0       	rjmp	.+188    	; 0x125e <__stack+0x15f>
    11a2:	88 8d       	ldd	r24, Y+24	; 0x18
    11a4:	81 11       	cpse	r24, r1
    11a6:	5b c0       	rjmp	.+182    	; 0x125e <__stack+0x15f>
    11a8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11aa:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11ac:	89 2b       	or	r24, r25
    11ae:	09 f0       	breq	.+2      	; 0x11b2 <__stack+0xb3>
    11b0:	56 c0       	rjmp	.+172    	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = IDLE;
    11b2:	83 e0       	ldi	r24, 0x03	; 3
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
    11b6:	53 c0       	rjmp	.+166    	; 0x125e <__stack+0x15f>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    11b8:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    11ba:	ce 01       	movw	r24, r28
    11bc:	27 d9       	rcall	.-3506   	; 0x40c <controller>
    11be:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    11c0:	74 da       	rcall	.-2840   	; 0x6aa <drivers>
    11c2:	8f 89       	ldd	r24, Y+23	; 0x17
    11c4:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    11c6:	06 c0       	rjmp	.+12     	; 0x11d4 <__stack+0xd5>
    11c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11cc:	89 2b       	or	r24, r25
    11ce:	11 f4       	brne	.+4      	; 0x11d4 <__stack+0xd5>
    11d0:	83 e0       	ldi	r24, 0x03	; 3
    11d2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    11d4:	8a a1       	ldd	r24, Y+34	; 0x22
    11d6:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    11d8:	41 f4       	brne	.+16     	; 0x11ea <__stack+0xeb>
    11da:	8a ad       	ldd	r24, Y+58	; 0x3a
    11dc:	81 11       	cpse	r24, r1
    11de:	05 c0       	rjmp	.+10     	; 0x11ea <__stack+0xeb>
    11e0:	85 e0       	ldi	r24, 0x05	; 5
    11e2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    11e4:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    11e6:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    11ea:	88 8d       	ldd	r24, Y+24	; 0x18
    11ec:	88 23       	and	r24, r24
    11ee:	b9 f1       	breq	.+110    	; 0x125e <__stack+0x15f>
    11f0:	8f 89       	ldd	r24, Y+23	; 0x17
    11f2:	81 11       	cpse	r24, r1
    11f4:	34 c0       	rjmp	.+104    	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = BRAKE;
    11f6:	82 e0       	ldi	r24, 0x02	; 2
    11f8:	8e 8f       	std	Y+30, r24	; 0x1e
    11fa:	31 c0       	rjmp	.+98     	; 0x125e <__stack+0x15f>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    11fc:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    11fe:	ce 01       	movw	r24, r28
    1200:	05 d9       	rcall	.-3574   	; 0x40c <controller>
    1202:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1204:	52 da       	rcall	.-2908   	; 0x6aa <drivers>
    1206:	88 8d       	ldd	r24, Y+24	; 0x18
    1208:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    120a:	06 c0       	rjmp	.+12     	; 0x1218 <__stack+0x119>
    120c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    120e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1210:	89 2b       	or	r24, r25
    1212:	11 f4       	brne	.+4      	; 0x1218 <__stack+0x119>
    1214:	83 e0       	ldi	r24, 0x03	; 3
    1216:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1218:	8a a1       	ldd	r24, Y+34	; 0x22
    121a:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    121c:	41 f4       	brne	.+16     	; 0x122e <__stack+0x12f>
    121e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1220:	81 11       	cpse	r24, r1
    1222:	05 c0       	rjmp	.+10     	; 0x122e <__stack+0x12f>
    1224:	85 e0       	ldi	r24, 0x05	; 5
    1226:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    122e:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    1230:	81 11       	cpse	r24, r1
    1232:	15 c0       	rjmp	.+42     	; 0x125e <__stack+0x15f>
    1234:	8f 89       	ldd	r24, Y+23	; 0x17
    1236:	88 23       	and	r24, r24
    1238:	91 f0       	breq	.+36     	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = ACCEL;
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	8e 8f       	std	Y+30, r24	; 0x1e
    123e:	0f c0       	rjmp	.+30     	; 0x125e <__stack+0x15f>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1240:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1244:	81 11       	cpse	r24, r1
    1246:	02 c0       	rjmp	.+4      	; 0x124c <__stack+0x14d>
			{
				vals->motor_status = IDLE;
    1248:	83 e0       	ldi	r24, 0x03	; 3
    124a:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	2d da       	rcall	.-2982   	; 0x6aa <drivers>
    1250:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    1252:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    1254:	b7 d8       	rcall	.-3730   	; 0x3c4 <reset_I>
			reset_I(); //reset integrator
    1256:	18 8e       	std	Y+24, r1	; 0x18
    1258:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    125a:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    125c:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    125e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1260:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1262:	49 f0       	breq	.+18     	; 0x1276 <__stack+0x177>
    1264:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1266:	81 30       	cpi	r24, 0x01	; 1
    1268:	31 f0       	breq	.+12     	; 0x1276 <__stack+0x177>
    126a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    126c:	82 30       	cpi	r24, 0x02	; 2
    126e:	19 f0       	breq	.+6      	; 0x1276 <__stack+0x177>
    1270:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1272:	85 30       	cpi	r24, 0x05	; 5
    1274:	29 f4       	brne	.+10     	; 0x1280 <__stack+0x181>
    1276:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1278:	9b 8d       	ldd	r25, Y+27	; 0x1b
    127a:	89 2b       	or	r24, r25
    127c:	09 f4       	brne	.+2      	; 0x1280 <__stack+0x181>
    127e:	1e 8e       	std	Y+30, r1	; 0x1e
    1280:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1282:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1284:	08 95       	ret

00001286 <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    128a:	8e b1       	in	r24, 0x0e	; 14
    128c:	87 7c       	andi	r24, 0xC7	; 199
    128e:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1290:	8d b1       	in	r24, 0x0d	; 13
    1292:	88 63       	ori	r24, 0x38	; 56
    1294:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    1296:	a1 e9       	ldi	r26, 0x91	; 145
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	8c 91       	ld	r24, X
    129c:	80 61       	ori	r24, 0x10	; 16
    129e:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    12a0:	8c 91       	ld	r24, X
    12a2:	87 7f       	andi	r24, 0xF7	; 247
    12a4:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    12a6:	e0 e9       	ldi	r30, 0x90	; 144
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	80 81       	ld	r24, Z
    12ac:	82 60       	ori	r24, 0x02	; 2
    12ae:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    12b0:	80 81       	ld	r24, Z
    12b2:	8e 7f       	andi	r24, 0xFE	; 254
    12b4:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    12b6:	80 81       	ld	r24, Z
    12b8:	80 68       	ori	r24, 0x80	; 128
    12ba:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    12bc:	80 81       	ld	r24, Z
    12be:	8f 7b       	andi	r24, 0xBF	; 191
    12c0:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    12c2:	80 81       	ld	r24, Z
    12c4:	80 62       	ori	r24, 0x20	; 32
    12c6:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    12c8:	80 81       	ld	r24, Z
    12ca:	8f 7e       	andi	r24, 0xEF	; 239
    12cc:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    12ce:	80 81       	ld	r24, Z
    12d0:	88 60       	ori	r24, 0x08	; 8
    12d2:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    12d4:	80 81       	ld	r24, Z
    12d6:	8b 7f       	andi	r24, 0xFB	; 251
    12d8:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    12da:	8c 91       	ld	r24, X
    12dc:	81 60       	ori	r24, 0x01	; 1
    12de:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    12e0:	8c 91       	ld	r24, X
    12e2:	89 7f       	andi	r24, 0xF9	; 249
    12e4:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    12e6:	c6 e9       	ldi	r28, 0x96	; 150
    12e8:	d0 e0       	ldi	r29, 0x00	; 0
    12ea:	85 e8       	ldi	r24, 0x85	; 133
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	99 83       	std	Y+1, r25	; 0x01
    12f0:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    12f2:	68 81       	ld	r22, Y
    12f4:	79 81       	ldd	r23, Y+1	; 0x01
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
    12fe:	20 e0       	ldi	r18, 0x00	; 0
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	40 e0       	ldi	r20, 0x00	; 0
    1304:	5f e3       	ldi	r21, 0x3F	; 63
    1306:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
    130a:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
    130e:	e8 e9       	ldi	r30, 0x98	; 152
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	71 83       	std	Z+1, r23	; 0x01
    1314:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    1316:	88 81       	ld	r24, Y
    1318:	99 81       	ldd	r25, Y+1	; 0x01
    131a:	20 81       	ld	r18, Z
    131c:	31 81       	ldd	r19, Z+1	; 0x01
    131e:	82 1b       	sub	r24, r18
    1320:	93 0b       	sbc	r25, r19
    1322:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    1326:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    132a:	68 81       	ld	r22, Y
    132c:	79 81       	ldd	r23, Y+1	; 0x01
    132e:	80 e0       	ldi	r24, 0x00	; 0
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	0e 94 20 12 	call	0x2440	; 0x2440 <__floatunsisf>
    1336:	20 e0       	ldi	r18, 0x00	; 0
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	40 e0       	ldi	r20, 0x00	; 0
    133c:	5f e3       	ldi	r21, 0x3F	; 63
    133e:	0e 94 d6 12 	call	0x25ac	; 0x25ac <__mulsf3>
    1342:	0e 94 ef 11 	call	0x23de	; 0x23de <__fixsfsi>
    1346:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    134a:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	08 95       	ret

00001354 <uart0_putc>:
    1354:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    1358:	9f 5f       	subi	r25, 0xFF	; 255
    135a:	9f 71       	andi	r25, 0x1F	; 31
    135c:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1360:	92 17       	cp	r25, r18
    1362:	e1 f3       	breq	.-8      	; 0x135c <uart0_putc+0x8>
    1364:	e9 2f       	mov	r30, r25
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	e5 5d       	subi	r30, 0xD5	; 213
    136a:	fb 4f       	sbci	r31, 0xFB	; 251
    136c:	80 83       	st	Z, r24
    136e:	2f b7       	in	r18, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    1376:	e1 ec       	ldi	r30, 0xC1	; 193
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	80 62       	ori	r24, 0x20	; 32
    137e:	80 83       	st	Z, r24
    1380:	2f bf       	out	0x3f, r18	; 63
    1382:	08 95       	ret

00001384 <uart0_flush>:
    1384:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    1388:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    138c:	98 13       	cpse	r25, r24
    138e:	fa cf       	rjmp	.-12     	; 0x1384 <uart0_flush>
    1390:	08 95       	ret

00001392 <uart1_putc>:
    1392:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    1396:	9f 5f       	subi	r25, 0xFF	; 255
    1398:	9f 71       	andi	r25, 0x1F	; 31
    139a:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    139e:	92 17       	cp	r25, r18
    13a0:	e1 f3       	breq	.-8      	; 0x139a <uart1_putc+0x8>
    13a2:	e9 2f       	mov	r30, r25
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	ea 51       	subi	r30, 0x1A	; 26
    13a8:	fc 4f       	sbci	r31, 0xFC	; 252
    13aa:	80 83       	st	Z, r24
    13ac:	2f b7       	in	r18, 0x3f	; 63
    13ae:	f8 94       	cli
    13b0:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    13b4:	e9 ec       	ldi	r30, 0xC9	; 201
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	80 81       	ld	r24, Z
    13ba:	80 62       	ori	r24, 0x20	; 32
    13bc:	80 83       	st	Z, r24
    13be:	2f bf       	out	0x3f, r18	; 63
    13c0:	08 95       	ret

000013c2 <uart_putchar>:
    13c2:	cf 93       	push	r28
    13c4:	c8 2f       	mov	r28, r24
    13c6:	fb 01       	movw	r30, r22
    13c8:	84 85       	ldd	r24, Z+12	; 0x0c
    13ca:	95 85       	ldd	r25, Z+13	; 0x0d
    13cc:	01 97       	sbiw	r24, 0x01	; 1
    13ce:	39 f0       	breq	.+14     	; 0x13de <uart_putchar+0x1c>
    13d0:	ca 30       	cpi	r28, 0x0A	; 10
    13d2:	11 f4       	brne	.+4      	; 0x13d8 <uart_putchar+0x16>
    13d4:	8d e0       	ldi	r24, 0x0D	; 13
    13d6:	be df       	rcall	.-132    	; 0x1354 <uart0_putc>
    13d8:	8c 2f       	mov	r24, r28
    13da:	bc df       	rcall	.-136    	; 0x1354 <uart0_putc>
    13dc:	06 c0       	rjmp	.+12     	; 0x13ea <uart_putchar+0x28>
    13de:	ca 30       	cpi	r28, 0x0A	; 10
    13e0:	11 f4       	brne	.+4      	; 0x13e6 <uart_putchar+0x24>
    13e2:	8d e0       	ldi	r24, 0x0D	; 13
    13e4:	d6 df       	rcall	.-84     	; 0x1392 <uart1_putc>
    13e6:	8c 2f       	mov	r24, r28
    13e8:	d4 df       	rcall	.-88     	; 0x1392 <uart1_putc>
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	cf 91       	pop	r28
    13f0:	08 95       	ret

000013f2 <uart0_getc>:
    13f2:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    13f6:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    13fa:	89 17       	cp	r24, r25
    13fc:	59 f0       	breq	.+22     	; 0x1414 <uart0_getc+0x22>
    13fe:	8f 5f       	subi	r24, 0xFF	; 255
    1400:	98 2f       	mov	r25, r24
    1402:	9f 71       	andi	r25, 0x1F	; 31
    1404:	e9 2f       	mov	r30, r25
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	ed 53       	subi	r30, 0x3D	; 61
    140a:	fc 4f       	sbci	r31, 0xFC	; 252
    140c:	80 81       	ld	r24, Z
    140e:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    1412:	08 95       	ret
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	08 95       	ret

00001418 <uart0_getln>:
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	ec 01       	movw	r28, r24
    1422:	61 30       	cpi	r22, 0x01	; 1
    1424:	b1 f0       	breq	.+44     	; 0x1452 <uart0_getln+0x3a>
    1426:	62 50       	subi	r22, 0x02	; 2
    1428:	06 2f       	mov	r16, r22
    142a:	10 e0       	ldi	r17, 0x00	; 0
    142c:	0f 5f       	subi	r16, 0xFF	; 255
    142e:	1f 4f       	sbci	r17, 0xFF	; 255
    1430:	08 0f       	add	r16, r24
    1432:	19 1f       	adc	r17, r25
    1434:	de df       	rcall	.-68     	; 0x13f2 <uart0_getc>
    1436:	88 83       	st	Y, r24
    1438:	88 23       	and	r24, r24
    143a:	e1 f3       	breq	.-8      	; 0x1434 <uart0_getln+0x1c>
    143c:	8d 30       	cpi	r24, 0x0D	; 13
    143e:	21 f4       	brne	.+8      	; 0x1448 <uart0_getln+0x30>
    1440:	d8 df       	rcall	.-80     	; 0x13f2 <uart0_getc>
    1442:	88 23       	and	r24, r24
    1444:	e9 f3       	breq	.-6      	; 0x1440 <uart0_getln+0x28>
    1446:	05 c0       	rjmp	.+10     	; 0x1452 <uart0_getln+0x3a>
    1448:	21 96       	adiw	r28, 0x01	; 1
    144a:	c0 17       	cp	r28, r16
    144c:	d1 07       	cpc	r29, r17
    144e:	91 f7       	brne	.-28     	; 0x1434 <uart0_getln+0x1c>
    1450:	e8 01       	movw	r28, r16
    1452:	18 82       	st	Y, r1
    1454:	df 91       	pop	r29
    1456:	cf 91       	pop	r28
    1458:	1f 91       	pop	r17
    145a:	0f 91       	pop	r16
    145c:	08 95       	ret

0000145e <uart0_getData>:
    145e:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1462:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    1466:	89 17       	cp	r24, r25
    1468:	61 f0       	breq	.+24     	; 0x1482 <uart0_getData+0x24>
    146a:	8f 5f       	subi	r24, 0xFF	; 255
    146c:	8f 71       	andi	r24, 0x1F	; 31
    146e:	e8 2f       	mov	r30, r24
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	ed 53       	subi	r30, 0x3D	; 61
    1474:	fc 4f       	sbci	r31, 0xFC	; 252
    1476:	90 81       	ld	r25, Z
    1478:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    147c:	89 2f       	mov	r24, r25
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	08 95       	ret
    1482:	8f ef       	ldi	r24, 0xFF	; 255
    1484:	9f ef       	ldi	r25, 0xFF	; 255
    1486:	08 95       	ret

00001488 <uart1_getData>:
    1488:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    148c:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1490:	89 17       	cp	r24, r25
    1492:	61 f0       	breq	.+24     	; 0x14ac <uart1_getData+0x24>
    1494:	8f 5f       	subi	r24, 0xFF	; 255
    1496:	8f 71       	andi	r24, 0x1F	; 31
    1498:	e8 2f       	mov	r30, r24
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	e9 5f       	subi	r30, 0xF9	; 249
    149e:	fb 4f       	sbci	r31, 0xFB	; 251
    14a0:	90 81       	ld	r25, Z
    14a2:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    14a6:	89 2f       	mov	r24, r25
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	08 95       	ret
    14ac:	8f ef       	ldi	r24, 0xFF	; 255
    14ae:	9f ef       	ldi	r25, 0xFF	; 255
    14b0:	08 95       	ret

000014b2 <uart_getchar>:
    14b2:	cf 93       	push	r28
    14b4:	df 93       	push	r29
    14b6:	fc 01       	movw	r30, r24
    14b8:	84 85       	ldd	r24, Z+12	; 0x0c
    14ba:	95 85       	ldd	r25, Z+13	; 0x0d
    14bc:	01 97       	sbiw	r24, 0x01	; 1
    14be:	41 f0       	breq	.+16     	; 0x14d0 <uart_getchar+0x1e>
    14c0:	ce df       	rcall	.-100    	; 0x145e <uart0_getData>
    14c2:	ec 01       	movw	r28, r24
    14c4:	99 23       	and	r25, r25
    14c6:	e4 f3       	brlt	.-8      	; 0x14c0 <uart_getchar+0xe>
    14c8:	45 df       	rcall	.-374    	; 0x1354 <uart0_putc>
    14ca:	ce 01       	movw	r24, r28
    14cc:	99 27       	eor	r25, r25
    14ce:	07 c0       	rjmp	.+14     	; 0x14de <uart_getchar+0x2c>
    14d0:	db df       	rcall	.-74     	; 0x1488 <uart1_getData>
    14d2:	ec 01       	movw	r28, r24
    14d4:	99 23       	and	r25, r25
    14d6:	e4 f3       	brlt	.-8      	; 0x14d0 <uart_getchar+0x1e>
    14d8:	5c df       	rcall	.-328    	; 0x1392 <uart1_putc>
    14da:	ce 01       	movw	r24, r28
    14dc:	99 27       	eor	r25, r25
    14de:	99 27       	eor	r25, r25
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	08 95       	ret

000014e6 <__vector_22>:
    14e6:	0f 93       	push	r16
    14e8:	0f b7       	in	r16, 0x3f	; 63
    14ea:	ef 93       	push	r30
    14ec:	ff 93       	push	r31
    14ee:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    14f2:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    14f6:	e3 95       	inc	r30
    14f8:	ef 71       	andi	r30, 0x1F	; 31
    14fa:	ef 13       	cpse	r30, r31
    14fc:	05 c0       	rjmp	.+10     	; 0x1508 <USART0_TX_CONTINUE>
    14fe:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1502:	ff 7d       	andi	r31, 0xDF	; 223
    1504:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

00001508 <USART0_TX_CONTINUE>:
    1508:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	e5 5d       	subi	r30, 0xD5	; 213
    1510:	fb 4f       	sbci	r31, 0xFB	; 251
    1512:	e0 81       	ld	r30, Z
    1514:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

00001518 <USART0_TX_EXIT>:
    1518:	ff 91       	pop	r31
    151a:	ef 91       	pop	r30
    151c:	0f bf       	out	0x3f, r16	; 63
    151e:	0f 91       	pop	r16
    1520:	18 95       	reti

00001522 <__vector_21>:
    1522:	0f 93       	push	r16
    1524:	0f b7       	in	r16, 0x3f	; 63
    1526:	9f 93       	push	r25
    1528:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    152c:	ef 93       	push	r30
    152e:	ff 93       	push	r31
    1530:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    1534:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    1538:	e3 95       	inc	r30
    153a:	ef 71       	andi	r30, 0x1F	; 31
    153c:	fe 17       	cp	r31, r30
    153e:	31 f0       	breq	.+12     	; 0x154c <USART0_RX_EXIT>
    1540:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	ed 53       	subi	r30, 0x3D	; 61
    1548:	fc 4f       	sbci	r31, 0xFC	; 252
    154a:	90 83       	st	Z, r25

0000154c <USART0_RX_EXIT>:
    154c:	ff 91       	pop	r31
    154e:	ef 91       	pop	r30
    1550:	9f 91       	pop	r25
    1552:	0f bf       	out	0x3f, r16	; 63
    1554:	0f 91       	pop	r16
    1556:	18 95       	reti

00001558 <__vector_33>:
    1558:	0f 93       	push	r16
    155a:	0f b7       	in	r16, 0x3f	; 63
    155c:	ef 93       	push	r30
    155e:	ff 93       	push	r31
    1560:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1564:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    1568:	e3 95       	inc	r30
    156a:	ef 71       	andi	r30, 0x1F	; 31
    156c:	ef 13       	cpse	r30, r31
    156e:	05 c0       	rjmp	.+10     	; 0x157a <USART1_TX_CONTINUE>
    1570:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1574:	ff 7d       	andi	r31, 0xDF	; 223
    1576:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

0000157a <USART1_TX_CONTINUE>:
    157a:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    157e:	f0 e0       	ldi	r31, 0x00	; 0
    1580:	ea 51       	subi	r30, 0x1A	; 26
    1582:	fc 4f       	sbci	r31, 0xFC	; 252
    1584:	e0 81       	ld	r30, Z
    1586:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

0000158a <USART1_TX_EXIT>:
    158a:	ff 91       	pop	r31
    158c:	ef 91       	pop	r30
    158e:	0f bf       	out	0x3f, r16	; 63
    1590:	0f 91       	pop	r16
    1592:	18 95       	reti

00001594 <__vector_32>:
    1594:	0f 93       	push	r16
    1596:	0f b7       	in	r16, 0x3f	; 63
    1598:	9f 93       	push	r25
    159a:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    159e:	ef 93       	push	r30
    15a0:	ff 93       	push	r31
    15a2:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    15a6:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    15aa:	e3 95       	inc	r30
    15ac:	ef 71       	andi	r30, 0x1F	; 31
    15ae:	fe 17       	cp	r31, r30
    15b0:	31 f0       	breq	.+12     	; 0x15be <USART1_RX_EXIT>
    15b2:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    15b6:	f0 e0       	ldi	r31, 0x00	; 0
    15b8:	e9 5f       	subi	r30, 0xF9	; 249
    15ba:	fb 4f       	sbci	r31, 0xFB	; 251
    15bc:	90 83       	st	Z, r25

000015be <USART1_RX_EXIT>:
    15be:	ff 91       	pop	r31
    15c0:	ef 91       	pop	r30
    15c2:	9f 91       	pop	r25
    15c4:	0f bf       	out	0x3f, r16	; 63
    15c6:	0f 91       	pop	r16
    15c8:	18 95       	reti

000015ca <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    15ca:	e1 e8       	ldi	r30, 0x81	; 129
    15cc:	f0 e0       	ldi	r31, 0x00	; 0
    15ce:	80 81       	ld	r24, Z
    15d0:	83 60       	ori	r24, 0x03	; 3
    15d2:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    15d4:	80 81       	ld	r24, Z
    15d6:	88 60       	ori	r24, 0x08	; 8
    15d8:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    15da:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    15de:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    15e2:	ef e6       	ldi	r30, 0x6F	; 111
    15e4:	f0 e0       	ldi	r31, 0x00	; 0
    15e6:	80 81       	ld	r24, Z
    15e8:	82 60       	ori	r24, 0x02	; 2
    15ea:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    15ec:	8d e7       	ldi	r24, 0x7D	; 125
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    15f4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    15f8:	08 95       	ret

000015fa <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    15fa:	84 b5       	in	r24, 0x24	; 36
    15fc:	85 60       	ori	r24, 0x05	; 5
    15fe:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    1600:	84 b5       	in	r24, 0x24	; 36
    1602:	88 60       	ori	r24, 0x08	; 8
    1604:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    1606:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    1608:	ee e6       	ldi	r30, 0x6E	; 110
    160a:	f0 e0       	ldi	r31, 0x00	; 0
    160c:	80 81       	ld	r24, Z
    160e:	82 60       	ori	r24, 0x02	; 2
    1610:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    1612:	87 e2       	ldi	r24, 0x27	; 39
    1614:	87 bd       	out	0x27, r24	; 39
    1616:	08 95       	ret

00001618 <main>:
};


int main(void)	
{
	cli();
    1618:	f8 94       	cli
	rgbled_init();
    161a:	90 d5       	rcall	.+2848   	; 0x213c <rgbled_init>
	DWC_init();
    161c:	0f d2       	rcall	.+1054   	; 0x1a3c <DWC_init>
	pwm_init();
    161e:	33 de       	rcall	.-922    	; 0x1286 <pwm_init>
    1620:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    1622:	70 e0       	ldi	r23, 0x00	; 0
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    1628:	6f d4       	rcall	.+2270   	; 0x1f08 <can_init>
	timer0_init_ts();
    162a:	cf df       	rcall	.-98     	; 0x15ca <timer1_init_ts>
    162c:	e6 df       	rcall	.-52     	; 0x15fa <timer0_init_ts>
	speed_init();
    162e:	7f dc       	rcall	.-1794   	; 0xf2e <speed_init>
    1630:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    1632:	93 d5       	rcall	.+2854   	; 0x215a <spi_init>
    1634:	82 e1       	ldi	r24, 0x12	; 18
    1636:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    1638:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    163c:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    1640:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1644:	88 e9       	ldi	r24, 0x98	; 152
    1646:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    164a:	eb e4       	ldi	r30, 0x4B	; 75
    164c:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    164e:	84 e0       	ldi	r24, 0x04	; 4
    1650:	91 e0       	ldi	r25, 0x01	; 1
    1652:	93 83       	std	Z+3, r25	; 0x03
    1654:	82 83       	std	Z+2, r24	; 0x02
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    1656:	91 83       	std	Z+1, r25	; 0x01
    1658:	80 83       	st	Z, r24
	drivers_init();
    165a:	25 d8       	rcall	.-4022   	; 0x6a6 <drivers_init>
    165c:	80 e0       	ldi	r24, 0x00	; 0
	drivers(0);
    165e:	25 d8       	rcall	.-4022   	; 0x6aa <drivers>
    1660:	78 94       	sei
	sei();
    1662:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    1664:	67 e9       	ldi	r22, 0x97	; 151
    1666:	73 e0       	ldi	r23, 0x03	; 3
    1668:	82 e1       	ldi	r24, 0x12	; 18
    166a:	91 e0       	ldi	r25, 0x01	; 1
    166c:	19 d9       	rcall	.-3534   	; 0x8a0 <handle_can>
    166e:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1670:	91 e0       	ldi	r25, 0x01	; 1
    1672:	f2 d9       	rcall	.-3100   	; 0xa58 <receive_uart>
    1674:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1678:	88 23       	and	r24, r24
    167a:	09 f4       	brne	.+2      	; 0x167e <main+0x66>
    167c:	41 c0       	rjmp	.+130    	; 0x1700 <main+0xe8>
    167e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1682:	88 23       	and	r24, r24
    1684:	f1 f0       	breq	.+60     	; 0x16c2 <main+0xaa>
    1686:	8d b7       	in	r24, 0x3d	; 61
    1688:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    168a:	cd 97       	sbiw	r24, 0x3d	; 61
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	9e bf       	out	0x3e, r25	; 62
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	8d bf       	out	0x3d, r24	; 61
    1696:	ad b7       	in	r26, 0x3d	; 61
    1698:	be b7       	in	r27, 0x3e	; 62
    169a:	11 96       	adiw	r26, 0x01	; 1
    169c:	8d e3       	ldi	r24, 0x3D	; 61
    169e:	e2 e1       	ldi	r30, 0x12	; 18
    16a0:	f1 e0       	ldi	r31, 0x01	; 1
    16a2:	01 90       	ld	r0, Z+
    16a4:	0d 92       	st	X+, r0
    16a6:	8a 95       	dec	r24
    16a8:	e1 f7       	brne	.-8      	; 0x16a2 <main+0x8a>
    16aa:	51 d9       	rcall	.-3422   	; 0x94e <handle_motor_status_can_msg>
    16ac:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    16b0:	8d b7       	in	r24, 0x3d	; 61
    16b2:	9e b7       	in	r25, 0x3e	; 62
    16b4:	cd 96       	adiw	r24, 0x3d	; 61
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	9e bf       	out	0x3e, r25	; 62
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	8d bf       	out	0x3d, r24	; 61
    16c0:	1d c0       	rjmp	.+58     	; 0x16fc <main+0xe4>
    16c2:	8d b7       	in	r24, 0x3d	; 61
    16c4:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    16c6:	cd 97       	sbiw	r24, 0x3d	; 61
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	9e bf       	out	0x3e, r25	; 62
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	8d bf       	out	0x3d, r24	; 61
    16d2:	ad b7       	in	r26, 0x3d	; 61
    16d4:	be b7       	in	r27, 0x3e	; 62
    16d6:	11 96       	adiw	r26, 0x01	; 1
    16d8:	8d e3       	ldi	r24, 0x3D	; 61
    16da:	e2 e1       	ldi	r30, 0x12	; 18
    16dc:	f1 e0       	ldi	r31, 0x01	; 1
    16de:	01 90       	ld	r0, Z+
    16e0:	0d 92       	st	X+, r0
    16e2:	8a 95       	dec	r24
    16e4:	e1 f7       	brne	.-8      	; 0x16de <main+0xc6>
    16e6:	a2 d9       	rcall	.-3260   	; 0xa2c <handle_clutch_cmd_can_msg>
    16e8:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    16ec:	8d b7       	in	r24, 0x3d	; 61
    16ee:	9e b7       	in	r25, 0x3e	; 62
    16f0:	cd 96       	adiw	r24, 0x3d	; 61
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	9e bf       	out	0x3e, r25	; 62
    16f8:	0f be       	out	0x3f, r0	; 63
    16fa:	8d bf       	out	0x3d, r24	; 61
    16fc:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    1700:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    1704:	88 23       	and	r24, r24
    1706:	09 f4       	brne	.+2      	; 0x170a <main+0xf2>
    1708:	ad cf       	rjmp	.-166    	; 0x1664 <main+0x4c>
    170a:	8d b7       	in	r24, 0x3d	; 61
    170c:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    170e:	cd 97       	sbiw	r24, 0x3d	; 61
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	9e bf       	out	0x3e, r25	; 62
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	8d bf       	out	0x3d, r24	; 61
    171a:	ad b7       	in	r26, 0x3d	; 61
    171c:	be b7       	in	r27, 0x3e	; 62
    171e:	11 96       	adiw	r26, 0x01	; 1
    1720:	8d e3       	ldi	r24, 0x3D	; 61
    1722:	e2 e1       	ldi	r30, 0x12	; 18
    1724:	f1 e0       	ldi	r31, 0x01	; 1
    1726:	01 90       	ld	r0, Z+
    1728:	0d 92       	st	X+, r0
    172a:	8a 95       	dec	r24
    172c:	e1 f7       	brne	.-8      	; 0x1726 <main+0x10e>
    172e:	15 db       	rcall	.-2518   	; 0xd5a <send_uart>
    1730:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    1734:	8d b7       	in	r24, 0x3d	; 61
    1736:	9e b7       	in	r25, 0x3e	; 62
    1738:	cd 96       	adiw	r24, 0x3d	; 61
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	9e bf       	out	0x3e, r25	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	8d bf       	out	0x3d, r24	; 61
    1744:	8f cf       	rjmp	.-226    	; 0x1664 <main+0x4c>

00001746 <__vector_16>:
    1746:	1f 92       	push	r1
    1748:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	0f 92       	push	r0
    174e:	11 24       	eor	r1, r1
    1750:	0b b6       	in	r0, 0x3b	; 59
    1752:	0f 92       	push	r0
    1754:	ef 92       	push	r14
    1756:	0f 93       	push	r16
    1758:	1f 93       	push	r17
    175a:	2f 93       	push	r18
    175c:	3f 93       	push	r19
    175e:	4f 93       	push	r20
    1760:	5f 93       	push	r21
    1762:	6f 93       	push	r22
    1764:	7f 93       	push	r23
    1766:	8f 93       	push	r24
    1768:	9f 93       	push	r25
    176a:	af 93       	push	r26
    176c:	bf 93       	push	r27
    176e:	ef 93       	push	r30
    1770:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1772:	82 e1       	ldi	r24, 0x12	; 18
    1774:	91 e0       	ldi	r25, 0x01	; 1
    1776:	63 d1       	rcall	.+710    	; 0x1a3e <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1778:	82 e1       	ldi	r24, 0x12	; 18
    177a:	91 e0       	ldi	r25, 0x01	; 1
    177c:	65 dc       	rcall	.-1846   	; 0x1048 <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    177e:	82 e1       	ldi	r24, 0x12	; 18
    1780:	91 e0       	ldi	r25, 0x01	; 1
    1782:	0e 94 9b 01 	call	0x336	; 0x336 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    1786:	82 e1       	ldi	r24, 0x12	; 18
    1788:	91 e0       	ldi	r25, 0x01	; 1
    178a:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    178e:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1792:	87 30       	cpi	r24, 0x07	; 7
    1794:	09 f0       	breq	.+2      	; 0x1798 <__vector_16+0x52>
    1796:	51 c0       	rjmp	.+162    	; 0x183a <__vector_16+0xf4>
	{
		b_send_can = 1;
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    179e:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    17a2:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    17a6:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    17aa:	89 2b       	or	r24, r25
    17ac:	b1 f0       	breq	.+44     	; 0x17da <__vector_16+0x94>
    17ae:	e2 e1       	ldi	r30, 0x12	; 18
    17b0:	f1 e0       	ldi	r31, 0x01	; 1
    17b2:	97 8d       	ldd	r25, Z+31	; 0x1f
    17b4:	27 8d       	ldd	r18, Z+31	; 0x1f
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	91 30       	cpi	r25, 0x01	; 1
    17ba:	09 f0       	breq	.+2      	; 0x17be <__vector_16+0x78>
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	81 11       	cpse	r24, r1
    17c0:	05 c0       	rjmp	.+10     	; 0x17cc <__vector_16+0x86>
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	21 11       	cpse	r18, r1
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	88 23       	and	r24, r24
    17ca:	39 f0       	breq	.+14     	; 0x17da <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    17cc:	e2 e1       	ldi	r30, 0x12	; 18
    17ce:	f1 e0       	ldi	r31, 0x01	; 1
    17d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    17d2:	93 8d       	ldd	r25, Z+27	; 0x1b
    17d4:	01 97       	sbiw	r24, 0x01	; 1
    17d6:	93 8f       	std	Z+27, r25	; 0x1b
    17d8:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    17da:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    17de:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    17e2:	89 2b       	or	r24, r25
    17e4:	b1 f0       	breq	.+44     	; 0x1812 <__vector_16+0xcc>
    17e6:	e2 e1       	ldi	r30, 0x12	; 18
    17e8:	f1 e0       	ldi	r31, 0x01	; 1
    17ea:	97 8d       	ldd	r25, Z+31	; 0x1f
    17ec:	27 8d       	ldd	r18, Z+31	; 0x1f
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	91 30       	cpi	r25, 0x01	; 1
    17f2:	09 f0       	breq	.+2      	; 0x17f6 <__vector_16+0xb0>
    17f4:	80 e0       	ldi	r24, 0x00	; 0
    17f6:	81 11       	cpse	r24, r1
    17f8:	05 c0       	rjmp	.+10     	; 0x1804 <__vector_16+0xbe>
    17fa:	81 e0       	ldi	r24, 0x01	; 1
    17fc:	21 11       	cpse	r18, r1
    17fe:	80 e0       	ldi	r24, 0x00	; 0
    1800:	88 23       	and	r24, r24
    1802:	39 f0       	breq	.+14     	; 0x1812 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    1804:	e2 e1       	ldi	r30, 0x12	; 18
    1806:	f1 e0       	ldi	r31, 0x01	; 1
    1808:	84 8d       	ldd	r24, Z+28	; 0x1c
    180a:	95 8d       	ldd	r25, Z+29	; 0x1d
    180c:	01 97       	sbiw	r24, 0x01	; 1
    180e:	95 8f       	std	Z+29, r25	; 0x1d
    1810:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    1812:	e2 e1       	ldi	r30, 0x12	; 18
    1814:	f1 e0       	ldi	r31, 0x01	; 1
    1816:	02 85       	ldd	r16, Z+10	; 0x0a
    1818:	13 85       	ldd	r17, Z+11	; 0x0b
    181a:	24 85       	ldd	r18, Z+12	; 0x0c
    181c:	35 85       	ldd	r19, Z+13	; 0x0d
    181e:	46 81       	ldd	r20, Z+6	; 0x06
    1820:	57 81       	ldd	r21, Z+7	; 0x07
    1822:	60 85       	ldd	r22, Z+8	; 0x08
    1824:	71 85       	ldd	r23, Z+9	; 0x09
    1826:	0f 2e       	mov	r0, r31
    1828:	f9 e2       	ldi	r31, 0x29	; 41
    182a:	ef 2e       	mov	r14, r31
    182c:	f0 2d       	mov	r31, r0
    182e:	80 e2       	ldi	r24, 0x20	; 32
    1830:	91 e0       	ldi	r25, 0x01	; 1
    1832:	e6 d1       	rcall	.+972    	; 0x1c00 <handle_joulemeter>
		systic_counter_fast = 0;
    1834:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    1838:	03 c0       	rjmp	.+6      	; 0x1840 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    183a:	8f 5f       	subi	r24, 0xFF	; 255
    183c:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1840:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    1844:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    1848:	84 36       	cpi	r24, 0x64	; 100
    184a:	91 05       	cpc	r25, r1
    184c:	01 f5       	brne	.+64     	; 0x188e <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    184e:	8d b7       	in	r24, 0x3d	; 61
    1850:	9e b7       	in	r25, 0x3e	; 62
    1852:	cd 97       	sbiw	r24, 0x3d	; 61
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	9e bf       	out	0x3e, r25	; 62
    185a:	0f be       	out	0x3f, r0	; 63
    185c:	8d bf       	out	0x3d, r24	; 61
    185e:	ad b7       	in	r26, 0x3d	; 61
    1860:	be b7       	in	r27, 0x3e	; 62
    1862:	11 96       	adiw	r26, 0x01	; 1
    1864:	8d e3       	ldi	r24, 0x3D	; 61
    1866:	e2 e1       	ldi	r30, 0x12	; 18
    1868:	f1 e0       	ldi	r31, 0x01	; 1
    186a:	01 90       	ld	r0, Z+
    186c:	0d 92       	st	X+, r0
    186e:	8a 95       	dec	r24
    1870:	e1 f7       	brne	.-8      	; 0x186a <__vector_16+0x124>
    1872:	04 db       	rcall	.-2552   	; 0xe7c <manage_LEDs>
		systic_counter_slow = 0;
    1874:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1878:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    187c:	8d b7       	in	r24, 0x3d	; 61
    187e:	9e b7       	in	r25, 0x3e	; 62
    1880:	cd 96       	adiw	r24, 0x3d	; 61
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	9e bf       	out	0x3e, r25	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	8d bf       	out	0x3d, r24	; 61
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    188e:	01 96       	adiw	r24, 0x01	; 1
    1890:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    1894:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1898:	ff 91       	pop	r31
    189a:	ef 91       	pop	r30
    189c:	bf 91       	pop	r27
    189e:	af 91       	pop	r26
    18a0:	9f 91       	pop	r25
    18a2:	8f 91       	pop	r24
    18a4:	7f 91       	pop	r23
    18a6:	6f 91       	pop	r22
    18a8:	5f 91       	pop	r21
    18aa:	4f 91       	pop	r20
    18ac:	3f 91       	pop	r19
    18ae:	2f 91       	pop	r18
    18b0:	1f 91       	pop	r17
    18b2:	0f 91       	pop	r16
    18b4:	ef 90       	pop	r14
    18b6:	0f 90       	pop	r0
    18b8:	0b be       	out	0x3b, r0	; 59
    18ba:	0f 90       	pop	r0
    18bc:	0f be       	out	0x3f, r0	; 63
    18be:	0f 90       	pop	r0
    18c0:	1f 90       	pop	r1
    18c2:	18 95       	reti

000018c4 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    18c4:	1f 92       	push	r1
    18c6:	0f 92       	push	r0
    18c8:	0f b6       	in	r0, 0x3f	; 63
    18ca:	0f 92       	push	r0
    18cc:	11 24       	eor	r1, r1
    18ce:	0b b6       	in	r0, 0x3b	; 59
    18d0:	0f 92       	push	r0
    18d2:	2f 93       	push	r18
    18d4:	3f 93       	push	r19
    18d6:	4f 93       	push	r20
    18d8:	5f 93       	push	r21
    18da:	6f 93       	push	r22
    18dc:	7f 93       	push	r23
    18de:	8f 93       	push	r24
    18e0:	9f 93       	push	r25
    18e2:	af 93       	push	r26
    18e4:	bf 93       	push	r27
    18e6:	ef 93       	push	r30
    18e8:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    18ea:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    18ee:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    18f2:	80 3d       	cpi	r24, 0xD0	; 208
    18f4:	97 40       	sbci	r25, 0x07	; 7
    18f6:	50 f4       	brcc	.+20     	; 0x190c <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    18f8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    18fc:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    1900:	01 96       	adiw	r24, 0x01	; 1
    1902:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    1906:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    190a:	08 c0       	rjmp	.+16     	; 0x191c <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    190c:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    1910:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    1914:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    1918:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    191c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1920:	87 30       	cpi	r24, 0x07	; 7
    1922:	41 f4       	brne	.+16     	; 0x1934 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    1924:	84 e1       	ldi	r24, 0x14	; 20
    1926:	91 e0       	ldi	r25, 0x01	; 1
    1928:	0e 94 2e 04 	call	0x85c	; 0x85c <SPI_handler_7>
		u8_SPI_count = 0 ;
    192c:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    1930:	80 e0       	ldi	r24, 0x00	; 0
    1932:	13 c0       	rjmp	.+38     	; 0x195a <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1934:	86 30       	cpi	r24, 0x06	; 6
    1936:	49 f4       	brne	.+18     	; 0x194a <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1938:	8d e3       	ldi	r24, 0x3D	; 61
    193a:	91 e0       	ldi	r25, 0x01	; 1
    193c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <SPI_handler_6>
		u8_SPI_count ++ ;
    1940:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1944:	8f 5f       	subi	r24, 0xFF	; 255
    1946:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    194a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    194e:	85 30       	cpi	r24, 0x05	; 5
    1950:	21 f4       	brne	.+8      	; 0x195a <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1952:	86 e0       	ldi	r24, 0x06	; 6
    1954:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1958:	13 c0       	rjmp	.+38     	; 0x1980 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    195a:	84 30       	cpi	r24, 0x04	; 4
    195c:	49 f4       	brne	.+18     	; 0x1970 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    195e:	84 e2       	ldi	r24, 0x24	; 36
    1960:	91 e0       	ldi	r25, 0x01	; 1
    1962:	0e 94 ba 03 	call	0x774	; 0x774 <SPI_handler_4>
		u8_SPI_count ++ ;
    1966:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    196a:	8f 5f       	subi	r24, 0xFF	; 255
    196c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1970:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1974:	83 30       	cpi	r24, 0x03	; 3
    1976:	21 f4       	brne	.+8      	; 0x1980 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1978:	84 e0       	ldi	r24, 0x04	; 4
    197a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    197e:	13 c0       	rjmp	.+38     	; 0x19a6 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1980:	82 30       	cpi	r24, 0x02	; 2
    1982:	21 f4       	brne	.+8      	; 0x198c <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1984:	83 e0       	ldi	r24, 0x03	; 3
    1986:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    198a:	1a c0       	rjmp	.+52     	; 0x19c0 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    198c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1990:	81 30       	cpi	r24, 0x01	; 1
    1992:	49 f4       	brne	.+18     	; 0x19a6 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1994:	88 e1       	ldi	r24, 0x18	; 24
    1996:	91 e0       	ldi	r25, 0x01	; 1
    1998:	0e 94 98 03 	call	0x730	; 0x730 <SPI_handler_1>
		u8_SPI_count ++ ;
    199c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19a0:	8f 5f       	subi	r24, 0xFF	; 255
    19a2:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    19a6:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19aa:	81 11       	cpse	r24, r1
    19ac:	09 c0       	rjmp	.+18     	; 0x19c0 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    19ae:	8c e1       	ldi	r24, 0x1C	; 28
    19b0:	91 e0       	ldi	r25, 0x01	; 1
    19b2:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <SPI_handler_0>
		u8_SPI_count ++ ;
    19b6:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19ba:	8f 5f       	subi	r24, 0xFF	; 255
    19bc:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    19c0:	ff 91       	pop	r31
    19c2:	ef 91       	pop	r30
    19c4:	bf 91       	pop	r27
    19c6:	af 91       	pop	r26
    19c8:	9f 91       	pop	r25
    19ca:	8f 91       	pop	r24
    19cc:	7f 91       	pop	r23
    19ce:	6f 91       	pop	r22
    19d0:	5f 91       	pop	r21
    19d2:	4f 91       	pop	r20
    19d4:	3f 91       	pop	r19
    19d6:	2f 91       	pop	r18
    19d8:	0f 90       	pop	r0
    19da:	0b be       	out	0x3b, r0	; 59
    19dc:	0f 90       	pop	r0
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	0f 90       	pop	r0
    19e2:	1f 90       	pop	r1
    19e4:	18 95       	reti

000019e6 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    19e6:	1f 92       	push	r1
    19e8:	0f 92       	push	r0
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	0f 92       	push	r0
    19ee:	11 24       	eor	r1, r1
    19f0:	0b b6       	in	r0, 0x3b	; 59
    19f2:	0f 92       	push	r0
    19f4:	2f 93       	push	r18
    19f6:	3f 93       	push	r19
    19f8:	4f 93       	push	r20
    19fa:	5f 93       	push	r21
    19fc:	6f 93       	push	r22
    19fe:	7f 93       	push	r23
    1a00:	8f 93       	push	r24
    1a02:	9f 93       	push	r25
    1a04:	af 93       	push	r26
    1a06:	bf 93       	push	r27
    1a08:	ef 93       	push	r30
    1a0a:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1a0c:	60 e0       	ldi	r22, 0x00	; 0
    1a0e:	72 e0       	ldi	r23, 0x02	; 2
    1a10:	85 e2       	ldi	r24, 0x25	; 37
    1a12:	91 e0       	ldi	r25, 0x01	; 1
    1a14:	97 da       	rcall	.-2770   	; 0xf44 <handle_speed_sensor>
}
    1a16:	ff 91       	pop	r31
    1a18:	ef 91       	pop	r30
    1a1a:	bf 91       	pop	r27
    1a1c:	af 91       	pop	r26
    1a1e:	9f 91       	pop	r25
    1a20:	8f 91       	pop	r24
    1a22:	7f 91       	pop	r23
    1a24:	6f 91       	pop	r22
    1a26:	5f 91       	pop	r21
    1a28:	4f 91       	pop	r20
    1a2a:	3f 91       	pop	r19
    1a2c:	2f 91       	pop	r18
    1a2e:	0f 90       	pop	r0
    1a30:	0b be       	out	0x3b, r0	; 59
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	0f 90       	pop	r0
    1a38:	1f 90       	pop	r1
    1a3a:	18 95       	reti

00001a3c <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1a3c:	08 95       	ret

00001a3e <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1a3e:	7a 99       	sbic	0x0f, 2	; 15
    1a40:	03 c0       	rjmp	.+6      	; 0x1a48 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1a42:	fc 01       	movw	r30, r24
    1a44:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1a46:	10 8e       	std	Z+24, r1	; 0x18
    1a48:	08 95       	ret

00001a4a <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1a4a:	8f 92       	push	r8
    1a4c:	9f 92       	push	r9
    1a4e:	af 92       	push	r10
    1a50:	bf 92       	push	r11
    1a52:	cf 92       	push	r12
    1a54:	df 92       	push	r13
    1a56:	ef 92       	push	r14
    1a58:	ff 92       	push	r15
    1a5a:	0f 93       	push	r16
    1a5c:	1f 93       	push	r17
    1a5e:	cf 93       	push	r28
    1a60:	df 93       	push	r29
    1a62:	00 d0       	rcall	.+0      	; 0x1a64 <handle_current_sensor+0x1a>
    1a64:	00 d0       	rcall	.+0      	; 0x1a66 <handle_current_sensor+0x1c>
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	8c 01       	movw	r16, r24
    1a6c:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	e6 d4       	rcall	.+2508   	; 0x2440 <__floatunsisf>
    1a74:	20 e0       	ldi	r18, 0x00	; 0
    1a76:	30 e0       	ldi	r19, 0x00	; 0
    1a78:	40 ea       	ldi	r20, 0xA0	; 160
    1a7a:	50 e4       	ldi	r21, 0x40	; 64
    1a7c:	97 d5       	rcall	.+2862   	; 0x25ac <__mulsf3>
    1a7e:	20 e0       	ldi	r18, 0x00	; 0
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	40 e8       	ldi	r20, 0x80	; 128
    1a84:	59 e3       	ldi	r21, 0x39	; 57
    1a86:	92 d5       	rcall	.+2852   	; 0x25ac <__mulsf3>
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	40 e0       	ldi	r20, 0x00	; 0
    1a8e:	51 e4       	ldi	r21, 0x41	; 65
    1a90:	8d d5       	rcall	.+2842   	; 0x25ac <__mulsf3>
    1a92:	20 e0       	ldi	r18, 0x00	; 0
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	40 ea       	ldi	r20, 0xA0	; 160
    1a98:	51 e4       	ldi	r21, 0x41	; 65
    1a9a:	d0 d3       	rcall	.+1952   	; 0x223c <__subsf3>
    1a9c:	69 83       	std	Y+1, r22	; 0x01
    1a9e:	7a 83       	std	Y+2, r23	; 0x02
    1aa0:	8b 83       	std	Y+3, r24	; 0x03
    1aa2:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1aa4:	ff 20       	and	r15, r15
    1aa6:	49 f0       	breq	.+18     	; 0x1aba <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	ab 81       	ldd	r26, Y+3	; 0x03
    1aae:	bc 81       	ldd	r27, Y+4	; 0x04
    1ab0:	89 83       	std	Y+1, r24	; 0x01
    1ab2:	9a 83       	std	Y+2, r25	; 0x02
    1ab4:	ab 83       	std	Y+3, r26	; 0x03
    1ab6:	bc 83       	std	Y+4, r27	; 0x04
    1ab8:	08 c0       	rjmp	.+16     	; 0x1aca <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    1abc:	9a 81       	ldd	r25, Y+2	; 0x02
    1abe:	ab 81       	ldd	r26, Y+3	; 0x03
    1ac0:	bc 81       	ldd	r27, Y+4	; 0x04
    1ac2:	89 83       	std	Y+1, r24	; 0x01
    1ac4:	9a 83       	std	Y+2, r25	; 0x02
    1ac6:	ab 83       	std	Y+3, r26	; 0x03
    1ac8:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1aca:	f8 01       	movw	r30, r16
    1acc:	60 81       	ld	r22, Z
    1ace:	71 81       	ldd	r23, Z+1	; 0x01
    1ad0:	82 81       	ldd	r24, Z+2	; 0x02
    1ad2:	93 81       	ldd	r25, Z+3	; 0x03
    1ad4:	89 80       	ldd	r8, Y+1	; 0x01
    1ad6:	9a 80       	ldd	r9, Y+2	; 0x02
    1ad8:	ab 80       	ldd	r10, Y+3	; 0x03
    1ada:	bc 80       	ldd	r11, Y+4	; 0x04
    1adc:	26 e6       	ldi	r18, 0x66	; 102
    1ade:	36 e6       	ldi	r19, 0x66	; 102
    1ae0:	46 e6       	ldi	r20, 0x66	; 102
    1ae2:	5f e3       	ldi	r21, 0x3F	; 63
    1ae4:	63 d5       	rcall	.+2758   	; 0x25ac <__mulsf3>
    1ae6:	6b 01       	movw	r12, r22
    1ae8:	7c 01       	movw	r14, r24
    1aea:	2d ec       	ldi	r18, 0xCD	; 205
    1aec:	3c ec       	ldi	r19, 0xCC	; 204
    1aee:	4c ec       	ldi	r20, 0xCC	; 204
    1af0:	5d e3       	ldi	r21, 0x3D	; 61
    1af2:	c5 01       	movw	r24, r10
    1af4:	b4 01       	movw	r22, r8
    1af6:	5a d5       	rcall	.+2740   	; 0x25ac <__mulsf3>
    1af8:	9b 01       	movw	r18, r22
    1afa:	ac 01       	movw	r20, r24
    1afc:	c7 01       	movw	r24, r14
    1afe:	b6 01       	movw	r22, r12
    1b00:	9e d3       	rcall	.+1852   	; 0x223e <__addsf3>
    1b02:	f8 01       	movw	r30, r16
    1b04:	60 83       	st	Z, r22
    1b06:	71 83       	std	Z+1, r23	; 0x01
    1b08:	82 83       	std	Z+2, r24	; 0x02
    1b0a:	93 83       	std	Z+3, r25	; 0x03
}
    1b0c:	0f 90       	pop	r0
    1b0e:	0f 90       	pop	r0
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	ef 90       	pop	r14
    1b20:	df 90       	pop	r13
    1b22:	cf 90       	pop	r12
    1b24:	bf 90       	pop	r11
    1b26:	af 90       	pop	r10
    1b28:	9f 90       	pop	r9
    1b2a:	8f 90       	pop	r8
    1b2c:	08 95       	ret

00001b2e <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1b2e:	cf 92       	push	r12
    1b30:	df 92       	push	r13
    1b32:	ef 92       	push	r14
    1b34:	ff 92       	push	r15
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1b3c:	80 e0       	ldi	r24, 0x00	; 0
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	7f d4       	rcall	.+2302   	; 0x2440 <__floatunsisf>
    1b42:	20 e0       	ldi	r18, 0x00	; 0
    1b44:	30 e0       	ldi	r19, 0x00	; 0
    1b46:	40 ea       	ldi	r20, 0xA0	; 160
    1b48:	50 e4       	ldi	r21, 0x40	; 64
    1b4a:	30 d5       	rcall	.+2656   	; 0x25ac <__mulsf3>
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	40 e8       	ldi	r20, 0x80	; 128
    1b52:	59 e3       	ldi	r21, 0x39	; 57
    1b54:	2b d5       	rcall	.+2646   	; 0x25ac <__mulsf3>
    1b56:	6b 01       	movw	r12, r22
    1b58:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1b5a:	2d ec       	ldi	r18, 0xCD	; 205
    1b5c:	3c ec       	ldi	r19, 0xCC	; 204
    1b5e:	4c e6       	ldi	r20, 0x6C	; 108
    1b60:	50 e4       	ldi	r21, 0x40	; 64
    1b62:	d1 d3       	rcall	.+1954   	; 0x2306 <__cmpsf2>
    1b64:	18 16       	cp	r1, r24
    1b66:	74 f0       	brlt	.+28     	; 0x1b84 <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1b68:	20 e0       	ldi	r18, 0x00	; 0
    1b6a:	30 e0       	ldi	r19, 0x00	; 0
    1b6c:	40 ea       	ldi	r20, 0xA0	; 160
    1b6e:	51 e4       	ldi	r21, 0x41	; 65
    1b70:	c7 01       	movw	r24, r14
    1b72:	b6 01       	movw	r22, r12
    1b74:	1b d5       	rcall	.+2614   	; 0x25ac <__mulsf3>
    1b76:	20 e0       	ldi	r18, 0x00	; 0
    1b78:	30 e0       	ldi	r19, 0x00	; 0
    1b7a:	40 eb       	ldi	r20, 0xB0	; 176
    1b7c:	51 e4       	ldi	r21, 0x41	; 65
    1b7e:	5e d3       	rcall	.+1724   	; 0x223c <__subsf3>
    1b80:	33 d4       	rcall	.+2150   	; 0x23e8 <__fixunssfsi>
    1b82:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1b84:	26 e6       	ldi	r18, 0x66	; 102
    1b86:	36 e6       	ldi	r19, 0x66	; 102
    1b88:	46 e9       	ldi	r20, 0x96	; 150
    1b8a:	50 e4       	ldi	r21, 0x40	; 64
    1b8c:	c7 01       	movw	r24, r14
    1b8e:	b6 01       	movw	r22, r12
    1b90:	ba d3       	rcall	.+1908   	; 0x2306 <__cmpsf2>
    1b92:	18 16       	cp	r1, r24
    1b94:	bc f0       	brlt	.+46     	; 0x1bc4 <handle_temp_sensor+0x96>
    1b96:	2d ec       	ldi	r18, 0xCD	; 205
    1b98:	3c ec       	ldi	r19, 0xCC	; 204
    1b9a:	4c e6       	ldi	r20, 0x6C	; 108
    1b9c:	50 e4       	ldi	r21, 0x40	; 64
    1b9e:	c7 01       	movw	r24, r14
    1ba0:	b6 01       	movw	r22, r12
    1ba2:	00 d5       	rcall	.+2560   	; 0x25a4 <__gesf2>
    1ba4:	18 16       	cp	r1, r24
    1ba6:	74 f4       	brge	.+28     	; 0x1bc4 <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	30 e0       	ldi	r19, 0x00	; 0
    1bac:	4e e5       	ldi	r20, 0x5E	; 94
    1bae:	52 e4       	ldi	r21, 0x42	; 66
    1bb0:	c7 01       	movw	r24, r14
    1bb2:	b6 01       	movw	r22, r12
    1bb4:	fb d4       	rcall	.+2550   	; 0x25ac <__mulsf3>
    1bb6:	20 e0       	ldi	r18, 0x00	; 0
    1bb8:	30 e8       	ldi	r19, 0x80	; 128
    1bba:	4b e1       	ldi	r20, 0x1B	; 27
    1bbc:	53 e4       	ldi	r21, 0x43	; 67
    1bbe:	3e d3       	rcall	.+1660   	; 0x223c <__subsf3>
    1bc0:	13 d4       	rcall	.+2086   	; 0x23e8 <__fixunssfsi>
    1bc2:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1bc4:	26 e6       	ldi	r18, 0x66	; 102
    1bc6:	36 e6       	ldi	r19, 0x66	; 102
    1bc8:	46 e9       	ldi	r20, 0x96	; 150
    1bca:	50 e4       	ldi	r21, 0x40	; 64
    1bcc:	c7 01       	movw	r24, r14
    1bce:	b6 01       	movw	r22, r12
    1bd0:	e9 d4       	rcall	.+2514   	; 0x25a4 <__gesf2>
    1bd2:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1bd4:	74 f4       	brge	.+28     	; 0x1bf2 <handle_temp_sensor+0xc4>
    1bd6:	20 e0       	ldi	r18, 0x00	; 0
    1bd8:	30 e0       	ldi	r19, 0x00	; 0
    1bda:	48 e4       	ldi	r20, 0x48	; 72
    1bdc:	53 e4       	ldi	r21, 0x43	; 67
    1bde:	c7 01       	movw	r24, r14
    1be0:	b6 01       	movw	r22, r12
    1be2:	e4 d4       	rcall	.+2504   	; 0x25ac <__mulsf3>
    1be4:	20 e0       	ldi	r18, 0x00	; 0
    1be6:	30 e0       	ldi	r19, 0x00	; 0
    1be8:	42 e5       	ldi	r20, 0x52	; 82
    1bea:	54 e4       	ldi	r21, 0x44	; 68
    1bec:	27 d3       	rcall	.+1614   	; 0x223c <__subsf3>
    1bee:	fc d3       	rcall	.+2040   	; 0x23e8 <__fixunssfsi>
    1bf0:	68 83       	st	Y, r22
    1bf2:	df 91       	pop	r29
    1bf4:	cf 91       	pop	r28
	}
}
    1bf6:	ff 90       	pop	r15
    1bf8:	ef 90       	pop	r14
    1bfa:	df 90       	pop	r13
    1bfc:	cf 90       	pop	r12
    1bfe:	08 95       	ret

00001c00 <handle_joulemeter>:
    1c00:	4f 92       	push	r4
    1c02:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1c04:	6f 92       	push	r6
    1c06:	7f 92       	push	r7
    1c08:	8f 92       	push	r8
    1c0a:	9f 92       	push	r9
    1c0c:	af 92       	push	r10
    1c0e:	bf 92       	push	r11
    1c10:	cf 92       	push	r12
    1c12:	df 92       	push	r13
    1c14:	ef 92       	push	r14
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	cd b7       	in	r28, 0x3d	; 61
    1c20:	de b7       	in	r29, 0x3e	; 62
    1c22:	28 97       	sbiw	r28, 0x08	; 8
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	de bf       	out	0x3e, r29	; 62
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	cd bf       	out	0x3d, r28	; 61
    1c2e:	6c 01       	movw	r12, r24
    1c30:	49 83       	std	Y+1, r20	; 0x01
    1c32:	5a 83       	std	Y+2, r21	; 0x02
    1c34:	6b 83       	std	Y+3, r22	; 0x03
    1c36:	7c 83       	std	Y+4, r23	; 0x04
    1c38:	0d 83       	std	Y+5, r16	; 0x05
    1c3a:	1e 83       	std	Y+6, r17	; 0x06
    1c3c:	2f 83       	std	Y+7, r18	; 0x07
    1c3e:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1c40:	6d 81       	ldd	r22, Y+5	; 0x05
    1c42:	7e 81       	ldd	r23, Y+6	; 0x06
    1c44:	8f 81       	ldd	r24, Y+7	; 0x07
    1c46:	98 85       	ldd	r25, Y+8	; 0x08
    1c48:	29 81       	ldd	r18, Y+1	; 0x01
    1c4a:	3a 81       	ldd	r19, Y+2	; 0x02
    1c4c:	4b 81       	ldd	r20, Y+3	; 0x03
    1c4e:	5c 81       	ldd	r21, Y+4	; 0x04
    1c50:	f6 01       	movw	r30, r12
    1c52:	80 80       	ld	r8, Z
    1c54:	91 80       	ldd	r9, Z+1	; 0x01
    1c56:	a2 80       	ldd	r10, Z+2	; 0x02
    1c58:	b3 80       	ldd	r11, Z+3	; 0x03
    1c5a:	a8 d4       	rcall	.+2384   	; 0x25ac <__mulsf3>
    1c5c:	2b 01       	movw	r4, r22
    1c5e:	3c 01       	movw	r6, r24
    1c60:	6e 2d       	mov	r22, r14
    1c62:	70 e0       	ldi	r23, 0x00	; 0
    1c64:	80 e0       	ldi	r24, 0x00	; 0
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	eb d3       	rcall	.+2006   	; 0x2440 <__floatunsisf>
    1c6a:	9b 01       	movw	r18, r22
    1c6c:	ac 01       	movw	r20, r24
    1c6e:	c3 01       	movw	r24, r6
    1c70:	b2 01       	movw	r22, r4
    1c72:	9c d4       	rcall	.+2360   	; 0x25ac <__mulsf3>
    1c74:	20 e0       	ldi	r18, 0x00	; 0
    1c76:	30 e0       	ldi	r19, 0x00	; 0
    1c78:	4a e7       	ldi	r20, 0x7A	; 122
    1c7a:	54 e4       	ldi	r21, 0x44	; 68
    1c7c:	48 d3       	rcall	.+1680   	; 0x230e <__divsf3>
    1c7e:	a5 01       	movw	r20, r10
    1c80:	94 01       	movw	r18, r8
    1c82:	dd d2       	rcall	.+1466   	; 0x223e <__addsf3>
    1c84:	f6 01       	movw	r30, r12
    1c86:	60 83       	st	Z, r22
    1c88:	71 83       	std	Z+1, r23	; 0x01
    1c8a:	82 83       	std	Z+2, r24	; 0x02
    1c8c:	93 83       	std	Z+3, r25	; 0x03
}
    1c8e:	28 96       	adiw	r28, 0x08	; 8
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	de bf       	out	0x3e, r29	; 62
    1c96:	0f be       	out	0x3f, r0	; 63
    1c98:	cd bf       	out	0x3d, r28	; 61
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	1f 91       	pop	r17
    1ca0:	0f 91       	pop	r16
    1ca2:	ef 90       	pop	r14
    1ca4:	df 90       	pop	r13
    1ca6:	cf 90       	pop	r12
    1ca8:	bf 90       	pop	r11
    1caa:	af 90       	pop	r10
    1cac:	9f 90       	pop	r9
    1cae:	8f 90       	pop	r8
    1cb0:	7f 90       	pop	r7
    1cb2:	6f 90       	pop	r6
    1cb4:	5f 90       	pop	r5
    1cb6:	4f 90       	pop	r4
    1cb8:	08 95       	ret

00001cba <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	88 30       	cpi	r24, 0x08	; 8
    1cbe:	91 05       	cpc	r25, r1
    1cc0:	88 f5       	brcc	.+98     	; 0x1d24 <Set_ADC_Channel_ext+0x6a>
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	e6 5b       	subi	r30, 0xB6	; 182
    1cc6:	ff 4f       	sbci	r31, 0xFF	; 255
    1cc8:	d4 c4       	rjmp	.+2472   	; 0x2672 <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1cca:	86 e0       	ldi	r24, 0x06	; 6
    1ccc:	fb 01       	movw	r30, r22
    1cce:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1cd0:	11 82       	std	Z+1, r1	; 0x01
		break;
    1cd2:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1cd4:	86 e0       	ldi	r24, 0x06	; 6
    1cd6:	fb 01       	movw	r30, r22
    1cd8:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1cda:	80 e4       	ldi	r24, 0x40	; 64
    1cdc:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cde:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1ce0:	86 e0       	ldi	r24, 0x06	; 6
    1ce2:	fb 01       	movw	r30, r22
    1ce4:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1ce6:	80 e8       	ldi	r24, 0x80	; 128
    1ce8:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cea:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1cec:	86 e0       	ldi	r24, 0x06	; 6
    1cee:	fb 01       	movw	r30, r22
    1cf0:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1cf2:	80 ec       	ldi	r24, 0xC0	; 192
    1cf4:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cf6:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1cf8:	87 e0       	ldi	r24, 0x07	; 7
    1cfa:	fb 01       	movw	r30, r22
    1cfc:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1cfe:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d00:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d02:	87 e0       	ldi	r24, 0x07	; 7
    1d04:	fb 01       	movw	r30, r22
    1d06:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1d08:	80 e4       	ldi	r24, 0x40	; 64
    1d0a:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d0c:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d0e:	87 e0       	ldi	r24, 0x07	; 7
    1d10:	fb 01       	movw	r30, r22
    1d12:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1d14:	80 e8       	ldi	r24, 0x80	; 128
    1d16:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d18:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d1a:	87 e0       	ldi	r24, 0x07	; 7
    1d1c:	fb 01       	movw	r30, r22
    1d1e:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1d20:	80 ec       	ldi	r24, 0xC0	; 192
    1d22:	81 83       	std	Z+1, r24	; 0x01
    1d24:	08 95       	ret

00001d26 <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1d26:	1f 92       	push	r1
    1d28:	0f 92       	push	r0
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	0f 92       	push	r0
    1d2e:	11 24       	eor	r1, r1
    1d30:	0b b6       	in	r0, 0x3b	; 59
    1d32:	0f 92       	push	r0
    1d34:	2f 93       	push	r18
    1d36:	3f 93       	push	r19
    1d38:	4f 93       	push	r20
    1d3a:	5f 93       	push	r21
    1d3c:	6f 93       	push	r22
    1d3e:	8f 93       	push	r24
    1d40:	9f 93       	push	r25
    1d42:	af 93       	push	r26
    1d44:	bf 93       	push	r27
    1d46:	ef 93       	push	r30
    1d48:	ff 93       	push	r31
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	1f 92       	push	r1
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1d54:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1d58:	80 ff       	sbrs	r24, 0
    1d5a:	47 c0       	rjmp	.+142    	; 0x1dea <__vector_18+0xc4>
    1d5c:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1d60:	90 ff       	sbrs	r25, 0
    1d62:	43 c0       	rjmp	.+134    	; 0x1dea <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1d64:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1d68:	ee ee       	ldi	r30, 0xEE	; 238
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	80 81       	ld	r24, Z
    1d6e:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1d70:	80 81       	ld	r24, Z
    1d72:	8f 7b       	andi	r24, 0xBF	; 191
    1d74:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1d76:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1d7a:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1d7e:	98 17       	cp	r25, r24
    1d80:	89 f1       	breq	.+98     	; 0x1de4 <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1d82:	8f 70       	andi	r24, 0x0F	; 15
    1d84:	2b e0       	ldi	r18, 0x0B	; 11
    1d86:	82 9f       	mul	r24, r18
    1d88:	c0 01       	movw	r24, r0
    1d8a:	11 24       	eor	r1, r1
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	e1 54       	subi	r30, 0x41	; 65
    1d90:	fd 4f       	sbci	r31, 0xFD	; 253
    1d92:	20 81       	ld	r18, Z
    1d94:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1d98:	20 81       	ld	r18, Z
    1d9a:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1d9e:	21 81       	ldd	r18, Z+1	; 0x01
    1da0:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1da4:	23 81       	ldd	r18, Z+3	; 0x03
    1da6:	aa ef       	ldi	r26, 0xFA	; 250
    1da8:	b0 e0       	ldi	r27, 0x00	; 0
    1daa:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1dac:	24 81       	ldd	r18, Z+4	; 0x04
    1dae:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1db0:	25 81       	ldd	r18, Z+5	; 0x05
    1db2:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1db4:	26 81       	ldd	r18, Z+6	; 0x06
    1db6:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1db8:	27 81       	ldd	r18, Z+7	; 0x07
    1dba:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1dbc:	20 85       	ldd	r18, Z+8	; 0x08
    1dbe:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1dc0:	21 85       	ldd	r18, Z+9	; 0x09
    1dc2:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1dc4:	22 85       	ldd	r18, Z+10	; 0x0a
    1dc6:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1dc8:	fc 01       	movw	r30, r24
    1dca:	ef 53       	subi	r30, 0x3F	; 63
    1dcc:	fd 4f       	sbci	r31, 0xFD	; 253
    1dce:	80 81       	ld	r24, Z
    1dd0:	8f 70       	andi	r24, 0x0F	; 15
    1dd2:	80 64       	ori	r24, 0x40	; 64
    1dd4:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1dd8:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1ddc:	8f 5f       	subi	r24, 0xFF	; 255
    1dde:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1de2:	7d c0       	rjmp	.+250    	; 0x1ede <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1de4:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1de8:	7a c0       	rjmp	.+244    	; 0x1ede <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1dea:	81 ff       	sbrs	r24, 1
    1dec:	78 c0       	rjmp	.+240    	; 0x1ede <__vector_18+0x1b8>
    1dee:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1df2:	81 ff       	sbrs	r24, 1
    1df4:	74 c0       	rjmp	.+232    	; 0x1ede <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1df6:	80 e1       	ldi	r24, 0x10	; 16
    1df8:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1dfc:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1e00:	28 2f       	mov	r18, r24
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1e08:	29 1b       	sub	r18, r25
    1e0a:	31 09       	sbc	r19, r1
    1e0c:	2f 77       	andi	r18, 0x7F	; 127
    1e0e:	33 27       	eor	r19, r19
    1e10:	20 31       	cpi	r18, 0x10	; 16
    1e12:	31 05       	cpc	r19, r1
    1e14:	0c f0       	brlt	.+2      	; 0x1e18 <__vector_18+0xf2>
    1e16:	58 c0       	rjmp	.+176    	; 0x1ec8 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1e18:	e8 2f       	mov	r30, r24
    1e1a:	ef 70       	andi	r30, 0x0F	; 15
    1e1c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1e20:	2e 2f       	mov	r18, r30
    1e22:	30 e0       	ldi	r19, 0x00	; 0
    1e24:	4b e0       	ldi	r20, 0x0B	; 11
    1e26:	e4 9f       	mul	r30, r20
    1e28:	f0 01       	movw	r30, r0
    1e2a:	11 24       	eor	r1, r1
    1e2c:	e1 5f       	subi	r30, 0xF1	; 241
    1e2e:	fd 4f       	sbci	r31, 0xFD	; 253
    1e30:	9f 70       	andi	r25, 0x0F	; 15
    1e32:	42 81       	ldd	r20, Z+2	; 0x02
    1e34:	40 7f       	andi	r20, 0xF0	; 240
    1e36:	94 2b       	or	r25, r20
    1e38:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1e3a:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1e3e:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1e42:	40 7e       	andi	r20, 0xE0	; 224
    1e44:	97 70       	andi	r25, 0x07	; 7
    1e46:	94 2b       	or	r25, r20
    1e48:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1e4a:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1e4e:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1e50:	aa ef       	ldi	r26, 0xFA	; 250
    1e52:	b0 e0       	ldi	r27, 0x00	; 0
    1e54:	9c 91       	ld	r25, X
    1e56:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1e58:	9c 91       	ld	r25, X
    1e5a:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1e5c:	9c 91       	ld	r25, X
    1e5e:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1e60:	9c 91       	ld	r25, X
    1e62:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1e64:	9c 91       	ld	r25, X
    1e66:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1e68:	9c 91       	ld	r25, X
    1e6a:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1e6c:	9c 91       	ld	r25, X
    1e6e:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1e70:	9c 91       	ld	r25, X
    1e72:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1e74:	8f 5f       	subi	r24, 0xFF	; 255
    1e76:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1e7a:	40 81       	ld	r20, Z
    1e7c:	42 95       	swap	r20
    1e7e:	46 95       	lsr	r20
    1e80:	47 70       	andi	r20, 0x07	; 7
    1e82:	51 81       	ldd	r21, Z+1	; 0x01
    1e84:	65 2f       	mov	r22, r21
    1e86:	66 0f       	add	r22, r22
    1e88:	66 0f       	add	r22, r22
    1e8a:	66 0f       	add	r22, r22
    1e8c:	86 2f       	mov	r24, r22
    1e8e:	84 2b       	or	r24, r20
    1e90:	95 2f       	mov	r25, r21
    1e92:	92 95       	swap	r25
    1e94:	96 95       	lsr	r25
    1e96:	97 70       	andi	r25, 0x07	; 7
    1e98:	89 2b       	or	r24, r25
    1e9a:	b1 f4       	brne	.+44     	; 0x1ec8 <__vector_18+0x1a2>
    1e9c:	8b e0       	ldi	r24, 0x0B	; 11
    1e9e:	82 9f       	mul	r24, r18
    1ea0:	f0 01       	movw	r30, r0
    1ea2:	83 9f       	mul	r24, r19
    1ea4:	f0 0d       	add	r31, r0
    1ea6:	11 24       	eor	r1, r1
    1ea8:	e1 5f       	subi	r30, 0xF1	; 241
    1eaa:	fd 4f       	sbci	r31, 0xFD	; 253
    1eac:	83 81       	ldd	r24, Z+3	; 0x03
    1eae:	83 30       	cpi	r24, 0x03	; 3
    1eb0:	59 f4       	brne	.+22     	; 0x1ec8 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1eb2:	98 e0       	ldi	r25, 0x08	; 8
    1eb4:	88 e1       	ldi	r24, 0x18	; 24
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	a8 95       	wdr
    1ebc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1ec0:	0f be       	out	0x3f, r0	; 63
    1ec2:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1ec6:	ff cf       	rjmp	.-2      	; 0x1ec6 <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1ec8:	ee ee       	ldi	r30, 0xEE	; 238
    1eca:	f0 e0       	ldi	r31, 0x00	; 0
    1ecc:	80 81       	ld	r24, Z
    1ece:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1ed0:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1ed2:	80 81       	ld	r24, Z
    1ed4:	8f 7d       	andi	r24, 0xDF	; 223
    1ed6:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1ed8:	80 e8       	ldi	r24, 0x80	; 128
    1eda:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1ede:	0f 90       	pop	r0
    1ee0:	df 91       	pop	r29
    1ee2:	cf 91       	pop	r28
    1ee4:	ff 91       	pop	r31
    1ee6:	ef 91       	pop	r30
    1ee8:	bf 91       	pop	r27
    1eea:	af 91       	pop	r26
    1eec:	9f 91       	pop	r25
    1eee:	8f 91       	pop	r24
    1ef0:	6f 91       	pop	r22
    1ef2:	5f 91       	pop	r21
    1ef4:	4f 91       	pop	r20
    1ef6:	3f 91       	pop	r19
    1ef8:	2f 91       	pop	r18
    1efa:	0f 90       	pop	r0
    1efc:	0b be       	out	0x3b, r0	; 59
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	0f 90       	pop	r0
    1f04:	1f 90       	pop	r1
    1f06:	18 95       	reti

00001f08 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1f0c:	e8 ed       	ldi	r30, 0xD8	; 216
    1f0e:	f0 e0       	ldi	r31, 0x00	; 0
    1f10:	21 e0       	ldi	r18, 0x01	; 1
    1f12:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1f14:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1f18:	2c e0       	ldi	r18, 0x0C	; 12
    1f1a:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1f1e:	27 e3       	ldi	r18, 0x37	; 55
    1f20:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1f24:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1f28:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1f2c:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1f30:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1f34:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1f38:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    1f3c:	cd ee       	ldi	r28, 0xED	; 237
    1f3e:	d0 e0       	ldi	r29, 0x00	; 0
    1f40:	18 82       	st	Y, r1
	CANSTMOB = 0;
    1f42:	ae ee       	ldi	r26, 0xEE	; 238
    1f44:	b0 e0       	ldi	r27, 0x00	; 0
    1f46:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    1f48:	20 e1       	ldi	r18, 0x10	; 16
    1f4a:	28 83       	st	Y, r18
	CANSTMOB = 0;
    1f4c:	1c 92       	st	X, r1
	CANIDM4 = 0;
    1f4e:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    1f52:	28 2f       	mov	r18, r24
    1f54:	22 95       	swap	r18
    1f56:	22 0f       	add	r18, r18
    1f58:	20 7e       	andi	r18, 0xE0	; 224
    1f5a:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    1f5e:	96 95       	lsr	r25
    1f60:	87 95       	ror	r24
    1f62:	96 95       	lsr	r25
    1f64:	87 95       	ror	r24
    1f66:	96 95       	lsr	r25
    1f68:	87 95       	ror	r24
    1f6a:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    1f6e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    1f72:	86 2f       	mov	r24, r22
    1f74:	82 95       	swap	r24
    1f76:	88 0f       	add	r24, r24
    1f78:	80 7e       	andi	r24, 0xE0	; 224
    1f7a:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    1f7e:	76 95       	lsr	r23
    1f80:	67 95       	ror	r22
    1f82:	76 95       	lsr	r23
    1f84:	67 95       	ror	r22
    1f86:	76 95       	lsr	r23
    1f88:	67 95       	ror	r22
    1f8a:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    1f8e:	80 e8       	ldi	r24, 0x80	; 128
    1f90:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    1f94:	83 e0       	ldi	r24, 0x03	; 3
    1f96:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    1f9a:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    1f9e:	80 eb       	ldi	r24, 0xB0	; 176
    1fa0:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    1fa4:	82 e0       	ldi	r24, 0x02	; 2
    1fa6:	80 83       	st	Z, r24

	reset = 0;
    1fa8:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	08 95       	ret

00001fb2 <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    1fb2:	cf 93       	push	r28
    1fb4:	df 93       	push	r29
    1fb6:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    1fb8:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    1fbc:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    1fc0:	24 17       	cp	r18, r20
    1fc2:	89 f1       	breq	.+98     	; 0x2026 <can_read_message_if_new+0x74>
    1fc4:	a4 2f       	mov	r26, r20
    1fc6:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    1fc8:	8b e0       	ldi	r24, 0x0B	; 11
    1fca:	a8 9f       	mul	r26, r24
    1fcc:	b0 01       	movw	r22, r0
    1fce:	11 24       	eor	r1, r1
    1fd0:	fb 01       	movw	r30, r22
    1fd2:	e1 5f       	subi	r30, 0xF1	; 241
    1fd4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fd6:	20 81       	ld	r18, Z
    1fd8:	22 95       	swap	r18
    1fda:	26 95       	lsr	r18
    1fdc:	27 70       	andi	r18, 0x07	; 7
    1fde:	31 81       	ldd	r19, Z+1	; 0x01
    1fe0:	53 2f       	mov	r21, r19
    1fe2:	55 0f       	add	r21, r21
    1fe4:	55 0f       	add	r21, r21
    1fe6:	55 0f       	add	r21, r21
    1fe8:	25 2b       	or	r18, r21
    1fea:	32 95       	swap	r19
    1fec:	36 95       	lsr	r19
    1fee:	37 70       	andi	r19, 0x07	; 7
    1ff0:	28 83       	st	Y, r18
    1ff2:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    1ff4:	fb 01       	movw	r30, r22
    1ff6:	ef 5e       	subi	r30, 0xEF	; 239
    1ff8:	fd 4f       	sbci	r31, 0xFD	; 253
    1ffa:	20 81       	ld	r18, Z
    1ffc:	2f 70       	andi	r18, 0x0F	; 15
    1ffe:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    2000:	22 23       	and	r18, r18
    2002:	99 f0       	breq	.+38     	; 0x202a <can_read_message_if_new+0x78>
    2004:	db 01       	movw	r26, r22
    2006:	ae 5e       	subi	r26, 0xEE	; 238
    2008:	bd 4f       	sbci	r27, 0xFD	; 253
    200a:	fe 01       	movw	r30, r28
    200c:	33 96       	adiw	r30, 0x03	; 3
    200e:	30 e0       	ldi	r19, 0x00	; 0
    2010:	2d 5f       	subi	r18, 0xFD	; 253
    2012:	3f 4f       	sbci	r19, 0xFF	; 255
    2014:	ce 01       	movw	r24, r28
    2016:	82 0f       	add	r24, r18
    2018:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    201a:	2d 91       	ld	r18, X+
    201c:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    201e:	e8 17       	cp	r30, r24
    2020:	f9 07       	cpc	r31, r25
    2022:	d9 f7       	brne	.-10     	; 0x201a <can_read_message_if_new+0x68>
    2024:	02 c0       	rjmp	.+4      	; 0x202a <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    2026:	80 e0       	ldi	r24, 0x00	; 0
    2028:	04 c0       	rjmp	.+8      	; 0x2032 <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    202a:	4f 5f       	subi	r20, 0xFF	; 255
    202c:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    2030:	81 e0       	ldi	r24, 0x01	; 1
}
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	08 95       	ret

00002038 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    2038:	cf 93       	push	r28
    203a:	df 93       	push	r29
    203c:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    203e:	ab ed       	ldi	r26, 0xDB	; 219
    2040:	b0 e0       	ldi	r27, 0x00	; 0
    2042:	8c 91       	ld	r24, X
    2044:	8f 77       	andi	r24, 0x7F	; 127
    2046:	8c 93       	st	X, r24

	if (!tx_busy) {
    2048:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    204c:	81 11       	cpse	r24, r1
    204e:	27 c0       	rjmp	.+78     	; 0x209e <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2050:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    2054:	80 81       	ld	r24, Z
    2056:	82 95       	swap	r24
    2058:	88 0f       	add	r24, r24
    205a:	80 7e       	andi	r24, 0xE0	; 224
    205c:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2060:	80 81       	ld	r24, Z
    2062:	91 81       	ldd	r25, Z+1	; 0x01
    2064:	96 95       	lsr	r25
    2066:	87 95       	ror	r24
    2068:	96 95       	lsr	r25
    206a:	87 95       	ror	r24
    206c:	96 95       	lsr	r25
    206e:	87 95       	ror	r24
    2070:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2074:	df 01       	movw	r26, r30
    2076:	13 96       	adiw	r26, 0x03	; 3
    2078:	9f 01       	movw	r18, r30
    207a:	25 5f       	subi	r18, 0xF5	; 245
    207c:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    207e:	ca ef       	ldi	r28, 0xFA	; 250
    2080:	d0 e0       	ldi	r29, 0x00	; 0
    2082:	9d 91       	ld	r25, X+
    2084:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    2086:	a2 17       	cp	r26, r18
    2088:	b3 07       	cpc	r27, r19
    208a:	d9 f7       	brne	.-10     	; 0x2082 <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    2092:	82 81       	ldd	r24, Z+2	; 0x02
    2094:	80 64       	ori	r24, 0x40	; 64
    2096:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    209a:	81 e0       	ldi	r24, 0x01	; 1
    209c:	43 c0       	rjmp	.+134    	; 0x2124 <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    209e:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    20a2:	82 2f       	mov	r24, r18
    20a4:	90 e0       	ldi	r25, 0x00	; 0
    20a6:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    20aa:	83 1b       	sub	r24, r19
    20ac:	91 09       	sbc	r25, r1
    20ae:	8f 77       	andi	r24, 0x7F	; 127
    20b0:	99 27       	eor	r25, r25
    20b2:	40 97       	sbiw	r24, 0x10	; 16
    20b4:	b1 f1       	breq	.+108    	; 0x2122 <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    20b6:	a2 2f       	mov	r26, r18
    20b8:	af 70       	andi	r26, 0x0F	; 15
    20ba:	8b e0       	ldi	r24, 0x0B	; 11
    20bc:	a8 9f       	mul	r26, r24
    20be:	d0 01       	movw	r26, r0
    20c0:	11 24       	eor	r1, r1
    20c2:	ed 01       	movw	r28, r26
    20c4:	c1 54       	subi	r28, 0x41	; 65
    20c6:	dd 4f       	sbci	r29, 0xFD	; 253
    20c8:	80 81       	ld	r24, Z
    20ca:	98 2f       	mov	r25, r24
    20cc:	92 95       	swap	r25
    20ce:	99 0f       	add	r25, r25
    20d0:	90 7e       	andi	r25, 0xE0	; 224
    20d2:	88 81       	ld	r24, Y
    20d4:	8f 71       	andi	r24, 0x1F	; 31
    20d6:	89 2b       	or	r24, r25
    20d8:	88 83       	st	Y, r24
    20da:	80 81       	ld	r24, Z
    20dc:	98 2f       	mov	r25, r24
    20de:	96 95       	lsr	r25
    20e0:	96 95       	lsr	r25
    20e2:	96 95       	lsr	r25
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	80 7e       	andi	r24, 0xE0	; 224
    20e8:	89 2b       	or	r24, r25
    20ea:	89 83       	std	Y+1, r24	; 0x01
    20ec:	91 81       	ldd	r25, Z+1	; 0x01
    20ee:	92 95       	swap	r25
    20f0:	99 0f       	add	r25, r25
    20f2:	90 7e       	andi	r25, 0xE0	; 224
    20f4:	8f 71       	andi	r24, 0x1F	; 31
    20f6:	89 2b       	or	r24, r25
    20f8:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    20fa:	82 81       	ldd	r24, Z+2	; 0x02
    20fc:	98 2f       	mov	r25, r24
    20fe:	9f 70       	andi	r25, 0x0F	; 15
    2100:	8a 81       	ldd	r24, Y+2	; 0x02
    2102:	80 7f       	andi	r24, 0xF0	; 240
    2104:	89 2b       	or	r24, r25
    2106:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    2108:	ae 53       	subi	r26, 0x3E	; 62
    210a:	bd 4f       	sbci	r27, 0xFD	; 253
    210c:	33 96       	adiw	r30, 0x03	; 3
    210e:	88 e0       	ldi	r24, 0x08	; 8
    2110:	01 90       	ld	r0, Z+
    2112:	0d 92       	st	X+, r0
    2114:	8a 95       	dec	r24
    2116:	e1 f7       	brne	.-8      	; 0x2110 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    2118:	2f 5f       	subi	r18, 0xFF	; 255
    211a:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	01 c0       	rjmp	.+2      	; 0x2124 <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    2122:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    2124:	eb ed       	ldi	r30, 0xDB	; 219
    2126:	f0 e0       	ldi	r31, 0x00	; 0
    2128:	90 81       	ld	r25, Z
    212a:	90 68       	ori	r25, 0x80	; 128
    212c:	90 83       	st	Z, r25

	return result;
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	08 95       	ret

00002134 <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    2134:	95 b1       	in	r25, 0x05	; 5
    2136:	89 2b       	or	r24, r25
    2138:	85 b9       	out	0x05, r24	; 5
    213a:	08 95       	ret

0000213c <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    213c:	84 b1       	in	r24, 0x04	; 4
    213e:	80 6e       	ori	r24, 0xE0	; 224
    2140:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    2142:	80 ee       	ldi	r24, 0xE0	; 224
    2144:	f7 cf       	rjmp	.-18     	; 0x2134 <rgbled_turn_off>
    2146:	08 95       	ret

00002148 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2148:	95 b1       	in	r25, 0x05	; 5
    214a:	80 95       	com	r24
    214c:	98 23       	and	r25, r24
    214e:	95 b9       	out	0x05, r25	; 5
    2150:	08 95       	ret

00002152 <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    2152:	95 b1       	in	r25, 0x05	; 5
    2154:	89 27       	eor	r24, r25
    2156:	85 b9       	out	0x05, r24	; 5
    2158:	08 95       	ret

0000215a <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    215a:	94 b1       	in	r25, 0x04	; 4
    215c:	97 60       	ori	r25, 0x07	; 7
    215e:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2160:	82 fb       	bst	r24, 2
    2162:	99 27       	eor	r25, r25
    2164:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    2166:	28 2f       	mov	r18, r24
    2168:	22 70       	andi	r18, 0x02	; 2
    216a:	81 70       	andi	r24, 0x01	; 1
    216c:	80 65       	ori	r24, 0x50	; 80
    216e:	82 2b       	or	r24, r18
    2170:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    2172:	8c b5       	in	r24, 0x2c	; 44
    2174:	83 7f       	andi	r24, 0xF3	; 243
    2176:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2178:	9d bd       	out	0x2d, r25	; 45
    217a:	08 95       	ret

0000217c <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    2182:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    2184:	41 15       	cp	r20, r1
    2186:	51 05       	cpc	r21, r1
    2188:	c1 f0       	breq	.+48     	; 0x21ba <spi_trancieve+0x3e>
    218a:	fb 01       	movw	r30, r22
    218c:	dc 01       	movw	r26, r24
    218e:	46 0f       	add	r20, r22
    2190:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    2192:	8f ef       	ldi	r24, 0xFF	; 255
    2194:	20 97       	sbiw	r28, 0x00	; 0
    2196:	11 f0       	breq	.+4      	; 0x219c <spi_trancieve+0x20>
    2198:	9c 91       	ld	r25, X
    219a:	01 c0       	rjmp	.+2      	; 0x219e <spi_trancieve+0x22>
    219c:	98 2f       	mov	r25, r24
    219e:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    21a0:	0d b4       	in	r0, 0x2d	; 45
    21a2:	07 fe       	sbrs	r0, 7
    21a4:	fd cf       	rjmp	.-6      	; 0x21a0 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    21a6:	61 15       	cp	r22, r1
    21a8:	71 05       	cpc	r23, r1
    21aa:	11 f0       	breq	.+4      	; 0x21b0 <spi_trancieve+0x34>
    21ac:	9e b5       	in	r25, 0x2e	; 46
    21ae:	90 83       	st	Z, r25
    21b0:	31 96       	adiw	r30, 0x01	; 1
    21b2:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    21b4:	e4 17       	cp	r30, r20
    21b6:	f5 07       	cpc	r31, r21
    21b8:	69 f7       	brne	.-38     	; 0x2194 <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    21ba:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    21bc:	28 9a       	sbi	0x05, 0	; 5
	}
}
    21be:	df 91       	pop	r29
    21c0:	cf 91       	pop	r28
    21c2:	08 95       	ret

000021c4 <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    21c4:	1f 92       	push	r1
    21c6:	0f 92       	push	r0
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	0f 92       	push	r0
    21cc:	11 24       	eor	r1, r1
    21ce:	0b b6       	in	r0, 0x3b	; 59
    21d0:	0f 92       	push	r0
    21d2:	2f 93       	push	r18
    21d4:	3f 93       	push	r19
    21d6:	4f 93       	push	r20
    21d8:	5f 93       	push	r21
    21da:	6f 93       	push	r22
    21dc:	7f 93       	push	r23
    21de:	8f 93       	push	r24
    21e0:	af 93       	push	r26
    21e2:	bf 93       	push	r27
    21e4:	ef 93       	push	r30
    21e6:	ff 93       	push	r31
    21e8:	af e8       	ldi	r26, 0x8F	; 143
    21ea:	b3 e0       	ldi	r27, 0x03	; 3
    21ec:	ef e6       	ldi	r30, 0x6F	; 111
    21ee:	f3 e0       	ldi	r31, 0x03	; 3
    21f0:	2f e8       	ldi	r18, 0x8F	; 143
    21f2:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    21f4:	8d 91       	ld	r24, X+
    21f6:	88 23       	and	r24, r24
    21f8:	59 f0       	breq	.+22     	; 0x2210 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    21fa:	40 81       	ld	r20, Z
    21fc:	51 81       	ldd	r21, Z+1	; 0x01
    21fe:	62 81       	ldd	r22, Z+2	; 0x02
    2200:	73 81       	ldd	r23, Z+3	; 0x03
    2202:	50 5e       	subi	r21, 0xE0	; 224
    2204:	6f 4f       	sbci	r22, 0xFF	; 255
    2206:	7f 4f       	sbci	r23, 0xFF	; 255
    2208:	40 83       	st	Z, r20
    220a:	51 83       	std	Z+1, r21	; 0x01
    220c:	62 83       	std	Z+2, r22	; 0x02
    220e:	73 83       	std	Z+3, r23	; 0x03
    2210:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    2212:	e2 17       	cp	r30, r18
    2214:	f3 07       	cpc	r31, r19
    2216:	71 f7       	brne	.-36     	; 0x21f4 <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    2218:	ff 91       	pop	r31
    221a:	ef 91       	pop	r30
    221c:	bf 91       	pop	r27
    221e:	af 91       	pop	r26
    2220:	8f 91       	pop	r24
    2222:	7f 91       	pop	r23
    2224:	6f 91       	pop	r22
    2226:	5f 91       	pop	r21
    2228:	4f 91       	pop	r20
    222a:	3f 91       	pop	r19
    222c:	2f 91       	pop	r18
    222e:	0f 90       	pop	r0
    2230:	0b be       	out	0x3b, r0	; 59
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63
    2236:	0f 90       	pop	r0
    2238:	1f 90       	pop	r1
    223a:	18 95       	reti

0000223c <__subsf3>:
    223c:	50 58       	subi	r21, 0x80	; 128

0000223e <__addsf3>:
    223e:	bb 27       	eor	r27, r27
    2240:	aa 27       	eor	r26, r26
    2242:	0e d0       	rcall	.+28     	; 0x2260 <__addsf3x>
    2244:	75 c1       	rjmp	.+746    	; 0x2530 <__fp_round>
    2246:	66 d1       	rcall	.+716    	; 0x2514 <__fp_pscA>
    2248:	30 f0       	brcs	.+12     	; 0x2256 <__addsf3+0x18>
    224a:	6b d1       	rcall	.+726    	; 0x2522 <__fp_pscB>
    224c:	20 f0       	brcs	.+8      	; 0x2256 <__addsf3+0x18>
    224e:	31 f4       	brne	.+12     	; 0x225c <__addsf3+0x1e>
    2250:	9f 3f       	cpi	r25, 0xFF	; 255
    2252:	11 f4       	brne	.+4      	; 0x2258 <__addsf3+0x1a>
    2254:	1e f4       	brtc	.+6      	; 0x225c <__addsf3+0x1e>
    2256:	5b c1       	rjmp	.+694    	; 0x250e <__fp_nan>
    2258:	0e f4       	brtc	.+2      	; 0x225c <__addsf3+0x1e>
    225a:	e0 95       	com	r30
    225c:	e7 fb       	bst	r30, 7
    225e:	51 c1       	rjmp	.+674    	; 0x2502 <__fp_inf>

00002260 <__addsf3x>:
    2260:	e9 2f       	mov	r30, r25
    2262:	77 d1       	rcall	.+750    	; 0x2552 <__fp_split3>
    2264:	80 f3       	brcs	.-32     	; 0x2246 <__addsf3+0x8>
    2266:	ba 17       	cp	r27, r26
    2268:	62 07       	cpc	r22, r18
    226a:	73 07       	cpc	r23, r19
    226c:	84 07       	cpc	r24, r20
    226e:	95 07       	cpc	r25, r21
    2270:	18 f0       	brcs	.+6      	; 0x2278 <__addsf3x+0x18>
    2272:	71 f4       	brne	.+28     	; 0x2290 <__addsf3x+0x30>
    2274:	9e f5       	brtc	.+102    	; 0x22dc <__addsf3x+0x7c>
    2276:	8f c1       	rjmp	.+798    	; 0x2596 <__fp_zero>
    2278:	0e f4       	brtc	.+2      	; 0x227c <__addsf3x+0x1c>
    227a:	e0 95       	com	r30
    227c:	0b 2e       	mov	r0, r27
    227e:	ba 2f       	mov	r27, r26
    2280:	a0 2d       	mov	r26, r0
    2282:	0b 01       	movw	r0, r22
    2284:	b9 01       	movw	r22, r18
    2286:	90 01       	movw	r18, r0
    2288:	0c 01       	movw	r0, r24
    228a:	ca 01       	movw	r24, r20
    228c:	a0 01       	movw	r20, r0
    228e:	11 24       	eor	r1, r1
    2290:	ff 27       	eor	r31, r31
    2292:	59 1b       	sub	r21, r25
    2294:	99 f0       	breq	.+38     	; 0x22bc <__addsf3x+0x5c>
    2296:	59 3f       	cpi	r21, 0xF9	; 249
    2298:	50 f4       	brcc	.+20     	; 0x22ae <__addsf3x+0x4e>
    229a:	50 3e       	cpi	r21, 0xE0	; 224
    229c:	68 f1       	brcs	.+90     	; 0x22f8 <__addsf3x+0x98>
    229e:	1a 16       	cp	r1, r26
    22a0:	f0 40       	sbci	r31, 0x00	; 0
    22a2:	a2 2f       	mov	r26, r18
    22a4:	23 2f       	mov	r18, r19
    22a6:	34 2f       	mov	r19, r20
    22a8:	44 27       	eor	r20, r20
    22aa:	58 5f       	subi	r21, 0xF8	; 248
    22ac:	f3 cf       	rjmp	.-26     	; 0x2294 <__addsf3x+0x34>
    22ae:	46 95       	lsr	r20
    22b0:	37 95       	ror	r19
    22b2:	27 95       	ror	r18
    22b4:	a7 95       	ror	r26
    22b6:	f0 40       	sbci	r31, 0x00	; 0
    22b8:	53 95       	inc	r21
    22ba:	c9 f7       	brne	.-14     	; 0x22ae <__addsf3x+0x4e>
    22bc:	7e f4       	brtc	.+30     	; 0x22dc <__addsf3x+0x7c>
    22be:	1f 16       	cp	r1, r31
    22c0:	ba 0b       	sbc	r27, r26
    22c2:	62 0b       	sbc	r22, r18
    22c4:	73 0b       	sbc	r23, r19
    22c6:	84 0b       	sbc	r24, r20
    22c8:	ba f0       	brmi	.+46     	; 0x22f8 <__addsf3x+0x98>
    22ca:	91 50       	subi	r25, 0x01	; 1
    22cc:	a1 f0       	breq	.+40     	; 0x22f6 <__addsf3x+0x96>
    22ce:	ff 0f       	add	r31, r31
    22d0:	bb 1f       	adc	r27, r27
    22d2:	66 1f       	adc	r22, r22
    22d4:	77 1f       	adc	r23, r23
    22d6:	88 1f       	adc	r24, r24
    22d8:	c2 f7       	brpl	.-16     	; 0x22ca <__addsf3x+0x6a>
    22da:	0e c0       	rjmp	.+28     	; 0x22f8 <__addsf3x+0x98>
    22dc:	ba 0f       	add	r27, r26
    22de:	62 1f       	adc	r22, r18
    22e0:	73 1f       	adc	r23, r19
    22e2:	84 1f       	adc	r24, r20
    22e4:	48 f4       	brcc	.+18     	; 0x22f8 <__addsf3x+0x98>
    22e6:	87 95       	ror	r24
    22e8:	77 95       	ror	r23
    22ea:	67 95       	ror	r22
    22ec:	b7 95       	ror	r27
    22ee:	f7 95       	ror	r31
    22f0:	9e 3f       	cpi	r25, 0xFE	; 254
    22f2:	08 f0       	brcs	.+2      	; 0x22f6 <__addsf3x+0x96>
    22f4:	b3 cf       	rjmp	.-154    	; 0x225c <__addsf3+0x1e>
    22f6:	93 95       	inc	r25
    22f8:	88 0f       	add	r24, r24
    22fa:	08 f0       	brcs	.+2      	; 0x22fe <__addsf3x+0x9e>
    22fc:	99 27       	eor	r25, r25
    22fe:	ee 0f       	add	r30, r30
    2300:	97 95       	ror	r25
    2302:	87 95       	ror	r24
    2304:	08 95       	ret

00002306 <__cmpsf2>:
    2306:	d9 d0       	rcall	.+434    	; 0x24ba <__fp_cmp>
    2308:	08 f4       	brcc	.+2      	; 0x230c <__cmpsf2+0x6>
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	08 95       	ret

0000230e <__divsf3>:
    230e:	0c d0       	rcall	.+24     	; 0x2328 <__divsf3x>
    2310:	0f c1       	rjmp	.+542    	; 0x2530 <__fp_round>
    2312:	07 d1       	rcall	.+526    	; 0x2522 <__fp_pscB>
    2314:	40 f0       	brcs	.+16     	; 0x2326 <__divsf3+0x18>
    2316:	fe d0       	rcall	.+508    	; 0x2514 <__fp_pscA>
    2318:	30 f0       	brcs	.+12     	; 0x2326 <__divsf3+0x18>
    231a:	21 f4       	brne	.+8      	; 0x2324 <__divsf3+0x16>
    231c:	5f 3f       	cpi	r21, 0xFF	; 255
    231e:	19 f0       	breq	.+6      	; 0x2326 <__divsf3+0x18>
    2320:	f0 c0       	rjmp	.+480    	; 0x2502 <__fp_inf>
    2322:	51 11       	cpse	r21, r1
    2324:	39 c1       	rjmp	.+626    	; 0x2598 <__fp_szero>
    2326:	f3 c0       	rjmp	.+486    	; 0x250e <__fp_nan>

00002328 <__divsf3x>:
    2328:	14 d1       	rcall	.+552    	; 0x2552 <__fp_split3>
    232a:	98 f3       	brcs	.-26     	; 0x2312 <__divsf3+0x4>

0000232c <__divsf3_pse>:
    232c:	99 23       	and	r25, r25
    232e:	c9 f3       	breq	.-14     	; 0x2322 <__divsf3+0x14>
    2330:	55 23       	and	r21, r21
    2332:	b1 f3       	breq	.-20     	; 0x2320 <__divsf3+0x12>
    2334:	95 1b       	sub	r25, r21
    2336:	55 0b       	sbc	r21, r21
    2338:	bb 27       	eor	r27, r27
    233a:	aa 27       	eor	r26, r26
    233c:	62 17       	cp	r22, r18
    233e:	73 07       	cpc	r23, r19
    2340:	84 07       	cpc	r24, r20
    2342:	38 f0       	brcs	.+14     	; 0x2352 <__divsf3_pse+0x26>
    2344:	9f 5f       	subi	r25, 0xFF	; 255
    2346:	5f 4f       	sbci	r21, 0xFF	; 255
    2348:	22 0f       	add	r18, r18
    234a:	33 1f       	adc	r19, r19
    234c:	44 1f       	adc	r20, r20
    234e:	aa 1f       	adc	r26, r26
    2350:	a9 f3       	breq	.-22     	; 0x233c <__divsf3_pse+0x10>
    2352:	33 d0       	rcall	.+102    	; 0x23ba <__divsf3_pse+0x8e>
    2354:	0e 2e       	mov	r0, r30
    2356:	3a f0       	brmi	.+14     	; 0x2366 <__divsf3_pse+0x3a>
    2358:	e0 e8       	ldi	r30, 0x80	; 128
    235a:	30 d0       	rcall	.+96     	; 0x23bc <__divsf3_pse+0x90>
    235c:	91 50       	subi	r25, 0x01	; 1
    235e:	50 40       	sbci	r21, 0x00	; 0
    2360:	e6 95       	lsr	r30
    2362:	00 1c       	adc	r0, r0
    2364:	ca f7       	brpl	.-14     	; 0x2358 <__divsf3_pse+0x2c>
    2366:	29 d0       	rcall	.+82     	; 0x23ba <__divsf3_pse+0x8e>
    2368:	fe 2f       	mov	r31, r30
    236a:	27 d0       	rcall	.+78     	; 0x23ba <__divsf3_pse+0x8e>
    236c:	66 0f       	add	r22, r22
    236e:	77 1f       	adc	r23, r23
    2370:	88 1f       	adc	r24, r24
    2372:	bb 1f       	adc	r27, r27
    2374:	26 17       	cp	r18, r22
    2376:	37 07       	cpc	r19, r23
    2378:	48 07       	cpc	r20, r24
    237a:	ab 07       	cpc	r26, r27
    237c:	b0 e8       	ldi	r27, 0x80	; 128
    237e:	09 f0       	breq	.+2      	; 0x2382 <__divsf3_pse+0x56>
    2380:	bb 0b       	sbc	r27, r27
    2382:	80 2d       	mov	r24, r0
    2384:	bf 01       	movw	r22, r30
    2386:	ff 27       	eor	r31, r31
    2388:	93 58       	subi	r25, 0x83	; 131
    238a:	5f 4f       	sbci	r21, 0xFF	; 255
    238c:	2a f0       	brmi	.+10     	; 0x2398 <__divsf3_pse+0x6c>
    238e:	9e 3f       	cpi	r25, 0xFE	; 254
    2390:	51 05       	cpc	r21, r1
    2392:	68 f0       	brcs	.+26     	; 0x23ae <__divsf3_pse+0x82>
    2394:	b6 c0       	rjmp	.+364    	; 0x2502 <__fp_inf>
    2396:	00 c1       	rjmp	.+512    	; 0x2598 <__fp_szero>
    2398:	5f 3f       	cpi	r21, 0xFF	; 255
    239a:	ec f3       	brlt	.-6      	; 0x2396 <__divsf3_pse+0x6a>
    239c:	98 3e       	cpi	r25, 0xE8	; 232
    239e:	dc f3       	brlt	.-10     	; 0x2396 <__divsf3_pse+0x6a>
    23a0:	86 95       	lsr	r24
    23a2:	77 95       	ror	r23
    23a4:	67 95       	ror	r22
    23a6:	b7 95       	ror	r27
    23a8:	f7 95       	ror	r31
    23aa:	9f 5f       	subi	r25, 0xFF	; 255
    23ac:	c9 f7       	brne	.-14     	; 0x23a0 <__divsf3_pse+0x74>
    23ae:	88 0f       	add	r24, r24
    23b0:	91 1d       	adc	r25, r1
    23b2:	96 95       	lsr	r25
    23b4:	87 95       	ror	r24
    23b6:	97 f9       	bld	r25, 7
    23b8:	08 95       	ret
    23ba:	e1 e0       	ldi	r30, 0x01	; 1
    23bc:	66 0f       	add	r22, r22
    23be:	77 1f       	adc	r23, r23
    23c0:	88 1f       	adc	r24, r24
    23c2:	bb 1f       	adc	r27, r27
    23c4:	62 17       	cp	r22, r18
    23c6:	73 07       	cpc	r23, r19
    23c8:	84 07       	cpc	r24, r20
    23ca:	ba 07       	cpc	r27, r26
    23cc:	20 f0       	brcs	.+8      	; 0x23d6 <__divsf3_pse+0xaa>
    23ce:	62 1b       	sub	r22, r18
    23d0:	73 0b       	sbc	r23, r19
    23d2:	84 0b       	sbc	r24, r20
    23d4:	ba 0b       	sbc	r27, r26
    23d6:	ee 1f       	adc	r30, r30
    23d8:	88 f7       	brcc	.-30     	; 0x23bc <__divsf3_pse+0x90>
    23da:	e0 95       	com	r30
    23dc:	08 95       	ret

000023de <__fixsfsi>:
    23de:	04 d0       	rcall	.+8      	; 0x23e8 <__fixunssfsi>
    23e0:	68 94       	set
    23e2:	b1 11       	cpse	r27, r1
    23e4:	d9 c0       	rjmp	.+434    	; 0x2598 <__fp_szero>
    23e6:	08 95       	ret

000023e8 <__fixunssfsi>:
    23e8:	bc d0       	rcall	.+376    	; 0x2562 <__fp_splitA>
    23ea:	88 f0       	brcs	.+34     	; 0x240e <__fixunssfsi+0x26>
    23ec:	9f 57       	subi	r25, 0x7F	; 127
    23ee:	90 f0       	brcs	.+36     	; 0x2414 <__fixunssfsi+0x2c>
    23f0:	b9 2f       	mov	r27, r25
    23f2:	99 27       	eor	r25, r25
    23f4:	b7 51       	subi	r27, 0x17	; 23
    23f6:	a0 f0       	brcs	.+40     	; 0x2420 <__fixunssfsi+0x38>
    23f8:	d1 f0       	breq	.+52     	; 0x242e <__fixunssfsi+0x46>
    23fa:	66 0f       	add	r22, r22
    23fc:	77 1f       	adc	r23, r23
    23fe:	88 1f       	adc	r24, r24
    2400:	99 1f       	adc	r25, r25
    2402:	1a f0       	brmi	.+6      	; 0x240a <__fixunssfsi+0x22>
    2404:	ba 95       	dec	r27
    2406:	c9 f7       	brne	.-14     	; 0x23fa <__fixunssfsi+0x12>
    2408:	12 c0       	rjmp	.+36     	; 0x242e <__fixunssfsi+0x46>
    240a:	b1 30       	cpi	r27, 0x01	; 1
    240c:	81 f0       	breq	.+32     	; 0x242e <__fixunssfsi+0x46>
    240e:	c3 d0       	rcall	.+390    	; 0x2596 <__fp_zero>
    2410:	b1 e0       	ldi	r27, 0x01	; 1
    2412:	08 95       	ret
    2414:	c0 c0       	rjmp	.+384    	; 0x2596 <__fp_zero>
    2416:	67 2f       	mov	r22, r23
    2418:	78 2f       	mov	r23, r24
    241a:	88 27       	eor	r24, r24
    241c:	b8 5f       	subi	r27, 0xF8	; 248
    241e:	39 f0       	breq	.+14     	; 0x242e <__fixunssfsi+0x46>
    2420:	b9 3f       	cpi	r27, 0xF9	; 249
    2422:	cc f3       	brlt	.-14     	; 0x2416 <__fixunssfsi+0x2e>
    2424:	86 95       	lsr	r24
    2426:	77 95       	ror	r23
    2428:	67 95       	ror	r22
    242a:	b3 95       	inc	r27
    242c:	d9 f7       	brne	.-10     	; 0x2424 <__fixunssfsi+0x3c>
    242e:	3e f4       	brtc	.+14     	; 0x243e <__fixunssfsi+0x56>
    2430:	90 95       	com	r25
    2432:	80 95       	com	r24
    2434:	70 95       	com	r23
    2436:	61 95       	neg	r22
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	8f 4f       	sbci	r24, 0xFF	; 255
    243c:	9f 4f       	sbci	r25, 0xFF	; 255
    243e:	08 95       	ret

00002440 <__floatunsisf>:
    2440:	e8 94       	clt
    2442:	09 c0       	rjmp	.+18     	; 0x2456 <__floatsisf+0x12>

00002444 <__floatsisf>:
    2444:	97 fb       	bst	r25, 7
    2446:	3e f4       	brtc	.+14     	; 0x2456 <__floatsisf+0x12>
    2448:	90 95       	com	r25
    244a:	80 95       	com	r24
    244c:	70 95       	com	r23
    244e:	61 95       	neg	r22
    2450:	7f 4f       	sbci	r23, 0xFF	; 255
    2452:	8f 4f       	sbci	r24, 0xFF	; 255
    2454:	9f 4f       	sbci	r25, 0xFF	; 255
    2456:	99 23       	and	r25, r25
    2458:	a9 f0       	breq	.+42     	; 0x2484 <__floatsisf+0x40>
    245a:	f9 2f       	mov	r31, r25
    245c:	96 e9       	ldi	r25, 0x96	; 150
    245e:	bb 27       	eor	r27, r27
    2460:	93 95       	inc	r25
    2462:	f6 95       	lsr	r31
    2464:	87 95       	ror	r24
    2466:	77 95       	ror	r23
    2468:	67 95       	ror	r22
    246a:	b7 95       	ror	r27
    246c:	f1 11       	cpse	r31, r1
    246e:	f8 cf       	rjmp	.-16     	; 0x2460 <__floatsisf+0x1c>
    2470:	fa f4       	brpl	.+62     	; 0x24b0 <__floatsisf+0x6c>
    2472:	bb 0f       	add	r27, r27
    2474:	11 f4       	brne	.+4      	; 0x247a <__floatsisf+0x36>
    2476:	60 ff       	sbrs	r22, 0
    2478:	1b c0       	rjmp	.+54     	; 0x24b0 <__floatsisf+0x6c>
    247a:	6f 5f       	subi	r22, 0xFF	; 255
    247c:	7f 4f       	sbci	r23, 0xFF	; 255
    247e:	8f 4f       	sbci	r24, 0xFF	; 255
    2480:	9f 4f       	sbci	r25, 0xFF	; 255
    2482:	16 c0       	rjmp	.+44     	; 0x24b0 <__floatsisf+0x6c>
    2484:	88 23       	and	r24, r24
    2486:	11 f0       	breq	.+4      	; 0x248c <__floatsisf+0x48>
    2488:	96 e9       	ldi	r25, 0x96	; 150
    248a:	11 c0       	rjmp	.+34     	; 0x24ae <__floatsisf+0x6a>
    248c:	77 23       	and	r23, r23
    248e:	21 f0       	breq	.+8      	; 0x2498 <__floatsisf+0x54>
    2490:	9e e8       	ldi	r25, 0x8E	; 142
    2492:	87 2f       	mov	r24, r23
    2494:	76 2f       	mov	r23, r22
    2496:	05 c0       	rjmp	.+10     	; 0x24a2 <__floatsisf+0x5e>
    2498:	66 23       	and	r22, r22
    249a:	71 f0       	breq	.+28     	; 0x24b8 <__floatsisf+0x74>
    249c:	96 e8       	ldi	r25, 0x86	; 134
    249e:	86 2f       	mov	r24, r22
    24a0:	70 e0       	ldi	r23, 0x00	; 0
    24a2:	60 e0       	ldi	r22, 0x00	; 0
    24a4:	2a f0       	brmi	.+10     	; 0x24b0 <__floatsisf+0x6c>
    24a6:	9a 95       	dec	r25
    24a8:	66 0f       	add	r22, r22
    24aa:	77 1f       	adc	r23, r23
    24ac:	88 1f       	adc	r24, r24
    24ae:	da f7       	brpl	.-10     	; 0x24a6 <__floatsisf+0x62>
    24b0:	88 0f       	add	r24, r24
    24b2:	96 95       	lsr	r25
    24b4:	87 95       	ror	r24
    24b6:	97 f9       	bld	r25, 7
    24b8:	08 95       	ret

000024ba <__fp_cmp>:
    24ba:	99 0f       	add	r25, r25
    24bc:	00 08       	sbc	r0, r0
    24be:	55 0f       	add	r21, r21
    24c0:	aa 0b       	sbc	r26, r26
    24c2:	e0 e8       	ldi	r30, 0x80	; 128
    24c4:	fe ef       	ldi	r31, 0xFE	; 254
    24c6:	16 16       	cp	r1, r22
    24c8:	17 06       	cpc	r1, r23
    24ca:	e8 07       	cpc	r30, r24
    24cc:	f9 07       	cpc	r31, r25
    24ce:	c0 f0       	brcs	.+48     	; 0x2500 <__fp_cmp+0x46>
    24d0:	12 16       	cp	r1, r18
    24d2:	13 06       	cpc	r1, r19
    24d4:	e4 07       	cpc	r30, r20
    24d6:	f5 07       	cpc	r31, r21
    24d8:	98 f0       	brcs	.+38     	; 0x2500 <__fp_cmp+0x46>
    24da:	62 1b       	sub	r22, r18
    24dc:	73 0b       	sbc	r23, r19
    24de:	84 0b       	sbc	r24, r20
    24e0:	95 0b       	sbc	r25, r21
    24e2:	39 f4       	brne	.+14     	; 0x24f2 <__fp_cmp+0x38>
    24e4:	0a 26       	eor	r0, r26
    24e6:	61 f0       	breq	.+24     	; 0x2500 <__fp_cmp+0x46>
    24e8:	23 2b       	or	r18, r19
    24ea:	24 2b       	or	r18, r20
    24ec:	25 2b       	or	r18, r21
    24ee:	21 f4       	brne	.+8      	; 0x24f8 <__fp_cmp+0x3e>
    24f0:	08 95       	ret
    24f2:	0a 26       	eor	r0, r26
    24f4:	09 f4       	brne	.+2      	; 0x24f8 <__fp_cmp+0x3e>
    24f6:	a1 40       	sbci	r26, 0x01	; 1
    24f8:	a6 95       	lsr	r26
    24fa:	8f ef       	ldi	r24, 0xFF	; 255
    24fc:	81 1d       	adc	r24, r1
    24fe:	81 1d       	adc	r24, r1
    2500:	08 95       	ret

00002502 <__fp_inf>:
    2502:	97 f9       	bld	r25, 7
    2504:	9f 67       	ori	r25, 0x7F	; 127
    2506:	80 e8       	ldi	r24, 0x80	; 128
    2508:	70 e0       	ldi	r23, 0x00	; 0
    250a:	60 e0       	ldi	r22, 0x00	; 0
    250c:	08 95       	ret

0000250e <__fp_nan>:
    250e:	9f ef       	ldi	r25, 0xFF	; 255
    2510:	80 ec       	ldi	r24, 0xC0	; 192
    2512:	08 95       	ret

00002514 <__fp_pscA>:
    2514:	00 24       	eor	r0, r0
    2516:	0a 94       	dec	r0
    2518:	16 16       	cp	r1, r22
    251a:	17 06       	cpc	r1, r23
    251c:	18 06       	cpc	r1, r24
    251e:	09 06       	cpc	r0, r25
    2520:	08 95       	ret

00002522 <__fp_pscB>:
    2522:	00 24       	eor	r0, r0
    2524:	0a 94       	dec	r0
    2526:	12 16       	cp	r1, r18
    2528:	13 06       	cpc	r1, r19
    252a:	14 06       	cpc	r1, r20
    252c:	05 06       	cpc	r0, r21
    252e:	08 95       	ret

00002530 <__fp_round>:
    2530:	09 2e       	mov	r0, r25
    2532:	03 94       	inc	r0
    2534:	00 0c       	add	r0, r0
    2536:	11 f4       	brne	.+4      	; 0x253c <__fp_round+0xc>
    2538:	88 23       	and	r24, r24
    253a:	52 f0       	brmi	.+20     	; 0x2550 <__fp_round+0x20>
    253c:	bb 0f       	add	r27, r27
    253e:	40 f4       	brcc	.+16     	; 0x2550 <__fp_round+0x20>
    2540:	bf 2b       	or	r27, r31
    2542:	11 f4       	brne	.+4      	; 0x2548 <__fp_round+0x18>
    2544:	60 ff       	sbrs	r22, 0
    2546:	04 c0       	rjmp	.+8      	; 0x2550 <__fp_round+0x20>
    2548:	6f 5f       	subi	r22, 0xFF	; 255
    254a:	7f 4f       	sbci	r23, 0xFF	; 255
    254c:	8f 4f       	sbci	r24, 0xFF	; 255
    254e:	9f 4f       	sbci	r25, 0xFF	; 255
    2550:	08 95       	ret

00002552 <__fp_split3>:
    2552:	57 fd       	sbrc	r21, 7
    2554:	90 58       	subi	r25, 0x80	; 128
    2556:	44 0f       	add	r20, r20
    2558:	55 1f       	adc	r21, r21
    255a:	59 f0       	breq	.+22     	; 0x2572 <__fp_splitA+0x10>
    255c:	5f 3f       	cpi	r21, 0xFF	; 255
    255e:	71 f0       	breq	.+28     	; 0x257c <__fp_splitA+0x1a>
    2560:	47 95       	ror	r20

00002562 <__fp_splitA>:
    2562:	88 0f       	add	r24, r24
    2564:	97 fb       	bst	r25, 7
    2566:	99 1f       	adc	r25, r25
    2568:	61 f0       	breq	.+24     	; 0x2582 <__fp_splitA+0x20>
    256a:	9f 3f       	cpi	r25, 0xFF	; 255
    256c:	79 f0       	breq	.+30     	; 0x258c <__fp_splitA+0x2a>
    256e:	87 95       	ror	r24
    2570:	08 95       	ret
    2572:	12 16       	cp	r1, r18
    2574:	13 06       	cpc	r1, r19
    2576:	14 06       	cpc	r1, r20
    2578:	55 1f       	adc	r21, r21
    257a:	f2 cf       	rjmp	.-28     	; 0x2560 <__fp_split3+0xe>
    257c:	46 95       	lsr	r20
    257e:	f1 df       	rcall	.-30     	; 0x2562 <__fp_splitA>
    2580:	08 c0       	rjmp	.+16     	; 0x2592 <__fp_splitA+0x30>
    2582:	16 16       	cp	r1, r22
    2584:	17 06       	cpc	r1, r23
    2586:	18 06       	cpc	r1, r24
    2588:	99 1f       	adc	r25, r25
    258a:	f1 cf       	rjmp	.-30     	; 0x256e <__fp_splitA+0xc>
    258c:	86 95       	lsr	r24
    258e:	71 05       	cpc	r23, r1
    2590:	61 05       	cpc	r22, r1
    2592:	08 94       	sec
    2594:	08 95       	ret

00002596 <__fp_zero>:
    2596:	e8 94       	clt

00002598 <__fp_szero>:
    2598:	bb 27       	eor	r27, r27
    259a:	66 27       	eor	r22, r22
    259c:	77 27       	eor	r23, r23
    259e:	cb 01       	movw	r24, r22
    25a0:	97 f9       	bld	r25, 7
    25a2:	08 95       	ret

000025a4 <__gesf2>:
    25a4:	8a df       	rcall	.-236    	; 0x24ba <__fp_cmp>
    25a6:	08 f4       	brcc	.+2      	; 0x25aa <__gesf2+0x6>
    25a8:	8f ef       	ldi	r24, 0xFF	; 255
    25aa:	08 95       	ret

000025ac <__mulsf3>:
    25ac:	0b d0       	rcall	.+22     	; 0x25c4 <__mulsf3x>
    25ae:	c0 cf       	rjmp	.-128    	; 0x2530 <__fp_round>
    25b0:	b1 df       	rcall	.-158    	; 0x2514 <__fp_pscA>
    25b2:	28 f0       	brcs	.+10     	; 0x25be <__mulsf3+0x12>
    25b4:	b6 df       	rcall	.-148    	; 0x2522 <__fp_pscB>
    25b6:	18 f0       	brcs	.+6      	; 0x25be <__mulsf3+0x12>
    25b8:	95 23       	and	r25, r21
    25ba:	09 f0       	breq	.+2      	; 0x25be <__mulsf3+0x12>
    25bc:	a2 cf       	rjmp	.-188    	; 0x2502 <__fp_inf>
    25be:	a7 cf       	rjmp	.-178    	; 0x250e <__fp_nan>
    25c0:	11 24       	eor	r1, r1
    25c2:	ea cf       	rjmp	.-44     	; 0x2598 <__fp_szero>

000025c4 <__mulsf3x>:
    25c4:	c6 df       	rcall	.-116    	; 0x2552 <__fp_split3>
    25c6:	a0 f3       	brcs	.-24     	; 0x25b0 <__mulsf3+0x4>

000025c8 <__mulsf3_pse>:
    25c8:	95 9f       	mul	r25, r21
    25ca:	d1 f3       	breq	.-12     	; 0x25c0 <__mulsf3+0x14>
    25cc:	95 0f       	add	r25, r21
    25ce:	50 e0       	ldi	r21, 0x00	; 0
    25d0:	55 1f       	adc	r21, r21
    25d2:	62 9f       	mul	r22, r18
    25d4:	f0 01       	movw	r30, r0
    25d6:	72 9f       	mul	r23, r18
    25d8:	bb 27       	eor	r27, r27
    25da:	f0 0d       	add	r31, r0
    25dc:	b1 1d       	adc	r27, r1
    25de:	63 9f       	mul	r22, r19
    25e0:	aa 27       	eor	r26, r26
    25e2:	f0 0d       	add	r31, r0
    25e4:	b1 1d       	adc	r27, r1
    25e6:	aa 1f       	adc	r26, r26
    25e8:	64 9f       	mul	r22, r20
    25ea:	66 27       	eor	r22, r22
    25ec:	b0 0d       	add	r27, r0
    25ee:	a1 1d       	adc	r26, r1
    25f0:	66 1f       	adc	r22, r22
    25f2:	82 9f       	mul	r24, r18
    25f4:	22 27       	eor	r18, r18
    25f6:	b0 0d       	add	r27, r0
    25f8:	a1 1d       	adc	r26, r1
    25fa:	62 1f       	adc	r22, r18
    25fc:	73 9f       	mul	r23, r19
    25fe:	b0 0d       	add	r27, r0
    2600:	a1 1d       	adc	r26, r1
    2602:	62 1f       	adc	r22, r18
    2604:	83 9f       	mul	r24, r19
    2606:	a0 0d       	add	r26, r0
    2608:	61 1d       	adc	r22, r1
    260a:	22 1f       	adc	r18, r18
    260c:	74 9f       	mul	r23, r20
    260e:	33 27       	eor	r19, r19
    2610:	a0 0d       	add	r26, r0
    2612:	61 1d       	adc	r22, r1
    2614:	23 1f       	adc	r18, r19
    2616:	84 9f       	mul	r24, r20
    2618:	60 0d       	add	r22, r0
    261a:	21 1d       	adc	r18, r1
    261c:	82 2f       	mov	r24, r18
    261e:	76 2f       	mov	r23, r22
    2620:	6a 2f       	mov	r22, r26
    2622:	11 24       	eor	r1, r1
    2624:	9f 57       	subi	r25, 0x7F	; 127
    2626:	50 40       	sbci	r21, 0x00	; 0
    2628:	8a f0       	brmi	.+34     	; 0x264c <__mulsf3_pse+0x84>
    262a:	e1 f0       	breq	.+56     	; 0x2664 <__mulsf3_pse+0x9c>
    262c:	88 23       	and	r24, r24
    262e:	4a f0       	brmi	.+18     	; 0x2642 <__mulsf3_pse+0x7a>
    2630:	ee 0f       	add	r30, r30
    2632:	ff 1f       	adc	r31, r31
    2634:	bb 1f       	adc	r27, r27
    2636:	66 1f       	adc	r22, r22
    2638:	77 1f       	adc	r23, r23
    263a:	88 1f       	adc	r24, r24
    263c:	91 50       	subi	r25, 0x01	; 1
    263e:	50 40       	sbci	r21, 0x00	; 0
    2640:	a9 f7       	brne	.-22     	; 0x262c <__mulsf3_pse+0x64>
    2642:	9e 3f       	cpi	r25, 0xFE	; 254
    2644:	51 05       	cpc	r21, r1
    2646:	70 f0       	brcs	.+28     	; 0x2664 <__mulsf3_pse+0x9c>
    2648:	5c cf       	rjmp	.-328    	; 0x2502 <__fp_inf>
    264a:	a6 cf       	rjmp	.-180    	; 0x2598 <__fp_szero>
    264c:	5f 3f       	cpi	r21, 0xFF	; 255
    264e:	ec f3       	brlt	.-6      	; 0x264a <__mulsf3_pse+0x82>
    2650:	98 3e       	cpi	r25, 0xE8	; 232
    2652:	dc f3       	brlt	.-10     	; 0x264a <__mulsf3_pse+0x82>
    2654:	86 95       	lsr	r24
    2656:	77 95       	ror	r23
    2658:	67 95       	ror	r22
    265a:	b7 95       	ror	r27
    265c:	f7 95       	ror	r31
    265e:	e7 95       	ror	r30
    2660:	9f 5f       	subi	r25, 0xFF	; 255
    2662:	c1 f7       	brne	.-16     	; 0x2654 <__mulsf3_pse+0x8c>
    2664:	fe 2b       	or	r31, r30
    2666:	88 0f       	add	r24, r24
    2668:	91 1d       	adc	r25, r1
    266a:	96 95       	lsr	r25
    266c:	87 95       	ror	r24
    266e:	97 f9       	bld	r25, 7
    2670:	08 95       	ret

00002672 <__tablejump2__>:
    2672:	ee 0f       	add	r30, r30
    2674:	ff 1f       	adc	r31, r31
    2676:	00 24       	eor	r0, r0
    2678:	00 1c       	adc	r0, r0
    267a:	0b be       	out	0x3b, r0	; 59
    267c:	07 90       	elpm	r0, Z+
    267e:	f6 91       	elpm	r31, Z
    2680:	e0 2d       	mov	r30, r0
    2682:	09 94       	ijmp

00002684 <atoi>:
    2684:	fc 01       	movw	r30, r24
    2686:	88 27       	eor	r24, r24
    2688:	99 27       	eor	r25, r25
    268a:	e8 94       	clt
    268c:	21 91       	ld	r18, Z+
    268e:	20 32       	cpi	r18, 0x20	; 32
    2690:	e9 f3       	breq	.-6      	; 0x268c <atoi+0x8>
    2692:	29 30       	cpi	r18, 0x09	; 9
    2694:	10 f0       	brcs	.+4      	; 0x269a <atoi+0x16>
    2696:	2e 30       	cpi	r18, 0x0E	; 14
    2698:	c8 f3       	brcs	.-14     	; 0x268c <atoi+0x8>
    269a:	2b 32       	cpi	r18, 0x2B	; 43
    269c:	39 f0       	breq	.+14     	; 0x26ac <atoi+0x28>
    269e:	2d 32       	cpi	r18, 0x2D	; 45
    26a0:	31 f4       	brne	.+12     	; 0x26ae <atoi+0x2a>
    26a2:	68 94       	set
    26a4:	03 c0       	rjmp	.+6      	; 0x26ac <atoi+0x28>
    26a6:	14 d0       	rcall	.+40     	; 0x26d0 <__mulhi_const_10>
    26a8:	82 0f       	add	r24, r18
    26aa:	91 1d       	adc	r25, r1
    26ac:	21 91       	ld	r18, Z+
    26ae:	20 53       	subi	r18, 0x30	; 48
    26b0:	2a 30       	cpi	r18, 0x0A	; 10
    26b2:	c8 f3       	brcs	.-14     	; 0x26a6 <atoi+0x22>
    26b4:	1e f4       	brtc	.+6      	; 0x26bc <atoi+0x38>
    26b6:	90 95       	com	r25
    26b8:	81 95       	neg	r24
    26ba:	9f 4f       	sbci	r25, 0xFF	; 255
    26bc:	08 95       	ret

000026be <strcmp>:
    26be:	fb 01       	movw	r30, r22
    26c0:	dc 01       	movw	r26, r24
    26c2:	8d 91       	ld	r24, X+
    26c4:	01 90       	ld	r0, Z+
    26c6:	80 19       	sub	r24, r0
    26c8:	01 10       	cpse	r0, r1
    26ca:	d9 f3       	breq	.-10     	; 0x26c2 <strcmp+0x4>
    26cc:	99 0b       	sbc	r25, r25
    26ce:	08 95       	ret

000026d0 <__mulhi_const_10>:
    26d0:	7a e0       	ldi	r23, 0x0A	; 10
    26d2:	97 9f       	mul	r25, r23
    26d4:	90 2d       	mov	r25, r0
    26d6:	87 9f       	mul	r24, r23
    26d8:	80 2d       	mov	r24, r0
    26da:	91 0d       	add	r25, r1
    26dc:	11 24       	eor	r1, r1
    26de:	08 95       	ret

000026e0 <printf>:
    26e0:	cf 93       	push	r28
    26e2:	df 93       	push	r29
    26e4:	cd b7       	in	r28, 0x3d	; 61
    26e6:	de b7       	in	r29, 0x3e	; 62
    26e8:	ae 01       	movw	r20, r28
    26ea:	4b 5f       	subi	r20, 0xFB	; 251
    26ec:	5f 4f       	sbci	r21, 0xFF	; 255
    26ee:	fa 01       	movw	r30, r20
    26f0:	61 91       	ld	r22, Z+
    26f2:	71 91       	ld	r23, Z+
    26f4:	af 01       	movw	r20, r30
    26f6:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    26fa:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    26fe:	38 d0       	rcall	.+112    	; 0x2770 <vfprintf>
    2700:	df 91       	pop	r29
    2702:	cf 91       	pop	r28
    2704:	08 95       	ret

00002706 <putchar>:
    2706:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    270a:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    270e:	43 c2       	rjmp	.+1158   	; 0x2b96 <fputc>

00002710 <puts>:
    2710:	0f 93       	push	r16
    2712:	1f 93       	push	r17
    2714:	cf 93       	push	r28
    2716:	df 93       	push	r29
    2718:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    271c:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    2720:	23 81       	ldd	r18, Z+3	; 0x03
    2722:	21 ff       	sbrs	r18, 1
    2724:	1b c0       	rjmp	.+54     	; 0x275c <puts+0x4c>
    2726:	8c 01       	movw	r16, r24
    2728:	d0 e0       	ldi	r29, 0x00	; 0
    272a:	c0 e0       	ldi	r28, 0x00	; 0
    272c:	f8 01       	movw	r30, r16
    272e:	81 91       	ld	r24, Z+
    2730:	8f 01       	movw	r16, r30
    2732:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    2736:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    273a:	db 01       	movw	r26, r22
    273c:	18 96       	adiw	r26, 0x08	; 8
    273e:	ed 91       	ld	r30, X+
    2740:	fc 91       	ld	r31, X
    2742:	19 97       	sbiw	r26, 0x09	; 9
    2744:	88 23       	and	r24, r24
    2746:	31 f0       	breq	.+12     	; 0x2754 <puts+0x44>
    2748:	09 95       	icall
    274a:	89 2b       	or	r24, r25
    274c:	79 f3       	breq	.-34     	; 0x272c <puts+0x1c>
    274e:	df ef       	ldi	r29, 0xFF	; 255
    2750:	cf ef       	ldi	r28, 0xFF	; 255
    2752:	ec cf       	rjmp	.-40     	; 0x272c <puts+0x1c>
    2754:	8a e0       	ldi	r24, 0x0A	; 10
    2756:	09 95       	icall
    2758:	89 2b       	or	r24, r25
    275a:	19 f0       	breq	.+6      	; 0x2762 <puts+0x52>
    275c:	8f ef       	ldi	r24, 0xFF	; 255
    275e:	9f ef       	ldi	r25, 0xFF	; 255
    2760:	02 c0       	rjmp	.+4      	; 0x2766 <puts+0x56>
    2762:	8d 2f       	mov	r24, r29
    2764:	9c 2f       	mov	r25, r28
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	08 95       	ret

00002770 <vfprintf>:
    2770:	2f 92       	push	r2
    2772:	3f 92       	push	r3
    2774:	4f 92       	push	r4
    2776:	5f 92       	push	r5
    2778:	6f 92       	push	r6
    277a:	7f 92       	push	r7
    277c:	8f 92       	push	r8
    277e:	9f 92       	push	r9
    2780:	af 92       	push	r10
    2782:	bf 92       	push	r11
    2784:	cf 92       	push	r12
    2786:	df 92       	push	r13
    2788:	ef 92       	push	r14
    278a:	ff 92       	push	r15
    278c:	0f 93       	push	r16
    278e:	1f 93       	push	r17
    2790:	cf 93       	push	r28
    2792:	df 93       	push	r29
    2794:	cd b7       	in	r28, 0x3d	; 61
    2796:	de b7       	in	r29, 0x3e	; 62
    2798:	2b 97       	sbiw	r28, 0x0b	; 11
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	de bf       	out	0x3e, r29	; 62
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	cd bf       	out	0x3d, r28	; 61
    27a4:	6c 01       	movw	r12, r24
    27a6:	7b 01       	movw	r14, r22
    27a8:	8a 01       	movw	r16, r20
    27aa:	fc 01       	movw	r30, r24
    27ac:	17 82       	std	Z+7, r1	; 0x07
    27ae:	16 82       	std	Z+6, r1	; 0x06
    27b0:	83 81       	ldd	r24, Z+3	; 0x03
    27b2:	81 ff       	sbrs	r24, 1
    27b4:	bf c1       	rjmp	.+894    	; 0x2b34 <vfprintf+0x3c4>
    27b6:	ce 01       	movw	r24, r28
    27b8:	01 96       	adiw	r24, 0x01	; 1
    27ba:	3c 01       	movw	r6, r24
    27bc:	f6 01       	movw	r30, r12
    27be:	93 81       	ldd	r25, Z+3	; 0x03
    27c0:	f7 01       	movw	r30, r14
    27c2:	93 fd       	sbrc	r25, 3
    27c4:	85 91       	lpm	r24, Z+
    27c6:	93 ff       	sbrs	r25, 3
    27c8:	81 91       	ld	r24, Z+
    27ca:	7f 01       	movw	r14, r30
    27cc:	88 23       	and	r24, r24
    27ce:	09 f4       	brne	.+2      	; 0x27d2 <vfprintf+0x62>
    27d0:	ad c1       	rjmp	.+858    	; 0x2b2c <vfprintf+0x3bc>
    27d2:	85 32       	cpi	r24, 0x25	; 37
    27d4:	39 f4       	brne	.+14     	; 0x27e4 <vfprintf+0x74>
    27d6:	93 fd       	sbrc	r25, 3
    27d8:	85 91       	lpm	r24, Z+
    27da:	93 ff       	sbrs	r25, 3
    27dc:	81 91       	ld	r24, Z+
    27de:	7f 01       	movw	r14, r30
    27e0:	85 32       	cpi	r24, 0x25	; 37
    27e2:	21 f4       	brne	.+8      	; 0x27ec <vfprintf+0x7c>
    27e4:	b6 01       	movw	r22, r12
    27e6:	90 e0       	ldi	r25, 0x00	; 0
    27e8:	d6 d1       	rcall	.+940    	; 0x2b96 <fputc>
    27ea:	e8 cf       	rjmp	.-48     	; 0x27bc <vfprintf+0x4c>
    27ec:	91 2c       	mov	r9, r1
    27ee:	21 2c       	mov	r2, r1
    27f0:	31 2c       	mov	r3, r1
    27f2:	ff e1       	ldi	r31, 0x1F	; 31
    27f4:	f3 15       	cp	r31, r3
    27f6:	d8 f0       	brcs	.+54     	; 0x282e <vfprintf+0xbe>
    27f8:	8b 32       	cpi	r24, 0x2B	; 43
    27fa:	79 f0       	breq	.+30     	; 0x281a <vfprintf+0xaa>
    27fc:	38 f4       	brcc	.+14     	; 0x280c <vfprintf+0x9c>
    27fe:	80 32       	cpi	r24, 0x20	; 32
    2800:	79 f0       	breq	.+30     	; 0x2820 <vfprintf+0xb0>
    2802:	83 32       	cpi	r24, 0x23	; 35
    2804:	a1 f4       	brne	.+40     	; 0x282e <vfprintf+0xbe>
    2806:	23 2d       	mov	r18, r3
    2808:	20 61       	ori	r18, 0x10	; 16
    280a:	1d c0       	rjmp	.+58     	; 0x2846 <vfprintf+0xd6>
    280c:	8d 32       	cpi	r24, 0x2D	; 45
    280e:	61 f0       	breq	.+24     	; 0x2828 <vfprintf+0xb8>
    2810:	80 33       	cpi	r24, 0x30	; 48
    2812:	69 f4       	brne	.+26     	; 0x282e <vfprintf+0xbe>
    2814:	23 2d       	mov	r18, r3
    2816:	21 60       	ori	r18, 0x01	; 1
    2818:	16 c0       	rjmp	.+44     	; 0x2846 <vfprintf+0xd6>
    281a:	83 2d       	mov	r24, r3
    281c:	82 60       	ori	r24, 0x02	; 2
    281e:	38 2e       	mov	r3, r24
    2820:	e3 2d       	mov	r30, r3
    2822:	e4 60       	ori	r30, 0x04	; 4
    2824:	3e 2e       	mov	r3, r30
    2826:	2a c0       	rjmp	.+84     	; 0x287c <vfprintf+0x10c>
    2828:	f3 2d       	mov	r31, r3
    282a:	f8 60       	ori	r31, 0x08	; 8
    282c:	1d c0       	rjmp	.+58     	; 0x2868 <vfprintf+0xf8>
    282e:	37 fc       	sbrc	r3, 7
    2830:	2d c0       	rjmp	.+90     	; 0x288c <vfprintf+0x11c>
    2832:	20 ed       	ldi	r18, 0xD0	; 208
    2834:	28 0f       	add	r18, r24
    2836:	2a 30       	cpi	r18, 0x0A	; 10
    2838:	40 f0       	brcs	.+16     	; 0x284a <vfprintf+0xda>
    283a:	8e 32       	cpi	r24, 0x2E	; 46
    283c:	b9 f4       	brne	.+46     	; 0x286c <vfprintf+0xfc>
    283e:	36 fc       	sbrc	r3, 6
    2840:	75 c1       	rjmp	.+746    	; 0x2b2c <vfprintf+0x3bc>
    2842:	23 2d       	mov	r18, r3
    2844:	20 64       	ori	r18, 0x40	; 64
    2846:	32 2e       	mov	r3, r18
    2848:	19 c0       	rjmp	.+50     	; 0x287c <vfprintf+0x10c>
    284a:	36 fe       	sbrs	r3, 6
    284c:	06 c0       	rjmp	.+12     	; 0x285a <vfprintf+0xea>
    284e:	8a e0       	ldi	r24, 0x0A	; 10
    2850:	98 9e       	mul	r9, r24
    2852:	20 0d       	add	r18, r0
    2854:	11 24       	eor	r1, r1
    2856:	92 2e       	mov	r9, r18
    2858:	11 c0       	rjmp	.+34     	; 0x287c <vfprintf+0x10c>
    285a:	ea e0       	ldi	r30, 0x0A	; 10
    285c:	2e 9e       	mul	r2, r30
    285e:	20 0d       	add	r18, r0
    2860:	11 24       	eor	r1, r1
    2862:	22 2e       	mov	r2, r18
    2864:	f3 2d       	mov	r31, r3
    2866:	f0 62       	ori	r31, 0x20	; 32
    2868:	3f 2e       	mov	r3, r31
    286a:	08 c0       	rjmp	.+16     	; 0x287c <vfprintf+0x10c>
    286c:	8c 36       	cpi	r24, 0x6C	; 108
    286e:	21 f4       	brne	.+8      	; 0x2878 <vfprintf+0x108>
    2870:	83 2d       	mov	r24, r3
    2872:	80 68       	ori	r24, 0x80	; 128
    2874:	38 2e       	mov	r3, r24
    2876:	02 c0       	rjmp	.+4      	; 0x287c <vfprintf+0x10c>
    2878:	88 36       	cpi	r24, 0x68	; 104
    287a:	41 f4       	brne	.+16     	; 0x288c <vfprintf+0x11c>
    287c:	f7 01       	movw	r30, r14
    287e:	93 fd       	sbrc	r25, 3
    2880:	85 91       	lpm	r24, Z+
    2882:	93 ff       	sbrs	r25, 3
    2884:	81 91       	ld	r24, Z+
    2886:	7f 01       	movw	r14, r30
    2888:	81 11       	cpse	r24, r1
    288a:	b3 cf       	rjmp	.-154    	; 0x27f2 <vfprintf+0x82>
    288c:	98 2f       	mov	r25, r24
    288e:	9f 7d       	andi	r25, 0xDF	; 223
    2890:	95 54       	subi	r25, 0x45	; 69
    2892:	93 30       	cpi	r25, 0x03	; 3
    2894:	28 f4       	brcc	.+10     	; 0x28a0 <vfprintf+0x130>
    2896:	0c 5f       	subi	r16, 0xFC	; 252
    2898:	1f 4f       	sbci	r17, 0xFF	; 255
    289a:	9f e3       	ldi	r25, 0x3F	; 63
    289c:	99 83       	std	Y+1, r25	; 0x01
    289e:	0d c0       	rjmp	.+26     	; 0x28ba <vfprintf+0x14a>
    28a0:	83 36       	cpi	r24, 0x63	; 99
    28a2:	31 f0       	breq	.+12     	; 0x28b0 <vfprintf+0x140>
    28a4:	83 37       	cpi	r24, 0x73	; 115
    28a6:	71 f0       	breq	.+28     	; 0x28c4 <vfprintf+0x154>
    28a8:	83 35       	cpi	r24, 0x53	; 83
    28aa:	09 f0       	breq	.+2      	; 0x28ae <vfprintf+0x13e>
    28ac:	55 c0       	rjmp	.+170    	; 0x2958 <vfprintf+0x1e8>
    28ae:	20 c0       	rjmp	.+64     	; 0x28f0 <vfprintf+0x180>
    28b0:	f8 01       	movw	r30, r16
    28b2:	80 81       	ld	r24, Z
    28b4:	89 83       	std	Y+1, r24	; 0x01
    28b6:	0e 5f       	subi	r16, 0xFE	; 254
    28b8:	1f 4f       	sbci	r17, 0xFF	; 255
    28ba:	88 24       	eor	r8, r8
    28bc:	83 94       	inc	r8
    28be:	91 2c       	mov	r9, r1
    28c0:	53 01       	movw	r10, r6
    28c2:	12 c0       	rjmp	.+36     	; 0x28e8 <vfprintf+0x178>
    28c4:	28 01       	movw	r4, r16
    28c6:	f2 e0       	ldi	r31, 0x02	; 2
    28c8:	4f 0e       	add	r4, r31
    28ca:	51 1c       	adc	r5, r1
    28cc:	f8 01       	movw	r30, r16
    28ce:	a0 80       	ld	r10, Z
    28d0:	b1 80       	ldd	r11, Z+1	; 0x01
    28d2:	36 fe       	sbrs	r3, 6
    28d4:	03 c0       	rjmp	.+6      	; 0x28dc <vfprintf+0x16c>
    28d6:	69 2d       	mov	r22, r9
    28d8:	70 e0       	ldi	r23, 0x00	; 0
    28da:	02 c0       	rjmp	.+4      	; 0x28e0 <vfprintf+0x170>
    28dc:	6f ef       	ldi	r22, 0xFF	; 255
    28de:	7f ef       	ldi	r23, 0xFF	; 255
    28e0:	c5 01       	movw	r24, r10
    28e2:	4e d1       	rcall	.+668    	; 0x2b80 <strnlen>
    28e4:	4c 01       	movw	r8, r24
    28e6:	82 01       	movw	r16, r4
    28e8:	f3 2d       	mov	r31, r3
    28ea:	ff 77       	andi	r31, 0x7F	; 127
    28ec:	3f 2e       	mov	r3, r31
    28ee:	15 c0       	rjmp	.+42     	; 0x291a <vfprintf+0x1aa>
    28f0:	28 01       	movw	r4, r16
    28f2:	22 e0       	ldi	r18, 0x02	; 2
    28f4:	42 0e       	add	r4, r18
    28f6:	51 1c       	adc	r5, r1
    28f8:	f8 01       	movw	r30, r16
    28fa:	a0 80       	ld	r10, Z
    28fc:	b1 80       	ldd	r11, Z+1	; 0x01
    28fe:	36 fe       	sbrs	r3, 6
    2900:	03 c0       	rjmp	.+6      	; 0x2908 <vfprintf+0x198>
    2902:	69 2d       	mov	r22, r9
    2904:	70 e0       	ldi	r23, 0x00	; 0
    2906:	02 c0       	rjmp	.+4      	; 0x290c <vfprintf+0x19c>
    2908:	6f ef       	ldi	r22, 0xFF	; 255
    290a:	7f ef       	ldi	r23, 0xFF	; 255
    290c:	c5 01       	movw	r24, r10
    290e:	2d d1       	rcall	.+602    	; 0x2b6a <strnlen_P>
    2910:	4c 01       	movw	r8, r24
    2912:	f3 2d       	mov	r31, r3
    2914:	f0 68       	ori	r31, 0x80	; 128
    2916:	3f 2e       	mov	r3, r31
    2918:	82 01       	movw	r16, r4
    291a:	33 fc       	sbrc	r3, 3
    291c:	19 c0       	rjmp	.+50     	; 0x2950 <vfprintf+0x1e0>
    291e:	82 2d       	mov	r24, r2
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	88 16       	cp	r8, r24
    2924:	99 06       	cpc	r9, r25
    2926:	a0 f4       	brcc	.+40     	; 0x2950 <vfprintf+0x1e0>
    2928:	b6 01       	movw	r22, r12
    292a:	80 e2       	ldi	r24, 0x20	; 32
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	33 d1       	rcall	.+614    	; 0x2b96 <fputc>
    2930:	2a 94       	dec	r2
    2932:	f5 cf       	rjmp	.-22     	; 0x291e <vfprintf+0x1ae>
    2934:	f5 01       	movw	r30, r10
    2936:	37 fc       	sbrc	r3, 7
    2938:	85 91       	lpm	r24, Z+
    293a:	37 fe       	sbrs	r3, 7
    293c:	81 91       	ld	r24, Z+
    293e:	5f 01       	movw	r10, r30
    2940:	b6 01       	movw	r22, r12
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	28 d1       	rcall	.+592    	; 0x2b96 <fputc>
    2946:	21 10       	cpse	r2, r1
    2948:	2a 94       	dec	r2
    294a:	21 e0       	ldi	r18, 0x01	; 1
    294c:	82 1a       	sub	r8, r18
    294e:	91 08       	sbc	r9, r1
    2950:	81 14       	cp	r8, r1
    2952:	91 04       	cpc	r9, r1
    2954:	79 f7       	brne	.-34     	; 0x2934 <vfprintf+0x1c4>
    2956:	e1 c0       	rjmp	.+450    	; 0x2b1a <vfprintf+0x3aa>
    2958:	84 36       	cpi	r24, 0x64	; 100
    295a:	11 f0       	breq	.+4      	; 0x2960 <vfprintf+0x1f0>
    295c:	89 36       	cpi	r24, 0x69	; 105
    295e:	39 f5       	brne	.+78     	; 0x29ae <vfprintf+0x23e>
    2960:	f8 01       	movw	r30, r16
    2962:	37 fe       	sbrs	r3, 7
    2964:	07 c0       	rjmp	.+14     	; 0x2974 <vfprintf+0x204>
    2966:	60 81       	ld	r22, Z
    2968:	71 81       	ldd	r23, Z+1	; 0x01
    296a:	82 81       	ldd	r24, Z+2	; 0x02
    296c:	93 81       	ldd	r25, Z+3	; 0x03
    296e:	0c 5f       	subi	r16, 0xFC	; 252
    2970:	1f 4f       	sbci	r17, 0xFF	; 255
    2972:	08 c0       	rjmp	.+16     	; 0x2984 <vfprintf+0x214>
    2974:	60 81       	ld	r22, Z
    2976:	71 81       	ldd	r23, Z+1	; 0x01
    2978:	07 2e       	mov	r0, r23
    297a:	00 0c       	add	r0, r0
    297c:	88 0b       	sbc	r24, r24
    297e:	99 0b       	sbc	r25, r25
    2980:	0e 5f       	subi	r16, 0xFE	; 254
    2982:	1f 4f       	sbci	r17, 0xFF	; 255
    2984:	f3 2d       	mov	r31, r3
    2986:	ff 76       	andi	r31, 0x6F	; 111
    2988:	3f 2e       	mov	r3, r31
    298a:	97 ff       	sbrs	r25, 7
    298c:	09 c0       	rjmp	.+18     	; 0x29a0 <vfprintf+0x230>
    298e:	90 95       	com	r25
    2990:	80 95       	com	r24
    2992:	70 95       	com	r23
    2994:	61 95       	neg	r22
    2996:	7f 4f       	sbci	r23, 0xFF	; 255
    2998:	8f 4f       	sbci	r24, 0xFF	; 255
    299a:	9f 4f       	sbci	r25, 0xFF	; 255
    299c:	f0 68       	ori	r31, 0x80	; 128
    299e:	3f 2e       	mov	r3, r31
    29a0:	2a e0       	ldi	r18, 0x0A	; 10
    29a2:	30 e0       	ldi	r19, 0x00	; 0
    29a4:	a3 01       	movw	r20, r6
    29a6:	33 d1       	rcall	.+614    	; 0x2c0e <__ultoa_invert>
    29a8:	88 2e       	mov	r8, r24
    29aa:	86 18       	sub	r8, r6
    29ac:	44 c0       	rjmp	.+136    	; 0x2a36 <vfprintf+0x2c6>
    29ae:	85 37       	cpi	r24, 0x75	; 117
    29b0:	31 f4       	brne	.+12     	; 0x29be <vfprintf+0x24e>
    29b2:	23 2d       	mov	r18, r3
    29b4:	2f 7e       	andi	r18, 0xEF	; 239
    29b6:	b2 2e       	mov	r11, r18
    29b8:	2a e0       	ldi	r18, 0x0A	; 10
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	25 c0       	rjmp	.+74     	; 0x2a08 <vfprintf+0x298>
    29be:	93 2d       	mov	r25, r3
    29c0:	99 7f       	andi	r25, 0xF9	; 249
    29c2:	b9 2e       	mov	r11, r25
    29c4:	8f 36       	cpi	r24, 0x6F	; 111
    29c6:	c1 f0       	breq	.+48     	; 0x29f8 <vfprintf+0x288>
    29c8:	18 f4       	brcc	.+6      	; 0x29d0 <vfprintf+0x260>
    29ca:	88 35       	cpi	r24, 0x58	; 88
    29cc:	79 f0       	breq	.+30     	; 0x29ec <vfprintf+0x27c>
    29ce:	ae c0       	rjmp	.+348    	; 0x2b2c <vfprintf+0x3bc>
    29d0:	80 37       	cpi	r24, 0x70	; 112
    29d2:	19 f0       	breq	.+6      	; 0x29da <vfprintf+0x26a>
    29d4:	88 37       	cpi	r24, 0x78	; 120
    29d6:	21 f0       	breq	.+8      	; 0x29e0 <vfprintf+0x270>
    29d8:	a9 c0       	rjmp	.+338    	; 0x2b2c <vfprintf+0x3bc>
    29da:	e9 2f       	mov	r30, r25
    29dc:	e0 61       	ori	r30, 0x10	; 16
    29de:	be 2e       	mov	r11, r30
    29e0:	b4 fe       	sbrs	r11, 4
    29e2:	0d c0       	rjmp	.+26     	; 0x29fe <vfprintf+0x28e>
    29e4:	fb 2d       	mov	r31, r11
    29e6:	f4 60       	ori	r31, 0x04	; 4
    29e8:	bf 2e       	mov	r11, r31
    29ea:	09 c0       	rjmp	.+18     	; 0x29fe <vfprintf+0x28e>
    29ec:	34 fe       	sbrs	r3, 4
    29ee:	0a c0       	rjmp	.+20     	; 0x2a04 <vfprintf+0x294>
    29f0:	29 2f       	mov	r18, r25
    29f2:	26 60       	ori	r18, 0x06	; 6
    29f4:	b2 2e       	mov	r11, r18
    29f6:	06 c0       	rjmp	.+12     	; 0x2a04 <vfprintf+0x294>
    29f8:	28 e0       	ldi	r18, 0x08	; 8
    29fa:	30 e0       	ldi	r19, 0x00	; 0
    29fc:	05 c0       	rjmp	.+10     	; 0x2a08 <vfprintf+0x298>
    29fe:	20 e1       	ldi	r18, 0x10	; 16
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	02 c0       	rjmp	.+4      	; 0x2a08 <vfprintf+0x298>
    2a04:	20 e1       	ldi	r18, 0x10	; 16
    2a06:	32 e0       	ldi	r19, 0x02	; 2
    2a08:	f8 01       	movw	r30, r16
    2a0a:	b7 fe       	sbrs	r11, 7
    2a0c:	07 c0       	rjmp	.+14     	; 0x2a1c <vfprintf+0x2ac>
    2a0e:	60 81       	ld	r22, Z
    2a10:	71 81       	ldd	r23, Z+1	; 0x01
    2a12:	82 81       	ldd	r24, Z+2	; 0x02
    2a14:	93 81       	ldd	r25, Z+3	; 0x03
    2a16:	0c 5f       	subi	r16, 0xFC	; 252
    2a18:	1f 4f       	sbci	r17, 0xFF	; 255
    2a1a:	06 c0       	rjmp	.+12     	; 0x2a28 <vfprintf+0x2b8>
    2a1c:	60 81       	ld	r22, Z
    2a1e:	71 81       	ldd	r23, Z+1	; 0x01
    2a20:	80 e0       	ldi	r24, 0x00	; 0
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	0e 5f       	subi	r16, 0xFE	; 254
    2a26:	1f 4f       	sbci	r17, 0xFF	; 255
    2a28:	a3 01       	movw	r20, r6
    2a2a:	f1 d0       	rcall	.+482    	; 0x2c0e <__ultoa_invert>
    2a2c:	88 2e       	mov	r8, r24
    2a2e:	86 18       	sub	r8, r6
    2a30:	fb 2d       	mov	r31, r11
    2a32:	ff 77       	andi	r31, 0x7F	; 127
    2a34:	3f 2e       	mov	r3, r31
    2a36:	36 fe       	sbrs	r3, 6
    2a38:	0d c0       	rjmp	.+26     	; 0x2a54 <vfprintf+0x2e4>
    2a3a:	23 2d       	mov	r18, r3
    2a3c:	2e 7f       	andi	r18, 0xFE	; 254
    2a3e:	a2 2e       	mov	r10, r18
    2a40:	89 14       	cp	r8, r9
    2a42:	58 f4       	brcc	.+22     	; 0x2a5a <vfprintf+0x2ea>
    2a44:	34 fe       	sbrs	r3, 4
    2a46:	0b c0       	rjmp	.+22     	; 0x2a5e <vfprintf+0x2ee>
    2a48:	32 fc       	sbrc	r3, 2
    2a4a:	09 c0       	rjmp	.+18     	; 0x2a5e <vfprintf+0x2ee>
    2a4c:	83 2d       	mov	r24, r3
    2a4e:	8e 7e       	andi	r24, 0xEE	; 238
    2a50:	a8 2e       	mov	r10, r24
    2a52:	05 c0       	rjmp	.+10     	; 0x2a5e <vfprintf+0x2ee>
    2a54:	b8 2c       	mov	r11, r8
    2a56:	a3 2c       	mov	r10, r3
    2a58:	03 c0       	rjmp	.+6      	; 0x2a60 <vfprintf+0x2f0>
    2a5a:	b8 2c       	mov	r11, r8
    2a5c:	01 c0       	rjmp	.+2      	; 0x2a60 <vfprintf+0x2f0>
    2a5e:	b9 2c       	mov	r11, r9
    2a60:	a4 fe       	sbrs	r10, 4
    2a62:	0f c0       	rjmp	.+30     	; 0x2a82 <vfprintf+0x312>
    2a64:	fe 01       	movw	r30, r28
    2a66:	e8 0d       	add	r30, r8
    2a68:	f1 1d       	adc	r31, r1
    2a6a:	80 81       	ld	r24, Z
    2a6c:	80 33       	cpi	r24, 0x30	; 48
    2a6e:	21 f4       	brne	.+8      	; 0x2a78 <vfprintf+0x308>
    2a70:	9a 2d       	mov	r25, r10
    2a72:	99 7e       	andi	r25, 0xE9	; 233
    2a74:	a9 2e       	mov	r10, r25
    2a76:	09 c0       	rjmp	.+18     	; 0x2a8a <vfprintf+0x31a>
    2a78:	a2 fe       	sbrs	r10, 2
    2a7a:	06 c0       	rjmp	.+12     	; 0x2a88 <vfprintf+0x318>
    2a7c:	b3 94       	inc	r11
    2a7e:	b3 94       	inc	r11
    2a80:	04 c0       	rjmp	.+8      	; 0x2a8a <vfprintf+0x31a>
    2a82:	8a 2d       	mov	r24, r10
    2a84:	86 78       	andi	r24, 0x86	; 134
    2a86:	09 f0       	breq	.+2      	; 0x2a8a <vfprintf+0x31a>
    2a88:	b3 94       	inc	r11
    2a8a:	a3 fc       	sbrc	r10, 3
    2a8c:	10 c0       	rjmp	.+32     	; 0x2aae <vfprintf+0x33e>
    2a8e:	a0 fe       	sbrs	r10, 0
    2a90:	06 c0       	rjmp	.+12     	; 0x2a9e <vfprintf+0x32e>
    2a92:	b2 14       	cp	r11, r2
    2a94:	80 f4       	brcc	.+32     	; 0x2ab6 <vfprintf+0x346>
    2a96:	28 0c       	add	r2, r8
    2a98:	92 2c       	mov	r9, r2
    2a9a:	9b 18       	sub	r9, r11
    2a9c:	0d c0       	rjmp	.+26     	; 0x2ab8 <vfprintf+0x348>
    2a9e:	b2 14       	cp	r11, r2
    2aa0:	58 f4       	brcc	.+22     	; 0x2ab8 <vfprintf+0x348>
    2aa2:	b6 01       	movw	r22, r12
    2aa4:	80 e2       	ldi	r24, 0x20	; 32
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	76 d0       	rcall	.+236    	; 0x2b96 <fputc>
    2aaa:	b3 94       	inc	r11
    2aac:	f8 cf       	rjmp	.-16     	; 0x2a9e <vfprintf+0x32e>
    2aae:	b2 14       	cp	r11, r2
    2ab0:	18 f4       	brcc	.+6      	; 0x2ab8 <vfprintf+0x348>
    2ab2:	2b 18       	sub	r2, r11
    2ab4:	02 c0       	rjmp	.+4      	; 0x2aba <vfprintf+0x34a>
    2ab6:	98 2c       	mov	r9, r8
    2ab8:	21 2c       	mov	r2, r1
    2aba:	a4 fe       	sbrs	r10, 4
    2abc:	0f c0       	rjmp	.+30     	; 0x2adc <vfprintf+0x36c>
    2abe:	b6 01       	movw	r22, r12
    2ac0:	80 e3       	ldi	r24, 0x30	; 48
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	68 d0       	rcall	.+208    	; 0x2b96 <fputc>
    2ac6:	a2 fe       	sbrs	r10, 2
    2ac8:	16 c0       	rjmp	.+44     	; 0x2af6 <vfprintf+0x386>
    2aca:	a1 fc       	sbrc	r10, 1
    2acc:	03 c0       	rjmp	.+6      	; 0x2ad4 <vfprintf+0x364>
    2ace:	88 e7       	ldi	r24, 0x78	; 120
    2ad0:	90 e0       	ldi	r25, 0x00	; 0
    2ad2:	02 c0       	rjmp	.+4      	; 0x2ad8 <vfprintf+0x368>
    2ad4:	88 e5       	ldi	r24, 0x58	; 88
    2ad6:	90 e0       	ldi	r25, 0x00	; 0
    2ad8:	b6 01       	movw	r22, r12
    2ada:	0c c0       	rjmp	.+24     	; 0x2af4 <vfprintf+0x384>
    2adc:	8a 2d       	mov	r24, r10
    2ade:	86 78       	andi	r24, 0x86	; 134
    2ae0:	51 f0       	breq	.+20     	; 0x2af6 <vfprintf+0x386>
    2ae2:	a1 fe       	sbrs	r10, 1
    2ae4:	02 c0       	rjmp	.+4      	; 0x2aea <vfprintf+0x37a>
    2ae6:	8b e2       	ldi	r24, 0x2B	; 43
    2ae8:	01 c0       	rjmp	.+2      	; 0x2aec <vfprintf+0x37c>
    2aea:	80 e2       	ldi	r24, 0x20	; 32
    2aec:	a7 fc       	sbrc	r10, 7
    2aee:	8d e2       	ldi	r24, 0x2D	; 45
    2af0:	b6 01       	movw	r22, r12
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	50 d0       	rcall	.+160    	; 0x2b96 <fputc>
    2af6:	89 14       	cp	r8, r9
    2af8:	30 f4       	brcc	.+12     	; 0x2b06 <vfprintf+0x396>
    2afa:	b6 01       	movw	r22, r12
    2afc:	80 e3       	ldi	r24, 0x30	; 48
    2afe:	90 e0       	ldi	r25, 0x00	; 0
    2b00:	4a d0       	rcall	.+148    	; 0x2b96 <fputc>
    2b02:	9a 94       	dec	r9
    2b04:	f8 cf       	rjmp	.-16     	; 0x2af6 <vfprintf+0x386>
    2b06:	8a 94       	dec	r8
    2b08:	f3 01       	movw	r30, r6
    2b0a:	e8 0d       	add	r30, r8
    2b0c:	f1 1d       	adc	r31, r1
    2b0e:	80 81       	ld	r24, Z
    2b10:	b6 01       	movw	r22, r12
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	40 d0       	rcall	.+128    	; 0x2b96 <fputc>
    2b16:	81 10       	cpse	r8, r1
    2b18:	f6 cf       	rjmp	.-20     	; 0x2b06 <vfprintf+0x396>
    2b1a:	22 20       	and	r2, r2
    2b1c:	09 f4       	brne	.+2      	; 0x2b20 <vfprintf+0x3b0>
    2b1e:	4e ce       	rjmp	.-868    	; 0x27bc <vfprintf+0x4c>
    2b20:	b6 01       	movw	r22, r12
    2b22:	80 e2       	ldi	r24, 0x20	; 32
    2b24:	90 e0       	ldi	r25, 0x00	; 0
    2b26:	37 d0       	rcall	.+110    	; 0x2b96 <fputc>
    2b28:	2a 94       	dec	r2
    2b2a:	f7 cf       	rjmp	.-18     	; 0x2b1a <vfprintf+0x3aa>
    2b2c:	f6 01       	movw	r30, r12
    2b2e:	86 81       	ldd	r24, Z+6	; 0x06
    2b30:	97 81       	ldd	r25, Z+7	; 0x07
    2b32:	02 c0       	rjmp	.+4      	; 0x2b38 <vfprintf+0x3c8>
    2b34:	8f ef       	ldi	r24, 0xFF	; 255
    2b36:	9f ef       	ldi	r25, 0xFF	; 255
    2b38:	2b 96       	adiw	r28, 0x0b	; 11
    2b3a:	0f b6       	in	r0, 0x3f	; 63
    2b3c:	f8 94       	cli
    2b3e:	de bf       	out	0x3e, r29	; 62
    2b40:	0f be       	out	0x3f, r0	; 63
    2b42:	cd bf       	out	0x3d, r28	; 61
    2b44:	df 91       	pop	r29
    2b46:	cf 91       	pop	r28
    2b48:	1f 91       	pop	r17
    2b4a:	0f 91       	pop	r16
    2b4c:	ff 90       	pop	r15
    2b4e:	ef 90       	pop	r14
    2b50:	df 90       	pop	r13
    2b52:	cf 90       	pop	r12
    2b54:	bf 90       	pop	r11
    2b56:	af 90       	pop	r10
    2b58:	9f 90       	pop	r9
    2b5a:	8f 90       	pop	r8
    2b5c:	7f 90       	pop	r7
    2b5e:	6f 90       	pop	r6
    2b60:	5f 90       	pop	r5
    2b62:	4f 90       	pop	r4
    2b64:	3f 90       	pop	r3
    2b66:	2f 90       	pop	r2
    2b68:	08 95       	ret

00002b6a <strnlen_P>:
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	05 90       	lpm	r0, Z+
    2b6e:	61 50       	subi	r22, 0x01	; 1
    2b70:	70 40       	sbci	r23, 0x00	; 0
    2b72:	01 10       	cpse	r0, r1
    2b74:	d8 f7       	brcc	.-10     	; 0x2b6c <strnlen_P+0x2>
    2b76:	80 95       	com	r24
    2b78:	90 95       	com	r25
    2b7a:	8e 0f       	add	r24, r30
    2b7c:	9f 1f       	adc	r25, r31
    2b7e:	08 95       	ret

00002b80 <strnlen>:
    2b80:	fc 01       	movw	r30, r24
    2b82:	61 50       	subi	r22, 0x01	; 1
    2b84:	70 40       	sbci	r23, 0x00	; 0
    2b86:	01 90       	ld	r0, Z+
    2b88:	01 10       	cpse	r0, r1
    2b8a:	d8 f7       	brcc	.-10     	; 0x2b82 <strnlen+0x2>
    2b8c:	80 95       	com	r24
    2b8e:	90 95       	com	r25
    2b90:	8e 0f       	add	r24, r30
    2b92:	9f 1f       	adc	r25, r31
    2b94:	08 95       	ret

00002b96 <fputc>:
    2b96:	0f 93       	push	r16
    2b98:	1f 93       	push	r17
    2b9a:	cf 93       	push	r28
    2b9c:	df 93       	push	r29
    2b9e:	fb 01       	movw	r30, r22
    2ba0:	23 81       	ldd	r18, Z+3	; 0x03
    2ba2:	21 fd       	sbrc	r18, 1
    2ba4:	03 c0       	rjmp	.+6      	; 0x2bac <fputc+0x16>
    2ba6:	8f ef       	ldi	r24, 0xFF	; 255
    2ba8:	9f ef       	ldi	r25, 0xFF	; 255
    2baa:	2c c0       	rjmp	.+88     	; 0x2c04 <fputc+0x6e>
    2bac:	22 ff       	sbrs	r18, 2
    2bae:	16 c0       	rjmp	.+44     	; 0x2bdc <fputc+0x46>
    2bb0:	46 81       	ldd	r20, Z+6	; 0x06
    2bb2:	57 81       	ldd	r21, Z+7	; 0x07
    2bb4:	24 81       	ldd	r18, Z+4	; 0x04
    2bb6:	35 81       	ldd	r19, Z+5	; 0x05
    2bb8:	42 17       	cp	r20, r18
    2bba:	53 07       	cpc	r21, r19
    2bbc:	44 f4       	brge	.+16     	; 0x2bce <fputc+0x38>
    2bbe:	a0 81       	ld	r26, Z
    2bc0:	b1 81       	ldd	r27, Z+1	; 0x01
    2bc2:	9d 01       	movw	r18, r26
    2bc4:	2f 5f       	subi	r18, 0xFF	; 255
    2bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc8:	31 83       	std	Z+1, r19	; 0x01
    2bca:	20 83       	st	Z, r18
    2bcc:	8c 93       	st	X, r24
    2bce:	26 81       	ldd	r18, Z+6	; 0x06
    2bd0:	37 81       	ldd	r19, Z+7	; 0x07
    2bd2:	2f 5f       	subi	r18, 0xFF	; 255
    2bd4:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd6:	37 83       	std	Z+7, r19	; 0x07
    2bd8:	26 83       	std	Z+6, r18	; 0x06
    2bda:	14 c0       	rjmp	.+40     	; 0x2c04 <fputc+0x6e>
    2bdc:	8b 01       	movw	r16, r22
    2bde:	ec 01       	movw	r28, r24
    2be0:	fb 01       	movw	r30, r22
    2be2:	00 84       	ldd	r0, Z+8	; 0x08
    2be4:	f1 85       	ldd	r31, Z+9	; 0x09
    2be6:	e0 2d       	mov	r30, r0
    2be8:	09 95       	icall
    2bea:	89 2b       	or	r24, r25
    2bec:	e1 f6       	brne	.-72     	; 0x2ba6 <fputc+0x10>
    2bee:	d8 01       	movw	r26, r16
    2bf0:	16 96       	adiw	r26, 0x06	; 6
    2bf2:	8d 91       	ld	r24, X+
    2bf4:	9c 91       	ld	r25, X
    2bf6:	17 97       	sbiw	r26, 0x07	; 7
    2bf8:	01 96       	adiw	r24, 0x01	; 1
    2bfa:	17 96       	adiw	r26, 0x07	; 7
    2bfc:	9c 93       	st	X, r25
    2bfe:	8e 93       	st	-X, r24
    2c00:	16 97       	sbiw	r26, 0x06	; 6
    2c02:	ce 01       	movw	r24, r28
    2c04:	df 91       	pop	r29
    2c06:	cf 91       	pop	r28
    2c08:	1f 91       	pop	r17
    2c0a:	0f 91       	pop	r16
    2c0c:	08 95       	ret

00002c0e <__ultoa_invert>:
    2c0e:	fa 01       	movw	r30, r20
    2c10:	aa 27       	eor	r26, r26
    2c12:	28 30       	cpi	r18, 0x08	; 8
    2c14:	51 f1       	breq	.+84     	; 0x2c6a <__ultoa_invert+0x5c>
    2c16:	20 31       	cpi	r18, 0x10	; 16
    2c18:	81 f1       	breq	.+96     	; 0x2c7a <__ultoa_invert+0x6c>
    2c1a:	e8 94       	clt
    2c1c:	6f 93       	push	r22
    2c1e:	6e 7f       	andi	r22, 0xFE	; 254
    2c20:	6e 5f       	subi	r22, 0xFE	; 254
    2c22:	7f 4f       	sbci	r23, 0xFF	; 255
    2c24:	8f 4f       	sbci	r24, 0xFF	; 255
    2c26:	9f 4f       	sbci	r25, 0xFF	; 255
    2c28:	af 4f       	sbci	r26, 0xFF	; 255
    2c2a:	b1 e0       	ldi	r27, 0x01	; 1
    2c2c:	3e d0       	rcall	.+124    	; 0x2caa <__ultoa_invert+0x9c>
    2c2e:	b4 e0       	ldi	r27, 0x04	; 4
    2c30:	3c d0       	rcall	.+120    	; 0x2caa <__ultoa_invert+0x9c>
    2c32:	67 0f       	add	r22, r23
    2c34:	78 1f       	adc	r23, r24
    2c36:	89 1f       	adc	r24, r25
    2c38:	9a 1f       	adc	r25, r26
    2c3a:	a1 1d       	adc	r26, r1
    2c3c:	68 0f       	add	r22, r24
    2c3e:	79 1f       	adc	r23, r25
    2c40:	8a 1f       	adc	r24, r26
    2c42:	91 1d       	adc	r25, r1
    2c44:	a1 1d       	adc	r26, r1
    2c46:	6a 0f       	add	r22, r26
    2c48:	71 1d       	adc	r23, r1
    2c4a:	81 1d       	adc	r24, r1
    2c4c:	91 1d       	adc	r25, r1
    2c4e:	a1 1d       	adc	r26, r1
    2c50:	20 d0       	rcall	.+64     	; 0x2c92 <__ultoa_invert+0x84>
    2c52:	09 f4       	brne	.+2      	; 0x2c56 <__ultoa_invert+0x48>
    2c54:	68 94       	set
    2c56:	3f 91       	pop	r19
    2c58:	2a e0       	ldi	r18, 0x0A	; 10
    2c5a:	26 9f       	mul	r18, r22
    2c5c:	11 24       	eor	r1, r1
    2c5e:	30 19       	sub	r19, r0
    2c60:	30 5d       	subi	r19, 0xD0	; 208
    2c62:	31 93       	st	Z+, r19
    2c64:	de f6       	brtc	.-74     	; 0x2c1c <__ultoa_invert+0xe>
    2c66:	cf 01       	movw	r24, r30
    2c68:	08 95       	ret
    2c6a:	46 2f       	mov	r20, r22
    2c6c:	47 70       	andi	r20, 0x07	; 7
    2c6e:	40 5d       	subi	r20, 0xD0	; 208
    2c70:	41 93       	st	Z+, r20
    2c72:	b3 e0       	ldi	r27, 0x03	; 3
    2c74:	0f d0       	rcall	.+30     	; 0x2c94 <__ultoa_invert+0x86>
    2c76:	c9 f7       	brne	.-14     	; 0x2c6a <__ultoa_invert+0x5c>
    2c78:	f6 cf       	rjmp	.-20     	; 0x2c66 <__ultoa_invert+0x58>
    2c7a:	46 2f       	mov	r20, r22
    2c7c:	4f 70       	andi	r20, 0x0F	; 15
    2c7e:	40 5d       	subi	r20, 0xD0	; 208
    2c80:	4a 33       	cpi	r20, 0x3A	; 58
    2c82:	18 f0       	brcs	.+6      	; 0x2c8a <__ultoa_invert+0x7c>
    2c84:	49 5d       	subi	r20, 0xD9	; 217
    2c86:	31 fd       	sbrc	r19, 1
    2c88:	40 52       	subi	r20, 0x20	; 32
    2c8a:	41 93       	st	Z+, r20
    2c8c:	02 d0       	rcall	.+4      	; 0x2c92 <__ultoa_invert+0x84>
    2c8e:	a9 f7       	brne	.-22     	; 0x2c7a <__ultoa_invert+0x6c>
    2c90:	ea cf       	rjmp	.-44     	; 0x2c66 <__ultoa_invert+0x58>
    2c92:	b4 e0       	ldi	r27, 0x04	; 4
    2c94:	a6 95       	lsr	r26
    2c96:	97 95       	ror	r25
    2c98:	87 95       	ror	r24
    2c9a:	77 95       	ror	r23
    2c9c:	67 95       	ror	r22
    2c9e:	ba 95       	dec	r27
    2ca0:	c9 f7       	brne	.-14     	; 0x2c94 <__ultoa_invert+0x86>
    2ca2:	00 97       	sbiw	r24, 0x00	; 0
    2ca4:	61 05       	cpc	r22, r1
    2ca6:	71 05       	cpc	r23, r1
    2ca8:	08 95       	ret
    2caa:	9b 01       	movw	r18, r22
    2cac:	ac 01       	movw	r20, r24
    2cae:	0a 2e       	mov	r0, r26
    2cb0:	06 94       	lsr	r0
    2cb2:	57 95       	ror	r21
    2cb4:	47 95       	ror	r20
    2cb6:	37 95       	ror	r19
    2cb8:	27 95       	ror	r18
    2cba:	ba 95       	dec	r27
    2cbc:	c9 f7       	brne	.-14     	; 0x2cb0 <__ultoa_invert+0xa2>
    2cbe:	62 0f       	add	r22, r18
    2cc0:	73 1f       	adc	r23, r19
    2cc2:	84 1f       	adc	r24, r20
    2cc4:	95 1f       	adc	r25, r21
    2cc6:	a0 1d       	adc	r26, r0
    2cc8:	08 95       	ret

00002cca <eeprom_read_word>:
    2cca:	a8 e1       	ldi	r26, 0x18	; 24
    2ccc:	b0 e0       	ldi	r27, 0x00	; 0
    2cce:	42 e0       	ldi	r20, 0x02	; 2
    2cd0:	50 e0       	ldi	r21, 0x00	; 0
    2cd2:	05 c0       	rjmp	.+10     	; 0x2cde <eeprom_read_blraw>

00002cd4 <eeprom_write_word>:
    2cd4:	12 d0       	rcall	.+36     	; 0x2cfa <eeprom_write_byte>
    2cd6:	27 2f       	mov	r18, r23
    2cd8:	11 c0       	rjmp	.+34     	; 0x2cfc <eeprom_write_r18>

00002cda <eeprom_read_block>:
    2cda:	dc 01       	movw	r26, r24
    2cdc:	cb 01       	movw	r24, r22

00002cde <eeprom_read_blraw>:
    2cde:	fc 01       	movw	r30, r24
    2ce0:	f9 99       	sbic	0x1f, 1	; 31
    2ce2:	fe cf       	rjmp	.-4      	; 0x2ce0 <eeprom_read_blraw+0x2>
    2ce4:	06 c0       	rjmp	.+12     	; 0x2cf2 <eeprom_read_blraw+0x14>
    2ce6:	f2 bd       	out	0x22, r31	; 34
    2ce8:	e1 bd       	out	0x21, r30	; 33
    2cea:	f8 9a       	sbi	0x1f, 0	; 31
    2cec:	31 96       	adiw	r30, 0x01	; 1
    2cee:	00 b4       	in	r0, 0x20	; 32
    2cf0:	0d 92       	st	X+, r0
    2cf2:	41 50       	subi	r20, 0x01	; 1
    2cf4:	50 40       	sbci	r21, 0x00	; 0
    2cf6:	b8 f7       	brcc	.-18     	; 0x2ce6 <eeprom_read_blraw+0x8>
    2cf8:	08 95       	ret

00002cfa <eeprom_write_byte>:
    2cfa:	26 2f       	mov	r18, r22

00002cfc <eeprom_write_r18>:
    2cfc:	f9 99       	sbic	0x1f, 1	; 31
    2cfe:	fe cf       	rjmp	.-4      	; 0x2cfc <eeprom_write_r18>
    2d00:	92 bd       	out	0x22, r25	; 34
    2d02:	81 bd       	out	0x21, r24	; 33
    2d04:	20 bd       	out	0x20, r18	; 32
    2d06:	0f b6       	in	r0, 0x3f	; 63
    2d08:	f8 94       	cli
    2d0a:	fa 9a       	sbi	0x1f, 2	; 31
    2d0c:	f9 9a       	sbi	0x1f, 1	; 31
    2d0e:	0f be       	out	0x3f, r0	; 63
    2d10:	01 96       	adiw	r24, 0x01	; 1
    2d12:	08 95       	ret

00002d14 <_exit>:
    2d14:	f8 94       	cli

00002d16 <__stop_program>:
    2d16:	ff cf       	rjmp	.-2      	; 0x2d16 <__stop_program>
