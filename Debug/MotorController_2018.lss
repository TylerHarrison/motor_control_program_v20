
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002de0  00002e74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002de0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f54  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f54  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fe0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000570  00000000  00000000  00003020  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006f7b  00000000  00000000  00003590  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001dc4  00000000  00000000  0000a50b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000327a  00000000  00000000  0000c2cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000010b8  00000000  00000000  0000f54c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a19  00000000  00000000  00010604  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000474d  00000000  00000000  0001201d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  0001676a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 6c 0d 	jmp	0x1ad8	; 0x1ad8 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 1c 0c 	jmp	0x1838	; 0x1838 <__vector_16>
      44:	0c 94 5b 11 	jmp	0x22b6	; 0x22b6 <__vector_17>
      48:	0c 94 0c 0f 	jmp	0x1e18	; 0x1e18 <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 0c 0b 	jmp	0x1618	; 0x1618 <__vector_21>
      58:	0c 94 ee 0a 	jmp	0x15dc	; 0x15dc <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__vector_32>
      84:	0c 94 27 0b 	jmp	0x164e	; 0x164e <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	de 0e       	add	r13, r30
      96:	e3 0e       	add	r14, r19
      98:	e9 0e       	add	r14, r25
      9a:	ef 0e       	add	r14, r31
      9c:	f5 0e       	add	r15, r21
      9e:	fa 0e       	add	r15, r26
      a0:	00 0f       	add	r16, r16
      a2:	06 0f       	add	r16, r22

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e0 ee       	ldi	r30, 0xE0	; 224
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 87 0b 	call	0x170e	; 0x170e <main>
      de:	0c 94 ee 16 	jmp	0x2ddc	; 0x2ddc <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_update>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	0f 93       	push	r16
      e6:	1f 93       	push	r17
      e8:	cf 93       	push	r28
      ea:	df 93       	push	r29
      ec:	ec 01       	movw	r28, r24
      ee:	00 ee       	ldi	r16, 0xE0	; 224
      f0:	11 e0       	ldi	r17, 0x01	; 1
      f2:	f8 01       	movw	r30, r16
      f4:	80 81       	ld	r24, Z
      f6:	91 81       	ldd	r25, Z+1	; 0x01
      f8:	8a af       	std	Y+58, r24	; 0x3a
      fa:	82 81       	ldd	r24, Z+2	; 0x02
      fc:	93 81       	ldd	r25, Z+3	; 0x03
      fe:	8c af       	std	Y+60, r24	; 0x3c
     100:	84 81       	ldd	r24, Z+4	; 0x04
     102:	95 81       	ldd	r25, Z+5	; 0x05
     104:	9e a3       	std	Y+38, r25	; 0x26
     106:	8d a3       	std	Y+37, r24	; 0x25
     108:	66 81       	ldd	r22, Z+6	; 0x06
     10a:	77 81       	ldd	r23, Z+7	; 0x07
     10c:	80 85       	ldd	r24, Z+8	; 0x08
     10e:	91 85       	ldd	r25, Z+9	; 0x09
     110:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     114:	79 ab       	std	Y+49, r23	; 0x31
     116:	68 ab       	std	Y+48, r22	; 0x30
     118:	f8 01       	movw	r30, r16
     11a:	82 85       	ldd	r24, Z+10	; 0x0a
     11c:	93 85       	ldd	r25, Z+11	; 0x0b
     11e:	8f a7       	std	Y+47, r24	; 0x2f
     120:	84 85       	ldd	r24, Z+12	; 0x0c
     122:	95 85       	ldd	r25, Z+13	; 0x0d
     124:	9d ab       	std	Y+53, r25	; 0x35
     126:	8c ab       	std	Y+52, r24	; 0x34
     128:	86 85       	ldd	r24, Z+14	; 0x0e
     12a:	97 85       	ldd	r25, Z+15	; 0x0f
     12c:	9f ab       	std	Y+55, r25	; 0x37
     12e:	8e ab       	std	Y+54, r24	; 0x36
     130:	80 89       	ldd	r24, Z+16	; 0x10
     132:	91 89       	ldd	r25, Z+17	; 0x11
     134:	99 af       	std	Y+57, r25	; 0x39
     136:	88 af       	std	Y+56, r24	; 0x38
     138:	df 91       	pop	r29
     13a:	cf 91       	pop	r28
     13c:	1f 91       	pop	r17
     13e:	0f 91       	pop	r16
     140:	08 95       	ret

00000142 <actuator_save_position>:
     142:	cf 92       	push	r12
     144:	df 92       	push	r13
     146:	ef 92       	push	r14
     148:	ff 92       	push	r15
     14a:	81 30       	cpi	r24, 0x01	; 1
     14c:	a9 f0       	breq	.+42     	; 0x178 <actuator_save_position+0x36>
     14e:	18 f0       	brcs	.+6      	; 0x156 <actuator_save_position+0x14>
     150:	82 30       	cpi	r24, 0x02	; 2
     152:	29 f1       	breq	.+74     	; 0x19e <actuator_save_position+0x5c>
     154:	36 c0       	rjmp	.+108    	; 0x1c2 <actuator_save_position+0x80>
     156:	ca 01       	movw	r24, r20
     158:	b9 01       	movw	r22, r18
     15a:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     15e:	6b 01       	movw	r12, r22
     160:	7c 01       	movw	r14, r24
     162:	8a e2       	ldi	r24, 0x2A	; 42
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <eeprom_write_word>
     16a:	e0 ee       	ldi	r30, 0xE0	; 224
     16c:	f1 e0       	ldi	r31, 0x01	; 1
     16e:	d5 86       	std	Z+13, r13	; 0x0d
     170:	c4 86       	std	Z+12, r12	; 0x0c
     172:	11 82       	std	Z+1, r1	; 0x01
     174:	10 82       	st	Z, r1
     176:	25 c0       	rjmp	.+74     	; 0x1c2 <actuator_save_position+0x80>
     178:	ca 01       	movw	r24, r20
     17a:	b9 01       	movw	r22, r18
     17c:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     180:	6b 01       	movw	r12, r22
     182:	7c 01       	movw	r14, r24
     184:	8e e2       	ldi	r24, 0x2E	; 46
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <eeprom_write_word>
     18c:	e0 ee       	ldi	r30, 0xE0	; 224
     18e:	f1 e0       	ldi	r31, 0x01	; 1
     190:	d7 86       	std	Z+15, r13	; 0x0f
     192:	c6 86       	std	Z+14, r12	; 0x0e
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	91 83       	std	Z+1, r25	; 0x01
     19a:	80 83       	st	Z, r24
     19c:	12 c0       	rjmp	.+36     	; 0x1c2 <actuator_save_position+0x80>
     19e:	ca 01       	movw	r24, r20
     1a0:	b9 01       	movw	r22, r18
     1a2:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     1a6:	6b 01       	movw	r12, r22
     1a8:	7c 01       	movw	r14, r24
     1aa:	8c e2       	ldi	r24, 0x2C	; 44
     1ac:	90 e0       	ldi	r25, 0x00	; 0
     1ae:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <eeprom_write_word>
     1b2:	e0 ee       	ldi	r30, 0xE0	; 224
     1b4:	f1 e0       	ldi	r31, 0x01	; 1
     1b6:	d1 8a       	std	Z+17, r13	; 0x11
     1b8:	c0 8a       	std	Z+16, r12	; 0x10
     1ba:	82 e0       	ldi	r24, 0x02	; 2
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	91 83       	std	Z+1, r25	; 0x01
     1c0:	80 83       	st	Z, r24
     1c2:	ff 90       	pop	r15
     1c4:	ef 90       	pop	r14
     1c6:	df 90       	pop	r13
     1c8:	cf 90       	pop	r12
     1ca:	08 95       	ret

000001cc <actuator_pwm>:
     1cc:	89 2b       	or	r24, r25
     1ce:	29 f0       	breq	.+10     	; 0x1da <actuator_pwm+0xe>
     1d0:	81 e0       	ldi	r24, 0x01	; 1
     1d2:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     1d6:	75 9a       	sbi	0x0e, 5	; 14
     1d8:	08 95       	ret
     1da:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     1de:	75 98       	cbi	0x0e, 5	; 14
     1e0:	08 95       	ret

000001e2 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     1e2:	4f 92       	push	r4
     1e4:	5f 92       	push	r5
     1e6:	6f 92       	push	r6
     1e8:	7f 92       	push	r7
     1ea:	9f 92       	push	r9
     1ec:	af 92       	push	r10
     1ee:	bf 92       	push	r11
     1f0:	cf 92       	push	r12
     1f2:	df 92       	push	r13
     1f4:	ef 92       	push	r14
     1f6:	ff 92       	push	r15
     1f8:	0f 93       	push	r16
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	ec 01       	movw	r28, r24
     202:	96 2e       	mov	r9, r22
     204:	c6 01       	movw	r24, r12
     206:	b5 01       	movw	r22, r10
			2) Position_ERROR
			3) actuator_duty_cycle
			4) gear_status
*/
	float kp = 0.7; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value 
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     208:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     20c:	87 01       	movw	r16, r14
     20e:	06 1b       	sub	r16, r22
     210:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     212:	b8 01       	movw	r22, r16
     214:	01 2e       	mov	r0, r17
     216:	00 0c       	add	r0, r0
     218:	88 0b       	sbc	r24, r24
     21a:	99 0b       	sbc	r25, r25
     21c:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     220:	2b 01       	movw	r4, r22
     222:	3c 01       	movw	r6, r24
     224:	23 e3       	ldi	r18, 0x33	; 51
     226:	33 e3       	ldi	r19, 0x33	; 51
     228:	43 e3       	ldi	r20, 0x33	; 51
     22a:	5f e3       	ldi	r21, 0x3F	; 63
     22c:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     230:	20 e0       	ldi	r18, 0x00	; 0
     232:	30 e0       	ldi	r19, 0x00	; 0
     234:	45 e8       	ldi	r20, 0x85	; 133
     236:	52 e4       	ldi	r21, 0x42	; 66
     238:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     23c:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     240:	6b 01       	movw	r12, r22
     242:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     244:	20 e0       	ldi	r18, 0x00	; 0
     246:	30 e0       	ldi	r19, 0x00	; 0
     248:	40 e2       	ldi	r20, 0x20	; 32
     24a:	51 e4       	ldi	r21, 0x41	; 65
     24c:	c3 01       	movw	r24, r6
     24e:	b2 01       	movw	r22, r4
     250:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <__cmpsf2>
     254:	88 23       	and	r24, r24
     256:	c4 f5       	brge	.+112    	; 0x2c8 <actuator_set_position+0xe6>
     258:	20 e0       	ldi	r18, 0x00	; 0
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	40 e2       	ldi	r20, 0x20	; 32
     25e:	51 ec       	ldi	r21, 0xC1	; 193
     260:	c3 01       	movw	r24, r6
     262:	b2 01       	movw	r22, r4
     264:	0e 94 4b 13 	call	0x2696	; 0x2696 <__gesf2>
     268:	18 16       	cp	r1, r24
     26a:	74 f5       	brge	.+92     	; 0x2c8 <actuator_set_position+0xe6>
     26c:	30 c0       	rjmp	.+96     	; 0x2ce <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	00 97       	sbiw	r24, 0x00	; 0
     274:	29 f0       	breq	.+10     	; 0x280 <actuator_set_position+0x9e>
     276:	01 97       	sbiw	r24, 0x01	; 1
     278:	89 f4       	brne	.+34     	; 0x29c <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     27a:	1b 82       	std	Y+3, r1	; 0x03
     27c:	1a 82       	std	Y+2, r1	; 0x02
		break;
     27e:	0e c0       	rjmp	.+28     	; 0x29c <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     280:	10 16       	cp	r1, r16
     282:	11 06       	cpc	r1, r17
     284:	2c f4       	brge	.+10     	; 0x290 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	9b 83       	std	Y+3, r25	; 0x03
     28c:	8a 83       	std	Y+2, r24	; 0x02
     28e:	06 c0       	rjmp	.+12     	; 0x29c <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     290:	11 23       	and	r17, r17
     292:	24 f4       	brge	.+8      	; 0x29c <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     294:	82 e0       	ldi	r24, 0x02	; 2
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	9b 83       	std	Y+3, r25	; 0x03
     29a:	8a 83       	std	Y+2, r24	; 0x02
     29c:	c6 01       	movw	r24, r12
     29e:	83 38       	cpi	r24, 0x83	; 131
     2a0:	91 05       	cpc	r25, r1
     2a2:	14 f0       	brlt	.+4      	; 0x2a8 <actuator_set_position+0xc6>
     2a4:	82 e8       	ldi	r24, 0x82	; 130
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	6c 01       	movw	r12, r24
     2aa:	99 23       	and	r25, r25
     2ac:	14 f4       	brge	.+4      	; 0x2b2 <actuator_set_position+0xd0>
     2ae:	c1 2c       	mov	r12, r1
     2b0:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2b2:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2b6:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2ba:	db 86       	std	Y+11, r13	; 0x0b
     2bc:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2be:	4e 82       	std	Y+6, r4	; 0x06
     2c0:	5f 82       	std	Y+7, r5	; 0x07
     2c2:	68 86       	std	Y+8, r6	; 0x08
     2c4:	79 86       	std	Y+9, r7	; 0x09
}
     2c6:	0c c0       	rjmp	.+24     	; 0x2e0 <actuator_set_position+0xfe>
	{
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2c8:	1d 82       	std	Y+5, r1	; 0x05
     2ca:	1c 82       	std	Y+4, r1	; 0x04
     2cc:	d0 cf       	rjmp	.-96     	; 0x26e <actuator_set_position+0x8c>
	
	//Is the actuator with in an acceptable error
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     2ce:	81 e0       	ldi	r24, 0x01	; 1
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	9d 83       	std	Y+5, r25	; 0x05
     2d4:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     2d6:	89 2d       	mov	r24, r9
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	99 83       	std	Y+1, r25	; 0x01
     2dc:	88 83       	st	Y, r24
     2de:	c7 cf       	rjmp	.-114    	; 0x26e <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     2e0:	df 91       	pop	r29
     2e2:	cf 91       	pop	r28
     2e4:	1f 91       	pop	r17
     2e6:	0f 91       	pop	r16
     2e8:	ff 90       	pop	r15
     2ea:	ef 90       	pop	r14
     2ec:	df 90       	pop	r13
     2ee:	cf 90       	pop	r12
     2f0:	bf 90       	pop	r11
     2f2:	af 90       	pop	r10
     2f4:	9f 90       	pop	r9
     2f6:	7f 90       	pop	r7
     2f8:	6f 90       	pop	r6
     2fa:	5f 90       	pop	r5
     2fc:	4f 90       	pop	r4
     2fe:	08 95       	ret

00000300 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     300:	af 92       	push	r10
     302:	bf 92       	push	r11
     304:	cf 92       	push	r12
     306:	df 92       	push	r13
     308:	ef 92       	push	r14
     30a:	ff 92       	push	r15
     30c:	0f 93       	push	r16
     30e:	1f 93       	push	r17
     310:	cf 93       	push	r28
     312:	df 93       	push	r29
     314:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     316:	8b a1       	ldd	r24, Y+35	; 0x23
     318:	9c a1       	ldd	r25, Y+36	; 0x24
     31a:	89 2b       	or	r24, r25
     31c:	a9 f1       	breq	.+106    	; 0x388 <actuator_p_controller+0x88>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     31e:	8b ad       	ldd	r24, Y+59	; 0x3b
     320:	81 30       	cpi	r24, 0x01	; 1
     322:	39 f0       	breq	.+14     	; 0x332 <actuator_p_controller+0x32>
     324:	18 f0       	brcs	.+6      	; 0x32c <actuator_p_controller+0x2c>
     326:	82 30       	cpi	r24, 0x02	; 2
     328:	39 f0       	breq	.+14     	; 0x338 <actuator_p_controller+0x38>
     32a:	09 c0       	rjmp	.+18     	; 0x33e <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     32c:	ec a8       	ldd	r14, Y+52	; 0x34
     32e:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     330:	08 c0       	rjmp	.+16     	; 0x342 <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     332:	ee a8       	ldd	r14, Y+54	; 0x36
     334:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     336:	05 c0       	rjmp	.+10     	; 0x342 <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     338:	e8 ac       	ldd	r14, Y+56	; 0x38
     33a:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     33c:	02 c0       	rjmp	.+4      	; 0x342 <actuator_p_controller+0x42>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     33e:	e1 2c       	mov	r14, r1
     340:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     342:	ab a4       	ldd	r10, Y+43	; 0x2b
     344:	bc a4       	ldd	r11, Y+44	; 0x2c
     346:	cd a4       	ldd	r12, Y+45	; 0x2d
     348:	de a4       	ldd	r13, Y+46	; 0x2e
     34a:	0f a5       	ldd	r16, Y+47	; 0x2f
     34c:	2f a1       	ldd	r18, Y+39	; 0x27
     34e:	38 a5       	ldd	r19, Y+40	; 0x28
     350:	49 a5       	ldd	r20, Y+41	; 0x29
     352:	5a a5       	ldd	r21, Y+42	; 0x2a
     354:	6b ad       	ldd	r22, Y+59	; 0x3b
     356:	10 e0       	ldi	r17, 0x00	; 0
     358:	80 ee       	ldi	r24, 0xE0	; 224
     35a:	91 e0       	ldi	r25, 0x01	; 1
     35c:	42 df       	rcall	.-380    	; 0x1e2 <actuator_set_position>
		//UPDATE ComValues
		vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
     35e:	e0 ee       	ldi	r30, 0xE0	; 224
     360:	f1 e0       	ldi	r31, 0x01	; 1
     362:	82 85       	ldd	r24, Z+10	; 0x0a
     364:	93 85       	ldd	r25, Z+11	; 0x0b
     366:	8f a7       	std	Y+47, r24	; 0x2f
		vals->actuator_direction = ActuatorComValues.actuator_direction;
     368:	82 81       	ldd	r24, Z+2	; 0x02
     36a:	93 81       	ldd	r25, Z+3	; 0x03
     36c:	8c af       	std	Y+60, r24	; 0x3c
		vals->gear_status = ActuatorComValues.clutch_state;
     36e:	80 81       	ld	r24, Z
     370:	91 81       	ldd	r25, Z+1	; 0x01
     372:	8a af       	std	Y+58, r24	; 0x3a
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
		
		if (ActuatorComValues.actuator_in_position)
     374:	84 81       	ldd	r24, Z+4	; 0x04
     376:	95 81       	ldd	r25, Z+5	; 0x05
     378:	89 2b       	or	r24, r25
     37a:	b1 f1       	breq	.+108    	; 0x3e8 <actuator_p_controller+0xe8>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     37c:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     380:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     384:	8a af       	std	Y+58, r24	; 0x3a
     386:	30 c0       	rjmp	.+96     	; 0x3e8 <actuator_p_controller+0xe8>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     388:	ea a8       	ldd	r14, Y+50	; 0x32
     38a:	fb a8       	ldd	r15, Y+51	; 0x33
		vals->uart_debug = target_position;
     38c:	b7 01       	movw	r22, r14
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     396:	6f a3       	std	Y+39, r22	; 0x27
     398:	78 a7       	std	Y+40, r23	; 0x28
     39a:	89 a7       	std	Y+41, r24	; 0x29
     39c:	9a a7       	std	Y+42, r25	; 0x2a
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     39e:	ab a4       	ldd	r10, Y+43	; 0x2b
     3a0:	bc a4       	ldd	r11, Y+44	; 0x2c
     3a2:	cd a4       	ldd	r12, Y+45	; 0x2d
     3a4:	de a4       	ldd	r13, Y+46	; 0x2e
     3a6:	0f a5       	ldd	r16, Y+47	; 0x2f
     3a8:	2f a1       	ldd	r18, Y+39	; 0x27
     3aa:	38 a5       	ldd	r19, Y+40	; 0x28
     3ac:	49 a5       	ldd	r20, Y+41	; 0x29
     3ae:	5a a5       	ldd	r21, Y+42	; 0x2a
     3b0:	6b ad       	ldd	r22, Y+59	; 0x3b
     3b2:	10 e0       	ldi	r17, 0x00	; 0
     3b4:	80 ee       	ldi	r24, 0xE0	; 224
     3b6:	91 e0       	ldi	r25, 0x01	; 1
     3b8:	14 df       	rcall	.-472    	; 0x1e2 <actuator_set_position>
		//UPDATE ComValues
		vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
     3ba:	e0 ee       	ldi	r30, 0xE0	; 224
     3bc:	f1 e0       	ldi	r31, 0x01	; 1
     3be:	82 85       	ldd	r24, Z+10	; 0x0a
     3c0:	93 85       	ldd	r25, Z+11	; 0x0b
     3c2:	8f a7       	std	Y+47, r24	; 0x2f
		vals->actuator_direction = ActuatorComValues.actuator_direction;
     3c4:	82 81       	ldd	r24, Z+2	; 0x02
     3c6:	93 81       	ldd	r25, Z+3	; 0x03
     3c8:	8c af       	std	Y+60, r24	; 0x3c
		vals->gear_status = ActuatorComValues.clutch_state;
     3ca:	80 81       	ld	r24, Z
     3cc:	91 81       	ldd	r25, Z+1	; 0x01
     3ce:	8a af       	std	Y+58, r24	; 0x3a
		vals->uart_debug = ActuatorComValues.actuator_in_position;
     3d0:	64 81       	ldd	r22, Z+4	; 0x04
     3d2:	75 81       	ldd	r23, Z+5	; 0x05
     3d4:	07 2e       	mov	r0, r23
     3d6:	00 0c       	add	r0, r0
     3d8:	88 0b       	sbc	r24, r24
     3da:	99 0b       	sbc	r25, r25
     3dc:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     3e0:	6f a3       	std	Y+39, r22	; 0x27
     3e2:	78 a7       	std	Y+40, r23	; 0x28
     3e4:	89 a7       	std	Y+41, r24	; 0x29
     3e6:	9a a7       	std	Y+42, r25	; 0x2a
	}
}
     3e8:	df 91       	pop	r29
     3ea:	cf 91       	pop	r28
     3ec:	1f 91       	pop	r17
     3ee:	0f 91       	pop	r16
     3f0:	ff 90       	pop	r15
     3f2:	ef 90       	pop	r14
     3f4:	df 90       	pop	r13
     3f6:	cf 90       	pop	r12
     3f8:	bf 90       	pop	r11
     3fa:	af 90       	pop	r10
     3fc:	08 95       	ret

000003fe <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3fe:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     402:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     406:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     40a:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     40e:	08 95       	ret

00000410 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     410:	68 2f       	mov	r22, r24
     412:	70 e0       	ldi	r23, 0x00	; 0
     414:	80 e0       	ldi	r24, 0x00	; 0
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     41c:	20 e0       	ldi	r18, 0x00	; 0
     41e:	30 e0       	ldi	r19, 0x00	; 0
     420:	48 e4       	ldi	r20, 0x48	; 72
     422:	52 e4       	ldi	r21, 0x42	; 66
     424:	0e 94 97 11 	call	0x232e	; 0x232e <__subsf3>
     428:	27 ed       	ldi	r18, 0xD7	; 215
     42a:	33 ea       	ldi	r19, 0xA3	; 163
     42c:	48 e8       	ldi	r20, 0x88	; 136
     42e:	51 e4       	ldi	r21, 0x41	; 65
     430:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
     434:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     438:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     43c:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     440:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     444:	08 95       	ret

00000446 <controller>:
}

void controller(volatile ModuleValues_t *vals){
     446:	8f 92       	push	r8
     448:	9f 92       	push	r9
     44a:	af 92       	push	r10
     44c:	bf 92       	push	r11
     44e:	cf 92       	push	r12
     450:	df 92       	push	r13
     452:	ef 92       	push	r14
     454:	ff 92       	push	r15
     456:	0f 93       	push	r16
     458:	1f 93       	push	r17
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     460:	8e 8d       	ldd	r24, Y+30	; 0x1e
     462:	82 30       	cpi	r24, 0x02	; 2
     464:	21 f4       	brne	.+8      	; 0x46e <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     466:	68 8d       	ldd	r22, Y+24	; 0x18
     468:	16 2f       	mov	r17, r22
     46a:	11 95       	neg	r17
     46c:	01 c0       	rjmp	.+2      	; 0x470 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     46e:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     470:	8e 8d       	ldd	r24, Y+30	; 0x1e
     472:	81 30       	cpi	r24, 0x01	; 1
     474:	09 f4       	brne	.+2      	; 0x478 <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     476:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     478:	89 a1       	ldd	r24, Y+33	; 0x21
     47a:	81 11       	cpse	r24, r1
     47c:	7b c0       	rjmp	.+246    	; 0x574 <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     47e:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     482:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     486:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     48a:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     48e:	20 e0       	ldi	r18, 0x00	; 0
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	4e eb       	ldi	r20, 0xBE	; 190
     494:	52 e4       	ldi	r21, 0x42	; 66
     496:	c7 01       	movw	r24, r14
     498:	b6 01       	movw	r22, r12
     49a:	0e 94 4b 13 	call	0x2696	; 0x2696 <__gesf2>
     49e:	88 23       	and	r24, r24
     4a0:	54 f4       	brge	.+20     	; 0x4b6 <controller+0x70>
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	30 e0       	ldi	r19, 0x00	; 0
     4a6:	48 e4       	ldi	r20, 0x48	; 72
     4a8:	52 e4       	ldi	r21, 0x42	; 66
     4aa:	c7 01       	movw	r24, r14
     4ac:	b6 01       	movw	r22, r12
     4ae:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <__cmpsf2>
     4b2:	18 16       	cp	r1, r24
     4b4:	6c f0       	brlt	.+26     	; 0x4d0 <controller+0x8a>
		{
			b_saturation = 1 ;
     4b6:	81 e0       	ldi	r24, 0x01	; 1
     4b8:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4bc:	61 2f       	mov	r22, r17
     4be:	11 0f       	add	r17, r17
     4c0:	77 0b       	sbc	r23, r23
     4c2:	88 0b       	sbc	r24, r24
     4c4:	99 0b       	sbc	r25, r25
     4c6:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     4ca:	6b 01       	movw	r12, r22
     4cc:	7c 01       	movw	r14, r24
     4ce:	25 c0       	rjmp	.+74     	; 0x51a <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     4d0:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4d4:	61 2f       	mov	r22, r17
     4d6:	11 0f       	add	r17, r17
     4d8:	77 0b       	sbc	r23, r23
     4da:	88 0b       	sbc	r24, r24
     4dc:	99 0b       	sbc	r25, r25
     4de:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     4e2:	6b 01       	movw	r12, r22
     4e4:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4e6:	2a e0       	ldi	r18, 0x0A	; 10
     4e8:	37 ed       	ldi	r19, 0xD7	; 215
     4ea:	43 ea       	ldi	r20, 0xA3	; 163
     4ec:	5b e3       	ldi	r21, 0x3B	; 59
     4ee:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     4f2:	9b 01       	movw	r18, r22
     4f4:	ac 01       	movw	r20, r24
     4f6:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4fa:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4fe:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     502:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     506:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     50a:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     50e:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     512:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     516:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     51a:	27 ed       	ldi	r18, 0xD7	; 215
     51c:	33 ea       	ldi	r19, 0xA3	; 163
     51e:	48 e8       	ldi	r20, 0x88	; 136
     520:	51 e4       	ldi	r21, 0x41	; 65
     522:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     526:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     52a:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     52e:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     532:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     536:	4b 01       	movw	r8, r22
     538:	5c 01       	movw	r10, r24
     53a:	27 e8       	ldi	r18, 0x87	; 135
     53c:	3f eb       	ldi	r19, 0xBF	; 191
     53e:	46 e2       	ldi	r20, 0x26	; 38
     540:	5e e3       	ldi	r21, 0x3E	; 62
     542:	c7 01       	movw	r24, r14
     544:	b6 01       	movw	r22, r12
     546:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     54a:	9b 01       	movw	r18, r22
     54c:	ac 01       	movw	r20, r24
     54e:	c5 01       	movw	r24, r10
     550:	b4 01       	movw	r22, r8
     552:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     556:	20 e0       	ldi	r18, 0x00	; 0
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	48 e4       	ldi	r20, 0x48	; 72
     55c:	52 e4       	ldi	r21, 0x42	; 66
     55e:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     562:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     566:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     56a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     56e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     572:	11 c0       	rjmp	.+34     	; 0x596 <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     574:	89 a1       	ldd	r24, Y+33	; 0x21
     576:	81 30       	cpi	r24, 0x01	; 1
     578:	71 f4       	brne	.+28     	; 0x596 <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     57a:	69 8d       	ldd	r22, Y+25	; 0x19
     57c:	70 e0       	ldi	r23, 0x00	; 0
     57e:	80 e0       	ldi	r24, 0x00	; 0
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     586:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     58a:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     58e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     592:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     596:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     59a:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     59e:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     5a2:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     5a6:	20 e0       	ldi	r18, 0x00	; 0
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	4e eb       	ldi	r20, 0xBE	; 190
     5ac:	52 e4       	ldi	r21, 0x42	; 66
     5ae:	c7 01       	movw	r24, r14
     5b0:	b6 01       	movw	r22, r12
     5b2:	0e 94 4b 13 	call	0x2696	; 0x2696 <__gesf2>
     5b6:	18 16       	cp	r1, r24
     5b8:	6c f4       	brge	.+26     	; 0x5d4 <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     5ba:	80 e0       	ldi	r24, 0x00	; 0
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	ae eb       	ldi	r26, 0xBE	; 190
     5c0:	b2 e4       	ldi	r27, 0x42	; 66
     5c2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5c6:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5ca:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5ce:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     5d2:	16 c0       	rjmp	.+44     	; 0x600 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	30 e0       	ldi	r19, 0x00	; 0
     5d8:	48 e4       	ldi	r20, 0x48	; 72
     5da:	52 e4       	ldi	r21, 0x42	; 66
     5dc:	c7 01       	movw	r24, r14
     5de:	b6 01       	movw	r22, r12
     5e0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <__cmpsf2>
     5e4:	88 23       	and	r24, r24
     5e6:	64 f4       	brge	.+24     	; 0x600 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5e8:	80 e0       	ldi	r24, 0x00	; 0
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	a8 e4       	ldi	r26, 0x48	; 72
     5ee:	b2 e4       	ldi	r27, 0x42	; 66
     5f0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5f4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5f8:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5fc:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     600:	06 e9       	ldi	r16, 0x96	; 150
     602:	10 e0       	ldi	r17, 0x00	; 0
     604:	f8 01       	movw	r30, r16
     606:	e0 80       	ld	r14, Z
     608:	f1 80       	ldd	r15, Z+1	; 0x01
     60a:	20 e0       	ldi	r18, 0x00	; 0
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	48 ec       	ldi	r20, 0xC8	; 200
     610:	52 e4       	ldi	r21, 0x42	; 66
     612:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     616:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     61a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     61e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     622:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
     626:	4b 01       	movw	r8, r22
     628:	5c 01       	movw	r10, r24
     62a:	b7 01       	movw	r22, r14
     62c:	80 e0       	ldi	r24, 0x00	; 0
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     634:	9b 01       	movw	r18, r22
     636:	ac 01       	movw	r20, r24
     638:	c5 01       	movw	r24, r10
     63a:	b4 01       	movw	r22, r8
     63c:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     640:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     644:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     648:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     64c:	f8 01       	movw	r30, r16
     64e:	60 81       	ld	r22, Z
     650:	71 81       	ldd	r23, Z+1	; 0x01
     652:	00 81       	ld	r16, Z
     654:	11 81       	ldd	r17, Z+1	; 0x01
     656:	80 e0       	ldi	r24, 0x00	; 0
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     65e:	6b 01       	movw	r12, r22
     660:	7c 01       	movw	r14, r24
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	48 ec       	ldi	r20, 0xC8	; 200
     668:	52 e4       	ldi	r21, 0x42	; 66
     66a:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     66e:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     672:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     676:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     67a:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
     67e:	4b 01       	movw	r8, r22
     680:	5c 01       	movw	r10, r24
     682:	b8 01       	movw	r22, r16
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     68c:	9b 01       	movw	r18, r22
     68e:	ac 01       	movw	r20, r24
     690:	c5 01       	movw	r24, r10
     692:	b4 01       	movw	r22, r8
     694:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     698:	9b 01       	movw	r18, r22
     69a:	ac 01       	movw	r20, r24
     69c:	c7 01       	movw	r24, r14
     69e:	b6 01       	movw	r22, r12
     6a0:	0e 94 97 11 	call	0x232e	; 0x232e <__subsf3>
     6a4:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     6a8:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     6ac:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     6b0:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     6b4:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     6b8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     6bc:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     6c0:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     6c4:	69 8f       	std	Y+25, r22	; 0x19

}
     6c6:	df 91       	pop	r29
     6c8:	cf 91       	pop	r28
     6ca:	1f 91       	pop	r17
     6cc:	0f 91       	pop	r16
     6ce:	ff 90       	pop	r15
     6d0:	ef 90       	pop	r14
     6d2:	df 90       	pop	r13
     6d4:	cf 90       	pop	r12
     6d6:	bf 90       	pop	r11
     6d8:	af 90       	pop	r10
     6da:	9f 90       	pop	r9
     6dc:	8f 90       	pop	r8
     6de:	08 95       	ret

000006e0 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6e0:	53 9a       	sbi	0x0a, 3	; 10
     6e2:	08 95       	ret

000006e4 <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6e4:	81 30       	cpi	r24, 0x01	; 1
     6e6:	11 f4       	brne	.+4      	; 0x6ec <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6e8:	5b 9a       	sbi	0x0b, 3	; 11
     6ea:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6ec:	5b 98       	cbi	0x0b, 3	; 11
     6ee:	08 95       	ret

000006f0 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6f6:	6a ef       	ldi	r22, 0xFA	; 250
     6f8:	71 e0       	ldi	r23, 0x01	; 1
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     700:	21 e0       	ldi	r18, 0x01	; 1
     702:	43 e0       	ldi	r20, 0x03	; 3
     704:	50 e0       	ldi	r21, 0x00	; 0
     706:	67 ef       	ldi	r22, 0xF7	; 247
     708:	71 e0       	ldi	r23, 0x01	; 1
     70a:	8a ef       	ldi	r24, 0xFA	; 250
     70c:	91 e0       	ldi	r25, 0x01	; 1
     70e:	0e 94 37 11 	call	0x226e	; 0x226e <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     712:	e7 ef       	ldi	r30, 0xF7	; 247
     714:	f1 e0       	ldi	r31, 0x01	; 1
     716:	61 81       	ldd	r22, Z+1	; 0x01
     718:	6f 71       	andi	r22, 0x1F	; 31
     71a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     71c:	70 e0       	ldi	r23, 0x00	; 0
     71e:	76 2f       	mov	r23, r22
     720:	66 27       	eor	r22, r22
     722:	82 81       	ldd	r24, Z+2	; 0x02
     724:	68 2b       	or	r22, r24
     726:	80 e0       	ldi	r24, 0x00	; 0
     728:	90 e0       	ldi	r25, 0x00	; 0
     72a:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	49 e8       	ldi	r20, 0x89	; 137
     734:	52 e4       	ldi	r21, 0x42	; 66
     736:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
     73a:	20 e0       	ldi	r18, 0x00	; 0
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	40 e2       	ldi	r20, 0x20	; 32
     740:	51 e4       	ldi	r21, 0x41	; 65
     742:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	30 e0       	ldi	r19, 0x00	; 0
     74a:	48 e8       	ldi	r20, 0x88	; 136
     74c:	51 e4       	ldi	r21, 0x41	; 65
     74e:	0e 94 97 11 	call	0x232e	; 0x232e <__subsf3>
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	30 e0       	ldi	r19, 0x00	; 0
     756:	a9 01       	movw	r20, r18
     758:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     75c:	68 83       	st	Y, r22
     75e:	79 83       	std	Y+1, r23	; 0x01
     760:	8a 83       	std	Y+2, r24	; 0x02
     762:	9b 83       	std	Y+3, r25	; 0x03
}
     764:	df 91       	pop	r29
     766:	cf 91       	pop	r28
     768:	08 95       	ret

0000076a <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     770:	6a ef       	ldi	r22, 0xFA	; 250
     772:	71 e0       	ldi	r23, 0x01	; 1
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     77a:	21 e0       	ldi	r18, 0x01	; 1
     77c:	43 e0       	ldi	r20, 0x03	; 3
     77e:	50 e0       	ldi	r21, 0x00	; 0
     780:	67 ef       	ldi	r22, 0xF7	; 247
     782:	71 e0       	ldi	r23, 0x01	; 1
     784:	8a ef       	ldi	r24, 0xFA	; 250
     786:	91 e0       	ldi	r25, 0x01	; 1
     788:	0e 94 37 11 	call	0x226e	; 0x226e <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     78c:	e7 ef       	ldi	r30, 0xF7	; 247
     78e:	f1 e0       	ldi	r31, 0x01	; 1
     790:	61 81       	ldd	r22, Z+1	; 0x01
     792:	6f 71       	andi	r22, 0x1F	; 31
     794:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     796:	70 e0       	ldi	r23, 0x00	; 0
     798:	76 2f       	mov	r23, r22
     79a:	66 27       	eor	r22, r22
     79c:	82 81       	ldd	r24, Z+2	; 0x02
     79e:	68 2b       	or	r22, r24
     7a0:	41 e0       	ldi	r20, 0x01	; 1
     7a2:	ce 01       	movw	r24, r28
     7a4:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <handle_current_sensor>
}
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	08 95       	ret

000007ae <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     7b4:	6a ef       	ldi	r22, 0xFA	; 250
     7b6:	71 e0       	ldi	r23, 0x01	; 1
     7b8:	84 e0       	ldi	r24, 0x04	; 4
     7ba:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7be:	21 e0       	ldi	r18, 0x01	; 1
     7c0:	43 e0       	ldi	r20, 0x03	; 3
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	67 ef       	ldi	r22, 0xF7	; 247
     7c6:	71 e0       	ldi	r23, 0x01	; 1
     7c8:	8a ef       	ldi	r24, 0xFA	; 250
     7ca:	91 e0       	ldi	r25, 0x01	; 1
     7cc:	0e 94 37 11 	call	0x226e	; 0x226e <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7d0:	e7 ef       	ldi	r30, 0xF7	; 247
     7d2:	f1 e0       	ldi	r31, 0x01	; 1
     7d4:	61 81       	ldd	r22, Z+1	; 0x01
     7d6:	6f 71       	andi	r22, 0x1F	; 31
     7d8:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7da:	70 e0       	ldi	r23, 0x00	; 0
     7dc:	76 2f       	mov	r23, r22
     7de:	66 27       	eor	r22, r22
     7e0:	82 81       	ldd	r24, Z+2	; 0x02
     7e2:	68 2b       	or	r22, r24
     7e4:	ce 01       	movw	r24, r28
     7e6:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <handle_temp_sensor>
}
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	00 d0       	rcall	.+0      	; 0x7fa <SPI_handler_6+0xa>
     7fa:	00 d0       	rcall	.+0      	; 0x7fc <SPI_handler_6+0xc>
     7fc:	cd b7       	in	r28, 0x3d	; 61
     7fe:	de b7       	in	r29, 0x3e	; 62
     800:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     802:	6a ef       	ldi	r22, 0xFA	; 250
     804:	71 e0       	ldi	r23, 0x01	; 1
     806:	86 e0       	ldi	r24, 0x06	; 6
     808:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     80c:	21 e0       	ldi	r18, 0x01	; 1
     80e:	43 e0       	ldi	r20, 0x03	; 3
     810:	50 e0       	ldi	r21, 0x00	; 0
     812:	67 ef       	ldi	r22, 0xF7	; 247
     814:	71 e0       	ldi	r23, 0x01	; 1
     816:	8a ef       	ldi	r24, 0xFA	; 250
     818:	91 e0       	ldi	r25, 0x01	; 1
     81a:	0e 94 37 11 	call	0x226e	; 0x226e <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     81e:	e7 ef       	ldi	r30, 0xF7	; 247
     820:	f1 e0       	ldi	r31, 0x01	; 1
     822:	61 81       	ldd	r22, Z+1	; 0x01
     824:	6f 71       	andi	r22, 0x1F	; 31
     826:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	76 2f       	mov	r23, r22
     82c:	66 27       	eor	r22, r22
     82e:	82 81       	ldd	r24, Z+2	; 0x02
     830:	68 2b       	or	r22, r24
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	90 e0       	ldi	r25, 0x00	; 0
     836:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     83a:	20 e0       	ldi	r18, 0x00	; 0
     83c:	30 e0       	ldi	r19, 0x00	; 0
     83e:	40 ea       	ldi	r20, 0xA0	; 160
     840:	50 e4       	ldi	r21, 0x40	; 64
     842:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	40 e8       	ldi	r20, 0x80	; 128
     84c:	59 e3       	ldi	r21, 0x39	; 57
     84e:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     852:	69 83       	std	Y+1, r22	; 0x01
     854:	7a 83       	std	Y+2, r23	; 0x02
     856:	8b 83       	std	Y+3, r24	; 0x03
     858:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     85a:	69 81       	ldd	r22, Y+1	; 0x01
     85c:	7a 81       	ldd	r23, Y+2	; 0x02
     85e:	8b 81       	ldd	r24, Y+3	; 0x03
     860:	9c 81       	ldd	r25, Y+4	; 0x04
     862:	20 e0       	ldi	r18, 0x00	; 0
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	48 ec       	ldi	r20, 0xC8	; 200
     868:	52 e4       	ldi	r21, 0x42	; 66
     86a:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	48 ec       	ldi	r20, 0xC8	; 200
     874:	51 e4       	ldi	r21, 0x41	; 65
     876:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
     87a:	f8 01       	movw	r30, r16
     87c:	60 83       	st	Z, r22
     87e:	71 83       	std	Z+1, r23	; 0x01
     880:	82 83       	std	Z+2, r24	; 0x02
     882:	93 83       	std	Z+3, r25	; 0x03
}
     884:	0f 90       	pop	r0
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	0f 90       	pop	r0
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	08 95       	ret

00000896 <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     89c:	6a ef       	ldi	r22, 0xFA	; 250
     89e:	71 e0       	ldi	r23, 0x01	; 1
     8a0:	87 e0       	ldi	r24, 0x07	; 7
     8a2:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     8a6:	21 e0       	ldi	r18, 0x01	; 1
     8a8:	43 e0       	ldi	r20, 0x03	; 3
     8aa:	50 e0       	ldi	r21, 0x00	; 0
     8ac:	67 ef       	ldi	r22, 0xF7	; 247
     8ae:	71 e0       	ldi	r23, 0x01	; 1
     8b0:	8a ef       	ldi	r24, 0xFA	; 250
     8b2:	91 e0       	ldi	r25, 0x01	; 1
     8b4:	0e 94 37 11 	call	0x226e	; 0x226e <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     8b8:	e7 ef       	ldi	r30, 0xF7	; 247
     8ba:	f1 e0       	ldi	r31, 0x01	; 1
     8bc:	61 81       	ldd	r22, Z+1	; 0x01
     8be:	6f 71       	andi	r22, 0x1F	; 31
     8c0:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     8c2:	70 e0       	ldi	r23, 0x00	; 0
     8c4:	76 2f       	mov	r23, r22
     8c6:	66 27       	eor	r22, r22
     8c8:	82 81       	ldd	r24, Z+2	; 0x02
     8ca:	68 2b       	or	r22, r24
     8cc:	40 e0       	ldi	r20, 0x00	; 0
     8ce:	ce 01       	movw	r24, r28
     8d0:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <handle_current_sensor>
}
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	08 95       	ret

000008da <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8da:	0f 93       	push	r16
     8dc:	1f 93       	push	r17
     8de:	cf 93       	push	r28
     8e0:	df 93       	push	r29
     8e2:	8c 01       	movw	r16, r24
     8e4:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8e6:	cb 01       	movw	r24, r22
     8e8:	0e 94 52 10 	call	0x20a4	; 0x20a4 <can_read_message_if_new>
     8ec:	88 23       	and	r24, r24
     8ee:	09 f4       	brne	.+2      	; 0x8f2 <handle_can+0x18>
     8f0:	46 c0       	rjmp	.+140    	; 0x97e <handle_can+0xa4>
     8f2:	f8 01       	movw	r30, r16
     8f4:	86 8d       	ldd	r24, Z+30	; 0x1e
     8f6:	84 30       	cpi	r24, 0x04	; 4
     8f8:	09 f4       	brne	.+2      	; 0x8fc <handle_can+0x22>
     8fa:	41 c0       	rjmp	.+130    	; 0x97e <handle_can+0xa4>
		switch (rx->id){
     8fc:	88 81       	ld	r24, Y
     8fe:	99 81       	ldd	r25, Y+1	; 0x01
     900:	80 32       	cpi	r24, 0x20	; 32
     902:	f1 e0       	ldi	r31, 0x01	; 1
     904:	9f 07       	cpc	r25, r31
     906:	91 f1       	breq	.+100    	; 0x96c <handle_can+0x92>
     908:	80 33       	cpi	r24, 0x30	; 48
     90a:	92 40       	sbci	r25, 0x02	; 2
     90c:	c1 f5       	brne	.+112    	; 0x97e <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	f8 01       	movw	r30, r16
     912:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     914:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     916:	82 e3       	ldi	r24, 0x32	; 50
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	93 8f       	std	Z+27, r25	; 0x1b
     91c:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     91e:	8e 81       	ldd	r24, Y+6	; 0x06
     920:	89 30       	cpi	r24, 0x09	; 9
     922:	40 f0       	brcs	.+16     	; 0x934 <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     924:	86 95       	lsr	r24
     926:	86 95       	lsr	r24
     928:	86 95       	lsr	r24
     92a:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     92c:	8e e1       	ldi	r24, 0x1E	; 30
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	95 8f       	std	Z+29, r25	; 0x1d
     932:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     934:	8f 81       	ldd	r24, Y+7	; 0x07
     936:	89 30       	cpi	r24, 0x09	; 9
     938:	88 f0       	brcs	.+34     	; 0x95c <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     93a:	8d 81       	ldd	r24, Y+5	; 0x05
     93c:	9d ec       	ldi	r25, 0xCD	; 205
     93e:	89 9f       	mul	r24, r25
     940:	81 2d       	mov	r24, r1
     942:	11 24       	eor	r1, r1
     944:	86 95       	lsr	r24
     946:	86 95       	lsr	r24
     948:	86 95       	lsr	r24
     94a:	f8 01       	movw	r30, r16
     94c:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     94e:	8e e1       	ldi	r24, 0x1E	; 30
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	95 8f       	std	Z+29, r25	; 0x1d
     954:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     956:	8f 81       	ldd	r24, Y+7	; 0x07
     958:	89 30       	cpi	r24, 0x09	; 9
     95a:	10 f4       	brcc	.+4      	; 0x960 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     95c:	f8 01       	movw	r30, r16
     95e:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     960:	8e 81       	ldd	r24, Y+6	; 0x06
     962:	89 30       	cpi	r24, 0x09	; 9
     964:	60 f4       	brcc	.+24     	; 0x97e <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     966:	f8 01       	movw	r30, r16
     968:	17 8a       	std	Z+23, r1	; 0x17
     96a:	09 c0       	rjmp	.+18     	; 0x97e <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	f8 01       	movw	r30, r16
     970:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     972:	8b 81       	ldd	r24, Y+3	; 0x03
     974:	9c 81       	ldd	r25, Y+4	; 0x04
     976:	96 8b       	std	Z+22, r25	; 0x16
     978:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     97a:	8d 81       	ldd	r24, Y+5	; 0x05
     97c:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	1f 91       	pop	r17
     984:	0f 91       	pop	r16
     986:	08 95       	ret

00000988 <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     988:	0f 93       	push	r16
     98a:	1f 93       	push	r17
     98c:	cf 93       	push	r28
     98e:	df 93       	push	r29
     990:	cd b7       	in	r28, 0x3d	; 61
     992:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     994:	08 eb       	ldi	r16, 0xB8	; 184
     996:	13 e0       	ldi	r17, 0x03	; 3
     998:	80 e5       	ldi	r24, 0x50	; 80
     99a:	92 e0       	ldi	r25, 0x02	; 2
     99c:	f8 01       	movw	r30, r16
     99e:	91 83       	std	Z+1, r25	; 0x01
     9a0:	80 83       	st	Z, r24
	txFrame.length = 8;
     9a2:	88 e0       	ldi	r24, 0x08	; 8
     9a4:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     9a6:	8d a1       	ldd	r24, Y+37	; 0x25
     9a8:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     9aa:	69 85       	ldd	r22, Y+9	; 0x09
     9ac:	7a 85       	ldd	r23, Y+10	; 0x0a
     9ae:	8b 85       	ldd	r24, Y+11	; 0x0b
     9b0:	9c 85       	ldd	r25, Y+12	; 0x0c
     9b2:	20 e0       	ldi	r18, 0x00	; 0
     9b4:	30 e0       	ldi	r19, 0x00	; 0
     9b6:	40 e2       	ldi	r20, 0x20	; 32
     9b8:	51 e4       	ldi	r21, 0x41	; 65
     9ba:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     9be:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     9c2:	f8 01       	movw	r30, r16
     9c4:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     9c6:	69 89       	ldd	r22, Y+17	; 0x11
     9c8:	7a 89       	ldd	r23, Y+18	; 0x12
     9ca:	8b 89       	ldd	r24, Y+19	; 0x13
     9cc:	9c 89       	ldd	r25, Y+20	; 0x14
     9ce:	20 e0       	ldi	r18, 0x00	; 0
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	40 e2       	ldi	r20, 0x20	; 32
     9d4:	51 e4       	ldi	r21, 0x41	; 65
     9d6:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     9da:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     9de:	f8 01       	movw	r30, r16
     9e0:	76 83       	std	Z+6, r23	; 0x06
     9e2:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9e4:	6d 89       	ldd	r22, Y+21	; 0x15
     9e6:	7e 89       	ldd	r23, Y+22	; 0x16
     9e8:	8f 89       	ldd	r24, Y+23	; 0x17
     9ea:	98 8d       	ldd	r25, Y+24	; 0x18
     9ec:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     9f0:	07 2e       	mov	r0, r23
     9f2:	00 0c       	add	r0, r0
     9f4:	88 0b       	sbc	r24, r24
     9f6:	99 0b       	sbc	r25, r25
     9f8:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
     9fc:	20 e0       	ldi	r18, 0x00	; 0
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	48 ec       	ldi	r20, 0xC8	; 200
     a02:	52 e4       	ldi	r21, 0x42	; 66
     a04:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
     a08:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     a0c:	9b 01       	movw	r18, r22
     a0e:	77 23       	and	r23, r23
     a10:	24 f4       	brge	.+8      	; 0xa1a <handle_motor_status_can_msg+0x92>
     a12:	22 27       	eor	r18, r18
     a14:	33 27       	eor	r19, r19
     a16:	26 1b       	sub	r18, r22
     a18:	37 0b       	sbc	r19, r23
     a1a:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     a1e:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     a22:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a24:	7b 8d       	ldd	r23, Y+27	; 0x1b
     a26:	08 eb       	ldi	r16, 0xB8	; 184
     a28:	13 e0       	ldi	r17, 0x03	; 3
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	90 e0       	ldi	r25, 0x00	; 0
     a2e:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     a32:	26 e6       	ldi	r18, 0x66	; 102
     a34:	36 e6       	ldi	r19, 0x66	; 102
     a36:	46 e6       	ldi	r20, 0x66	; 102
     a38:	50 e4       	ldi	r21, 0x40	; 64
     a3a:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	40 e0       	ldi	r20, 0x00	; 0
     a44:	5f e3       	ldi	r21, 0x3F	; 63
     a46:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
     a4a:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
     a4e:	f8 01       	movw	r30, r16
     a50:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a52:	89 8d       	ldd	r24, Y+25	; 0x19
     a54:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a56:	c8 01       	movw	r24, r16
     a58:	0e 94 95 10 	call	0x212a	; 0x212a <can_send_message>
}
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	1f 91       	pop	r17
     a62:	0f 91       	pop	r16
     a64:	08 95       	ret

00000a66 <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a6e:	ed ea       	ldi	r30, 0xAD	; 173
     a70:	f3 e0       	ldi	r31, 0x03	; 3
     a72:	81 e5       	ldi	r24, 0x51	; 81
     a74:	92 e0       	ldi	r25, 0x02	; 2
     a76:	91 83       	std	Z+1, r25	; 0x01
     a78:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a7e:	21 96       	adiw	r28, 0x01	; 1
     a80:	8f ad       	ldd	r24, Y+63	; 0x3f
     a82:	21 97       	sbiw	r28, 0x01	; 1
     a84:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a86:	cf 01       	movw	r24, r30
     a88:	0e 94 95 10 	call	0x212a	; 0x212a <can_send_message>
}
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	08 95       	ret

00000a92 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a92:	6f 92       	push	r6
     a94:	7f 92       	push	r7
     a96:	8f 92       	push	r8
     a98:	9f 92       	push	r9
     a9a:	af 92       	push	r10
     a9c:	bf 92       	push	r11
     a9e:	cf 92       	push	r12
     aa0:	df 92       	push	r13
     aa2:	ef 92       	push	r14
     aa4:	ff 92       	push	r15
     aa6:	0f 93       	push	r16
     aa8:	1f 93       	push	r17
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29
     aae:	cd b7       	in	r28, 0x3d	; 61
     ab0:	de b7       	in	r29, 0x3e	; 62
     ab2:	66 97       	sbiw	r28, 0x16	; 22
     ab4:	0f b6       	in	r0, 0x3f	; 63
     ab6:	f8 94       	cli
     ab8:	de bf       	out	0x3e, r29	; 62
     aba:	0f be       	out	0x3f, r0	; 63
     abc:	cd bf       	out	0x3d, r28	; 61
     abe:	5c 01       	movw	r10, r24
	
	char uart_characters_received[22] = {0};
     ac0:	fe 01       	movw	r30, r28
     ac2:	31 96       	adiw	r30, 0x01	; 1
     ac4:	96 e1       	ldi	r25, 0x16	; 22
     ac6:	df 01       	movw	r26, r30
     ac8:	1d 92       	st	X+, r1
     aca:	9a 95       	dec	r25
     acc:	e9 f7       	brne	.-6      	; 0xac8 <receive_uart+0x36>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     ace:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     ad2:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     ad6:	92 1b       	sub	r25, r18
     ad8:	9f 71       	andi	r25, 0x1F	; 31
     ada:	09 f4       	brne	.+2      	; 0xade <receive_uart+0x4c>
     adc:	70 c1       	rjmp	.+736    	; 0xdbe <receive_uart+0x32c>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     ade:	f5 01       	movw	r30, r10
     ae0:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     ae2:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     ae4:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     ae6:	66 e1       	ldi	r22, 0x16	; 22
     ae8:	ce 01       	movw	r24, r28
     aea:	01 96       	adiw	r24, 0x01	; 1
     aec:	10 d5       	rcall	.+2592   	; 0x150e <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     aee:	ce 01       	movw	r24, r28
     af0:	01 96       	adiw	r24, 0x01	; 1
     af2:	0e 94 bb 13 	call	0x2776	; 0x2776 <atoi>
     af6:	18 2f       	mov	r17, r24
     af8:	88 2e       	mov	r8, r24
     afa:	99 2e       	mov	r9, r25
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     afc:	d5 01       	movw	r26, r10
     afe:	8d 91       	ld	r24, X+
     b00:	9c 91       	ld	r25, X
     b02:	89 2b       	or	r24, r25
     b04:	71 f4       	brne	.+28     	; 0xb22 <receive_uart+0x90>
     b06:	6f e4       	ldi	r22, 0x4F	; 79
     b08:	71 e0       	ldi	r23, 0x01	; 1
     b0a:	ce 01       	movw	r24, r28
     b0c:	01 96       	adiw	r24, 0x01	; 1
     b0e:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     b12:	89 2b       	or	r24, r25
     b14:	31 f4       	brne	.+12     	; 0xb22 <receive_uart+0x90>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     b16:	f5 01       	movw	r30, r10
     b18:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     b1a:	81 e0       	ldi	r24, 0x01	; 1
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	91 83       	std	Z+1, r25	; 0x01
     b20:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     b22:	d5 01       	movw	r26, r10
     b24:	8d 91       	ld	r24, X+
     b26:	9c 91       	ld	r25, X
     b28:	89 2b       	or	r24, r25
     b2a:	71 f0       	breq	.+28     	; 0xb48 <receive_uart+0xb6>
     b2c:	61 e6       	ldi	r22, 0x61	; 97
     b2e:	71 e0       	ldi	r23, 0x01	; 1
     b30:	ce 01       	movw	r24, r28
     b32:	01 96       	adiw	r24, 0x01	; 1
     b34:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     b38:	89 2b       	or	r24, r25
     b3a:	31 f4       	brne	.+12     	; 0xb48 <receive_uart+0xb6>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     b3c:	f5 01       	movw	r30, r10
     b3e:	11 82       	std	Z+1, r1	; 0x01
     b40:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     b42:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b44:	15 8e       	std	Z+29, r1	; 0x1d
     b46:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b48:	62 e7       	ldi	r22, 0x72	; 114
     b4a:	71 e0       	ldi	r23, 0x01	; 1
     b4c:	ce 01       	movw	r24, r28
     b4e:	01 96       	adiw	r24, 0x01	; 1
     b50:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     b54:	89 2b       	or	r24, r25
     b56:	11 f5       	brne	.+68     	; 0xb9c <receive_uart+0x10a>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b58:	d5 01       	movw	r26, r10
     b5a:	94 96       	adiw	r26, 0x24	; 36
     b5c:	1c 92       	st	X, r1
     b5e:	1e 92       	st	-X, r1
     b60:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b62:	da 96       	adiw	r26, 0x3a	; 58
     b64:	8c 91       	ld	r24, X
     b66:	81 30       	cpi	r24, 0x01	; 1
     b68:	51 f0       	breq	.+20     	; 0xb7e <receive_uart+0xec>
     b6a:	18 f0       	brcs	.+6      	; 0xb72 <receive_uart+0xe0>
     b6c:	82 30       	cpi	r24, 0x02	; 2
     b6e:	89 f0       	breq	.+34     	; 0xb92 <receive_uart+0x100>
     b70:	15 c0       	rjmp	.+42     	; 0xb9c <receive_uart+0x10a>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b72:	f5 01       	movw	r30, r10
     b74:	84 a9       	ldd	r24, Z+52	; 0x34
     b76:	95 a9       	ldd	r25, Z+53	; 0x35
     b78:	93 ab       	std	Z+51, r25	; 0x33
     b7a:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b7c:	0f c0       	rjmp	.+30     	; 0xb9c <receive_uart+0x10a>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b7e:	d5 01       	movw	r26, r10
     b80:	d6 96       	adiw	r26, 0x36	; 54
     b82:	8d 91       	ld	r24, X+
     b84:	9c 91       	ld	r25, X
     b86:	d7 97       	sbiw	r26, 0x37	; 55
     b88:	d3 96       	adiw	r26, 0x33	; 51
     b8a:	9c 93       	st	X, r25
     b8c:	8e 93       	st	-X, r24
     b8e:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b90:	05 c0       	rjmp	.+10     	; 0xb9c <receive_uart+0x10a>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b92:	f5 01       	movw	r30, r10
     b94:	80 ad       	ldd	r24, Z+56	; 0x38
     b96:	91 ad       	ldd	r25, Z+57	; 0x39
     b98:	93 ab       	std	Z+51, r25	; 0x33
     b9a:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b9c:	65 e8       	ldi	r22, 0x85	; 133
     b9e:	71 e0       	ldi	r23, 0x01	; 1
     ba0:	ce 01       	movw	r24, r28
     ba2:	01 96       	adiw	r24, 0x01	; 1
     ba4:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     ba8:	89 2b       	or	r24, r25
     baa:	39 f4       	brne	.+14     	; 0xbba <receive_uart+0x128>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	90 e0       	ldi	r25, 0x00	; 0
     bb0:	d5 01       	movw	r26, r10
     bb2:	94 96       	adiw	r26, 0x24	; 36
     bb4:	9c 93       	st	X, r25
     bb6:	8e 93       	st	-X, r24
     bb8:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     bba:	f5 01       	movw	r30, r10
     bbc:	80 81       	ld	r24, Z
     bbe:	91 81       	ldd	r25, Z+1	; 0x01
     bc0:	89 2b       	or	r24, r25
     bc2:	39 f0       	breq	.+14     	; 0xbd2 <receive_uart+0x140>
     bc4:	c4 01       	movw	r24, r8
     bc6:	0b 97       	sbiw	r24, 0x0b	; 11
     bc8:	0a 97       	sbiw	r24, 0x0a	; 10
     bca:	18 f4       	brcc	.+6      	; 0xbd2 <receive_uart+0x140>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     bcc:	86 ef       	ldi	r24, 0xF6	; 246
     bce:	81 0f       	add	r24, r17
     bd0:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     bd2:	d5 01       	movw	r26, r10
     bd4:	8d 91       	ld	r24, X+
     bd6:	9c 91       	ld	r25, X
     bd8:	89 2b       	or	r24, r25
     bda:	41 f0       	breq	.+16     	; 0xbec <receive_uart+0x15a>
     bdc:	ba e0       	ldi	r27, 0x0A	; 10
     bde:	8b 16       	cp	r8, r27
     be0:	91 04       	cpc	r9, r1
     be2:	20 f4       	brcc	.+8      	; 0xbec <receive_uart+0x15a>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     be4:	8a e0       	ldi	r24, 0x0A	; 10
     be6:	81 1b       	sub	r24, r17
     be8:	f5 01       	movw	r30, r10
     bea:	80 8f       	std	Z+24, r24	; 0x18
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     bec:	d5 01       	movw	r26, r10
     bee:	8d 91       	ld	r24, X+
     bf0:	9c 91       	ld	r25, X
     bf2:	11 97       	sbiw	r26, 0x01	; 1
     bf4:	89 2b       	or	r24, r25
     bf6:	61 f0       	breq	.+24     	; 0xc10 <receive_uart+0x17e>
     bf8:	81 14       	cp	r8, r1
     bfa:	91 04       	cpc	r9, r1
     bfc:	49 f4       	brne	.+18     	; 0xc10 <receive_uart+0x17e>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bfe:	57 96       	adiw	r26, 0x17	; 23
     c00:	1c 92       	st	X, r1
     c02:	57 97       	sbiw	r26, 0x17	; 23
			vals->u8_brake_cmd = 0;
     c04:	58 96       	adiw	r26, 0x18	; 24
     c06:	1c 92       	st	X, r1
     c08:	58 97       	sbiw	r26, 0x18	; 24
			vals->u8_duty_cycle = 50;
     c0a:	82 e3       	ldi	r24, 0x32	; 50
     c0c:	59 96       	adiw	r26, 0x19	; 25
     c0e:	8c 93       	st	X, r24
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     c10:	f5 01       	movw	r30, r10
     c12:	83 a1       	ldd	r24, Z+35	; 0x23
     c14:	94 a1       	ldd	r25, Z+36	; 0x24
     c16:	01 97       	sbiw	r24, 0x01	; 1
     c18:	59 f4       	brne	.+22     	; 0xc30 <receive_uart+0x19e>
     c1a:	67 e9       	ldi	r22, 0x97	; 151
     c1c:	71 e0       	ldi	r23, 0x01	; 1
     c1e:	ce 01       	movw	r24, r28
     c20:	01 96       	adiw	r24, 0x01	; 1
     c22:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     c26:	89 2b       	or	r24, r25
     c28:	19 f4       	brne	.+6      	; 0xc30 <receive_uart+0x19e>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     c2a:	d5 01       	movw	r26, r10
     c2c:	db 96       	adiw	r26, 0x3b	; 59
     c2e:	1c 92       	st	X, r1
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     c30:	f5 01       	movw	r30, r10
     c32:	83 a1       	ldd	r24, Z+35	; 0x23
     c34:	94 a1       	ldd	r25, Z+36	; 0x24
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	99 f4       	brne	.+38     	; 0xc60 <receive_uart+0x1ce>
     c3a:	69 e9       	ldi	r22, 0x99	; 153
     c3c:	71 e0       	ldi	r23, 0x01	; 1
     c3e:	ce 01       	movw	r24, r28
     c40:	01 96       	adiw	r24, 0x01	; 1
     c42:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     c46:	89 2b       	or	r24, r25
     c48:	59 f4       	brne	.+22     	; 0xc60 <receive_uart+0x1ce>
		{
			vals->uart_debug = 77;
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	aa e9       	ldi	r26, 0x9A	; 154
     c50:	b2 e4       	ldi	r27, 0x42	; 66
     c52:	f5 01       	movw	r30, r10
     c54:	87 a3       	std	Z+39, r24	; 0x27
     c56:	90 a7       	std	Z+40, r25	; 0x28
     c58:	a1 a7       	std	Z+41, r26	; 0x29
     c5a:	b2 a7       	std	Z+42, r27	; 0x2a
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c60:	d5 01       	movw	r26, r10
     c62:	93 96       	adiw	r26, 0x23	; 35
     c64:	8d 91       	ld	r24, X+
     c66:	9c 91       	ld	r25, X
     c68:	94 97       	sbiw	r26, 0x24	; 36
     c6a:	01 97       	sbiw	r24, 0x01	; 1
     c6c:	59 f4       	brne	.+22     	; 0xc84 <receive_uart+0x1f2>
     c6e:	65 eb       	ldi	r22, 0xB5	; 181
     c70:	71 e0       	ldi	r23, 0x01	; 1
     c72:	ce 01       	movw	r24, r28
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     c7a:	89 2b       	or	r24, r25
     c7c:	19 f4       	brne	.+6      	; 0xc84 <receive_uart+0x1f2>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c7e:	82 e0       	ldi	r24, 0x02	; 2
     c80:	f5 01       	movw	r30, r10
     c82:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c84:	d5 01       	movw	r26, r10
     c86:	93 96       	adiw	r26, 0x23	; 35
     c88:	8d 91       	ld	r24, X+
     c8a:	9c 91       	ld	r25, X
     c8c:	94 97       	sbiw	r26, 0x24	; 36
     c8e:	89 2b       	or	r24, r25
     c90:	59 f4       	brne	.+22     	; 0xca8 <receive_uart+0x216>
     c92:	6b e9       	ldi	r22, 0x9B	; 155
     c94:	71 e0       	ldi	r23, 0x01	; 1
     c96:	ce 01       	movw	r24, r28
     c98:	01 96       	adiw	r24, 0x01	; 1
     c9a:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     c9e:	89 2b       	or	r24, r25
     ca0:	19 f4       	brne	.+6      	; 0xca8 <receive_uart+0x216>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	92 da       	rcall	.-2780   	; 0x1cc <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     ca8:	f5 01       	movw	r30, r10
     caa:	83 a1       	ldd	r24, Z+35	; 0x23
     cac:	94 a1       	ldd	r25, Z+36	; 0x24
     cae:	89 2b       	or	r24, r25
     cb0:	59 f4       	brne	.+22     	; 0xcc8 <receive_uart+0x236>
     cb2:	63 ea       	ldi	r22, 0xA3	; 163
     cb4:	71 e0       	ldi	r23, 0x01	; 1
     cb6:	ce 01       	movw	r24, r28
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     cbe:	89 2b       	or	r24, r25
     cc0:	19 f4       	brne	.+6      	; 0xcc8 <receive_uart+0x236>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	82 da       	rcall	.-2812   	; 0x1cc <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     cc8:	d5 01       	movw	r26, r10
     cca:	93 96       	adiw	r26, 0x23	; 35
     ccc:	8d 91       	ld	r24, X+
     cce:	9c 91       	ld	r25, X
     cd0:	94 97       	sbiw	r26, 0x24	; 36
     cd2:	89 2b       	or	r24, r25
     cd4:	29 f5       	brne	.+74     	; 0xd20 <receive_uart+0x28e>
     cd6:	69 ea       	ldi	r22, 0xA9	; 169
     cd8:	71 e0       	ldi	r23, 0x01	; 1
     cda:	ce 01       	movw	r24, r28
     cdc:	01 96       	adiw	r24, 0x01	; 1
     cde:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     ce2:	89 2b       	or	r24, r25
     ce4:	e9 f4       	brne	.+58     	; 0xd20 <receive_uart+0x28e>
		{
			vals->uart_debug = 77;
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	90 e0       	ldi	r25, 0x00	; 0
     cea:	aa e9       	ldi	r26, 0x9A	; 154
     cec:	b2 e4       	ldi	r27, 0x42	; 66
     cee:	f5 01       	movw	r30, r10
     cf0:	87 a3       	std	Z+39, r24	; 0x27
     cf2:	90 a7       	std	Z+40, r25	; 0x28
     cf4:	a1 a7       	std	Z+41, r26	; 0x29
     cf6:	b2 a7       	std	Z+42, r27	; 0x2a
			vals->gear_required = NEUTRAL;
     cf8:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cfa:	c0 ac       	ldd	r12, Z+56	; 0x38
     cfc:	d1 ac       	ldd	r13, Z+57	; 0x39
     cfe:	e6 a8       	ldd	r14, Z+54	; 0x36
     d00:	f7 a8       	ldd	r15, Z+55	; 0x37
     d02:	04 a9       	ldd	r16, Z+52	; 0x34
     d04:	15 a9       	ldd	r17, Z+53	; 0x35
     d06:	62 a9       	ldd	r22, Z+50	; 0x32
     d08:	73 a9       	ldd	r23, Z+51	; 0x33
     d0a:	72 ac       	ldd	r7, Z+58	; 0x3a
     d0c:	63 ac       	ldd	r6, Z+59	; 0x3b
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
     d16:	9b 01       	movw	r18, r22
     d18:	ac 01       	movw	r20, r24
     d1a:	67 2d       	mov	r22, r7
     d1c:	86 2d       	mov	r24, r6
     d1e:	11 da       	rcall	.-3038   	; 0x142 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     d20:	d5 01       	movw	r26, r10
     d22:	93 96       	adiw	r26, 0x23	; 35
     d24:	8d 91       	ld	r24, X+
     d26:	9c 91       	ld	r25, X
     d28:	94 97       	sbiw	r26, 0x24	; 36
     d2a:	89 2b       	or	r24, r25
     d2c:	c1 f4       	brne	.+48     	; 0xd5e <receive_uart+0x2cc>
     d2e:	67 eb       	ldi	r22, 0xB7	; 183
     d30:	71 e0       	ldi	r23, 0x01	; 1
     d32:	ce 01       	movw	r24, r28
     d34:	01 96       	adiw	r24, 0x01	; 1
     d36:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     d3a:	89 2b       	or	r24, r25
     d3c:	81 f4       	brne	.+32     	; 0xd5e <receive_uart+0x2cc>
		{
			vals->gear_required = GEAR1;
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	f5 01       	movw	r30, r10
     d42:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->f32_actuator_feedback, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d44:	c0 ac       	ldd	r12, Z+56	; 0x38
     d46:	d1 ac       	ldd	r13, Z+57	; 0x39
     d48:	e6 a8       	ldd	r14, Z+54	; 0x36
     d4a:	f7 a8       	ldd	r15, Z+55	; 0x37
     d4c:	04 a9       	ldd	r16, Z+52	; 0x34
     d4e:	15 a9       	ldd	r17, Z+53	; 0x35
     d50:	23 a5       	ldd	r18, Z+43	; 0x2b
     d52:	34 a5       	ldd	r19, Z+44	; 0x2c
     d54:	45 a5       	ldd	r20, Z+45	; 0x2d
     d56:	56 a5       	ldd	r21, Z+46	; 0x2e
     d58:	62 ad       	ldd	r22, Z+58	; 0x3a
     d5a:	83 ad       	ldd	r24, Z+59	; 0x3b
     d5c:	f2 d9       	rcall	.-3100   	; 0x142 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     d5e:	d5 01       	movw	r26, r10
     d60:	93 96       	adiw	r26, 0x23	; 35
     d62:	8d 91       	ld	r24, X+
     d64:	9c 91       	ld	r25, X
     d66:	94 97       	sbiw	r26, 0x24	; 36
     d68:	89 2b       	or	r24, r25
     d6a:	c1 f4       	brne	.+48     	; 0xd9c <receive_uart+0x30a>
     d6c:	67 ec       	ldi	r22, 0xC7	; 199
     d6e:	71 e0       	ldi	r23, 0x01	; 1
     d70:	ce 01       	movw	r24, r28
     d72:	01 96       	adiw	r24, 0x01	; 1
     d74:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <strcmp>
     d78:	89 2b       	or	r24, r25
     d7a:	81 f4       	brne	.+32     	; 0xd9c <receive_uart+0x30a>
		{
			vals->gear_required = GEAR2;
     d7c:	82 e0       	ldi	r24, 0x02	; 2
     d7e:	f5 01       	movw	r30, r10
     d80:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->f32_actuator_feedback, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d82:	c0 ac       	ldd	r12, Z+56	; 0x38
     d84:	d1 ac       	ldd	r13, Z+57	; 0x39
     d86:	e6 a8       	ldd	r14, Z+54	; 0x36
     d88:	f7 a8       	ldd	r15, Z+55	; 0x37
     d8a:	04 a9       	ldd	r16, Z+52	; 0x34
     d8c:	15 a9       	ldd	r17, Z+53	; 0x35
     d8e:	23 a5       	ldd	r18, Z+43	; 0x2b
     d90:	34 a5       	ldd	r19, Z+44	; 0x2c
     d92:	45 a5       	ldd	r20, Z+45	; 0x2d
     d94:	56 a5       	ldd	r21, Z+46	; 0x2e
     d96:	62 ad       	ldd	r22, Z+58	; 0x3a
     d98:	83 ad       	ldd	r24, Z+59	; 0x3b
     d9a:	d3 d9       	rcall	.-3162   	; 0x142 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d9c:	d5 01       	movw	r26, r10
     d9e:	93 96       	adiw	r26, 0x23	; 35
     da0:	8d 91       	ld	r24, X+
     da2:	9c 91       	ld	r25, X
     da4:	94 97       	sbiw	r26, 0x24	; 36
     da6:	89 2b       	or	r24, r25
     da8:	49 f4       	brne	.+18     	; 0xdbc <receive_uart+0x32a>
     daa:	c4 01       	movw	r24, r8
     dac:	01 97       	sbiw	r24, 0x01	; 1
     dae:	87 3e       	cpi	r24, 0xE7	; 231
     db0:	93 40       	sbci	r25, 0x03	; 3
		{
			vals->gear_required = NEUTRAL;
     db2:	20 f4       	brcc	.+8      	; 0xdbc <receive_uart+0x32a>
     db4:	f5 01       	movw	r30, r10
			vals->position_uart_instruction = uart_uint16_received;
     db6:	13 ae       	std	Z+59, r1	; 0x3b
     db8:	93 aa       	std	Z+51, r9	; 0x33
			//uart_flush();
		}
		
		uart_flush();
     dba:	82 aa       	std	Z+50, r8	; 0x32
     dbc:	5e d3       	rcall	.+1724   	; 0x147a <uart0_flush>
	}
}
     dbe:	66 96       	adiw	r28, 0x16	; 22
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	de bf       	out	0x3e, r29	; 62
     dc6:	0f be       	out	0x3f, r0	; 63
     dc8:	cd bf       	out	0x3d, r28	; 61
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	1f 91       	pop	r17
     dd0:	0f 91       	pop	r16
     dd2:	ff 90       	pop	r15
     dd4:	ef 90       	pop	r14
     dd6:	df 90       	pop	r13
     dd8:	cf 90       	pop	r12
     dda:	bf 90       	pop	r11
     ddc:	af 90       	pop	r10
     dde:	9f 90       	pop	r9
     de0:	8f 90       	pop	r8
     de2:	7f 90       	pop	r7
     de4:	6f 90       	pop	r6
     de6:	08 95       	ret

00000de8 <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     de8:	ef 92       	push	r14
     dea:	ff 92       	push	r15
     dec:	0f 93       	push	r16
     dee:	1f 93       	push	r17
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     df8:	88 ed       	ldi	r24, 0xD8	; 216
     dfa:	91 e0       	ldi	r25, 0x01	; 1
     dfc:	0e 94 01 14 	call	0x2802	; 0x2802 <puts>
	printf("%u", vals.gear_required);
     e00:	25 96       	adiw	r28, 0x05	; 5
     e02:	8f ad       	ldd	r24, Y+63	; 0x3f
     e04:	25 97       	sbiw	r28, 0x05	; 5
     e06:	1f 92       	push	r1
     e08:	8f 93       	push	r24
     e0a:	0a ed       	ldi	r16, 0xDA	; 218
     e0c:	11 e0       	ldi	r17, 0x01	; 1
     e0e:	1f 93       	push	r17
     e10:	0f 93       	push	r16
     e12:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e16:	8c e2       	ldi	r24, 0x2C	; 44
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u",vals.gear_status);
     e1e:	24 96       	adiw	r28, 0x04	; 4
     e20:	8f ad       	ldd	r24, Y+63	; 0x3f
     e22:	24 97       	sbiw	r28, 0x04	; 4
     e24:	1f 92       	push	r1
     e26:	8f 93       	push	r24
     e28:	1f 93       	push	r17
     e2a:	0f 93       	push	r16
     e2c:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e30:	8c e2       	ldi	r24, 0x2C	; 44
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u", vals.motor_status);
     e38:	8f a1       	ldd	r24, Y+39	; 0x27
     e3a:	1f 92       	push	r1
     e3c:	8f 93       	push	r24
     e3e:	1f 93       	push	r17
     e40:	0f 93       	push	r16
     e42:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e46:	8c e2       	ldi	r24, 0x2C	; 44
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u",vals.message_mode);
     e4e:	88 a5       	ldd	r24, Y+40	; 0x28
     e50:	1f 92       	push	r1
     e52:	8f 93       	push	r24
     e54:	1f 93       	push	r17
     e56:	0f 93       	push	r16
     e58:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e5c:	8c e2       	ldi	r24, 0x2C	; 44
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u",vals.u8_duty_cycle);
     e64:	8a a1       	ldd	r24, Y+34	; 0x22
     e66:	1f 92       	push	r1
     e68:	8f 93       	push	r24
     e6a:	1f 93       	push	r17
     e6c:	0f 93       	push	r16
     e6e:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e72:	8c e2       	ldi	r24, 0x2C	; 44
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e7a:	6b 89       	ldd	r22, Y+19	; 0x13
     e7c:	7c 89       	ldd	r23, Y+20	; 0x14
     e7e:	8d 89       	ldd	r24, Y+21	; 0x15
     e80:	9e 89       	ldd	r25, Y+22	; 0x16
     e82:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     e86:	7f 93       	push	r23
     e88:	6f 93       	push	r22
     e8a:	0f 2e       	mov	r0, r31
     e8c:	fd ed       	ldi	r31, 0xDD	; 221
     e8e:	ef 2e       	mov	r14, r31
     e90:	f1 e0       	ldi	r31, 0x01	; 1
     e92:	ff 2e       	mov	r15, r31
     e94:	f0 2d       	mov	r31, r0
     e96:	ff 92       	push	r15
     e98:	ef 92       	push	r14
     e9a:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     e9e:	8c e2       	ldi	r24, 0x2C	; 44
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     ea6:	6c a9       	ldd	r22, Y+52	; 0x34
     ea8:	7d a9       	ldd	r23, Y+53	; 0x35
     eaa:	8e a9       	ldd	r24, Y+54	; 0x36
     eac:	9f a9       	ldd	r25, Y+55	; 0x37
     eae:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     eb2:	7f 93       	push	r23
     eb4:	6f 93       	push	r22
     eb6:	ff 92       	push	r15
     eb8:	ef 92       	push	r14
     eba:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     ebe:	8c e2       	ldi	r24, 0x2C	; 44
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     ec6:	89 85       	ldd	r24, Y+9	; 0x09
     ec8:	9a 85       	ldd	r25, Y+10	; 0x0a
     eca:	9f 93       	push	r25
     ecc:	8f 93       	push	r24
     ece:	ff 92       	push	r15
     ed0:	ef 92       	push	r14
     ed2:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     ed6:	0f b6       	in	r0, 0x3f	; 63
     ed8:	f8 94       	cli
     eda:	de bf       	out	0x3e, r29	; 62
     edc:	0f be       	out	0x3f, r0	; 63
     ede:	cd bf       	out	0x3d, r28	; 61
     ee0:	8c e2       	ldi	r24, 0x2C	; 44
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%i",vals.clutch_enabled);
     ee8:	8c a5       	ldd	r24, Y+44	; 0x2c
     eea:	9d a5       	ldd	r25, Y+45	; 0x2d
     eec:	9f 93       	push	r25
     eee:	8f 93       	push	r24
     ef0:	ff 92       	push	r15
     ef2:	ef 92       	push	r14
     ef4:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     ef8:	8c e2       	ldi	r24, 0x2C	; 44
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u",vals.position_neutral);
     f00:	8d ad       	ldd	r24, Y+61	; 0x3d
     f02:	9e ad       	ldd	r25, Y+62	; 0x3e
     f04:	9f 93       	push	r25
     f06:	8f 93       	push	r24
     f08:	1f 93       	push	r17
     f0a:	0f 93       	push	r16
     f0c:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     f10:	8c e2       	ldi	r24, 0x2C	; 44
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	printf("%u",vals.position_gear_1);
     f18:	21 96       	adiw	r28, 0x01	; 1
     f1a:	8e ad       	ldd	r24, Y+62	; 0x3e
     f1c:	9f ad       	ldd	r25, Y+63	; 0x3f
     f1e:	21 97       	sbiw	r28, 0x01	; 1
     f20:	9f 93       	push	r25
     f22:	8f 93       	push	r24
     f24:	1f 93       	push	r17
     f26:	0f 93       	push	r16
     f28:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	printf(",");
     f2c:	8c e2       	ldi	r24, 0x2C	; 44
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <putchar>
	//printf("%u",vals.position_gear_2);	
	//printf(",");
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     f34:	88 ad       	ldd	r24, Y+56	; 0x38
     f36:	1f 92       	push	r1
     f38:	8f 93       	push	r24
     f3a:	ff 92       	push	r15
     f3c:	ef 92       	push	r14
     f3e:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	//printf(",");
	printf("%i", (int16_t)vals.uart_debug);
     f42:	68 a9       	ldd	r22, Y+48	; 0x30
     f44:	79 a9       	ldd	r23, Y+49	; 0x31
     f46:	8a a9       	ldd	r24, Y+50	; 0x32
     f48:	9b a9       	ldd	r25, Y+51	; 0x33
     f4a:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
     f4e:	7f 93       	push	r23
     f50:	6f 93       	push	r22
     f52:	ff 92       	push	r15
     f54:	ef 92       	push	r14
     f56:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <printf>
	
}
     f5a:	0f b6       	in	r0, 0x3f	; 63
     f5c:	f8 94       	cli
     f5e:	de bf       	out	0x3e, r29	; 62
     f60:	0f be       	out	0x3f, r0	; 63
     f62:	cd bf       	out	0x3d, r28	; 61
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	ff 90       	pop	r15
     f6e:	ef 90       	pop	r14
     f70:	08 95       	ret

00000f72 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	cd b7       	in	r28, 0x3d	; 61
     f78:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f7a:	8b a1       	ldd	r24, Y+35	; 0x23
     f7c:	82 30       	cpi	r24, 0x02	; 2
     f7e:	91 f1       	breq	.+100    	; 0xfe4 <manage_LEDs+0x72>
     f80:	28 f4       	brcc	.+10     	; 0xf8c <manage_LEDs+0x1a>
     f82:	88 23       	and	r24, r24
     f84:	49 f0       	breq	.+18     	; 0xf98 <manage_LEDs+0x26>
     f86:	81 30       	cpi	r24, 0x01	; 1
     f88:	19 f1       	breq	.+70     	; 0xfd0 <manage_LEDs+0x5e>
     f8a:	49 c0       	rjmp	.+146    	; 0x101e <manage_LEDs+0xac>
     f8c:	84 30       	cpi	r24, 0x04	; 4
     f8e:	f1 f1       	breq	.+124    	; 0x100c <manage_LEDs+0x9a>
     f90:	98 f1       	brcs	.+102    	; 0xff8 <manage_LEDs+0x86>
     f92:	85 30       	cpi	r24, 0x05	; 5
     f94:	99 f0       	breq	.+38     	; 0xfbc <manage_LEDs+0x4a>
     f96:	43 c0       	rjmp	.+134    	; 0x101e <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f98:	80 e4       	ldi	r24, 0x40	; 64
     f9a:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f9e:	80 e8       	ldi	r24, 0x80	; 128
     fa0:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     fa4:	8f 8d       	ldd	r24, Y+31	; 0x1f
     fa6:	98 a1       	ldd	r25, Y+32	; 0x20
     fa8:	89 2b       	or	r24, r25
     faa:	21 f4       	brne	.+8      	; 0xfb4 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     fac:	80 e2       	ldi	r24, 0x20	; 32
     fae:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
     fb2:	35 c0       	rjmp	.+106    	; 0x101e <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     fb4:	80 e2       	ldi	r24, 0x20	; 32
     fb6:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
     fba:	31 c0       	rjmp	.+98     	; 0x101e <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     fbc:	80 e2       	ldi	r24, 0x20	; 32
     fbe:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fc2:	80 e4       	ldi	r24, 0x40	; 64
     fc4:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     fc8:	80 e8       	ldi	r24, 0x80	; 128
     fca:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
		break ;
     fce:	27 c0       	rjmp	.+78     	; 0x101e <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     fd0:	80 e2       	ldi	r24, 0x20	; 32
     fd2:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fd6:	80 e8       	ldi	r24, 0x80	; 128
     fd8:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fdc:	80 e4       	ldi	r24, 0x40	; 64
     fde:	0e 94 22 11 	call	0x2244	; 0x2244 <rgbled_toggle>
		break;
     fe2:	1d c0       	rjmp	.+58     	; 0x101e <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     fe4:	80 e8       	ldi	r24, 0x80	; 128
     fe6:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fea:	80 e4       	ldi	r24, 0x40	; 64
     fec:	0e 94 22 11 	call	0x2244	; 0x2244 <rgbled_toggle>
			rgbled_toggle(LED_RED);
     ff0:	80 e2       	ldi	r24, 0x20	; 32
     ff2:	0e 94 22 11 	call	0x2244	; 0x2244 <rgbled_toggle>
		break;
     ff6:	13 c0       	rjmp	.+38     	; 0x101e <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     ff8:	80 e2       	ldi	r24, 0x20	; 32
     ffa:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     ffe:	80 e8       	ldi	r24, 0x80	; 128
    1000:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
    1004:	80 e4       	ldi	r24, 0x40	; 64
    1006:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
		break;
    100a:	09 c0       	rjmp	.+18     	; 0x101e <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
    100c:	80 e4       	ldi	r24, 0x40	; 64
    100e:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
    1012:	80 e8       	ldi	r24, 0x80	; 128
    1014:	0e 94 13 11 	call	0x2226	; 0x2226 <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
    1018:	80 e2       	ldi	r24, 0x20	; 32
    101a:	0e 94 1d 11 	call	0x223a	; 0x223a <rgbled_turn_on>
		break;
	}
    101e:	df 91       	pop	r29
    1020:	cf 91       	pop	r28
    1022:	08 95       	ret

00001024 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
    1024:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
    1026:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
    1028:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
    102a:	e9 e6       	ldi	r30, 0x69	; 105
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	80 81       	ld	r24, Z
    1030:	84 60       	ori	r24, 0x04	; 4
    1032:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
    1034:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
    1036:	e9 9a       	sbi	0x1d, 1	; 29
    1038:	08 95       	ret

0000103a <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
    103a:	0f 93       	push	r16
    103c:	1f 93       	push	r17
    103e:	cf 93       	push	r28
    1040:	df 93       	push	r29
	
	if (*u16_counter > 70)
    1042:	fb 01       	movw	r30, r22
    1044:	20 81       	ld	r18, Z
    1046:	31 81       	ldd	r19, Z+1	; 0x01
    1048:	27 34       	cpi	r18, 0x47	; 71
    104a:	31 05       	cpc	r19, r1
    104c:	b8 f0       	brcs	.+46     	; 0x107c <handle_speed_sensor+0x42>
    104e:	eb 01       	movw	r28, r22
    1050:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    1052:	60 81       	ld	r22, Z
    1054:	71 81       	ldd	r23, Z+1	; 0x01
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
    105e:	9b 01       	movw	r18, r22
    1060:	ac 01       	movw	r20, r24
    1062:	60 e0       	ldi	r22, 0x00	; 0
    1064:	76 e7       	ldi	r23, 0x76	; 118
    1066:	88 e8       	ldi	r24, 0x88	; 136
    1068:	96 e4       	ldi	r25, 0x46	; 70
    106a:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
    106e:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
    1072:	f8 01       	movw	r30, r16
    1074:	71 83       	std	Z+1, r23	; 0x01
    1076:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    1078:	19 82       	std	Y+1, r1	; 0x01
    107a:	18 82       	st	Y, r1
	}	
}
    107c:	df 91       	pop	r29
    107e:	cf 91       	pop	r28
    1080:	1f 91       	pop	r17
    1082:	0f 91       	pop	r16
    1084:	08 95       	ret

00001086 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    1086:	cf 92       	push	r12
    1088:	df 92       	push	r13
    108a:	ef 92       	push	r14
    108c:	ff 92       	push	r15
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	1f 92       	push	r1
    1094:	cd b7       	in	r28, 0x3d	; 61
    1096:	de b7       	in	r29, 0x3e	; 62
    1098:	89 83       	std	Y+1, r24	; 0x01
    109a:	69 01       	movw	r12, r18
    109c:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    109e:	61 30       	cpi	r22, 0x01	; 1
    10a0:	19 f5       	brne	.+70     	; 0x10e8 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    10a2:	69 81       	ldd	r22, Y+1	; 0x01
    10a4:	70 e0       	ldi	r23, 0x00	; 0
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
    10ae:	22 e1       	ldi	r18, 0x12	; 18
    10b0:	35 e8       	ldi	r19, 0x85	; 133
    10b2:	41 e6       	ldi	r20, 0x61	; 97
    10b4:	5e e3       	ldi	r21, 0x3E	; 62
    10b6:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    10ba:	a7 01       	movw	r20, r14
    10bc:	96 01       	movw	r18, r12
    10be:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
    10c2:	20 e0       	ldi	r18, 0x00	; 0
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	48 ec       	ldi	r20, 0xC8	; 200
    10c8:	52 e4       	ldi	r21, 0x42	; 66
    10ca:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    10ce:	20 e0       	ldi	r18, 0x00	; 0
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	48 e4       	ldi	r20, 0x48	; 72
    10d4:	52 e4       	ldi	r21, 0x42	; 66
    10d6:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
    10da:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
    10de:	86 2f       	mov	r24, r22
		if (Duty == 50)
    10e0:	62 33       	cpi	r22, 0x32	; 50
    10e2:	29 f5       	brne	.+74     	; 0x112e <__stack+0x2f>
		{
			Duty = 52 ;
    10e4:	84 e3       	ldi	r24, 0x34	; 52
    10e6:	23 c0       	rjmp	.+70     	; 0x112e <__stack+0x2f>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    10e8:	62 30       	cpi	r22, 0x02	; 2
    10ea:	01 f5       	brne	.+64     	; 0x112c <__stack+0x2d>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    10ec:	69 81       	ldd	r22, Y+1	; 0x01
    10ee:	70 e0       	ldi	r23, 0x00	; 0
    10f0:	80 e0       	ldi	r24, 0x00	; 0
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	0e 94 9b 12 	call	0x2536	; 0x2536 <__floatsisf>
    10f8:	23 ee       	ldi	r18, 0xE3	; 227
    10fa:	3e ee       	ldi	r19, 0xEE	; 238
    10fc:	4b e3       	ldi	r20, 0x3B	; 59
    10fe:	5e e3       	ldi	r21, 0x3E	; 62
    1100:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    1104:	a7 01       	movw	r20, r14
    1106:	96 01       	movw	r18, r12
    1108:	0e 94 00 12 	call	0x2400	; 0x2400 <__divsf3>
    110c:	20 e0       	ldi	r18, 0x00	; 0
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	48 ec       	ldi	r20, 0xC8	; 200
    1112:	52 e4       	ldi	r21, 0x42	; 66
    1114:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	48 e4       	ldi	r20, 0x48	; 72
    111e:	52 e4       	ldi	r21, 0x42	; 66
    1120:	0e 94 98 11 	call	0x2330	; 0x2330 <__addsf3>
    1124:	0e 94 6d 12 	call	0x24da	; 0x24da <__fixunssfsi>
    1128:	86 2f       	mov	r24, r22
    112a:	01 c0       	rjmp	.+2      	; 0x112e <__stack+0x2f>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    112c:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    112e:	0f 90       	pop	r0
    1130:	df 91       	pop	r29
    1132:	cf 91       	pop	r28
    1134:	ff 90       	pop	r15
    1136:	ef 90       	pop	r14
    1138:	df 90       	pop	r13
    113a:	cf 90       	pop	r12
    113c:	08 95       	ret

0000113e <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    1144:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1146:	81 11       	cpse	r24, r1
    1148:	08 c0       	rjmp	.+16     	; 0x115a <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    114a:	82 e3       	ldi	r24, 0x32	; 50
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	9b 8f       	std	Y+27, r25	; 0x1b
    1150:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    1152:	8e e1       	ldi	r24, 0x1E	; 30
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	9d 8f       	std	Y+29, r25	; 0x1d
    1158:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    115a:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    115e:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    1162:	00 97       	sbiw	r24, 0x00	; 0
    1164:	31 f0       	breq	.+12     	; 0x1172 <state_handler+0x34>
	{
		fault_timeout -- ;
    1166:	01 97       	sbiw	r24, 0x01	; 1
    1168:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    116c:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    1170:	05 c0       	rjmp	.+10     	; 0x117c <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    1172:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1176:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1178:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    117c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    117e:	82 30       	cpi	r24, 0x02	; 2
    1180:	09 f4       	brne	.+2      	; 0x1184 <state_handler+0x46>
    1182:	b7 c0       	rjmp	.+366    	; 0x12f2 <state_handler+0x1b4>
    1184:	30 f4       	brcc	.+12     	; 0x1192 <state_handler+0x54>
    1186:	88 23       	and	r24, r24
    1188:	61 f0       	breq	.+24     	; 0x11a2 <state_handler+0x64>
    118a:	81 30       	cpi	r24, 0x01	; 1
    118c:	09 f4       	brne	.+2      	; 0x1190 <state_handler+0x52>
    118e:	8f c0       	rjmp	.+286    	; 0x12ae <state_handler+0x170>
    1190:	e1 c0       	rjmp	.+450    	; 0x1354 <state_handler+0x216>
    1192:	84 30       	cpi	r24, 0x04	; 4
    1194:	09 f4       	brne	.+2      	; 0x1198 <state_handler+0x5a>
    1196:	cf c0       	rjmp	.+414    	; 0x1336 <state_handler+0x1f8>
    1198:	a0 f0       	brcs	.+40     	; 0x11c2 <state_handler+0x84>
    119a:	85 30       	cpi	r24, 0x05	; 5
    119c:	09 f4       	brne	.+2      	; 0x11a0 <state_handler+0x62>
    119e:	51 c0       	rjmp	.+162    	; 0x1242 <state_handler+0x104>
    11a0:	d9 c0       	rjmp	.+434    	; 0x1354 <state_handler+0x216>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    11a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11a4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    11a6:	89 2b       	or	r24, r25
    11a8:	11 f0       	breq	.+4      	; 0x11ae <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    11aa:	83 e0       	ldi	r24, 0x03	; 3
    11ac:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    11ae:	80 e0       	ldi	r24, 0x00	; 0
    11b0:	99 da       	rcall	.-2766   	; 0x6e4 <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    11b2:	18 a2       	std	Y+32, r1	; 0x20
    11b4:	24 d9       	rcall	.-3512   	; 0x3fe <reset_I>
			vals->u8_brake_cmd = 0;
    11b6:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    11b8:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    11ba:	82 e3       	ldi	r24, 0x32	; 50
    11bc:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    11be:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    11c0:	c9 c0       	rjmp	.+402    	; 0x1354 <state_handler+0x216>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    11c2:	8a a1       	ldd	r24, Y+34	; 0x22
    11c4:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    11c6:	24 c0       	rjmp	.+72     	; 0x1210 <state_handler+0xd2>
    11c8:	8d da       	rcall	.-2790   	; 0x6e4 <drivers>
				reset_I();
    11ca:	19 d9       	rcall	.-3534   	; 0x3fe <reset_I>
    11cc:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    11ce:	89 8f       	std	Y+25, r24	; 0x19
    11d0:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    11d2:	88 23       	and	r24, r24
    11d4:	69 f0       	breq	.+26     	; 0x11f0 <state_handler+0xb2>
    11d6:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11d8:	3b 85       	ldd	r19, Y+11	; 0x0b
    11da:	4c 85       	ldd	r20, Y+12	; 0x0c
    11dc:	5d 85       	ldd	r21, Y+13	; 0x0d
    11de:	8b 89       	ldd	r24, Y+19	; 0x13
    11e0:	9c 89       	ldd	r25, Y+20	; 0x14
    11e2:	62 e0       	ldi	r22, 0x02	; 2
    11e4:	50 df       	rcall	.-352    	; 0x1086 <compute_synch_duty>
    11e6:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11e8:	89 8d       	ldd	r24, Y+25	; 0x19
    11ea:	12 d9       	rcall	.-3548   	; 0x410 <set_I>
    11ec:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    11ee:	8e 8f       	std	Y+30, r24	; 0x1e
    11f0:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11f2:	88 23       	and	r24, r24
    11f4:	69 f0       	breq	.+26     	; 0x1210 <state_handler+0xd2>
    11f6:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11f8:	3b 85       	ldd	r19, Y+11	; 0x0b
    11fa:	4c 85       	ldd	r20, Y+12	; 0x0c
    11fc:	5d 85       	ldd	r21, Y+13	; 0x0d
    11fe:	8b 89       	ldd	r24, Y+19	; 0x13
    1200:	9c 89       	ldd	r25, Y+20	; 0x14
    1202:	62 e0       	ldi	r22, 0x02	; 2
    1204:	40 df       	rcall	.-384    	; 0x1086 <compute_synch_duty>
    1206:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    1208:	89 8d       	ldd	r24, Y+25	; 0x19
    120a:	02 d9       	rcall	.-3580   	; 0x410 <set_I>
    120c:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    120e:	8e 8f       	std	Y+30, r24	; 0x1e
    1210:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    1212:	81 30       	cpi	r24, 0x01	; 1
    1214:	09 f0       	breq	.+2      	; 0x1218 <state_handler+0xda>
    1216:	9e c0       	rjmp	.+316    	; 0x1354 <state_handler+0x216>
    1218:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    121a:	81 11       	cpse	r24, r1
    121c:	03 c0       	rjmp	.+6      	; 0x1224 <state_handler+0xe6>
    121e:	88 8d       	ldd	r24, Y+24	; 0x18
    1220:	88 23       	and	r24, r24
    1222:	41 f0       	breq	.+16     	; 0x1234 <state_handler+0xf6>
    1224:	8a ad       	ldd	r24, Y+58	; 0x3a
    1226:	81 11       	cpse	r24, r1
    1228:	05 c0       	rjmp	.+10     	; 0x1234 <state_handler+0xf6>
				{
					vals->motor_status = ENGAGE;
    122a:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    122c:	8e 8f       	std	Y+30, r24	; 0x1e
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	56 da       	rcall	.-2900   	; 0x6e4 <drivers>
				vals->gear_required = NEUTRAL ;
    1238:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    123a:	e1 d8       	rcall	.-3646   	; 0x3fe <reset_I>
    123c:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    123e:	89 8f       	std	Y+25, r24	; 0x19
    1240:	89 c0       	rjmp	.+274    	; 0x1354 <state_handler+0x216>
    1242:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    1244:	8b af       	std	Y+59, r24	; 0x3b
    1246:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    124a:	88 23       	and	r24, r24
    124c:	69 f0       	breq	.+26     	; 0x1268 <state_handler+0x12a>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    124e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1250:	3b 85       	ldd	r19, Y+11	; 0x0b
    1252:	4c 85       	ldd	r20, Y+12	; 0x0c
    1254:	5d 85       	ldd	r21, Y+13	; 0x0d
    1256:	6b ad       	ldd	r22, Y+59	; 0x3b
    1258:	8b 89       	ldd	r24, Y+19	; 0x13
    125a:	9c 89       	ldd	r25, Y+20	; 0x14
    125c:	14 df       	rcall	.-472    	; 0x1086 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    125e:	89 8f       	std	Y+25, r24	; 0x19
    1260:	89 8d       	ldd	r24, Y+25	; 0x19
    1262:	d6 d8       	rcall	.-3668   	; 0x410 <set_I>
				starting_engage = 0;
    1264:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    126c:	ce 01       	movw	r24, r28
    126e:	eb d8       	rcall	.-3626   	; 0x446 <controller>
    1270:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1272:	38 da       	rcall	.-2960   	; 0x6e4 <drivers>
    1274:	88 8d       	ldd	r24, Y+24	; 0x18
    1276:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1278:	29 f0       	breq	.+10     	; 0x1284 <state_handler+0x146>
    127a:	8a ad       	ldd	r24, Y+58	; 0x3a
    127c:	81 30       	cpi	r24, 0x01	; 1
    127e:	11 f4       	brne	.+4      	; 0x1284 <state_handler+0x146>
    1280:	82 e0       	ldi	r24, 0x02	; 2
    1282:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    1284:	8f 89       	ldd	r24, Y+23	; 0x17
    1286:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1288:	21 f0       	breq	.+8      	; 0x1292 <state_handler+0x154>
    128a:	8a ad       	ldd	r24, Y+58	; 0x3a
    128c:	81 30       	cpi	r24, 0x01	; 1
    128e:	09 f4       	brne	.+2      	; 0x1292 <state_handler+0x154>
    1290:	8e 8f       	std	Y+30, r24	; 0x1e
    1292:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    1294:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1296:	5e c0       	rjmp	.+188    	; 0x1354 <state_handler+0x216>
    1298:	88 8d       	ldd	r24, Y+24	; 0x18
    129a:	81 11       	cpse	r24, r1
    129c:	5b c0       	rjmp	.+182    	; 0x1354 <state_handler+0x216>
    129e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12a0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12a2:	89 2b       	or	r24, r25
    12a4:	09 f0       	breq	.+2      	; 0x12a8 <state_handler+0x16a>
    12a6:	56 c0       	rjmp	.+172    	; 0x1354 <state_handler+0x216>
			{
				vals->motor_status = IDLE;
    12a8:	83 e0       	ldi	r24, 0x03	; 3
    12aa:	8e 8f       	std	Y+30, r24	; 0x1e
    12ac:	53 c0       	rjmp	.+166    	; 0x1354 <state_handler+0x216>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    12ae:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    12b0:	ce 01       	movw	r24, r28
    12b2:	c9 d8       	rcall	.-3694   	; 0x446 <controller>
    12b4:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12b6:	16 da       	rcall	.-3028   	; 0x6e4 <drivers>
    12b8:	8f 89       	ldd	r24, Y+23	; 0x17
    12ba:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12bc:	06 c0       	rjmp	.+12     	; 0x12ca <state_handler+0x18c>
    12be:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12c0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12c2:	89 2b       	or	r24, r25
    12c4:	11 f4       	brne	.+4      	; 0x12ca <state_handler+0x18c>
    12c6:	83 e0       	ldi	r24, 0x03	; 3
    12c8:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12ca:	8a a1       	ldd	r24, Y+34	; 0x22
    12cc:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12ce:	41 f4       	brne	.+16     	; 0x12e0 <state_handler+0x1a2>
    12d0:	8a ad       	ldd	r24, Y+58	; 0x3a
    12d2:	81 11       	cpse	r24, r1
    12d4:	05 c0       	rjmp	.+10     	; 0x12e0 <state_handler+0x1a2>
    12d6:	85 e0       	ldi	r24, 0x05	; 5
    12d8:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12da:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    12dc:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    12e0:	88 8d       	ldd	r24, Y+24	; 0x18
    12e2:	88 23       	and	r24, r24
    12e4:	b9 f1       	breq	.+110    	; 0x1354 <state_handler+0x216>
    12e6:	8f 89       	ldd	r24, Y+23	; 0x17
    12e8:	81 11       	cpse	r24, r1
    12ea:	34 c0       	rjmp	.+104    	; 0x1354 <state_handler+0x216>
			{
				vals->motor_status = BRAKE;
    12ec:	82 e0       	ldi	r24, 0x02	; 2
    12ee:	8e 8f       	std	Y+30, r24	; 0x1e
    12f0:	31 c0       	rjmp	.+98     	; 0x1354 <state_handler+0x216>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12f2:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12f4:	ce 01       	movw	r24, r28
    12f6:	a7 d8       	rcall	.-3762   	; 0x446 <controller>
    12f8:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12fa:	f4 d9       	rcall	.-3096   	; 0x6e4 <drivers>
    12fc:	88 8d       	ldd	r24, Y+24	; 0x18
    12fe:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1300:	06 c0       	rjmp	.+12     	; 0x130e <state_handler+0x1d0>
    1302:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1304:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1306:	89 2b       	or	r24, r25
    1308:	11 f4       	brne	.+4      	; 0x130e <state_handler+0x1d0>
    130a:	83 e0       	ldi	r24, 0x03	; 3
    130c:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    130e:	8a a1       	ldd	r24, Y+34	; 0x22
    1310:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    1312:	41 f4       	brne	.+16     	; 0x1324 <state_handler+0x1e6>
    1314:	8a ad       	ldd	r24, Y+58	; 0x3a
    1316:	81 11       	cpse	r24, r1
    1318:	05 c0       	rjmp	.+10     	; 0x1324 <state_handler+0x1e6>
    131a:	85 e0       	ldi	r24, 0x05	; 5
    131c:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    131e:	81 e0       	ldi	r24, 0x01	; 1
    1320:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    1324:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    1326:	81 11       	cpse	r24, r1
    1328:	15 c0       	rjmp	.+42     	; 0x1354 <state_handler+0x216>
    132a:	8f 89       	ldd	r24, Y+23	; 0x17
    132c:	88 23       	and	r24, r24
    132e:	91 f0       	breq	.+36     	; 0x1354 <state_handler+0x216>
			{
				vals->motor_status = ACCEL;
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	8e 8f       	std	Y+30, r24	; 0x1e
    1334:	0f c0       	rjmp	.+30     	; 0x1354 <state_handler+0x216>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1336:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    133a:	81 11       	cpse	r24, r1
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <state_handler+0x204>
			{
				vals->motor_status = IDLE;
    133e:	83 e0       	ldi	r24, 0x03	; 3
    1340:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	cf d9       	rcall	.-3170   	; 0x6e4 <drivers>
    1346:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    1348:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    134a:	59 d8       	rcall	.-3918   	; 0x3fe <reset_I>
			reset_I(); //reset integrator
    134c:	18 8e       	std	Y+24, r1	; 0x18
    134e:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    1350:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    1352:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    1354:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1356:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1358:	49 f0       	breq	.+18     	; 0x136c <state_handler+0x22e>
    135a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    135c:	81 30       	cpi	r24, 0x01	; 1
    135e:	31 f0       	breq	.+12     	; 0x136c <state_handler+0x22e>
    1360:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	19 f0       	breq	.+6      	; 0x136c <state_handler+0x22e>
    1366:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1368:	85 30       	cpi	r24, 0x05	; 5
    136a:	29 f4       	brne	.+10     	; 0x1376 <state_handler+0x238>
    136c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    136e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1370:	89 2b       	or	r24, r25
    1372:	09 f4       	brne	.+2      	; 0x1376 <state_handler+0x238>
    1374:	1e 8e       	std	Y+30, r1	; 0x1e
    1376:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1378:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    137a:	08 95       	ret

0000137c <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    1380:	8e b1       	in	r24, 0x0e	; 14
    1382:	87 7c       	andi	r24, 0xC7	; 199
    1384:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1386:	8d b1       	in	r24, 0x0d	; 13
    1388:	88 63       	ori	r24, 0x38	; 56
    138a:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    138c:	a1 e9       	ldi	r26, 0x91	; 145
    138e:	b0 e0       	ldi	r27, 0x00	; 0
    1390:	8c 91       	ld	r24, X
    1392:	80 61       	ori	r24, 0x10	; 16
    1394:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    1396:	8c 91       	ld	r24, X
    1398:	87 7f       	andi	r24, 0xF7	; 247
    139a:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    139c:	e0 e9       	ldi	r30, 0x90	; 144
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	80 81       	ld	r24, Z
    13a2:	82 60       	ori	r24, 0x02	; 2
    13a4:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    13a6:	80 81       	ld	r24, Z
    13a8:	8e 7f       	andi	r24, 0xFE	; 254
    13aa:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    13ac:	80 81       	ld	r24, Z
    13ae:	80 68       	ori	r24, 0x80	; 128
    13b0:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    13b2:	80 81       	ld	r24, Z
    13b4:	8f 7b       	andi	r24, 0xBF	; 191
    13b6:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    13b8:	80 81       	ld	r24, Z
    13ba:	80 62       	ori	r24, 0x20	; 32
    13bc:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    13be:	80 81       	ld	r24, Z
    13c0:	8f 7e       	andi	r24, 0xEF	; 239
    13c2:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    13c4:	80 81       	ld	r24, Z
    13c6:	88 60       	ori	r24, 0x08	; 8
    13c8:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    13ca:	80 81       	ld	r24, Z
    13cc:	8b 7f       	andi	r24, 0xFB	; 251
    13ce:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    13d0:	8c 91       	ld	r24, X
    13d2:	81 60       	ori	r24, 0x01	; 1
    13d4:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    13d6:	8c 91       	ld	r24, X
    13d8:	89 7f       	andi	r24, 0xF9	; 249
    13da:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    13dc:	c6 e9       	ldi	r28, 0x96	; 150
    13de:	d0 e0       	ldi	r29, 0x00	; 0
    13e0:	85 e8       	ldi	r24, 0x85	; 133
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	99 83       	std	Y+1, r25	; 0x01
    13e6:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    13e8:	68 81       	ld	r22, Y
    13ea:	79 81       	ldd	r23, Y+1	; 0x01
    13ec:	80 e0       	ldi	r24, 0x00	; 0
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
    13f4:	20 e0       	ldi	r18, 0x00	; 0
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	40 e0       	ldi	r20, 0x00	; 0
    13fa:	5f e3       	ldi	r21, 0x3F	; 63
    13fc:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    1400:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
    1404:	e8 e9       	ldi	r30, 0x98	; 152
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	71 83       	std	Z+1, r23	; 0x01
    140a:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    140c:	88 81       	ld	r24, Y
    140e:	99 81       	ldd	r25, Y+1	; 0x01
    1410:	20 81       	ld	r18, Z
    1412:	31 81       	ldd	r19, Z+1	; 0x01
    1414:	82 1b       	sub	r24, r18
    1416:	93 0b       	sbc	r25, r19
    1418:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    141c:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    1420:	68 81       	ld	r22, Y
    1422:	79 81       	ldd	r23, Y+1	; 0x01
    1424:	80 e0       	ldi	r24, 0x00	; 0
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	0e 94 99 12 	call	0x2532	; 0x2532 <__floatunsisf>
    142c:	20 e0       	ldi	r18, 0x00	; 0
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	40 e0       	ldi	r20, 0x00	; 0
    1432:	5f e3       	ldi	r21, 0x3F	; 63
    1434:	0e 94 4f 13 	call	0x269e	; 0x269e <__mulsf3>
    1438:	0e 94 68 12 	call	0x24d0	; 0x24d0 <__fixsfsi>
    143c:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    1440:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	08 95       	ret

0000144a <uart0_putc>:
    144a:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    144e:	9f 5f       	subi	r25, 0xFF	; 255
    1450:	9f 71       	andi	r25, 0x1F	; 31
    1452:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1456:	92 17       	cp	r25, r18
    1458:	e1 f3       	breq	.-8      	; 0x1452 <uart0_putc+0x8>
    145a:	e9 2f       	mov	r30, r25
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	e5 5d       	subi	r30, 0xD5	; 213
    1460:	fb 4f       	sbci	r31, 0xFB	; 251
    1462:	80 83       	st	Z, r24
    1464:	2f b7       	in	r18, 0x3f	; 63
    1466:	f8 94       	cli
    1468:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    146c:	e1 ec       	ldi	r30, 0xC1	; 193
    146e:	f0 e0       	ldi	r31, 0x00	; 0
    1470:	80 81       	ld	r24, Z
    1472:	80 62       	ori	r24, 0x20	; 32
    1474:	80 83       	st	Z, r24
    1476:	2f bf       	out	0x3f, r18	; 63
    1478:	08 95       	ret

0000147a <uart0_flush>:
    147a:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    147e:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    1482:	98 13       	cpse	r25, r24
    1484:	fa cf       	rjmp	.-12     	; 0x147a <uart0_flush>
    1486:	08 95       	ret

00001488 <uart1_putc>:
    1488:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    148c:	9f 5f       	subi	r25, 0xFF	; 255
    148e:	9f 71       	andi	r25, 0x1F	; 31
    1490:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    1494:	92 17       	cp	r25, r18
    1496:	e1 f3       	breq	.-8      	; 0x1490 <uart1_putc+0x8>
    1498:	e9 2f       	mov	r30, r25
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	ea 51       	subi	r30, 0x1A	; 26
    149e:	fc 4f       	sbci	r31, 0xFC	; 252
    14a0:	80 83       	st	Z, r24
    14a2:	2f b7       	in	r18, 0x3f	; 63
    14a4:	f8 94       	cli
    14a6:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    14aa:	e9 ec       	ldi	r30, 0xC9	; 201
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	80 81       	ld	r24, Z
    14b0:	80 62       	ori	r24, 0x20	; 32
    14b2:	80 83       	st	Z, r24
    14b4:	2f bf       	out	0x3f, r18	; 63
    14b6:	08 95       	ret

000014b8 <uart_putchar>:
    14b8:	cf 93       	push	r28
    14ba:	c8 2f       	mov	r28, r24
    14bc:	fb 01       	movw	r30, r22
    14be:	84 85       	ldd	r24, Z+12	; 0x0c
    14c0:	95 85       	ldd	r25, Z+13	; 0x0d
    14c2:	01 97       	sbiw	r24, 0x01	; 1
    14c4:	39 f0       	breq	.+14     	; 0x14d4 <uart_putchar+0x1c>
    14c6:	ca 30       	cpi	r28, 0x0A	; 10
    14c8:	11 f4       	brne	.+4      	; 0x14ce <uart_putchar+0x16>
    14ca:	8d e0       	ldi	r24, 0x0D	; 13
    14cc:	be df       	rcall	.-132    	; 0x144a <uart0_putc>
    14ce:	8c 2f       	mov	r24, r28
    14d0:	bc df       	rcall	.-136    	; 0x144a <uart0_putc>
    14d2:	06 c0       	rjmp	.+12     	; 0x14e0 <uart_putchar+0x28>
    14d4:	ca 30       	cpi	r28, 0x0A	; 10
    14d6:	11 f4       	brne	.+4      	; 0x14dc <uart_putchar+0x24>
    14d8:	8d e0       	ldi	r24, 0x0D	; 13
    14da:	d6 df       	rcall	.-84     	; 0x1488 <uart1_putc>
    14dc:	8c 2f       	mov	r24, r28
    14de:	d4 df       	rcall	.-88     	; 0x1488 <uart1_putc>
    14e0:	80 e0       	ldi	r24, 0x00	; 0
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	cf 91       	pop	r28
    14e6:	08 95       	ret

000014e8 <uart0_getc>:
    14e8:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    14ec:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    14f0:	89 17       	cp	r24, r25
    14f2:	59 f0       	breq	.+22     	; 0x150a <uart0_getc+0x22>
    14f4:	8f 5f       	subi	r24, 0xFF	; 255
    14f6:	98 2f       	mov	r25, r24
    14f8:	9f 71       	andi	r25, 0x1F	; 31
    14fa:	e9 2f       	mov	r30, r25
    14fc:	f0 e0       	ldi	r31, 0x00	; 0
    14fe:	ed 53       	subi	r30, 0x3D	; 61
    1500:	fc 4f       	sbci	r31, 0xFC	; 252
    1502:	80 81       	ld	r24, Z
    1504:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    1508:	08 95       	ret
    150a:	80 e0       	ldi	r24, 0x00	; 0
    150c:	08 95       	ret

0000150e <uart0_getln>:
    150e:	0f 93       	push	r16
    1510:	1f 93       	push	r17
    1512:	cf 93       	push	r28
    1514:	df 93       	push	r29
    1516:	ec 01       	movw	r28, r24
    1518:	61 30       	cpi	r22, 0x01	; 1
    151a:	b1 f0       	breq	.+44     	; 0x1548 <uart0_getln+0x3a>
    151c:	62 50       	subi	r22, 0x02	; 2
    151e:	06 2f       	mov	r16, r22
    1520:	10 e0       	ldi	r17, 0x00	; 0
    1522:	0f 5f       	subi	r16, 0xFF	; 255
    1524:	1f 4f       	sbci	r17, 0xFF	; 255
    1526:	08 0f       	add	r16, r24
    1528:	19 1f       	adc	r17, r25
    152a:	de df       	rcall	.-68     	; 0x14e8 <uart0_getc>
    152c:	88 83       	st	Y, r24
    152e:	88 23       	and	r24, r24
    1530:	e1 f3       	breq	.-8      	; 0x152a <uart0_getln+0x1c>
    1532:	8d 30       	cpi	r24, 0x0D	; 13
    1534:	21 f4       	brne	.+8      	; 0x153e <uart0_getln+0x30>
    1536:	d8 df       	rcall	.-80     	; 0x14e8 <uart0_getc>
    1538:	88 23       	and	r24, r24
    153a:	e9 f3       	breq	.-6      	; 0x1536 <uart0_getln+0x28>
    153c:	05 c0       	rjmp	.+10     	; 0x1548 <uart0_getln+0x3a>
    153e:	21 96       	adiw	r28, 0x01	; 1
    1540:	c0 17       	cp	r28, r16
    1542:	d1 07       	cpc	r29, r17
    1544:	91 f7       	brne	.-28     	; 0x152a <uart0_getln+0x1c>
    1546:	e8 01       	movw	r28, r16
    1548:	18 82       	st	Y, r1
    154a:	df 91       	pop	r29
    154c:	cf 91       	pop	r28
    154e:	1f 91       	pop	r17
    1550:	0f 91       	pop	r16
    1552:	08 95       	ret

00001554 <uart0_getData>:
    1554:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1558:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    155c:	89 17       	cp	r24, r25
    155e:	61 f0       	breq	.+24     	; 0x1578 <uart0_getData+0x24>
    1560:	8f 5f       	subi	r24, 0xFF	; 255
    1562:	8f 71       	andi	r24, 0x1F	; 31
    1564:	e8 2f       	mov	r30, r24
    1566:	f0 e0       	ldi	r31, 0x00	; 0
    1568:	ed 53       	subi	r30, 0x3D	; 61
    156a:	fc 4f       	sbci	r31, 0xFC	; 252
    156c:	90 81       	ld	r25, Z
    156e:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    1572:	89 2f       	mov	r24, r25
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	08 95       	ret
    1578:	8f ef       	ldi	r24, 0xFF	; 255
    157a:	9f ef       	ldi	r25, 0xFF	; 255
    157c:	08 95       	ret

0000157e <uart1_getData>:
    157e:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    1582:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1586:	89 17       	cp	r24, r25
    1588:	61 f0       	breq	.+24     	; 0x15a2 <uart1_getData+0x24>
    158a:	8f 5f       	subi	r24, 0xFF	; 255
    158c:	8f 71       	andi	r24, 0x1F	; 31
    158e:	e8 2f       	mov	r30, r24
    1590:	f0 e0       	ldi	r31, 0x00	; 0
    1592:	e9 5f       	subi	r30, 0xF9	; 249
    1594:	fb 4f       	sbci	r31, 0xFB	; 251
    1596:	90 81       	ld	r25, Z
    1598:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    159c:	89 2f       	mov	r24, r25
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	08 95       	ret
    15a2:	8f ef       	ldi	r24, 0xFF	; 255
    15a4:	9f ef       	ldi	r25, 0xFF	; 255
    15a6:	08 95       	ret

000015a8 <uart_getchar>:
    15a8:	cf 93       	push	r28
    15aa:	df 93       	push	r29
    15ac:	fc 01       	movw	r30, r24
    15ae:	84 85       	ldd	r24, Z+12	; 0x0c
    15b0:	95 85       	ldd	r25, Z+13	; 0x0d
    15b2:	01 97       	sbiw	r24, 0x01	; 1
    15b4:	41 f0       	breq	.+16     	; 0x15c6 <uart_getchar+0x1e>
    15b6:	ce df       	rcall	.-100    	; 0x1554 <uart0_getData>
    15b8:	ec 01       	movw	r28, r24
    15ba:	99 23       	and	r25, r25
    15bc:	e4 f3       	brlt	.-8      	; 0x15b6 <uart_getchar+0xe>
    15be:	45 df       	rcall	.-374    	; 0x144a <uart0_putc>
    15c0:	ce 01       	movw	r24, r28
    15c2:	99 27       	eor	r25, r25
    15c4:	07 c0       	rjmp	.+14     	; 0x15d4 <uart_getchar+0x2c>
    15c6:	db df       	rcall	.-74     	; 0x157e <uart1_getData>
    15c8:	ec 01       	movw	r28, r24
    15ca:	99 23       	and	r25, r25
    15cc:	e4 f3       	brlt	.-8      	; 0x15c6 <uart_getchar+0x1e>
    15ce:	5c df       	rcall	.-328    	; 0x1488 <uart1_putc>
    15d0:	ce 01       	movw	r24, r28
    15d2:	99 27       	eor	r25, r25
    15d4:	99 27       	eor	r25, r25
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	08 95       	ret

000015dc <__vector_22>:
    15dc:	0f 93       	push	r16
    15de:	0f b7       	in	r16, 0x3f	; 63
    15e0:	ef 93       	push	r30
    15e2:	ff 93       	push	r31
    15e4:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    15e8:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    15ec:	e3 95       	inc	r30
    15ee:	ef 71       	andi	r30, 0x1F	; 31
    15f0:	ef 13       	cpse	r30, r31
    15f2:	05 c0       	rjmp	.+10     	; 0x15fe <USART0_TX_CONTINUE>
    15f4:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15f8:	ff 7d       	andi	r31, 0xDF	; 223
    15fa:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015fe <USART0_TX_CONTINUE>:
    15fe:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    1602:	f0 e0       	ldi	r31, 0x00	; 0
    1604:	e5 5d       	subi	r30, 0xD5	; 213
    1606:	fb 4f       	sbci	r31, 0xFB	; 251
    1608:	e0 81       	ld	r30, Z
    160a:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

0000160e <USART0_TX_EXIT>:
    160e:	ff 91       	pop	r31
    1610:	ef 91       	pop	r30
    1612:	0f bf       	out	0x3f, r16	; 63
    1614:	0f 91       	pop	r16
    1616:	18 95       	reti

00001618 <__vector_21>:
    1618:	0f 93       	push	r16
    161a:	0f b7       	in	r16, 0x3f	; 63
    161c:	9f 93       	push	r25
    161e:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1622:	ef 93       	push	r30
    1624:	ff 93       	push	r31
    1626:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    162a:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    162e:	e3 95       	inc	r30
    1630:	ef 71       	andi	r30, 0x1F	; 31
    1632:	fe 17       	cp	r31, r30
    1634:	31 f0       	breq	.+12     	; 0x1642 <USART0_RX_EXIT>
    1636:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	ed 53       	subi	r30, 0x3D	; 61
    163e:	fc 4f       	sbci	r31, 0xFC	; 252
    1640:	90 83       	st	Z, r25

00001642 <USART0_RX_EXIT>:
    1642:	ff 91       	pop	r31
    1644:	ef 91       	pop	r30
    1646:	9f 91       	pop	r25
    1648:	0f bf       	out	0x3f, r16	; 63
    164a:	0f 91       	pop	r16
    164c:	18 95       	reti

0000164e <__vector_33>:
    164e:	0f 93       	push	r16
    1650:	0f b7       	in	r16, 0x3f	; 63
    1652:	ef 93       	push	r30
    1654:	ff 93       	push	r31
    1656:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    165a:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    165e:	e3 95       	inc	r30
    1660:	ef 71       	andi	r30, 0x1F	; 31
    1662:	ef 13       	cpse	r30, r31
    1664:	05 c0       	rjmp	.+10     	; 0x1670 <USART1_TX_CONTINUE>
    1666:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    166a:	ff 7d       	andi	r31, 0xDF	; 223
    166c:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

00001670 <USART1_TX_CONTINUE>:
    1670:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    1674:	f0 e0       	ldi	r31, 0x00	; 0
    1676:	ea 51       	subi	r30, 0x1A	; 26
    1678:	fc 4f       	sbci	r31, 0xFC	; 252
    167a:	e0 81       	ld	r30, Z
    167c:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

00001680 <USART1_TX_EXIT>:
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	0f bf       	out	0x3f, r16	; 63
    1686:	0f 91       	pop	r16
    1688:	18 95       	reti

0000168a <__vector_32>:
    168a:	0f 93       	push	r16
    168c:	0f b7       	in	r16, 0x3f	; 63
    168e:	9f 93       	push	r25
    1690:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1694:	ef 93       	push	r30
    1696:	ff 93       	push	r31
    1698:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    169c:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    16a0:	e3 95       	inc	r30
    16a2:	ef 71       	andi	r30, 0x1F	; 31
    16a4:	fe 17       	cp	r31, r30
    16a6:	31 f0       	breq	.+12     	; 0x16b4 <USART1_RX_EXIT>
    16a8:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    16ac:	f0 e0       	ldi	r31, 0x00	; 0
    16ae:	e9 5f       	subi	r30, 0xF9	; 249
    16b0:	fb 4f       	sbci	r31, 0xFB	; 251
    16b2:	90 83       	st	Z, r25

000016b4 <USART1_RX_EXIT>:
    16b4:	ff 91       	pop	r31
    16b6:	ef 91       	pop	r30
    16b8:	9f 91       	pop	r25
    16ba:	0f bf       	out	0x3f, r16	; 63
    16bc:	0f 91       	pop	r16
    16be:	18 95       	reti

000016c0 <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    16c0:	e1 e8       	ldi	r30, 0x81	; 129
    16c2:	f0 e0       	ldi	r31, 0x00	; 0
    16c4:	80 81       	ld	r24, Z
    16c6:	83 60       	ori	r24, 0x03	; 3
    16c8:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    16ca:	80 81       	ld	r24, Z
    16cc:	88 60       	ori	r24, 0x08	; 8
    16ce:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    16d0:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    16d4:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    16d8:	ef e6       	ldi	r30, 0x6F	; 111
    16da:	f0 e0       	ldi	r31, 0x00	; 0
    16dc:	80 81       	ld	r24, Z
    16de:	82 60       	ori	r24, 0x02	; 2
    16e0:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    16e2:	8d e7       	ldi	r24, 0x7D	; 125
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16ea:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16ee:	08 95       	ret

000016f0 <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    16f0:	84 b5       	in	r24, 0x24	; 36
    16f2:	85 60       	ori	r24, 0x05	; 5
    16f4:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16f6:	84 b5       	in	r24, 0x24	; 36
    16f8:	88 60       	ori	r24, 0x08	; 8
    16fa:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16fc:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16fe:	ee e6       	ldi	r30, 0x6E	; 110
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	80 81       	ld	r24, Z
    1704:	82 60       	ori	r24, 0x02	; 2
    1706:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    1708:	87 e2       	ldi	r24, 0x27	; 39
    170a:	87 bd       	out	0x27, r24	; 39
    170c:	08 95       	ret

0000170e <main>:
};


int main(void)	
{
	cli();
    170e:	f8 94       	cli
	rgbled_init();
    1710:	8e d5       	rcall	.+2844   	; 0x222e <rgbled_init>
	DWC_init();
    1712:	0d d2       	rcall	.+1050   	; 0x1b2e <DWC_init>
	pwm_init();
    1714:	33 de       	rcall	.-922    	; 0x137c <pwm_init>
    1716:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	80 e0       	ldi	r24, 0x00	; 0
    171c:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    171e:	6d d4       	rcall	.+2266   	; 0x1ffa <can_init>
	timer0_init_ts();
    1720:	cf df       	rcall	.-98     	; 0x16c0 <timer1_init_ts>
    1722:	e6 df       	rcall	.-52     	; 0x16f0 <timer0_init_ts>
	speed_init();
    1724:	7f dc       	rcall	.-1794   	; 0x1024 <speed_init>
    1726:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    1728:	91 d5       	rcall	.+2850   	; 0x224c <spi_init>
    172a:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    172e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1732:	88 e9       	ldi	r24, 0x98	; 152
    1734:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    1738:	eb e4       	ldi	r30, 0x4B	; 75
    173a:	f4 e0       	ldi	r31, 0x04	; 4
	//actuator_init(&ComValues);
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    173c:	84 e0       	ldi	r24, 0x04	; 4
    173e:	91 e0       	ldi	r25, 0x01	; 1
    1740:	93 83       	std	Z+3, r25	; 0x03
    1742:	82 83       	std	Z+2, r24	; 0x02
    1744:	91 83       	std	Z+1, r25	; 0x01
    1746:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    1748:	0e 94 70 03 	call	0x6e0	; 0x6e0 <drivers_init>
	drivers_init();
    174c:	80 e0       	ldi	r24, 0x00	; 0
    174e:	0e 94 72 03 	call	0x6e4	; 0x6e4 <drivers>
	drivers(0);
    1752:	78 94       	sei
	sei();
    1754:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    1756:	67 e9       	ldi	r22, 0x97	; 151
    1758:	73 e0       	ldi	r23, 0x03	; 3
    175a:	82 e1       	ldi	r24, 0x12	; 18
    175c:	91 e0       	ldi	r25, 0x01	; 1
    175e:	bd d8       	rcall	.-3718   	; 0x8da <handle_can>
    1760:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1762:	91 e0       	ldi	r25, 0x01	; 1
    1764:	96 d9       	rcall	.-3284   	; 0xa92 <receive_uart>
    1766:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    176a:	88 23       	and	r24, r24
    176c:	09 f4       	brne	.+2      	; 0x1770 <main+0x62>
    176e:	41 c0       	rjmp	.+130    	; 0x17f2 <main+0xe4>
    1770:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1774:	88 23       	and	r24, r24
    1776:	f1 f0       	breq	.+60     	; 0x17b4 <main+0xa6>
    1778:	8d b7       	in	r24, 0x3d	; 61
    177a:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    177c:	cd 97       	sbiw	r24, 0x3d	; 61
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	9e bf       	out	0x3e, r25	; 62
    1784:	0f be       	out	0x3f, r0	; 63
    1786:	8d bf       	out	0x3d, r24	; 61
    1788:	ad b7       	in	r26, 0x3d	; 61
    178a:	be b7       	in	r27, 0x3e	; 62
    178c:	11 96       	adiw	r26, 0x01	; 1
    178e:	8d e3       	ldi	r24, 0x3D	; 61
    1790:	e2 e1       	ldi	r30, 0x12	; 18
    1792:	f1 e0       	ldi	r31, 0x01	; 1
    1794:	01 90       	ld	r0, Z+
    1796:	0d 92       	st	X+, r0
    1798:	8a 95       	dec	r24
    179a:	e1 f7       	brne	.-8      	; 0x1794 <main+0x86>
    179c:	f5 d8       	rcall	.-3606   	; 0x988 <handle_motor_status_can_msg>
    179e:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    17a2:	8d b7       	in	r24, 0x3d	; 61
    17a4:	9e b7       	in	r25, 0x3e	; 62
    17a6:	cd 96       	adiw	r24, 0x3d	; 61
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	9e bf       	out	0x3e, r25	; 62
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	8d bf       	out	0x3d, r24	; 61
    17b2:	1d c0       	rjmp	.+58     	; 0x17ee <main+0xe0>
    17b4:	8d b7       	in	r24, 0x3d	; 61
    17b6:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    17b8:	cd 97       	sbiw	r24, 0x3d	; 61
    17ba:	0f b6       	in	r0, 0x3f	; 63
    17bc:	f8 94       	cli
    17be:	9e bf       	out	0x3e, r25	; 62
    17c0:	0f be       	out	0x3f, r0	; 63
    17c2:	8d bf       	out	0x3d, r24	; 61
    17c4:	ad b7       	in	r26, 0x3d	; 61
    17c6:	be b7       	in	r27, 0x3e	; 62
    17c8:	11 96       	adiw	r26, 0x01	; 1
    17ca:	8d e3       	ldi	r24, 0x3D	; 61
    17cc:	e2 e1       	ldi	r30, 0x12	; 18
    17ce:	f1 e0       	ldi	r31, 0x01	; 1
    17d0:	01 90       	ld	r0, Z+
    17d2:	0d 92       	st	X+, r0
    17d4:	8a 95       	dec	r24
    17d6:	e1 f7       	brne	.-8      	; 0x17d0 <main+0xc2>
    17d8:	46 d9       	rcall	.-3444   	; 0xa66 <handle_clutch_cmd_can_msg>
    17da:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    17de:	8d b7       	in	r24, 0x3d	; 61
    17e0:	9e b7       	in	r25, 0x3e	; 62
    17e2:	cd 96       	adiw	r24, 0x3d	; 61
    17e4:	0f b6       	in	r0, 0x3f	; 63
    17e6:	f8 94       	cli
    17e8:	9e bf       	out	0x3e, r25	; 62
    17ea:	0f be       	out	0x3f, r0	; 63
    17ec:	8d bf       	out	0x3d, r24	; 61
    17ee:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17f2:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17f6:	88 23       	and	r24, r24
    17f8:	09 f4       	brne	.+2      	; 0x17fc <main+0xee>
    17fa:	ad cf       	rjmp	.-166    	; 0x1756 <main+0x48>
    17fc:	8d b7       	in	r24, 0x3d	; 61
    17fe:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    1800:	cd 97       	sbiw	r24, 0x3d	; 61
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	9e bf       	out	0x3e, r25	; 62
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	8d bf       	out	0x3d, r24	; 61
    180c:	ad b7       	in	r26, 0x3d	; 61
    180e:	be b7       	in	r27, 0x3e	; 62
    1810:	11 96       	adiw	r26, 0x01	; 1
    1812:	8d e3       	ldi	r24, 0x3D	; 61
    1814:	e2 e1       	ldi	r30, 0x12	; 18
    1816:	f1 e0       	ldi	r31, 0x01	; 1
    1818:	01 90       	ld	r0, Z+
    181a:	0d 92       	st	X+, r0
    181c:	8a 95       	dec	r24
    181e:	e1 f7       	brne	.-8      	; 0x1818 <main+0x10a>
    1820:	e3 da       	rcall	.-2618   	; 0xde8 <send_uart>
    1822:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    1826:	8d b7       	in	r24, 0x3d	; 61
    1828:	9e b7       	in	r25, 0x3e	; 62
    182a:	cd 96       	adiw	r24, 0x3d	; 61
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	9e bf       	out	0x3e, r25	; 62
    1832:	0f be       	out	0x3f, r0	; 63
    1834:	8d bf       	out	0x3d, r24	; 61
    1836:	8f cf       	rjmp	.-226    	; 0x1756 <main+0x48>

00001838 <__vector_16>:
    1838:	1f 92       	push	r1
    183a:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	0f 92       	push	r0
    1840:	11 24       	eor	r1, r1
    1842:	0b b6       	in	r0, 0x3b	; 59
    1844:	0f 92       	push	r0
    1846:	ef 92       	push	r14
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	2f 93       	push	r18
    184e:	3f 93       	push	r19
    1850:	4f 93       	push	r20
    1852:	5f 93       	push	r21
    1854:	6f 93       	push	r22
    1856:	7f 93       	push	r23
    1858:	8f 93       	push	r24
    185a:	9f 93       	push	r25
    185c:	af 93       	push	r26
    185e:	bf 93       	push	r27
    1860:	ef 93       	push	r30
    1862:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1864:	82 e1       	ldi	r24, 0x12	; 18
    1866:	91 e0       	ldi	r25, 0x01	; 1
    1868:	63 d1       	rcall	.+710    	; 0x1b30 <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    186a:	82 e1       	ldi	r24, 0x12	; 18
    186c:	91 e0       	ldi	r25, 0x01	; 1
    186e:	67 dc       	rcall	.-1842   	; 0x113e <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    1870:	82 e1       	ldi	r24, 0x12	; 18
    1872:	91 e0       	ldi	r25, 0x01	; 1
    1874:	0e 94 80 01 	call	0x300	; 0x300 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    1878:	82 e1       	ldi	r24, 0x12	; 18
    187a:	91 e0       	ldi	r25, 0x01	; 1
    187c:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    1880:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1884:	87 30       	cpi	r24, 0x07	; 7
    1886:	09 f0       	breq	.+2      	; 0x188a <__vector_16+0x52>
    1888:	51 c0       	rjmp	.+162    	; 0x192c <__vector_16+0xf4>
	{
		b_send_can = 1;
    188a:	81 e0       	ldi	r24, 0x01	; 1
    188c:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    1890:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1894:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    1898:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    189c:	89 2b       	or	r24, r25
    189e:	b1 f0       	breq	.+44     	; 0x18cc <__vector_16+0x94>
    18a0:	e2 e1       	ldi	r30, 0x12	; 18
    18a2:	f1 e0       	ldi	r31, 0x01	; 1
    18a4:	97 8d       	ldd	r25, Z+31	; 0x1f
    18a6:	27 8d       	ldd	r18, Z+31	; 0x1f
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	91 30       	cpi	r25, 0x01	; 1
    18ac:	09 f0       	breq	.+2      	; 0x18b0 <__vector_16+0x78>
    18ae:	80 e0       	ldi	r24, 0x00	; 0
    18b0:	81 11       	cpse	r24, r1
    18b2:	05 c0       	rjmp	.+10     	; 0x18be <__vector_16+0x86>
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	21 11       	cpse	r18, r1
    18b8:	80 e0       	ldi	r24, 0x00	; 0
    18ba:	88 23       	and	r24, r24
    18bc:	39 f0       	breq	.+14     	; 0x18cc <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    18be:	e2 e1       	ldi	r30, 0x12	; 18
    18c0:	f1 e0       	ldi	r31, 0x01	; 1
    18c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    18c4:	93 8d       	ldd	r25, Z+27	; 0x1b
    18c6:	01 97       	sbiw	r24, 0x01	; 1
    18c8:	93 8f       	std	Z+27, r25	; 0x1b
    18ca:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    18cc:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    18d0:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    18d4:	89 2b       	or	r24, r25
    18d6:	b1 f0       	breq	.+44     	; 0x1904 <__vector_16+0xcc>
    18d8:	e2 e1       	ldi	r30, 0x12	; 18
    18da:	f1 e0       	ldi	r31, 0x01	; 1
    18dc:	97 8d       	ldd	r25, Z+31	; 0x1f
    18de:	27 8d       	ldd	r18, Z+31	; 0x1f
    18e0:	81 e0       	ldi	r24, 0x01	; 1
    18e2:	91 30       	cpi	r25, 0x01	; 1
    18e4:	09 f0       	breq	.+2      	; 0x18e8 <__vector_16+0xb0>
    18e6:	80 e0       	ldi	r24, 0x00	; 0
    18e8:	81 11       	cpse	r24, r1
    18ea:	05 c0       	rjmp	.+10     	; 0x18f6 <__vector_16+0xbe>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	21 11       	cpse	r18, r1
    18f0:	80 e0       	ldi	r24, 0x00	; 0
    18f2:	88 23       	and	r24, r24
    18f4:	39 f0       	breq	.+14     	; 0x1904 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18f6:	e2 e1       	ldi	r30, 0x12	; 18
    18f8:	f1 e0       	ldi	r31, 0x01	; 1
    18fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    18fc:	95 8d       	ldd	r25, Z+29	; 0x1d
    18fe:	01 97       	sbiw	r24, 0x01	; 1
    1900:	95 8f       	std	Z+29, r25	; 0x1d
    1902:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    1904:	e2 e1       	ldi	r30, 0x12	; 18
    1906:	f1 e0       	ldi	r31, 0x01	; 1
    1908:	02 85       	ldd	r16, Z+10	; 0x0a
    190a:	13 85       	ldd	r17, Z+11	; 0x0b
    190c:	24 85       	ldd	r18, Z+12	; 0x0c
    190e:	35 85       	ldd	r19, Z+13	; 0x0d
    1910:	46 81       	ldd	r20, Z+6	; 0x06
    1912:	57 81       	ldd	r21, Z+7	; 0x07
    1914:	60 85       	ldd	r22, Z+8	; 0x08
    1916:	71 85       	ldd	r23, Z+9	; 0x09
    1918:	0f 2e       	mov	r0, r31
    191a:	f9 e2       	ldi	r31, 0x29	; 41
    191c:	ef 2e       	mov	r14, r31
    191e:	f0 2d       	mov	r31, r0
    1920:	80 e2       	ldi	r24, 0x20	; 32
    1922:	91 e0       	ldi	r25, 0x01	; 1
    1924:	e6 d1       	rcall	.+972    	; 0x1cf2 <handle_joulemeter>
		systic_counter_fast = 0;
    1926:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    192a:	03 c0       	rjmp	.+6      	; 0x1932 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    192c:	8f 5f       	subi	r24, 0xFF	; 255
    192e:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1932:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    1936:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    193a:	84 36       	cpi	r24, 0x64	; 100
    193c:	91 05       	cpc	r25, r1
    193e:	01 f5       	brne	.+64     	; 0x1980 <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    1940:	8d b7       	in	r24, 0x3d	; 61
    1942:	9e b7       	in	r25, 0x3e	; 62
    1944:	cd 97       	sbiw	r24, 0x3d	; 61
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	f8 94       	cli
    194a:	9e bf       	out	0x3e, r25	; 62
    194c:	0f be       	out	0x3f, r0	; 63
    194e:	8d bf       	out	0x3d, r24	; 61
    1950:	ad b7       	in	r26, 0x3d	; 61
    1952:	be b7       	in	r27, 0x3e	; 62
    1954:	11 96       	adiw	r26, 0x01	; 1
    1956:	8d e3       	ldi	r24, 0x3D	; 61
    1958:	e2 e1       	ldi	r30, 0x12	; 18
    195a:	f1 e0       	ldi	r31, 0x01	; 1
    195c:	01 90       	ld	r0, Z+
    195e:	0d 92       	st	X+, r0
    1960:	8a 95       	dec	r24
    1962:	e1 f7       	brne	.-8      	; 0x195c <__vector_16+0x124>
    1964:	06 db       	rcall	.-2548   	; 0xf72 <manage_LEDs>
		systic_counter_slow = 0;
    1966:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    196a:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    196e:	8d b7       	in	r24, 0x3d	; 61
    1970:	9e b7       	in	r25, 0x3e	; 62
    1972:	cd 96       	adiw	r24, 0x3d	; 61
    1974:	0f b6       	in	r0, 0x3f	; 63
    1976:	f8 94       	cli
    1978:	9e bf       	out	0x3e, r25	; 62
    197a:	0f be       	out	0x3f, r0	; 63
    197c:	8d bf       	out	0x3d, r24	; 61
    197e:	05 c0       	rjmp	.+10     	; 0x198a <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    1980:	01 96       	adiw	r24, 0x01	; 1
    1982:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    1986:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    198a:	ff 91       	pop	r31
    198c:	ef 91       	pop	r30
    198e:	bf 91       	pop	r27
    1990:	af 91       	pop	r26
    1992:	9f 91       	pop	r25
    1994:	8f 91       	pop	r24
    1996:	7f 91       	pop	r23
    1998:	6f 91       	pop	r22
    199a:	5f 91       	pop	r21
    199c:	4f 91       	pop	r20
    199e:	3f 91       	pop	r19
    19a0:	2f 91       	pop	r18
    19a2:	1f 91       	pop	r17
    19a4:	0f 91       	pop	r16
    19a6:	ef 90       	pop	r14
    19a8:	0f 90       	pop	r0
    19aa:	0b be       	out	0x3b, r0	; 59
    19ac:	0f 90       	pop	r0
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	0f 90       	pop	r0
    19b2:	1f 90       	pop	r1
    19b4:	18 95       	reti

000019b6 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    19b6:	1f 92       	push	r1
    19b8:	0f 92       	push	r0
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	0f 92       	push	r0
    19be:	11 24       	eor	r1, r1
    19c0:	0b b6       	in	r0, 0x3b	; 59
    19c2:	0f 92       	push	r0
    19c4:	2f 93       	push	r18
    19c6:	3f 93       	push	r19
    19c8:	4f 93       	push	r20
    19ca:	5f 93       	push	r21
    19cc:	6f 93       	push	r22
    19ce:	7f 93       	push	r23
    19d0:	8f 93       	push	r24
    19d2:	9f 93       	push	r25
    19d4:	af 93       	push	r26
    19d6:	bf 93       	push	r27
    19d8:	ef 93       	push	r30
    19da:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    19dc:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19e0:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19e4:	80 3d       	cpi	r24, 0xD0	; 208
    19e6:	97 40       	sbci	r25, 0x07	; 7
    19e8:	50 f4       	brcc	.+20     	; 0x19fe <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19ea:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19ee:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19f2:	01 96       	adiw	r24, 0x01	; 1
    19f4:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19f8:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19fc:	08 c0       	rjmp	.+16     	; 0x1a0e <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19fe:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    1a02:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    1a06:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    1a0a:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    1a0e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a12:	87 30       	cpi	r24, 0x07	; 7
    1a14:	41 f4       	brne	.+16     	; 0x1a26 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    1a16:	84 e1       	ldi	r24, 0x14	; 20
    1a18:	91 e0       	ldi	r25, 0x01	; 1
    1a1a:	0e 94 4b 04 	call	0x896	; 0x896 <SPI_handler_7>
		u8_SPI_count = 0 ;
    1a1e:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    1a22:	80 e0       	ldi	r24, 0x00	; 0
    1a24:	13 c0       	rjmp	.+38     	; 0x1a4c <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1a26:	86 30       	cpi	r24, 0x06	; 6
    1a28:	49 f4       	brne	.+18     	; 0x1a3c <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1a2a:	8d e3       	ldi	r24, 0x3D	; 61
    1a2c:	91 e0       	ldi	r25, 0x01	; 1
    1a2e:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <SPI_handler_6>
		u8_SPI_count ++ ;
    1a32:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1a3c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a40:	85 30       	cpi	r24, 0x05	; 5
    1a42:	21 f4       	brne	.+8      	; 0x1a4c <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1a44:	86 e0       	ldi	r24, 0x06	; 6
    1a46:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a4a:	13 c0       	rjmp	.+38     	; 0x1a72 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a4c:	84 30       	cpi	r24, 0x04	; 4
    1a4e:	49 f4       	brne	.+18     	; 0x1a62 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a50:	84 e2       	ldi	r24, 0x24	; 36
    1a52:	91 e0       	ldi	r25, 0x01	; 1
    1a54:	0e 94 d7 03 	call	0x7ae	; 0x7ae <SPI_handler_4>
		u8_SPI_count ++ ;
    1a58:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a5c:	8f 5f       	subi	r24, 0xFF	; 255
    1a5e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a62:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a66:	83 30       	cpi	r24, 0x03	; 3
    1a68:	21 f4       	brne	.+8      	; 0x1a72 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a6a:	84 e0       	ldi	r24, 0x04	; 4
    1a6c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a70:	13 c0       	rjmp	.+38     	; 0x1a98 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a72:	82 30       	cpi	r24, 0x02	; 2
    1a74:	21 f4       	brne	.+8      	; 0x1a7e <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a76:	83 e0       	ldi	r24, 0x03	; 3
    1a78:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a7c:	1a c0       	rjmp	.+52     	; 0x1ab2 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a7e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a82:	81 30       	cpi	r24, 0x01	; 1
    1a84:	49 f4       	brne	.+18     	; 0x1a98 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a86:	88 e1       	ldi	r24, 0x18	; 24
    1a88:	91 e0       	ldi	r25, 0x01	; 1
    1a8a:	0e 94 b5 03 	call	0x76a	; 0x76a <SPI_handler_1>
		u8_SPI_count ++ ;
    1a8e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a92:	8f 5f       	subi	r24, 0xFF	; 255
    1a94:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a98:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a9c:	81 11       	cpse	r24, r1
    1a9e:	09 c0       	rjmp	.+18     	; 0x1ab2 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1aa0:	8c e1       	ldi	r24, 0x1C	; 28
    1aa2:	91 e0       	ldi	r25, 0x01	; 1
    1aa4:	0e 94 78 03 	call	0x6f0	; 0x6f0 <SPI_handler_0>
		u8_SPI_count ++ ;
    1aa8:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1aac:	8f 5f       	subi	r24, 0xFF	; 255
    1aae:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1ab2:	ff 91       	pop	r31
    1ab4:	ef 91       	pop	r30
    1ab6:	bf 91       	pop	r27
    1ab8:	af 91       	pop	r26
    1aba:	9f 91       	pop	r25
    1abc:	8f 91       	pop	r24
    1abe:	7f 91       	pop	r23
    1ac0:	6f 91       	pop	r22
    1ac2:	5f 91       	pop	r21
    1ac4:	4f 91       	pop	r20
    1ac6:	3f 91       	pop	r19
    1ac8:	2f 91       	pop	r18
    1aca:	0f 90       	pop	r0
    1acc:	0b be       	out	0x3b, r0	; 59
    1ace:	0f 90       	pop	r0
    1ad0:	0f be       	out	0x3f, r0	; 63
    1ad2:	0f 90       	pop	r0
    1ad4:	1f 90       	pop	r1
    1ad6:	18 95       	reti

00001ad8 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1ad8:	1f 92       	push	r1
    1ada:	0f 92       	push	r0
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	0f 92       	push	r0
    1ae0:	11 24       	eor	r1, r1
    1ae2:	0b b6       	in	r0, 0x3b	; 59
    1ae4:	0f 92       	push	r0
    1ae6:	2f 93       	push	r18
    1ae8:	3f 93       	push	r19
    1aea:	4f 93       	push	r20
    1aec:	5f 93       	push	r21
    1aee:	6f 93       	push	r22
    1af0:	7f 93       	push	r23
    1af2:	8f 93       	push	r24
    1af4:	9f 93       	push	r25
    1af6:	af 93       	push	r26
    1af8:	bf 93       	push	r27
    1afa:	ef 93       	push	r30
    1afc:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1afe:	60 e0       	ldi	r22, 0x00	; 0
    1b00:	72 e0       	ldi	r23, 0x02	; 2
    1b02:	85 e2       	ldi	r24, 0x25	; 37
    1b04:	91 e0       	ldi	r25, 0x01	; 1
    1b06:	99 da       	rcall	.-2766   	; 0x103a <handle_speed_sensor>
}
    1b08:	ff 91       	pop	r31
    1b0a:	ef 91       	pop	r30
    1b0c:	bf 91       	pop	r27
    1b0e:	af 91       	pop	r26
    1b10:	9f 91       	pop	r25
    1b12:	8f 91       	pop	r24
    1b14:	7f 91       	pop	r23
    1b16:	6f 91       	pop	r22
    1b18:	5f 91       	pop	r21
    1b1a:	4f 91       	pop	r20
    1b1c:	3f 91       	pop	r19
    1b1e:	2f 91       	pop	r18
    1b20:	0f 90       	pop	r0
    1b22:	0b be       	out	0x3b, r0	; 59
    1b24:	0f 90       	pop	r0
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	0f 90       	pop	r0
    1b2a:	1f 90       	pop	r1
    1b2c:	18 95       	reti

00001b2e <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1b2e:	08 95       	ret

00001b30 <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1b30:	7a 99       	sbic	0x0f, 2	; 15
    1b32:	03 c0       	rjmp	.+6      	; 0x1b3a <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1b34:	fc 01       	movw	r30, r24
    1b36:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1b38:	10 8e       	std	Z+24, r1	; 0x18
    1b3a:	08 95       	ret

00001b3c <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1b3c:	8f 92       	push	r8
    1b3e:	9f 92       	push	r9
    1b40:	af 92       	push	r10
    1b42:	bf 92       	push	r11
    1b44:	cf 92       	push	r12
    1b46:	df 92       	push	r13
    1b48:	ef 92       	push	r14
    1b4a:	ff 92       	push	r15
    1b4c:	0f 93       	push	r16
    1b4e:	1f 93       	push	r17
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	00 d0       	rcall	.+0      	; 0x1b56 <handle_current_sensor+0x1a>
    1b56:	00 d0       	rcall	.+0      	; 0x1b58 <handle_current_sensor+0x1c>
    1b58:	cd b7       	in	r28, 0x3d	; 61
    1b5a:	de b7       	in	r29, 0x3e	; 62
    1b5c:	8c 01       	movw	r16, r24
    1b5e:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b60:	80 e0       	ldi	r24, 0x00	; 0
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	e6 d4       	rcall	.+2508   	; 0x2532 <__floatunsisf>
    1b66:	20 e0       	ldi	r18, 0x00	; 0
    1b68:	30 e0       	ldi	r19, 0x00	; 0
    1b6a:	40 ea       	ldi	r20, 0xA0	; 160
    1b6c:	50 e4       	ldi	r21, 0x40	; 64
    1b6e:	97 d5       	rcall	.+2862   	; 0x269e <__mulsf3>
    1b70:	20 e0       	ldi	r18, 0x00	; 0
    1b72:	30 e0       	ldi	r19, 0x00	; 0
    1b74:	40 e8       	ldi	r20, 0x80	; 128
    1b76:	59 e3       	ldi	r21, 0x39	; 57
    1b78:	92 d5       	rcall	.+2852   	; 0x269e <__mulsf3>
    1b7a:	20 e0       	ldi	r18, 0x00	; 0
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
    1b7e:	40 e0       	ldi	r20, 0x00	; 0
    1b80:	51 e4       	ldi	r21, 0x41	; 65
    1b82:	8d d5       	rcall	.+2842   	; 0x269e <__mulsf3>
    1b84:	20 e0       	ldi	r18, 0x00	; 0
    1b86:	30 e0       	ldi	r19, 0x00	; 0
    1b88:	40 ea       	ldi	r20, 0xA0	; 160
    1b8a:	51 e4       	ldi	r21, 0x41	; 65
    1b8c:	d0 d3       	rcall	.+1952   	; 0x232e <__subsf3>
    1b8e:	69 83       	std	Y+1, r22	; 0x01
    1b90:	7a 83       	std	Y+2, r23	; 0x02
    1b92:	8b 83       	std	Y+3, r24	; 0x03
    1b94:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b96:	ff 20       	and	r15, r15
    1b98:	49 f0       	breq	.+18     	; 0x1bac <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b9a:	89 81       	ldd	r24, Y+1	; 0x01
    1b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9e:	ab 81       	ldd	r26, Y+3	; 0x03
    1ba0:	bc 81       	ldd	r27, Y+4	; 0x04
    1ba2:	89 83       	std	Y+1, r24	; 0x01
    1ba4:	9a 83       	std	Y+2, r25	; 0x02
    1ba6:	ab 83       	std	Y+3, r26	; 0x03
    1ba8:	bc 83       	std	Y+4, r27	; 0x04
    1baa:	08 c0       	rjmp	.+16     	; 0x1bbc <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1bac:	89 81       	ldd	r24, Y+1	; 0x01
    1bae:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb0:	ab 81       	ldd	r26, Y+3	; 0x03
    1bb2:	bc 81       	ldd	r27, Y+4	; 0x04
    1bb4:	89 83       	std	Y+1, r24	; 0x01
    1bb6:	9a 83       	std	Y+2, r25	; 0x02
    1bb8:	ab 83       	std	Y+3, r26	; 0x03
    1bba:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1bbc:	f8 01       	movw	r30, r16
    1bbe:	60 81       	ld	r22, Z
    1bc0:	71 81       	ldd	r23, Z+1	; 0x01
    1bc2:	82 81       	ldd	r24, Z+2	; 0x02
    1bc4:	93 81       	ldd	r25, Z+3	; 0x03
    1bc6:	89 80       	ldd	r8, Y+1	; 0x01
    1bc8:	9a 80       	ldd	r9, Y+2	; 0x02
    1bca:	ab 80       	ldd	r10, Y+3	; 0x03
    1bcc:	bc 80       	ldd	r11, Y+4	; 0x04
    1bce:	26 e6       	ldi	r18, 0x66	; 102
    1bd0:	36 e6       	ldi	r19, 0x66	; 102
    1bd2:	46 e6       	ldi	r20, 0x66	; 102
    1bd4:	5f e3       	ldi	r21, 0x3F	; 63
    1bd6:	63 d5       	rcall	.+2758   	; 0x269e <__mulsf3>
    1bd8:	6b 01       	movw	r12, r22
    1bda:	7c 01       	movw	r14, r24
    1bdc:	2d ec       	ldi	r18, 0xCD	; 205
    1bde:	3c ec       	ldi	r19, 0xCC	; 204
    1be0:	4c ec       	ldi	r20, 0xCC	; 204
    1be2:	5d e3       	ldi	r21, 0x3D	; 61
    1be4:	c5 01       	movw	r24, r10
    1be6:	b4 01       	movw	r22, r8
    1be8:	5a d5       	rcall	.+2740   	; 0x269e <__mulsf3>
    1bea:	9b 01       	movw	r18, r22
    1bec:	ac 01       	movw	r20, r24
    1bee:	c7 01       	movw	r24, r14
    1bf0:	b6 01       	movw	r22, r12
    1bf2:	9e d3       	rcall	.+1852   	; 0x2330 <__addsf3>
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	60 83       	st	Z, r22
    1bf8:	71 83       	std	Z+1, r23	; 0x01
    1bfa:	82 83       	std	Z+2, r24	; 0x02
    1bfc:	93 83       	std	Z+3, r25	; 0x03
}
    1bfe:	0f 90       	pop	r0
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	df 91       	pop	r29
    1c08:	cf 91       	pop	r28
    1c0a:	1f 91       	pop	r17
    1c0c:	0f 91       	pop	r16
    1c0e:	ff 90       	pop	r15
    1c10:	ef 90       	pop	r14
    1c12:	df 90       	pop	r13
    1c14:	cf 90       	pop	r12
    1c16:	bf 90       	pop	r11
    1c18:	af 90       	pop	r10
    1c1a:	9f 90       	pop	r9
    1c1c:	8f 90       	pop	r8
    1c1e:	08 95       	ret

00001c20 <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1c20:	cf 92       	push	r12
    1c22:	df 92       	push	r13
    1c24:	ef 92       	push	r14
    1c26:	ff 92       	push	r15
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	7f d4       	rcall	.+2302   	; 0x2532 <__floatunsisf>
    1c34:	20 e0       	ldi	r18, 0x00	; 0
    1c36:	30 e0       	ldi	r19, 0x00	; 0
    1c38:	40 ea       	ldi	r20, 0xA0	; 160
    1c3a:	50 e4       	ldi	r21, 0x40	; 64
    1c3c:	30 d5       	rcall	.+2656   	; 0x269e <__mulsf3>
    1c3e:	20 e0       	ldi	r18, 0x00	; 0
    1c40:	30 e0       	ldi	r19, 0x00	; 0
    1c42:	40 e8       	ldi	r20, 0x80	; 128
    1c44:	59 e3       	ldi	r21, 0x39	; 57
    1c46:	2b d5       	rcall	.+2646   	; 0x269e <__mulsf3>
    1c48:	6b 01       	movw	r12, r22
    1c4a:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c4c:	2d ec       	ldi	r18, 0xCD	; 205
    1c4e:	3c ec       	ldi	r19, 0xCC	; 204
    1c50:	4c e6       	ldi	r20, 0x6C	; 108
    1c52:	50 e4       	ldi	r21, 0x40	; 64
    1c54:	d1 d3       	rcall	.+1954   	; 0x23f8 <__cmpsf2>
    1c56:	18 16       	cp	r1, r24
    1c58:	74 f0       	brlt	.+28     	; 0x1c76 <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c5a:	20 e0       	ldi	r18, 0x00	; 0
    1c5c:	30 e0       	ldi	r19, 0x00	; 0
    1c5e:	40 ea       	ldi	r20, 0xA0	; 160
    1c60:	51 e4       	ldi	r21, 0x41	; 65
    1c62:	c7 01       	movw	r24, r14
    1c64:	b6 01       	movw	r22, r12
    1c66:	1b d5       	rcall	.+2614   	; 0x269e <__mulsf3>
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	40 eb       	ldi	r20, 0xB0	; 176
    1c6e:	51 e4       	ldi	r21, 0x41	; 65
    1c70:	5e d3       	rcall	.+1724   	; 0x232e <__subsf3>
    1c72:	33 d4       	rcall	.+2150   	; 0x24da <__fixunssfsi>
    1c74:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c76:	26 e6       	ldi	r18, 0x66	; 102
    1c78:	36 e6       	ldi	r19, 0x66	; 102
    1c7a:	46 e9       	ldi	r20, 0x96	; 150
    1c7c:	50 e4       	ldi	r21, 0x40	; 64
    1c7e:	c7 01       	movw	r24, r14
    1c80:	b6 01       	movw	r22, r12
    1c82:	ba d3       	rcall	.+1908   	; 0x23f8 <__cmpsf2>
    1c84:	18 16       	cp	r1, r24
    1c86:	bc f0       	brlt	.+46     	; 0x1cb6 <handle_temp_sensor+0x96>
    1c88:	2d ec       	ldi	r18, 0xCD	; 205
    1c8a:	3c ec       	ldi	r19, 0xCC	; 204
    1c8c:	4c e6       	ldi	r20, 0x6C	; 108
    1c8e:	50 e4       	ldi	r21, 0x40	; 64
    1c90:	c7 01       	movw	r24, r14
    1c92:	b6 01       	movw	r22, r12
    1c94:	00 d5       	rcall	.+2560   	; 0x2696 <__gesf2>
    1c96:	18 16       	cp	r1, r24
    1c98:	74 f4       	brge	.+28     	; 0x1cb6 <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c9a:	20 e0       	ldi	r18, 0x00	; 0
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	4e e5       	ldi	r20, 0x5E	; 94
    1ca0:	52 e4       	ldi	r21, 0x42	; 66
    1ca2:	c7 01       	movw	r24, r14
    1ca4:	b6 01       	movw	r22, r12
    1ca6:	fb d4       	rcall	.+2550   	; 0x269e <__mulsf3>
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e8       	ldi	r19, 0x80	; 128
    1cac:	4b e1       	ldi	r20, 0x1B	; 27
    1cae:	53 e4       	ldi	r21, 0x43	; 67
    1cb0:	3e d3       	rcall	.+1660   	; 0x232e <__subsf3>
    1cb2:	13 d4       	rcall	.+2086   	; 0x24da <__fixunssfsi>
    1cb4:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1cb6:	26 e6       	ldi	r18, 0x66	; 102
    1cb8:	36 e6       	ldi	r19, 0x66	; 102
    1cba:	46 e9       	ldi	r20, 0x96	; 150
    1cbc:	50 e4       	ldi	r21, 0x40	; 64
    1cbe:	c7 01       	movw	r24, r14
    1cc0:	b6 01       	movw	r22, r12
    1cc2:	e9 d4       	rcall	.+2514   	; 0x2696 <__gesf2>
    1cc4:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1cc6:	74 f4       	brge	.+28     	; 0x1ce4 <handle_temp_sensor+0xc4>
    1cc8:	20 e0       	ldi	r18, 0x00	; 0
    1cca:	30 e0       	ldi	r19, 0x00	; 0
    1ccc:	48 e4       	ldi	r20, 0x48	; 72
    1cce:	53 e4       	ldi	r21, 0x43	; 67
    1cd0:	c7 01       	movw	r24, r14
    1cd2:	b6 01       	movw	r22, r12
    1cd4:	e4 d4       	rcall	.+2504   	; 0x269e <__mulsf3>
    1cd6:	20 e0       	ldi	r18, 0x00	; 0
    1cd8:	30 e0       	ldi	r19, 0x00	; 0
    1cda:	42 e5       	ldi	r20, 0x52	; 82
    1cdc:	54 e4       	ldi	r21, 0x44	; 68
    1cde:	27 d3       	rcall	.+1614   	; 0x232e <__subsf3>
    1ce0:	fc d3       	rcall	.+2040   	; 0x24da <__fixunssfsi>
    1ce2:	68 83       	st	Y, r22
    1ce4:	df 91       	pop	r29
    1ce6:	cf 91       	pop	r28
	}
}
    1ce8:	ff 90       	pop	r15
    1cea:	ef 90       	pop	r14
    1cec:	df 90       	pop	r13
    1cee:	cf 90       	pop	r12
    1cf0:	08 95       	ret

00001cf2 <handle_joulemeter>:
    1cf2:	4f 92       	push	r4
    1cf4:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cf6:	6f 92       	push	r6
    1cf8:	7f 92       	push	r7
    1cfa:	8f 92       	push	r8
    1cfc:	9f 92       	push	r9
    1cfe:	af 92       	push	r10
    1d00:	bf 92       	push	r11
    1d02:	cf 92       	push	r12
    1d04:	df 92       	push	r13
    1d06:	ef 92       	push	r14
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	cd b7       	in	r28, 0x3d	; 61
    1d12:	de b7       	in	r29, 0x3e	; 62
    1d14:	28 97       	sbiw	r28, 0x08	; 8
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	f8 94       	cli
    1d1a:	de bf       	out	0x3e, r29	; 62
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	cd bf       	out	0x3d, r28	; 61
    1d20:	6c 01       	movw	r12, r24
    1d22:	49 83       	std	Y+1, r20	; 0x01
    1d24:	5a 83       	std	Y+2, r21	; 0x02
    1d26:	6b 83       	std	Y+3, r22	; 0x03
    1d28:	7c 83       	std	Y+4, r23	; 0x04
    1d2a:	0d 83       	std	Y+5, r16	; 0x05
    1d2c:	1e 83       	std	Y+6, r17	; 0x06
    1d2e:	2f 83       	std	Y+7, r18	; 0x07
    1d30:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1d32:	6d 81       	ldd	r22, Y+5	; 0x05
    1d34:	7e 81       	ldd	r23, Y+6	; 0x06
    1d36:	8f 81       	ldd	r24, Y+7	; 0x07
    1d38:	98 85       	ldd	r25, Y+8	; 0x08
    1d3a:	29 81       	ldd	r18, Y+1	; 0x01
    1d3c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d3e:	4b 81       	ldd	r20, Y+3	; 0x03
    1d40:	5c 81       	ldd	r21, Y+4	; 0x04
    1d42:	f6 01       	movw	r30, r12
    1d44:	80 80       	ld	r8, Z
    1d46:	91 80       	ldd	r9, Z+1	; 0x01
    1d48:	a2 80       	ldd	r10, Z+2	; 0x02
    1d4a:	b3 80       	ldd	r11, Z+3	; 0x03
    1d4c:	a8 d4       	rcall	.+2384   	; 0x269e <__mulsf3>
    1d4e:	2b 01       	movw	r4, r22
    1d50:	3c 01       	movw	r6, r24
    1d52:	6e 2d       	mov	r22, r14
    1d54:	70 e0       	ldi	r23, 0x00	; 0
    1d56:	80 e0       	ldi	r24, 0x00	; 0
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	eb d3       	rcall	.+2006   	; 0x2532 <__floatunsisf>
    1d5c:	9b 01       	movw	r18, r22
    1d5e:	ac 01       	movw	r20, r24
    1d60:	c3 01       	movw	r24, r6
    1d62:	b2 01       	movw	r22, r4
    1d64:	9c d4       	rcall	.+2360   	; 0x269e <__mulsf3>
    1d66:	20 e0       	ldi	r18, 0x00	; 0
    1d68:	30 e0       	ldi	r19, 0x00	; 0
    1d6a:	4a e7       	ldi	r20, 0x7A	; 122
    1d6c:	54 e4       	ldi	r21, 0x44	; 68
    1d6e:	48 d3       	rcall	.+1680   	; 0x2400 <__divsf3>
    1d70:	a5 01       	movw	r20, r10
    1d72:	94 01       	movw	r18, r8
    1d74:	dd d2       	rcall	.+1466   	; 0x2330 <__addsf3>
    1d76:	f6 01       	movw	r30, r12
    1d78:	60 83       	st	Z, r22
    1d7a:	71 83       	std	Z+1, r23	; 0x01
    1d7c:	82 83       	std	Z+2, r24	; 0x02
    1d7e:	93 83       	std	Z+3, r25	; 0x03
}
    1d80:	28 96       	adiw	r28, 0x08	; 8
    1d82:	0f b6       	in	r0, 0x3f	; 63
    1d84:	f8 94       	cli
    1d86:	de bf       	out	0x3e, r29	; 62
    1d88:	0f be       	out	0x3f, r0	; 63
    1d8a:	cd bf       	out	0x3d, r28	; 61
    1d8c:	df 91       	pop	r29
    1d8e:	cf 91       	pop	r28
    1d90:	1f 91       	pop	r17
    1d92:	0f 91       	pop	r16
    1d94:	ef 90       	pop	r14
    1d96:	df 90       	pop	r13
    1d98:	cf 90       	pop	r12
    1d9a:	bf 90       	pop	r11
    1d9c:	af 90       	pop	r10
    1d9e:	9f 90       	pop	r9
    1da0:	8f 90       	pop	r8
    1da2:	7f 90       	pop	r7
    1da4:	6f 90       	pop	r6
    1da6:	5f 90       	pop	r5
    1da8:	4f 90       	pop	r4
    1daa:	08 95       	ret

00001dac <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	88 30       	cpi	r24, 0x08	; 8
    1db0:	91 05       	cpc	r25, r1
    1db2:	88 f5       	brcc	.+98     	; 0x1e16 <Set_ADC_Channel_ext+0x6a>
    1db4:	fc 01       	movw	r30, r24
    1db6:	e6 5b       	subi	r30, 0xB6	; 182
    1db8:	ff 4f       	sbci	r31, 0xFF	; 255
    1dba:	d4 c4       	rjmp	.+2472   	; 0x2764 <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1dbc:	86 e0       	ldi	r24, 0x06	; 6
    1dbe:	fb 01       	movw	r30, r22
    1dc0:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1dc2:	11 82       	std	Z+1, r1	; 0x01
		break;
    1dc4:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1dc6:	86 e0       	ldi	r24, 0x06	; 6
    1dc8:	fb 01       	movw	r30, r22
    1dca:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1dcc:	80 e4       	ldi	r24, 0x40	; 64
    1dce:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dd0:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1dd2:	86 e0       	ldi	r24, 0x06	; 6
    1dd4:	fb 01       	movw	r30, r22
    1dd6:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1dd8:	80 e8       	ldi	r24, 0x80	; 128
    1dda:	81 83       	std	Z+1, r24	; 0x01
		break;
    1ddc:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1dde:	86 e0       	ldi	r24, 0x06	; 6
    1de0:	fb 01       	movw	r30, r22
    1de2:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1de4:	80 ec       	ldi	r24, 0xC0	; 192
    1de6:	81 83       	std	Z+1, r24	; 0x01
		break;
    1de8:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dea:	87 e0       	ldi	r24, 0x07	; 7
    1dec:	fb 01       	movw	r30, r22
    1dee:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1df0:	11 82       	std	Z+1, r1	; 0x01
		break;
    1df2:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1df4:	87 e0       	ldi	r24, 0x07	; 7
    1df6:	fb 01       	movw	r30, r22
    1df8:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1dfa:	80 e4       	ldi	r24, 0x40	; 64
    1dfc:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dfe:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1e00:	87 e0       	ldi	r24, 0x07	; 7
    1e02:	fb 01       	movw	r30, r22
    1e04:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1e06:	80 e8       	ldi	r24, 0x80	; 128
    1e08:	81 83       	std	Z+1, r24	; 0x01
		break;
    1e0a:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1e0c:	87 e0       	ldi	r24, 0x07	; 7
    1e0e:	fb 01       	movw	r30, r22
    1e10:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1e12:	80 ec       	ldi	r24, 0xC0	; 192
    1e14:	81 83       	std	Z+1, r24	; 0x01
    1e16:	08 95       	ret

00001e18 <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1e18:	1f 92       	push	r1
    1e1a:	0f 92       	push	r0
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	0f 92       	push	r0
    1e20:	11 24       	eor	r1, r1
    1e22:	0b b6       	in	r0, 0x3b	; 59
    1e24:	0f 92       	push	r0
    1e26:	2f 93       	push	r18
    1e28:	3f 93       	push	r19
    1e2a:	4f 93       	push	r20
    1e2c:	5f 93       	push	r21
    1e2e:	6f 93       	push	r22
    1e30:	8f 93       	push	r24
    1e32:	9f 93       	push	r25
    1e34:	af 93       	push	r26
    1e36:	bf 93       	push	r27
    1e38:	ef 93       	push	r30
    1e3a:	ff 93       	push	r31
    1e3c:	cf 93       	push	r28
    1e3e:	df 93       	push	r29
    1e40:	1f 92       	push	r1
    1e42:	cd b7       	in	r28, 0x3d	; 61
    1e44:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1e46:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e4a:	80 ff       	sbrs	r24, 0
    1e4c:	47 c0       	rjmp	.+142    	; 0x1edc <__vector_18+0xc4>
    1e4e:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e52:	90 ff       	sbrs	r25, 0
    1e54:	43 c0       	rjmp	.+134    	; 0x1edc <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e56:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e5a:	ee ee       	ldi	r30, 0xEE	; 238
    1e5c:	f0 e0       	ldi	r31, 0x00	; 0
    1e5e:	80 81       	ld	r24, Z
    1e60:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e62:	80 81       	ld	r24, Z
    1e64:	8f 7b       	andi	r24, 0xBF	; 191
    1e66:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e68:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e6c:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e70:	98 17       	cp	r25, r24
    1e72:	89 f1       	breq	.+98     	; 0x1ed6 <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e74:	8f 70       	andi	r24, 0x0F	; 15
    1e76:	2b e0       	ldi	r18, 0x0B	; 11
    1e78:	82 9f       	mul	r24, r18
    1e7a:	c0 01       	movw	r24, r0
    1e7c:	11 24       	eor	r1, r1
    1e7e:	fc 01       	movw	r30, r24
    1e80:	e1 54       	subi	r30, 0x41	; 65
    1e82:	fd 4f       	sbci	r31, 0xFD	; 253
    1e84:	20 81       	ld	r18, Z
    1e86:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e8a:	20 81       	ld	r18, Z
    1e8c:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e90:	21 81       	ldd	r18, Z+1	; 0x01
    1e92:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e96:	23 81       	ldd	r18, Z+3	; 0x03
    1e98:	aa ef       	ldi	r26, 0xFA	; 250
    1e9a:	b0 e0       	ldi	r27, 0x00	; 0
    1e9c:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e9e:	24 81       	ldd	r18, Z+4	; 0x04
    1ea0:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1ea2:	25 81       	ldd	r18, Z+5	; 0x05
    1ea4:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1ea6:	26 81       	ldd	r18, Z+6	; 0x06
    1ea8:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1eaa:	27 81       	ldd	r18, Z+7	; 0x07
    1eac:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1eae:	20 85       	ldd	r18, Z+8	; 0x08
    1eb0:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1eb2:	21 85       	ldd	r18, Z+9	; 0x09
    1eb4:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1eb6:	22 85       	ldd	r18, Z+10	; 0x0a
    1eb8:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1eba:	fc 01       	movw	r30, r24
    1ebc:	ef 53       	subi	r30, 0x3F	; 63
    1ebe:	fd 4f       	sbci	r31, 0xFD	; 253
    1ec0:	80 81       	ld	r24, Z
    1ec2:	8f 70       	andi	r24, 0x0F	; 15
    1ec4:	80 64       	ori	r24, 0x40	; 64
    1ec6:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1eca:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1ece:	8f 5f       	subi	r24, 0xFF	; 255
    1ed0:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1ed4:	7d c0       	rjmp	.+250    	; 0x1fd0 <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1ed6:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1eda:	7a c0       	rjmp	.+244    	; 0x1fd0 <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1edc:	81 ff       	sbrs	r24, 1
    1ede:	78 c0       	rjmp	.+240    	; 0x1fd0 <__vector_18+0x1b8>
    1ee0:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1ee4:	81 ff       	sbrs	r24, 1
    1ee6:	74 c0       	rjmp	.+232    	; 0x1fd0 <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1ee8:	80 e1       	ldi	r24, 0x10	; 16
    1eea:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1eee:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ef2:	28 2f       	mov	r18, r24
    1ef4:	30 e0       	ldi	r19, 0x00	; 0
    1ef6:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1efa:	29 1b       	sub	r18, r25
    1efc:	31 09       	sbc	r19, r1
    1efe:	2f 77       	andi	r18, 0x7F	; 127
    1f00:	33 27       	eor	r19, r19
    1f02:	20 31       	cpi	r18, 0x10	; 16
    1f04:	31 05       	cpc	r19, r1
    1f06:	0c f0       	brlt	.+2      	; 0x1f0a <__vector_18+0xf2>
    1f08:	58 c0       	rjmp	.+176    	; 0x1fba <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1f0a:	e8 2f       	mov	r30, r24
    1f0c:	ef 70       	andi	r30, 0x0F	; 15
    1f0e:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1f12:	2e 2f       	mov	r18, r30
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	4b e0       	ldi	r20, 0x0B	; 11
    1f18:	e4 9f       	mul	r30, r20
    1f1a:	f0 01       	movw	r30, r0
    1f1c:	11 24       	eor	r1, r1
    1f1e:	e1 5f       	subi	r30, 0xF1	; 241
    1f20:	fd 4f       	sbci	r31, 0xFD	; 253
    1f22:	9f 70       	andi	r25, 0x0F	; 15
    1f24:	42 81       	ldd	r20, Z+2	; 0x02
    1f26:	40 7f       	andi	r20, 0xF0	; 240
    1f28:	94 2b       	or	r25, r20
    1f2a:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1f2c:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1f30:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f34:	40 7e       	andi	r20, 0xE0	; 224
    1f36:	97 70       	andi	r25, 0x07	; 7
    1f38:	94 2b       	or	r25, r20
    1f3a:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1f3c:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1f40:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1f42:	aa ef       	ldi	r26, 0xFA	; 250
    1f44:	b0 e0       	ldi	r27, 0x00	; 0
    1f46:	9c 91       	ld	r25, X
    1f48:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f4a:	9c 91       	ld	r25, X
    1f4c:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f4e:	9c 91       	ld	r25, X
    1f50:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f52:	9c 91       	ld	r25, X
    1f54:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f56:	9c 91       	ld	r25, X
    1f58:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f5a:	9c 91       	ld	r25, X
    1f5c:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f5e:	9c 91       	ld	r25, X
    1f60:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f62:	9c 91       	ld	r25, X
    1f64:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f66:	8f 5f       	subi	r24, 0xFF	; 255
    1f68:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f6c:	40 81       	ld	r20, Z
    1f6e:	42 95       	swap	r20
    1f70:	46 95       	lsr	r20
    1f72:	47 70       	andi	r20, 0x07	; 7
    1f74:	51 81       	ldd	r21, Z+1	; 0x01
    1f76:	65 2f       	mov	r22, r21
    1f78:	66 0f       	add	r22, r22
    1f7a:	66 0f       	add	r22, r22
    1f7c:	66 0f       	add	r22, r22
    1f7e:	86 2f       	mov	r24, r22
    1f80:	84 2b       	or	r24, r20
    1f82:	95 2f       	mov	r25, r21
    1f84:	92 95       	swap	r25
    1f86:	96 95       	lsr	r25
    1f88:	97 70       	andi	r25, 0x07	; 7
    1f8a:	89 2b       	or	r24, r25
    1f8c:	b1 f4       	brne	.+44     	; 0x1fba <__vector_18+0x1a2>
    1f8e:	8b e0       	ldi	r24, 0x0B	; 11
    1f90:	82 9f       	mul	r24, r18
    1f92:	f0 01       	movw	r30, r0
    1f94:	83 9f       	mul	r24, r19
    1f96:	f0 0d       	add	r31, r0
    1f98:	11 24       	eor	r1, r1
    1f9a:	e1 5f       	subi	r30, 0xF1	; 241
    1f9c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f9e:	83 81       	ldd	r24, Z+3	; 0x03
    1fa0:	83 30       	cpi	r24, 0x03	; 3
    1fa2:	59 f4       	brne	.+22     	; 0x1fba <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1fa4:	98 e0       	ldi	r25, 0x08	; 8
    1fa6:	88 e1       	ldi	r24, 0x18	; 24
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	a8 95       	wdr
    1fae:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1fb2:	0f be       	out	0x3f, r0	; 63
    1fb4:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1fb8:	ff cf       	rjmp	.-2      	; 0x1fb8 <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1fba:	ee ee       	ldi	r30, 0xEE	; 238
    1fbc:	f0 e0       	ldi	r31, 0x00	; 0
    1fbe:	80 81       	ld	r24, Z
    1fc0:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1fc4:	80 81       	ld	r24, Z
    1fc6:	8f 7d       	andi	r24, 0xDF	; 223
    1fc8:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1fca:	80 e8       	ldi	r24, 0x80	; 128
    1fcc:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1fd0:	0f 90       	pop	r0
    1fd2:	df 91       	pop	r29
    1fd4:	cf 91       	pop	r28
    1fd6:	ff 91       	pop	r31
    1fd8:	ef 91       	pop	r30
    1fda:	bf 91       	pop	r27
    1fdc:	af 91       	pop	r26
    1fde:	9f 91       	pop	r25
    1fe0:	8f 91       	pop	r24
    1fe2:	6f 91       	pop	r22
    1fe4:	5f 91       	pop	r21
    1fe6:	4f 91       	pop	r20
    1fe8:	3f 91       	pop	r19
    1fea:	2f 91       	pop	r18
    1fec:	0f 90       	pop	r0
    1fee:	0b be       	out	0x3b, r0	; 59
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63
    1ff4:	0f 90       	pop	r0
    1ff6:	1f 90       	pop	r1
    1ff8:	18 95       	reti

00001ffa <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1ffe:	e8 ed       	ldi	r30, 0xD8	; 216
    2000:	f0 e0       	ldi	r31, 0x00	; 0
    2002:	21 e0       	ldi	r18, 0x01	; 1
    2004:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    2006:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    200a:	2c e0       	ldi	r18, 0x0C	; 12
    200c:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    2010:	27 e3       	ldi	r18, 0x37	; 55
    2012:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    2016:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    201a:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    201e:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2022:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    2026:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    202a:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    202e:	cd ee       	ldi	r28, 0xED	; 237
    2030:	d0 e0       	ldi	r29, 0x00	; 0
    2032:	18 82       	st	Y, r1
	CANSTMOB = 0;
    2034:	ae ee       	ldi	r26, 0xEE	; 238
    2036:	b0 e0       	ldi	r27, 0x00	; 0
    2038:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    203a:	20 e1       	ldi	r18, 0x10	; 16
    203c:	28 83       	st	Y, r18
	CANSTMOB = 0;
    203e:	1c 92       	st	X, r1
	CANIDM4 = 0;
    2040:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    2044:	28 2f       	mov	r18, r24
    2046:	22 95       	swap	r18
    2048:	22 0f       	add	r18, r18
    204a:	20 7e       	andi	r18, 0xE0	; 224
    204c:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    2050:	96 95       	lsr	r25
    2052:	87 95       	ror	r24
    2054:	96 95       	lsr	r25
    2056:	87 95       	ror	r24
    2058:	96 95       	lsr	r25
    205a:	87 95       	ror	r24
    205c:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    2060:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    2064:	86 2f       	mov	r24, r22
    2066:	82 95       	swap	r24
    2068:	88 0f       	add	r24, r24
    206a:	80 7e       	andi	r24, 0xE0	; 224
    206c:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    2070:	76 95       	lsr	r23
    2072:	67 95       	ror	r22
    2074:	76 95       	lsr	r23
    2076:	67 95       	ror	r22
    2078:	76 95       	lsr	r23
    207a:	67 95       	ror	r22
    207c:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    2080:	80 e8       	ldi	r24, 0x80	; 128
    2082:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    2086:	83 e0       	ldi	r24, 0x03	; 3
    2088:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    208c:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    2090:	80 eb       	ldi	r24, 0xB0	; 176
    2092:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    2096:	82 e0       	ldi	r24, 0x02	; 2
    2098:	80 83       	st	Z, r24

	reset = 0;
    209a:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
    20a2:	08 95       	ret

000020a4 <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    20a4:	cf 93       	push	r28
    20a6:	df 93       	push	r29
    20a8:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    20aa:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    20ae:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    20b2:	24 17       	cp	r18, r20
    20b4:	89 f1       	breq	.+98     	; 0x2118 <can_read_message_if_new+0x74>
    20b6:	a4 2f       	mov	r26, r20
    20b8:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    20ba:	8b e0       	ldi	r24, 0x0B	; 11
    20bc:	a8 9f       	mul	r26, r24
    20be:	b0 01       	movw	r22, r0
    20c0:	11 24       	eor	r1, r1
    20c2:	fb 01       	movw	r30, r22
    20c4:	e1 5f       	subi	r30, 0xF1	; 241
    20c6:	fd 4f       	sbci	r31, 0xFD	; 253
    20c8:	20 81       	ld	r18, Z
    20ca:	22 95       	swap	r18
    20cc:	26 95       	lsr	r18
    20ce:	27 70       	andi	r18, 0x07	; 7
    20d0:	31 81       	ldd	r19, Z+1	; 0x01
    20d2:	53 2f       	mov	r21, r19
    20d4:	55 0f       	add	r21, r21
    20d6:	55 0f       	add	r21, r21
    20d8:	55 0f       	add	r21, r21
    20da:	25 2b       	or	r18, r21
    20dc:	32 95       	swap	r19
    20de:	36 95       	lsr	r19
    20e0:	37 70       	andi	r19, 0x07	; 7
    20e2:	28 83       	st	Y, r18
    20e4:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    20e6:	fb 01       	movw	r30, r22
    20e8:	ef 5e       	subi	r30, 0xEF	; 239
    20ea:	fd 4f       	sbci	r31, 0xFD	; 253
    20ec:	20 81       	ld	r18, Z
    20ee:	2f 70       	andi	r18, 0x0F	; 15
    20f0:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20f2:	22 23       	and	r18, r18
    20f4:	99 f0       	breq	.+38     	; 0x211c <can_read_message_if_new+0x78>
    20f6:	db 01       	movw	r26, r22
    20f8:	ae 5e       	subi	r26, 0xEE	; 238
    20fa:	bd 4f       	sbci	r27, 0xFD	; 253
    20fc:	fe 01       	movw	r30, r28
    20fe:	33 96       	adiw	r30, 0x03	; 3
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	2d 5f       	subi	r18, 0xFD	; 253
    2104:	3f 4f       	sbci	r19, 0xFF	; 255
    2106:	ce 01       	movw	r24, r28
    2108:	82 0f       	add	r24, r18
    210a:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    210c:	2d 91       	ld	r18, X+
    210e:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    2110:	e8 17       	cp	r30, r24
    2112:	f9 07       	cpc	r31, r25
    2114:	d9 f7       	brne	.-10     	; 0x210c <can_read_message_if_new+0x68>
    2116:	02 c0       	rjmp	.+4      	; 0x211c <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    2118:	80 e0       	ldi	r24, 0x00	; 0
    211a:	04 c0       	rjmp	.+8      	; 0x2124 <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    211c:	4f 5f       	subi	r20, 0xFF	; 255
    211e:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    2122:	81 e0       	ldi	r24, 0x01	; 1
}
    2124:	df 91       	pop	r29
    2126:	cf 91       	pop	r28
    2128:	08 95       	ret

0000212a <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    212a:	cf 93       	push	r28
    212c:	df 93       	push	r29
    212e:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    2130:	ab ed       	ldi	r26, 0xDB	; 219
    2132:	b0 e0       	ldi	r27, 0x00	; 0
    2134:	8c 91       	ld	r24, X
    2136:	8f 77       	andi	r24, 0x7F	; 127
    2138:	8c 93       	st	X, r24

	if (!tx_busy) {
    213a:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    213e:	81 11       	cpse	r24, r1
    2140:	27 c0       	rjmp	.+78     	; 0x2190 <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2142:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    2146:	80 81       	ld	r24, Z
    2148:	82 95       	swap	r24
    214a:	88 0f       	add	r24, r24
    214c:	80 7e       	andi	r24, 0xE0	; 224
    214e:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2152:	80 81       	ld	r24, Z
    2154:	91 81       	ldd	r25, Z+1	; 0x01
    2156:	96 95       	lsr	r25
    2158:	87 95       	ror	r24
    215a:	96 95       	lsr	r25
    215c:	87 95       	ror	r24
    215e:	96 95       	lsr	r25
    2160:	87 95       	ror	r24
    2162:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2166:	df 01       	movw	r26, r30
    2168:	13 96       	adiw	r26, 0x03	; 3
    216a:	9f 01       	movw	r18, r30
    216c:	25 5f       	subi	r18, 0xF5	; 245
    216e:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    2170:	ca ef       	ldi	r28, 0xFA	; 250
    2172:	d0 e0       	ldi	r29, 0x00	; 0
    2174:	9d 91       	ld	r25, X+
    2176:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    2178:	a2 17       	cp	r26, r18
    217a:	b3 07       	cpc	r27, r19
    217c:	d9 f7       	brne	.-10     	; 0x2174 <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    217e:	81 e0       	ldi	r24, 0x01	; 1
    2180:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    2184:	82 81       	ldd	r24, Z+2	; 0x02
    2186:	80 64       	ori	r24, 0x40	; 64
    2188:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	43 c0       	rjmp	.+134    	; 0x2216 <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    2190:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    2194:	82 2f       	mov	r24, r18
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    219c:	83 1b       	sub	r24, r19
    219e:	91 09       	sbc	r25, r1
    21a0:	8f 77       	andi	r24, 0x7F	; 127
    21a2:	99 27       	eor	r25, r25
    21a4:	40 97       	sbiw	r24, 0x10	; 16
    21a6:	b1 f1       	breq	.+108    	; 0x2214 <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    21a8:	a2 2f       	mov	r26, r18
    21aa:	af 70       	andi	r26, 0x0F	; 15
    21ac:	8b e0       	ldi	r24, 0x0B	; 11
    21ae:	a8 9f       	mul	r26, r24
    21b0:	d0 01       	movw	r26, r0
    21b2:	11 24       	eor	r1, r1
    21b4:	ed 01       	movw	r28, r26
    21b6:	c1 54       	subi	r28, 0x41	; 65
    21b8:	dd 4f       	sbci	r29, 0xFD	; 253
    21ba:	80 81       	ld	r24, Z
    21bc:	98 2f       	mov	r25, r24
    21be:	92 95       	swap	r25
    21c0:	99 0f       	add	r25, r25
    21c2:	90 7e       	andi	r25, 0xE0	; 224
    21c4:	88 81       	ld	r24, Y
    21c6:	8f 71       	andi	r24, 0x1F	; 31
    21c8:	89 2b       	or	r24, r25
    21ca:	88 83       	st	Y, r24
    21cc:	80 81       	ld	r24, Z
    21ce:	98 2f       	mov	r25, r24
    21d0:	96 95       	lsr	r25
    21d2:	96 95       	lsr	r25
    21d4:	96 95       	lsr	r25
    21d6:	89 81       	ldd	r24, Y+1	; 0x01
    21d8:	80 7e       	andi	r24, 0xE0	; 224
    21da:	89 2b       	or	r24, r25
    21dc:	89 83       	std	Y+1, r24	; 0x01
    21de:	91 81       	ldd	r25, Z+1	; 0x01
    21e0:	92 95       	swap	r25
    21e2:	99 0f       	add	r25, r25
    21e4:	90 7e       	andi	r25, 0xE0	; 224
    21e6:	8f 71       	andi	r24, 0x1F	; 31
    21e8:	89 2b       	or	r24, r25
    21ea:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21ec:	82 81       	ldd	r24, Z+2	; 0x02
    21ee:	98 2f       	mov	r25, r24
    21f0:	9f 70       	andi	r25, 0x0F	; 15
    21f2:	8a 81       	ldd	r24, Y+2	; 0x02
    21f4:	80 7f       	andi	r24, 0xF0	; 240
    21f6:	89 2b       	or	r24, r25
    21f8:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21fa:	ae 53       	subi	r26, 0x3E	; 62
    21fc:	bd 4f       	sbci	r27, 0xFD	; 253
    21fe:	33 96       	adiw	r30, 0x03	; 3
    2200:	88 e0       	ldi	r24, 0x08	; 8
    2202:	01 90       	ld	r0, Z+
    2204:	0d 92       	st	X+, r0
    2206:	8a 95       	dec	r24
    2208:	e1 f7       	brne	.-8      	; 0x2202 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    220a:	2f 5f       	subi	r18, 0xFF	; 255
    220c:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    2210:	81 e0       	ldi	r24, 0x01	; 1
    2212:	01 c0       	rjmp	.+2      	; 0x2216 <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    2214:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    2216:	eb ed       	ldi	r30, 0xDB	; 219
    2218:	f0 e0       	ldi	r31, 0x00	; 0
    221a:	90 81       	ld	r25, Z
    221c:	90 68       	ori	r25, 0x80	; 128
    221e:	90 83       	st	Z, r25

	return result;
    2220:	df 91       	pop	r29
    2222:	cf 91       	pop	r28
    2224:	08 95       	ret

00002226 <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    2226:	95 b1       	in	r25, 0x05	; 5
    2228:	89 2b       	or	r24, r25
    222a:	85 b9       	out	0x05, r24	; 5
    222c:	08 95       	ret

0000222e <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    222e:	84 b1       	in	r24, 0x04	; 4
    2230:	80 6e       	ori	r24, 0xE0	; 224
    2232:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    2234:	80 ee       	ldi	r24, 0xE0	; 224
    2236:	f7 cf       	rjmp	.-18     	; 0x2226 <rgbled_turn_off>
    2238:	08 95       	ret

0000223a <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    223a:	95 b1       	in	r25, 0x05	; 5
    223c:	80 95       	com	r24
    223e:	98 23       	and	r25, r24
    2240:	95 b9       	out	0x05, r25	; 5
    2242:	08 95       	ret

00002244 <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    2244:	95 b1       	in	r25, 0x05	; 5
    2246:	89 27       	eor	r24, r25
    2248:	85 b9       	out	0x05, r24	; 5
    224a:	08 95       	ret

0000224c <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    224c:	94 b1       	in	r25, 0x04	; 4
    224e:	97 60       	ori	r25, 0x07	; 7
    2250:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2252:	82 fb       	bst	r24, 2
    2254:	99 27       	eor	r25, r25
    2256:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    2258:	28 2f       	mov	r18, r24
    225a:	22 70       	andi	r18, 0x02	; 2
    225c:	81 70       	andi	r24, 0x01	; 1
    225e:	80 65       	ori	r24, 0x50	; 80
    2260:	82 2b       	or	r24, r18
    2262:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    2264:	8c b5       	in	r24, 0x2c	; 44
    2266:	83 7f       	andi	r24, 0xF3	; 243
    2268:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    226a:	9d bd       	out	0x2d, r25	; 45
    226c:	08 95       	ret

0000226e <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    226e:	cf 93       	push	r28
    2270:	df 93       	push	r29
    2272:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    2274:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    2276:	41 15       	cp	r20, r1
    2278:	51 05       	cpc	r21, r1
    227a:	c1 f0       	breq	.+48     	; 0x22ac <spi_trancieve+0x3e>
    227c:	fb 01       	movw	r30, r22
    227e:	dc 01       	movw	r26, r24
    2280:	46 0f       	add	r20, r22
    2282:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    2284:	8f ef       	ldi	r24, 0xFF	; 255
    2286:	20 97       	sbiw	r28, 0x00	; 0
    2288:	11 f0       	breq	.+4      	; 0x228e <spi_trancieve+0x20>
    228a:	9c 91       	ld	r25, X
    228c:	01 c0       	rjmp	.+2      	; 0x2290 <spi_trancieve+0x22>
    228e:	98 2f       	mov	r25, r24
    2290:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2292:	0d b4       	in	r0, 0x2d	; 45
    2294:	07 fe       	sbrs	r0, 7
    2296:	fd cf       	rjmp	.-6      	; 0x2292 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    2298:	61 15       	cp	r22, r1
    229a:	71 05       	cpc	r23, r1
    229c:	11 f0       	breq	.+4      	; 0x22a2 <spi_trancieve+0x34>
    229e:	9e b5       	in	r25, 0x2e	; 46
    22a0:	90 83       	st	Z, r25
    22a2:	31 96       	adiw	r30, 0x01	; 1
    22a4:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    22a6:	e4 17       	cp	r30, r20
    22a8:	f5 07       	cpc	r31, r21
    22aa:	69 f7       	brne	.-38     	; 0x2286 <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    22ac:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    22ae:	28 9a       	sbi	0x05, 0	; 5
	}
}
    22b0:	df 91       	pop	r29
    22b2:	cf 91       	pop	r28
    22b4:	08 95       	ret

000022b6 <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    22b6:	1f 92       	push	r1
    22b8:	0f 92       	push	r0
    22ba:	0f b6       	in	r0, 0x3f	; 63
    22bc:	0f 92       	push	r0
    22be:	11 24       	eor	r1, r1
    22c0:	0b b6       	in	r0, 0x3b	; 59
    22c2:	0f 92       	push	r0
    22c4:	2f 93       	push	r18
    22c6:	3f 93       	push	r19
    22c8:	4f 93       	push	r20
    22ca:	5f 93       	push	r21
    22cc:	6f 93       	push	r22
    22ce:	7f 93       	push	r23
    22d0:	8f 93       	push	r24
    22d2:	af 93       	push	r26
    22d4:	bf 93       	push	r27
    22d6:	ef 93       	push	r30
    22d8:	ff 93       	push	r31
    22da:	af e8       	ldi	r26, 0x8F	; 143
    22dc:	b3 e0       	ldi	r27, 0x03	; 3
    22de:	ef e6       	ldi	r30, 0x6F	; 111
    22e0:	f3 e0       	ldi	r31, 0x03	; 3
    22e2:	2f e8       	ldi	r18, 0x8F	; 143
    22e4:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    22e6:	8d 91       	ld	r24, X+
    22e8:	88 23       	and	r24, r24
    22ea:	59 f0       	breq	.+22     	; 0x2302 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22ec:	40 81       	ld	r20, Z
    22ee:	51 81       	ldd	r21, Z+1	; 0x01
    22f0:	62 81       	ldd	r22, Z+2	; 0x02
    22f2:	73 81       	ldd	r23, Z+3	; 0x03
    22f4:	50 5e       	subi	r21, 0xE0	; 224
    22f6:	6f 4f       	sbci	r22, 0xFF	; 255
    22f8:	7f 4f       	sbci	r23, 0xFF	; 255
    22fa:	40 83       	st	Z, r20
    22fc:	51 83       	std	Z+1, r21	; 0x01
    22fe:	62 83       	std	Z+2, r22	; 0x02
    2300:	73 83       	std	Z+3, r23	; 0x03
    2302:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    2304:	e2 17       	cp	r30, r18
    2306:	f3 07       	cpc	r31, r19
    2308:	71 f7       	brne	.-36     	; 0x22e6 <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    230a:	ff 91       	pop	r31
    230c:	ef 91       	pop	r30
    230e:	bf 91       	pop	r27
    2310:	af 91       	pop	r26
    2312:	8f 91       	pop	r24
    2314:	7f 91       	pop	r23
    2316:	6f 91       	pop	r22
    2318:	5f 91       	pop	r21
    231a:	4f 91       	pop	r20
    231c:	3f 91       	pop	r19
    231e:	2f 91       	pop	r18
    2320:	0f 90       	pop	r0
    2322:	0b be       	out	0x3b, r0	; 59
    2324:	0f 90       	pop	r0
    2326:	0f be       	out	0x3f, r0	; 63
    2328:	0f 90       	pop	r0
    232a:	1f 90       	pop	r1
    232c:	18 95       	reti

0000232e <__subsf3>:
    232e:	50 58       	subi	r21, 0x80	; 128

00002330 <__addsf3>:
    2330:	bb 27       	eor	r27, r27
    2332:	aa 27       	eor	r26, r26
    2334:	0e d0       	rcall	.+28     	; 0x2352 <__addsf3x>
    2336:	75 c1       	rjmp	.+746    	; 0x2622 <__fp_round>
    2338:	66 d1       	rcall	.+716    	; 0x2606 <__fp_pscA>
    233a:	30 f0       	brcs	.+12     	; 0x2348 <__addsf3+0x18>
    233c:	6b d1       	rcall	.+726    	; 0x2614 <__fp_pscB>
    233e:	20 f0       	brcs	.+8      	; 0x2348 <__addsf3+0x18>
    2340:	31 f4       	brne	.+12     	; 0x234e <__addsf3+0x1e>
    2342:	9f 3f       	cpi	r25, 0xFF	; 255
    2344:	11 f4       	brne	.+4      	; 0x234a <__addsf3+0x1a>
    2346:	1e f4       	brtc	.+6      	; 0x234e <__addsf3+0x1e>
    2348:	5b c1       	rjmp	.+694    	; 0x2600 <__fp_nan>
    234a:	0e f4       	brtc	.+2      	; 0x234e <__addsf3+0x1e>
    234c:	e0 95       	com	r30
    234e:	e7 fb       	bst	r30, 7
    2350:	51 c1       	rjmp	.+674    	; 0x25f4 <__fp_inf>

00002352 <__addsf3x>:
    2352:	e9 2f       	mov	r30, r25
    2354:	77 d1       	rcall	.+750    	; 0x2644 <__fp_split3>
    2356:	80 f3       	brcs	.-32     	; 0x2338 <__addsf3+0x8>
    2358:	ba 17       	cp	r27, r26
    235a:	62 07       	cpc	r22, r18
    235c:	73 07       	cpc	r23, r19
    235e:	84 07       	cpc	r24, r20
    2360:	95 07       	cpc	r25, r21
    2362:	18 f0       	brcs	.+6      	; 0x236a <__addsf3x+0x18>
    2364:	71 f4       	brne	.+28     	; 0x2382 <__addsf3x+0x30>
    2366:	9e f5       	brtc	.+102    	; 0x23ce <__addsf3x+0x7c>
    2368:	8f c1       	rjmp	.+798    	; 0x2688 <__fp_zero>
    236a:	0e f4       	brtc	.+2      	; 0x236e <__addsf3x+0x1c>
    236c:	e0 95       	com	r30
    236e:	0b 2e       	mov	r0, r27
    2370:	ba 2f       	mov	r27, r26
    2372:	a0 2d       	mov	r26, r0
    2374:	0b 01       	movw	r0, r22
    2376:	b9 01       	movw	r22, r18
    2378:	90 01       	movw	r18, r0
    237a:	0c 01       	movw	r0, r24
    237c:	ca 01       	movw	r24, r20
    237e:	a0 01       	movw	r20, r0
    2380:	11 24       	eor	r1, r1
    2382:	ff 27       	eor	r31, r31
    2384:	59 1b       	sub	r21, r25
    2386:	99 f0       	breq	.+38     	; 0x23ae <__addsf3x+0x5c>
    2388:	59 3f       	cpi	r21, 0xF9	; 249
    238a:	50 f4       	brcc	.+20     	; 0x23a0 <__addsf3x+0x4e>
    238c:	50 3e       	cpi	r21, 0xE0	; 224
    238e:	68 f1       	brcs	.+90     	; 0x23ea <__addsf3x+0x98>
    2390:	1a 16       	cp	r1, r26
    2392:	f0 40       	sbci	r31, 0x00	; 0
    2394:	a2 2f       	mov	r26, r18
    2396:	23 2f       	mov	r18, r19
    2398:	34 2f       	mov	r19, r20
    239a:	44 27       	eor	r20, r20
    239c:	58 5f       	subi	r21, 0xF8	; 248
    239e:	f3 cf       	rjmp	.-26     	; 0x2386 <__addsf3x+0x34>
    23a0:	46 95       	lsr	r20
    23a2:	37 95       	ror	r19
    23a4:	27 95       	ror	r18
    23a6:	a7 95       	ror	r26
    23a8:	f0 40       	sbci	r31, 0x00	; 0
    23aa:	53 95       	inc	r21
    23ac:	c9 f7       	brne	.-14     	; 0x23a0 <__addsf3x+0x4e>
    23ae:	7e f4       	brtc	.+30     	; 0x23ce <__addsf3x+0x7c>
    23b0:	1f 16       	cp	r1, r31
    23b2:	ba 0b       	sbc	r27, r26
    23b4:	62 0b       	sbc	r22, r18
    23b6:	73 0b       	sbc	r23, r19
    23b8:	84 0b       	sbc	r24, r20
    23ba:	ba f0       	brmi	.+46     	; 0x23ea <__addsf3x+0x98>
    23bc:	91 50       	subi	r25, 0x01	; 1
    23be:	a1 f0       	breq	.+40     	; 0x23e8 <__addsf3x+0x96>
    23c0:	ff 0f       	add	r31, r31
    23c2:	bb 1f       	adc	r27, r27
    23c4:	66 1f       	adc	r22, r22
    23c6:	77 1f       	adc	r23, r23
    23c8:	88 1f       	adc	r24, r24
    23ca:	c2 f7       	brpl	.-16     	; 0x23bc <__addsf3x+0x6a>
    23cc:	0e c0       	rjmp	.+28     	; 0x23ea <__addsf3x+0x98>
    23ce:	ba 0f       	add	r27, r26
    23d0:	62 1f       	adc	r22, r18
    23d2:	73 1f       	adc	r23, r19
    23d4:	84 1f       	adc	r24, r20
    23d6:	48 f4       	brcc	.+18     	; 0x23ea <__addsf3x+0x98>
    23d8:	87 95       	ror	r24
    23da:	77 95       	ror	r23
    23dc:	67 95       	ror	r22
    23de:	b7 95       	ror	r27
    23e0:	f7 95       	ror	r31
    23e2:	9e 3f       	cpi	r25, 0xFE	; 254
    23e4:	08 f0       	brcs	.+2      	; 0x23e8 <__addsf3x+0x96>
    23e6:	b3 cf       	rjmp	.-154    	; 0x234e <__addsf3+0x1e>
    23e8:	93 95       	inc	r25
    23ea:	88 0f       	add	r24, r24
    23ec:	08 f0       	brcs	.+2      	; 0x23f0 <__addsf3x+0x9e>
    23ee:	99 27       	eor	r25, r25
    23f0:	ee 0f       	add	r30, r30
    23f2:	97 95       	ror	r25
    23f4:	87 95       	ror	r24
    23f6:	08 95       	ret

000023f8 <__cmpsf2>:
    23f8:	d9 d0       	rcall	.+434    	; 0x25ac <__fp_cmp>
    23fa:	08 f4       	brcc	.+2      	; 0x23fe <__cmpsf2+0x6>
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	08 95       	ret

00002400 <__divsf3>:
    2400:	0c d0       	rcall	.+24     	; 0x241a <__divsf3x>
    2402:	0f c1       	rjmp	.+542    	; 0x2622 <__fp_round>
    2404:	07 d1       	rcall	.+526    	; 0x2614 <__fp_pscB>
    2406:	40 f0       	brcs	.+16     	; 0x2418 <__divsf3+0x18>
    2408:	fe d0       	rcall	.+508    	; 0x2606 <__fp_pscA>
    240a:	30 f0       	brcs	.+12     	; 0x2418 <__divsf3+0x18>
    240c:	21 f4       	brne	.+8      	; 0x2416 <__divsf3+0x16>
    240e:	5f 3f       	cpi	r21, 0xFF	; 255
    2410:	19 f0       	breq	.+6      	; 0x2418 <__divsf3+0x18>
    2412:	f0 c0       	rjmp	.+480    	; 0x25f4 <__fp_inf>
    2414:	51 11       	cpse	r21, r1
    2416:	39 c1       	rjmp	.+626    	; 0x268a <__fp_szero>
    2418:	f3 c0       	rjmp	.+486    	; 0x2600 <__fp_nan>

0000241a <__divsf3x>:
    241a:	14 d1       	rcall	.+552    	; 0x2644 <__fp_split3>
    241c:	98 f3       	brcs	.-26     	; 0x2404 <__divsf3+0x4>

0000241e <__divsf3_pse>:
    241e:	99 23       	and	r25, r25
    2420:	c9 f3       	breq	.-14     	; 0x2414 <__divsf3+0x14>
    2422:	55 23       	and	r21, r21
    2424:	b1 f3       	breq	.-20     	; 0x2412 <__divsf3+0x12>
    2426:	95 1b       	sub	r25, r21
    2428:	55 0b       	sbc	r21, r21
    242a:	bb 27       	eor	r27, r27
    242c:	aa 27       	eor	r26, r26
    242e:	62 17       	cp	r22, r18
    2430:	73 07       	cpc	r23, r19
    2432:	84 07       	cpc	r24, r20
    2434:	38 f0       	brcs	.+14     	; 0x2444 <__divsf3_pse+0x26>
    2436:	9f 5f       	subi	r25, 0xFF	; 255
    2438:	5f 4f       	sbci	r21, 0xFF	; 255
    243a:	22 0f       	add	r18, r18
    243c:	33 1f       	adc	r19, r19
    243e:	44 1f       	adc	r20, r20
    2440:	aa 1f       	adc	r26, r26
    2442:	a9 f3       	breq	.-22     	; 0x242e <__divsf3_pse+0x10>
    2444:	33 d0       	rcall	.+102    	; 0x24ac <__divsf3_pse+0x8e>
    2446:	0e 2e       	mov	r0, r30
    2448:	3a f0       	brmi	.+14     	; 0x2458 <__divsf3_pse+0x3a>
    244a:	e0 e8       	ldi	r30, 0x80	; 128
    244c:	30 d0       	rcall	.+96     	; 0x24ae <__divsf3_pse+0x90>
    244e:	91 50       	subi	r25, 0x01	; 1
    2450:	50 40       	sbci	r21, 0x00	; 0
    2452:	e6 95       	lsr	r30
    2454:	00 1c       	adc	r0, r0
    2456:	ca f7       	brpl	.-14     	; 0x244a <__divsf3_pse+0x2c>
    2458:	29 d0       	rcall	.+82     	; 0x24ac <__divsf3_pse+0x8e>
    245a:	fe 2f       	mov	r31, r30
    245c:	27 d0       	rcall	.+78     	; 0x24ac <__divsf3_pse+0x8e>
    245e:	66 0f       	add	r22, r22
    2460:	77 1f       	adc	r23, r23
    2462:	88 1f       	adc	r24, r24
    2464:	bb 1f       	adc	r27, r27
    2466:	26 17       	cp	r18, r22
    2468:	37 07       	cpc	r19, r23
    246a:	48 07       	cpc	r20, r24
    246c:	ab 07       	cpc	r26, r27
    246e:	b0 e8       	ldi	r27, 0x80	; 128
    2470:	09 f0       	breq	.+2      	; 0x2474 <__divsf3_pse+0x56>
    2472:	bb 0b       	sbc	r27, r27
    2474:	80 2d       	mov	r24, r0
    2476:	bf 01       	movw	r22, r30
    2478:	ff 27       	eor	r31, r31
    247a:	93 58       	subi	r25, 0x83	; 131
    247c:	5f 4f       	sbci	r21, 0xFF	; 255
    247e:	2a f0       	brmi	.+10     	; 0x248a <__divsf3_pse+0x6c>
    2480:	9e 3f       	cpi	r25, 0xFE	; 254
    2482:	51 05       	cpc	r21, r1
    2484:	68 f0       	brcs	.+26     	; 0x24a0 <__divsf3_pse+0x82>
    2486:	b6 c0       	rjmp	.+364    	; 0x25f4 <__fp_inf>
    2488:	00 c1       	rjmp	.+512    	; 0x268a <__fp_szero>
    248a:	5f 3f       	cpi	r21, 0xFF	; 255
    248c:	ec f3       	brlt	.-6      	; 0x2488 <__divsf3_pse+0x6a>
    248e:	98 3e       	cpi	r25, 0xE8	; 232
    2490:	dc f3       	brlt	.-10     	; 0x2488 <__divsf3_pse+0x6a>
    2492:	86 95       	lsr	r24
    2494:	77 95       	ror	r23
    2496:	67 95       	ror	r22
    2498:	b7 95       	ror	r27
    249a:	f7 95       	ror	r31
    249c:	9f 5f       	subi	r25, 0xFF	; 255
    249e:	c9 f7       	brne	.-14     	; 0x2492 <__divsf3_pse+0x74>
    24a0:	88 0f       	add	r24, r24
    24a2:	91 1d       	adc	r25, r1
    24a4:	96 95       	lsr	r25
    24a6:	87 95       	ror	r24
    24a8:	97 f9       	bld	r25, 7
    24aa:	08 95       	ret
    24ac:	e1 e0       	ldi	r30, 0x01	; 1
    24ae:	66 0f       	add	r22, r22
    24b0:	77 1f       	adc	r23, r23
    24b2:	88 1f       	adc	r24, r24
    24b4:	bb 1f       	adc	r27, r27
    24b6:	62 17       	cp	r22, r18
    24b8:	73 07       	cpc	r23, r19
    24ba:	84 07       	cpc	r24, r20
    24bc:	ba 07       	cpc	r27, r26
    24be:	20 f0       	brcs	.+8      	; 0x24c8 <__divsf3_pse+0xaa>
    24c0:	62 1b       	sub	r22, r18
    24c2:	73 0b       	sbc	r23, r19
    24c4:	84 0b       	sbc	r24, r20
    24c6:	ba 0b       	sbc	r27, r26
    24c8:	ee 1f       	adc	r30, r30
    24ca:	88 f7       	brcc	.-30     	; 0x24ae <__divsf3_pse+0x90>
    24cc:	e0 95       	com	r30
    24ce:	08 95       	ret

000024d0 <__fixsfsi>:
    24d0:	04 d0       	rcall	.+8      	; 0x24da <__fixunssfsi>
    24d2:	68 94       	set
    24d4:	b1 11       	cpse	r27, r1
    24d6:	d9 c0       	rjmp	.+434    	; 0x268a <__fp_szero>
    24d8:	08 95       	ret

000024da <__fixunssfsi>:
    24da:	bc d0       	rcall	.+376    	; 0x2654 <__fp_splitA>
    24dc:	88 f0       	brcs	.+34     	; 0x2500 <__fixunssfsi+0x26>
    24de:	9f 57       	subi	r25, 0x7F	; 127
    24e0:	90 f0       	brcs	.+36     	; 0x2506 <__fixunssfsi+0x2c>
    24e2:	b9 2f       	mov	r27, r25
    24e4:	99 27       	eor	r25, r25
    24e6:	b7 51       	subi	r27, 0x17	; 23
    24e8:	a0 f0       	brcs	.+40     	; 0x2512 <__fixunssfsi+0x38>
    24ea:	d1 f0       	breq	.+52     	; 0x2520 <__fixunssfsi+0x46>
    24ec:	66 0f       	add	r22, r22
    24ee:	77 1f       	adc	r23, r23
    24f0:	88 1f       	adc	r24, r24
    24f2:	99 1f       	adc	r25, r25
    24f4:	1a f0       	brmi	.+6      	; 0x24fc <__fixunssfsi+0x22>
    24f6:	ba 95       	dec	r27
    24f8:	c9 f7       	brne	.-14     	; 0x24ec <__fixunssfsi+0x12>
    24fa:	12 c0       	rjmp	.+36     	; 0x2520 <__fixunssfsi+0x46>
    24fc:	b1 30       	cpi	r27, 0x01	; 1
    24fe:	81 f0       	breq	.+32     	; 0x2520 <__fixunssfsi+0x46>
    2500:	c3 d0       	rcall	.+390    	; 0x2688 <__fp_zero>
    2502:	b1 e0       	ldi	r27, 0x01	; 1
    2504:	08 95       	ret
    2506:	c0 c0       	rjmp	.+384    	; 0x2688 <__fp_zero>
    2508:	67 2f       	mov	r22, r23
    250a:	78 2f       	mov	r23, r24
    250c:	88 27       	eor	r24, r24
    250e:	b8 5f       	subi	r27, 0xF8	; 248
    2510:	39 f0       	breq	.+14     	; 0x2520 <__fixunssfsi+0x46>
    2512:	b9 3f       	cpi	r27, 0xF9	; 249
    2514:	cc f3       	brlt	.-14     	; 0x2508 <__fixunssfsi+0x2e>
    2516:	86 95       	lsr	r24
    2518:	77 95       	ror	r23
    251a:	67 95       	ror	r22
    251c:	b3 95       	inc	r27
    251e:	d9 f7       	brne	.-10     	; 0x2516 <__fixunssfsi+0x3c>
    2520:	3e f4       	brtc	.+14     	; 0x2530 <__fixunssfsi+0x56>
    2522:	90 95       	com	r25
    2524:	80 95       	com	r24
    2526:	70 95       	com	r23
    2528:	61 95       	neg	r22
    252a:	7f 4f       	sbci	r23, 0xFF	; 255
    252c:	8f 4f       	sbci	r24, 0xFF	; 255
    252e:	9f 4f       	sbci	r25, 0xFF	; 255
    2530:	08 95       	ret

00002532 <__floatunsisf>:
    2532:	e8 94       	clt
    2534:	09 c0       	rjmp	.+18     	; 0x2548 <__floatsisf+0x12>

00002536 <__floatsisf>:
    2536:	97 fb       	bst	r25, 7
    2538:	3e f4       	brtc	.+14     	; 0x2548 <__floatsisf+0x12>
    253a:	90 95       	com	r25
    253c:	80 95       	com	r24
    253e:	70 95       	com	r23
    2540:	61 95       	neg	r22
    2542:	7f 4f       	sbci	r23, 0xFF	; 255
    2544:	8f 4f       	sbci	r24, 0xFF	; 255
    2546:	9f 4f       	sbci	r25, 0xFF	; 255
    2548:	99 23       	and	r25, r25
    254a:	a9 f0       	breq	.+42     	; 0x2576 <__floatsisf+0x40>
    254c:	f9 2f       	mov	r31, r25
    254e:	96 e9       	ldi	r25, 0x96	; 150
    2550:	bb 27       	eor	r27, r27
    2552:	93 95       	inc	r25
    2554:	f6 95       	lsr	r31
    2556:	87 95       	ror	r24
    2558:	77 95       	ror	r23
    255a:	67 95       	ror	r22
    255c:	b7 95       	ror	r27
    255e:	f1 11       	cpse	r31, r1
    2560:	f8 cf       	rjmp	.-16     	; 0x2552 <__floatsisf+0x1c>
    2562:	fa f4       	brpl	.+62     	; 0x25a2 <__floatsisf+0x6c>
    2564:	bb 0f       	add	r27, r27
    2566:	11 f4       	brne	.+4      	; 0x256c <__floatsisf+0x36>
    2568:	60 ff       	sbrs	r22, 0
    256a:	1b c0       	rjmp	.+54     	; 0x25a2 <__floatsisf+0x6c>
    256c:	6f 5f       	subi	r22, 0xFF	; 255
    256e:	7f 4f       	sbci	r23, 0xFF	; 255
    2570:	8f 4f       	sbci	r24, 0xFF	; 255
    2572:	9f 4f       	sbci	r25, 0xFF	; 255
    2574:	16 c0       	rjmp	.+44     	; 0x25a2 <__floatsisf+0x6c>
    2576:	88 23       	and	r24, r24
    2578:	11 f0       	breq	.+4      	; 0x257e <__floatsisf+0x48>
    257a:	96 e9       	ldi	r25, 0x96	; 150
    257c:	11 c0       	rjmp	.+34     	; 0x25a0 <__floatsisf+0x6a>
    257e:	77 23       	and	r23, r23
    2580:	21 f0       	breq	.+8      	; 0x258a <__floatsisf+0x54>
    2582:	9e e8       	ldi	r25, 0x8E	; 142
    2584:	87 2f       	mov	r24, r23
    2586:	76 2f       	mov	r23, r22
    2588:	05 c0       	rjmp	.+10     	; 0x2594 <__floatsisf+0x5e>
    258a:	66 23       	and	r22, r22
    258c:	71 f0       	breq	.+28     	; 0x25aa <__floatsisf+0x74>
    258e:	96 e8       	ldi	r25, 0x86	; 134
    2590:	86 2f       	mov	r24, r22
    2592:	70 e0       	ldi	r23, 0x00	; 0
    2594:	60 e0       	ldi	r22, 0x00	; 0
    2596:	2a f0       	brmi	.+10     	; 0x25a2 <__floatsisf+0x6c>
    2598:	9a 95       	dec	r25
    259a:	66 0f       	add	r22, r22
    259c:	77 1f       	adc	r23, r23
    259e:	88 1f       	adc	r24, r24
    25a0:	da f7       	brpl	.-10     	; 0x2598 <__floatsisf+0x62>
    25a2:	88 0f       	add	r24, r24
    25a4:	96 95       	lsr	r25
    25a6:	87 95       	ror	r24
    25a8:	97 f9       	bld	r25, 7
    25aa:	08 95       	ret

000025ac <__fp_cmp>:
    25ac:	99 0f       	add	r25, r25
    25ae:	00 08       	sbc	r0, r0
    25b0:	55 0f       	add	r21, r21
    25b2:	aa 0b       	sbc	r26, r26
    25b4:	e0 e8       	ldi	r30, 0x80	; 128
    25b6:	fe ef       	ldi	r31, 0xFE	; 254
    25b8:	16 16       	cp	r1, r22
    25ba:	17 06       	cpc	r1, r23
    25bc:	e8 07       	cpc	r30, r24
    25be:	f9 07       	cpc	r31, r25
    25c0:	c0 f0       	brcs	.+48     	; 0x25f2 <__fp_cmp+0x46>
    25c2:	12 16       	cp	r1, r18
    25c4:	13 06       	cpc	r1, r19
    25c6:	e4 07       	cpc	r30, r20
    25c8:	f5 07       	cpc	r31, r21
    25ca:	98 f0       	brcs	.+38     	; 0x25f2 <__fp_cmp+0x46>
    25cc:	62 1b       	sub	r22, r18
    25ce:	73 0b       	sbc	r23, r19
    25d0:	84 0b       	sbc	r24, r20
    25d2:	95 0b       	sbc	r25, r21
    25d4:	39 f4       	brne	.+14     	; 0x25e4 <__fp_cmp+0x38>
    25d6:	0a 26       	eor	r0, r26
    25d8:	61 f0       	breq	.+24     	; 0x25f2 <__fp_cmp+0x46>
    25da:	23 2b       	or	r18, r19
    25dc:	24 2b       	or	r18, r20
    25de:	25 2b       	or	r18, r21
    25e0:	21 f4       	brne	.+8      	; 0x25ea <__fp_cmp+0x3e>
    25e2:	08 95       	ret
    25e4:	0a 26       	eor	r0, r26
    25e6:	09 f4       	brne	.+2      	; 0x25ea <__fp_cmp+0x3e>
    25e8:	a1 40       	sbci	r26, 0x01	; 1
    25ea:	a6 95       	lsr	r26
    25ec:	8f ef       	ldi	r24, 0xFF	; 255
    25ee:	81 1d       	adc	r24, r1
    25f0:	81 1d       	adc	r24, r1
    25f2:	08 95       	ret

000025f4 <__fp_inf>:
    25f4:	97 f9       	bld	r25, 7
    25f6:	9f 67       	ori	r25, 0x7F	; 127
    25f8:	80 e8       	ldi	r24, 0x80	; 128
    25fa:	70 e0       	ldi	r23, 0x00	; 0
    25fc:	60 e0       	ldi	r22, 0x00	; 0
    25fe:	08 95       	ret

00002600 <__fp_nan>:
    2600:	9f ef       	ldi	r25, 0xFF	; 255
    2602:	80 ec       	ldi	r24, 0xC0	; 192
    2604:	08 95       	ret

00002606 <__fp_pscA>:
    2606:	00 24       	eor	r0, r0
    2608:	0a 94       	dec	r0
    260a:	16 16       	cp	r1, r22
    260c:	17 06       	cpc	r1, r23
    260e:	18 06       	cpc	r1, r24
    2610:	09 06       	cpc	r0, r25
    2612:	08 95       	ret

00002614 <__fp_pscB>:
    2614:	00 24       	eor	r0, r0
    2616:	0a 94       	dec	r0
    2618:	12 16       	cp	r1, r18
    261a:	13 06       	cpc	r1, r19
    261c:	14 06       	cpc	r1, r20
    261e:	05 06       	cpc	r0, r21
    2620:	08 95       	ret

00002622 <__fp_round>:
    2622:	09 2e       	mov	r0, r25
    2624:	03 94       	inc	r0
    2626:	00 0c       	add	r0, r0
    2628:	11 f4       	brne	.+4      	; 0x262e <__fp_round+0xc>
    262a:	88 23       	and	r24, r24
    262c:	52 f0       	brmi	.+20     	; 0x2642 <__fp_round+0x20>
    262e:	bb 0f       	add	r27, r27
    2630:	40 f4       	brcc	.+16     	; 0x2642 <__fp_round+0x20>
    2632:	bf 2b       	or	r27, r31
    2634:	11 f4       	brne	.+4      	; 0x263a <__fp_round+0x18>
    2636:	60 ff       	sbrs	r22, 0
    2638:	04 c0       	rjmp	.+8      	; 0x2642 <__fp_round+0x20>
    263a:	6f 5f       	subi	r22, 0xFF	; 255
    263c:	7f 4f       	sbci	r23, 0xFF	; 255
    263e:	8f 4f       	sbci	r24, 0xFF	; 255
    2640:	9f 4f       	sbci	r25, 0xFF	; 255
    2642:	08 95       	ret

00002644 <__fp_split3>:
    2644:	57 fd       	sbrc	r21, 7
    2646:	90 58       	subi	r25, 0x80	; 128
    2648:	44 0f       	add	r20, r20
    264a:	55 1f       	adc	r21, r21
    264c:	59 f0       	breq	.+22     	; 0x2664 <__fp_splitA+0x10>
    264e:	5f 3f       	cpi	r21, 0xFF	; 255
    2650:	71 f0       	breq	.+28     	; 0x266e <__fp_splitA+0x1a>
    2652:	47 95       	ror	r20

00002654 <__fp_splitA>:
    2654:	88 0f       	add	r24, r24
    2656:	97 fb       	bst	r25, 7
    2658:	99 1f       	adc	r25, r25
    265a:	61 f0       	breq	.+24     	; 0x2674 <__fp_splitA+0x20>
    265c:	9f 3f       	cpi	r25, 0xFF	; 255
    265e:	79 f0       	breq	.+30     	; 0x267e <__fp_splitA+0x2a>
    2660:	87 95       	ror	r24
    2662:	08 95       	ret
    2664:	12 16       	cp	r1, r18
    2666:	13 06       	cpc	r1, r19
    2668:	14 06       	cpc	r1, r20
    266a:	55 1f       	adc	r21, r21
    266c:	f2 cf       	rjmp	.-28     	; 0x2652 <__fp_split3+0xe>
    266e:	46 95       	lsr	r20
    2670:	f1 df       	rcall	.-30     	; 0x2654 <__fp_splitA>
    2672:	08 c0       	rjmp	.+16     	; 0x2684 <__fp_splitA+0x30>
    2674:	16 16       	cp	r1, r22
    2676:	17 06       	cpc	r1, r23
    2678:	18 06       	cpc	r1, r24
    267a:	99 1f       	adc	r25, r25
    267c:	f1 cf       	rjmp	.-30     	; 0x2660 <__fp_splitA+0xc>
    267e:	86 95       	lsr	r24
    2680:	71 05       	cpc	r23, r1
    2682:	61 05       	cpc	r22, r1
    2684:	08 94       	sec
    2686:	08 95       	ret

00002688 <__fp_zero>:
    2688:	e8 94       	clt

0000268a <__fp_szero>:
    268a:	bb 27       	eor	r27, r27
    268c:	66 27       	eor	r22, r22
    268e:	77 27       	eor	r23, r23
    2690:	cb 01       	movw	r24, r22
    2692:	97 f9       	bld	r25, 7
    2694:	08 95       	ret

00002696 <__gesf2>:
    2696:	8a df       	rcall	.-236    	; 0x25ac <__fp_cmp>
    2698:	08 f4       	brcc	.+2      	; 0x269c <__gesf2+0x6>
    269a:	8f ef       	ldi	r24, 0xFF	; 255
    269c:	08 95       	ret

0000269e <__mulsf3>:
    269e:	0b d0       	rcall	.+22     	; 0x26b6 <__mulsf3x>
    26a0:	c0 cf       	rjmp	.-128    	; 0x2622 <__fp_round>
    26a2:	b1 df       	rcall	.-158    	; 0x2606 <__fp_pscA>
    26a4:	28 f0       	brcs	.+10     	; 0x26b0 <__mulsf3+0x12>
    26a6:	b6 df       	rcall	.-148    	; 0x2614 <__fp_pscB>
    26a8:	18 f0       	brcs	.+6      	; 0x26b0 <__mulsf3+0x12>
    26aa:	95 23       	and	r25, r21
    26ac:	09 f0       	breq	.+2      	; 0x26b0 <__mulsf3+0x12>
    26ae:	a2 cf       	rjmp	.-188    	; 0x25f4 <__fp_inf>
    26b0:	a7 cf       	rjmp	.-178    	; 0x2600 <__fp_nan>
    26b2:	11 24       	eor	r1, r1
    26b4:	ea cf       	rjmp	.-44     	; 0x268a <__fp_szero>

000026b6 <__mulsf3x>:
    26b6:	c6 df       	rcall	.-116    	; 0x2644 <__fp_split3>
    26b8:	a0 f3       	brcs	.-24     	; 0x26a2 <__mulsf3+0x4>

000026ba <__mulsf3_pse>:
    26ba:	95 9f       	mul	r25, r21
    26bc:	d1 f3       	breq	.-12     	; 0x26b2 <__mulsf3+0x14>
    26be:	95 0f       	add	r25, r21
    26c0:	50 e0       	ldi	r21, 0x00	; 0
    26c2:	55 1f       	adc	r21, r21
    26c4:	62 9f       	mul	r22, r18
    26c6:	f0 01       	movw	r30, r0
    26c8:	72 9f       	mul	r23, r18
    26ca:	bb 27       	eor	r27, r27
    26cc:	f0 0d       	add	r31, r0
    26ce:	b1 1d       	adc	r27, r1
    26d0:	63 9f       	mul	r22, r19
    26d2:	aa 27       	eor	r26, r26
    26d4:	f0 0d       	add	r31, r0
    26d6:	b1 1d       	adc	r27, r1
    26d8:	aa 1f       	adc	r26, r26
    26da:	64 9f       	mul	r22, r20
    26dc:	66 27       	eor	r22, r22
    26de:	b0 0d       	add	r27, r0
    26e0:	a1 1d       	adc	r26, r1
    26e2:	66 1f       	adc	r22, r22
    26e4:	82 9f       	mul	r24, r18
    26e6:	22 27       	eor	r18, r18
    26e8:	b0 0d       	add	r27, r0
    26ea:	a1 1d       	adc	r26, r1
    26ec:	62 1f       	adc	r22, r18
    26ee:	73 9f       	mul	r23, r19
    26f0:	b0 0d       	add	r27, r0
    26f2:	a1 1d       	adc	r26, r1
    26f4:	62 1f       	adc	r22, r18
    26f6:	83 9f       	mul	r24, r19
    26f8:	a0 0d       	add	r26, r0
    26fa:	61 1d       	adc	r22, r1
    26fc:	22 1f       	adc	r18, r18
    26fe:	74 9f       	mul	r23, r20
    2700:	33 27       	eor	r19, r19
    2702:	a0 0d       	add	r26, r0
    2704:	61 1d       	adc	r22, r1
    2706:	23 1f       	adc	r18, r19
    2708:	84 9f       	mul	r24, r20
    270a:	60 0d       	add	r22, r0
    270c:	21 1d       	adc	r18, r1
    270e:	82 2f       	mov	r24, r18
    2710:	76 2f       	mov	r23, r22
    2712:	6a 2f       	mov	r22, r26
    2714:	11 24       	eor	r1, r1
    2716:	9f 57       	subi	r25, 0x7F	; 127
    2718:	50 40       	sbci	r21, 0x00	; 0
    271a:	8a f0       	brmi	.+34     	; 0x273e <__mulsf3_pse+0x84>
    271c:	e1 f0       	breq	.+56     	; 0x2756 <__mulsf3_pse+0x9c>
    271e:	88 23       	and	r24, r24
    2720:	4a f0       	brmi	.+18     	; 0x2734 <__mulsf3_pse+0x7a>
    2722:	ee 0f       	add	r30, r30
    2724:	ff 1f       	adc	r31, r31
    2726:	bb 1f       	adc	r27, r27
    2728:	66 1f       	adc	r22, r22
    272a:	77 1f       	adc	r23, r23
    272c:	88 1f       	adc	r24, r24
    272e:	91 50       	subi	r25, 0x01	; 1
    2730:	50 40       	sbci	r21, 0x00	; 0
    2732:	a9 f7       	brne	.-22     	; 0x271e <__mulsf3_pse+0x64>
    2734:	9e 3f       	cpi	r25, 0xFE	; 254
    2736:	51 05       	cpc	r21, r1
    2738:	70 f0       	brcs	.+28     	; 0x2756 <__mulsf3_pse+0x9c>
    273a:	5c cf       	rjmp	.-328    	; 0x25f4 <__fp_inf>
    273c:	a6 cf       	rjmp	.-180    	; 0x268a <__fp_szero>
    273e:	5f 3f       	cpi	r21, 0xFF	; 255
    2740:	ec f3       	brlt	.-6      	; 0x273c <__mulsf3_pse+0x82>
    2742:	98 3e       	cpi	r25, 0xE8	; 232
    2744:	dc f3       	brlt	.-10     	; 0x273c <__mulsf3_pse+0x82>
    2746:	86 95       	lsr	r24
    2748:	77 95       	ror	r23
    274a:	67 95       	ror	r22
    274c:	b7 95       	ror	r27
    274e:	f7 95       	ror	r31
    2750:	e7 95       	ror	r30
    2752:	9f 5f       	subi	r25, 0xFF	; 255
    2754:	c1 f7       	brne	.-16     	; 0x2746 <__mulsf3_pse+0x8c>
    2756:	fe 2b       	or	r31, r30
    2758:	88 0f       	add	r24, r24
    275a:	91 1d       	adc	r25, r1
    275c:	96 95       	lsr	r25
    275e:	87 95       	ror	r24
    2760:	97 f9       	bld	r25, 7
    2762:	08 95       	ret

00002764 <__tablejump2__>:
    2764:	ee 0f       	add	r30, r30
    2766:	ff 1f       	adc	r31, r31
    2768:	00 24       	eor	r0, r0
    276a:	00 1c       	adc	r0, r0
    276c:	0b be       	out	0x3b, r0	; 59
    276e:	07 90       	elpm	r0, Z+
    2770:	f6 91       	elpm	r31, Z
    2772:	e0 2d       	mov	r30, r0
    2774:	09 94       	ijmp

00002776 <atoi>:
    2776:	fc 01       	movw	r30, r24
    2778:	88 27       	eor	r24, r24
    277a:	99 27       	eor	r25, r25
    277c:	e8 94       	clt
    277e:	21 91       	ld	r18, Z+
    2780:	20 32       	cpi	r18, 0x20	; 32
    2782:	e9 f3       	breq	.-6      	; 0x277e <atoi+0x8>
    2784:	29 30       	cpi	r18, 0x09	; 9
    2786:	10 f0       	brcs	.+4      	; 0x278c <atoi+0x16>
    2788:	2e 30       	cpi	r18, 0x0E	; 14
    278a:	c8 f3       	brcs	.-14     	; 0x277e <atoi+0x8>
    278c:	2b 32       	cpi	r18, 0x2B	; 43
    278e:	39 f0       	breq	.+14     	; 0x279e <atoi+0x28>
    2790:	2d 32       	cpi	r18, 0x2D	; 45
    2792:	31 f4       	brne	.+12     	; 0x27a0 <atoi+0x2a>
    2794:	68 94       	set
    2796:	03 c0       	rjmp	.+6      	; 0x279e <atoi+0x28>
    2798:	14 d0       	rcall	.+40     	; 0x27c2 <__mulhi_const_10>
    279a:	82 0f       	add	r24, r18
    279c:	91 1d       	adc	r25, r1
    279e:	21 91       	ld	r18, Z+
    27a0:	20 53       	subi	r18, 0x30	; 48
    27a2:	2a 30       	cpi	r18, 0x0A	; 10
    27a4:	c8 f3       	brcs	.-14     	; 0x2798 <atoi+0x22>
    27a6:	1e f4       	brtc	.+6      	; 0x27ae <atoi+0x38>
    27a8:	90 95       	com	r25
    27aa:	81 95       	neg	r24
    27ac:	9f 4f       	sbci	r25, 0xFF	; 255
    27ae:	08 95       	ret

000027b0 <strcmp>:
    27b0:	fb 01       	movw	r30, r22
    27b2:	dc 01       	movw	r26, r24
    27b4:	8d 91       	ld	r24, X+
    27b6:	01 90       	ld	r0, Z+
    27b8:	80 19       	sub	r24, r0
    27ba:	01 10       	cpse	r0, r1
    27bc:	d9 f3       	breq	.-10     	; 0x27b4 <strcmp+0x4>
    27be:	99 0b       	sbc	r25, r25
    27c0:	08 95       	ret

000027c2 <__mulhi_const_10>:
    27c2:	7a e0       	ldi	r23, 0x0A	; 10
    27c4:	97 9f       	mul	r25, r23
    27c6:	90 2d       	mov	r25, r0
    27c8:	87 9f       	mul	r24, r23
    27ca:	80 2d       	mov	r24, r0
    27cc:	91 0d       	add	r25, r1
    27ce:	11 24       	eor	r1, r1
    27d0:	08 95       	ret

000027d2 <printf>:
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	cd b7       	in	r28, 0x3d	; 61
    27d8:	de b7       	in	r29, 0x3e	; 62
    27da:	ae 01       	movw	r20, r28
    27dc:	4b 5f       	subi	r20, 0xFB	; 251
    27de:	5f 4f       	sbci	r21, 0xFF	; 255
    27e0:	fa 01       	movw	r30, r20
    27e2:	61 91       	ld	r22, Z+
    27e4:	71 91       	ld	r23, Z+
    27e6:	af 01       	movw	r20, r30
    27e8:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27ec:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27f0:	38 d0       	rcall	.+112    	; 0x2862 <vfprintf>
    27f2:	df 91       	pop	r29
    27f4:	cf 91       	pop	r28
    27f6:	08 95       	ret

000027f8 <putchar>:
    27f8:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27fc:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    2800:	43 c2       	rjmp	.+1158   	; 0x2c88 <fputc>

00002802 <puts>:
    2802:	0f 93       	push	r16
    2804:	1f 93       	push	r17
    2806:	cf 93       	push	r28
    2808:	df 93       	push	r29
    280a:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    280e:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    2812:	23 81       	ldd	r18, Z+3	; 0x03
    2814:	21 ff       	sbrs	r18, 1
    2816:	1b c0       	rjmp	.+54     	; 0x284e <puts+0x4c>
    2818:	8c 01       	movw	r16, r24
    281a:	d0 e0       	ldi	r29, 0x00	; 0
    281c:	c0 e0       	ldi	r28, 0x00	; 0
    281e:	f8 01       	movw	r30, r16
    2820:	81 91       	ld	r24, Z+
    2822:	8f 01       	movw	r16, r30
    2824:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    2828:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    282c:	db 01       	movw	r26, r22
    282e:	18 96       	adiw	r26, 0x08	; 8
    2830:	ed 91       	ld	r30, X+
    2832:	fc 91       	ld	r31, X
    2834:	19 97       	sbiw	r26, 0x09	; 9
    2836:	88 23       	and	r24, r24
    2838:	31 f0       	breq	.+12     	; 0x2846 <puts+0x44>
    283a:	09 95       	icall
    283c:	89 2b       	or	r24, r25
    283e:	79 f3       	breq	.-34     	; 0x281e <puts+0x1c>
    2840:	df ef       	ldi	r29, 0xFF	; 255
    2842:	cf ef       	ldi	r28, 0xFF	; 255
    2844:	ec cf       	rjmp	.-40     	; 0x281e <puts+0x1c>
    2846:	8a e0       	ldi	r24, 0x0A	; 10
    2848:	09 95       	icall
    284a:	89 2b       	or	r24, r25
    284c:	19 f0       	breq	.+6      	; 0x2854 <puts+0x52>
    284e:	8f ef       	ldi	r24, 0xFF	; 255
    2850:	9f ef       	ldi	r25, 0xFF	; 255
    2852:	02 c0       	rjmp	.+4      	; 0x2858 <puts+0x56>
    2854:	8d 2f       	mov	r24, r29
    2856:	9c 2f       	mov	r25, r28
    2858:	df 91       	pop	r29
    285a:	cf 91       	pop	r28
    285c:	1f 91       	pop	r17
    285e:	0f 91       	pop	r16
    2860:	08 95       	ret

00002862 <vfprintf>:
    2862:	2f 92       	push	r2
    2864:	3f 92       	push	r3
    2866:	4f 92       	push	r4
    2868:	5f 92       	push	r5
    286a:	6f 92       	push	r6
    286c:	7f 92       	push	r7
    286e:	8f 92       	push	r8
    2870:	9f 92       	push	r9
    2872:	af 92       	push	r10
    2874:	bf 92       	push	r11
    2876:	cf 92       	push	r12
    2878:	df 92       	push	r13
    287a:	ef 92       	push	r14
    287c:	ff 92       	push	r15
    287e:	0f 93       	push	r16
    2880:	1f 93       	push	r17
    2882:	cf 93       	push	r28
    2884:	df 93       	push	r29
    2886:	cd b7       	in	r28, 0x3d	; 61
    2888:	de b7       	in	r29, 0x3e	; 62
    288a:	2b 97       	sbiw	r28, 0x0b	; 11
    288c:	0f b6       	in	r0, 0x3f	; 63
    288e:	f8 94       	cli
    2890:	de bf       	out	0x3e, r29	; 62
    2892:	0f be       	out	0x3f, r0	; 63
    2894:	cd bf       	out	0x3d, r28	; 61
    2896:	6c 01       	movw	r12, r24
    2898:	7b 01       	movw	r14, r22
    289a:	8a 01       	movw	r16, r20
    289c:	fc 01       	movw	r30, r24
    289e:	17 82       	std	Z+7, r1	; 0x07
    28a0:	16 82       	std	Z+6, r1	; 0x06
    28a2:	83 81       	ldd	r24, Z+3	; 0x03
    28a4:	81 ff       	sbrs	r24, 1
    28a6:	bf c1       	rjmp	.+894    	; 0x2c26 <vfprintf+0x3c4>
    28a8:	ce 01       	movw	r24, r28
    28aa:	01 96       	adiw	r24, 0x01	; 1
    28ac:	3c 01       	movw	r6, r24
    28ae:	f6 01       	movw	r30, r12
    28b0:	93 81       	ldd	r25, Z+3	; 0x03
    28b2:	f7 01       	movw	r30, r14
    28b4:	93 fd       	sbrc	r25, 3
    28b6:	85 91       	lpm	r24, Z+
    28b8:	93 ff       	sbrs	r25, 3
    28ba:	81 91       	ld	r24, Z+
    28bc:	7f 01       	movw	r14, r30
    28be:	88 23       	and	r24, r24
    28c0:	09 f4       	brne	.+2      	; 0x28c4 <vfprintf+0x62>
    28c2:	ad c1       	rjmp	.+858    	; 0x2c1e <vfprintf+0x3bc>
    28c4:	85 32       	cpi	r24, 0x25	; 37
    28c6:	39 f4       	brne	.+14     	; 0x28d6 <vfprintf+0x74>
    28c8:	93 fd       	sbrc	r25, 3
    28ca:	85 91       	lpm	r24, Z+
    28cc:	93 ff       	sbrs	r25, 3
    28ce:	81 91       	ld	r24, Z+
    28d0:	7f 01       	movw	r14, r30
    28d2:	85 32       	cpi	r24, 0x25	; 37
    28d4:	21 f4       	brne	.+8      	; 0x28de <vfprintf+0x7c>
    28d6:	b6 01       	movw	r22, r12
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	d6 d1       	rcall	.+940    	; 0x2c88 <fputc>
    28dc:	e8 cf       	rjmp	.-48     	; 0x28ae <vfprintf+0x4c>
    28de:	91 2c       	mov	r9, r1
    28e0:	21 2c       	mov	r2, r1
    28e2:	31 2c       	mov	r3, r1
    28e4:	ff e1       	ldi	r31, 0x1F	; 31
    28e6:	f3 15       	cp	r31, r3
    28e8:	d8 f0       	brcs	.+54     	; 0x2920 <vfprintf+0xbe>
    28ea:	8b 32       	cpi	r24, 0x2B	; 43
    28ec:	79 f0       	breq	.+30     	; 0x290c <vfprintf+0xaa>
    28ee:	38 f4       	brcc	.+14     	; 0x28fe <vfprintf+0x9c>
    28f0:	80 32       	cpi	r24, 0x20	; 32
    28f2:	79 f0       	breq	.+30     	; 0x2912 <vfprintf+0xb0>
    28f4:	83 32       	cpi	r24, 0x23	; 35
    28f6:	a1 f4       	brne	.+40     	; 0x2920 <vfprintf+0xbe>
    28f8:	23 2d       	mov	r18, r3
    28fa:	20 61       	ori	r18, 0x10	; 16
    28fc:	1d c0       	rjmp	.+58     	; 0x2938 <vfprintf+0xd6>
    28fe:	8d 32       	cpi	r24, 0x2D	; 45
    2900:	61 f0       	breq	.+24     	; 0x291a <vfprintf+0xb8>
    2902:	80 33       	cpi	r24, 0x30	; 48
    2904:	69 f4       	brne	.+26     	; 0x2920 <vfprintf+0xbe>
    2906:	23 2d       	mov	r18, r3
    2908:	21 60       	ori	r18, 0x01	; 1
    290a:	16 c0       	rjmp	.+44     	; 0x2938 <vfprintf+0xd6>
    290c:	83 2d       	mov	r24, r3
    290e:	82 60       	ori	r24, 0x02	; 2
    2910:	38 2e       	mov	r3, r24
    2912:	e3 2d       	mov	r30, r3
    2914:	e4 60       	ori	r30, 0x04	; 4
    2916:	3e 2e       	mov	r3, r30
    2918:	2a c0       	rjmp	.+84     	; 0x296e <vfprintf+0x10c>
    291a:	f3 2d       	mov	r31, r3
    291c:	f8 60       	ori	r31, 0x08	; 8
    291e:	1d c0       	rjmp	.+58     	; 0x295a <vfprintf+0xf8>
    2920:	37 fc       	sbrc	r3, 7
    2922:	2d c0       	rjmp	.+90     	; 0x297e <vfprintf+0x11c>
    2924:	20 ed       	ldi	r18, 0xD0	; 208
    2926:	28 0f       	add	r18, r24
    2928:	2a 30       	cpi	r18, 0x0A	; 10
    292a:	40 f0       	brcs	.+16     	; 0x293c <vfprintf+0xda>
    292c:	8e 32       	cpi	r24, 0x2E	; 46
    292e:	b9 f4       	brne	.+46     	; 0x295e <vfprintf+0xfc>
    2930:	36 fc       	sbrc	r3, 6
    2932:	75 c1       	rjmp	.+746    	; 0x2c1e <vfprintf+0x3bc>
    2934:	23 2d       	mov	r18, r3
    2936:	20 64       	ori	r18, 0x40	; 64
    2938:	32 2e       	mov	r3, r18
    293a:	19 c0       	rjmp	.+50     	; 0x296e <vfprintf+0x10c>
    293c:	36 fe       	sbrs	r3, 6
    293e:	06 c0       	rjmp	.+12     	; 0x294c <vfprintf+0xea>
    2940:	8a e0       	ldi	r24, 0x0A	; 10
    2942:	98 9e       	mul	r9, r24
    2944:	20 0d       	add	r18, r0
    2946:	11 24       	eor	r1, r1
    2948:	92 2e       	mov	r9, r18
    294a:	11 c0       	rjmp	.+34     	; 0x296e <vfprintf+0x10c>
    294c:	ea e0       	ldi	r30, 0x0A	; 10
    294e:	2e 9e       	mul	r2, r30
    2950:	20 0d       	add	r18, r0
    2952:	11 24       	eor	r1, r1
    2954:	22 2e       	mov	r2, r18
    2956:	f3 2d       	mov	r31, r3
    2958:	f0 62       	ori	r31, 0x20	; 32
    295a:	3f 2e       	mov	r3, r31
    295c:	08 c0       	rjmp	.+16     	; 0x296e <vfprintf+0x10c>
    295e:	8c 36       	cpi	r24, 0x6C	; 108
    2960:	21 f4       	brne	.+8      	; 0x296a <vfprintf+0x108>
    2962:	83 2d       	mov	r24, r3
    2964:	80 68       	ori	r24, 0x80	; 128
    2966:	38 2e       	mov	r3, r24
    2968:	02 c0       	rjmp	.+4      	; 0x296e <vfprintf+0x10c>
    296a:	88 36       	cpi	r24, 0x68	; 104
    296c:	41 f4       	brne	.+16     	; 0x297e <vfprintf+0x11c>
    296e:	f7 01       	movw	r30, r14
    2970:	93 fd       	sbrc	r25, 3
    2972:	85 91       	lpm	r24, Z+
    2974:	93 ff       	sbrs	r25, 3
    2976:	81 91       	ld	r24, Z+
    2978:	7f 01       	movw	r14, r30
    297a:	81 11       	cpse	r24, r1
    297c:	b3 cf       	rjmp	.-154    	; 0x28e4 <vfprintf+0x82>
    297e:	98 2f       	mov	r25, r24
    2980:	9f 7d       	andi	r25, 0xDF	; 223
    2982:	95 54       	subi	r25, 0x45	; 69
    2984:	93 30       	cpi	r25, 0x03	; 3
    2986:	28 f4       	brcc	.+10     	; 0x2992 <vfprintf+0x130>
    2988:	0c 5f       	subi	r16, 0xFC	; 252
    298a:	1f 4f       	sbci	r17, 0xFF	; 255
    298c:	9f e3       	ldi	r25, 0x3F	; 63
    298e:	99 83       	std	Y+1, r25	; 0x01
    2990:	0d c0       	rjmp	.+26     	; 0x29ac <vfprintf+0x14a>
    2992:	83 36       	cpi	r24, 0x63	; 99
    2994:	31 f0       	breq	.+12     	; 0x29a2 <vfprintf+0x140>
    2996:	83 37       	cpi	r24, 0x73	; 115
    2998:	71 f0       	breq	.+28     	; 0x29b6 <vfprintf+0x154>
    299a:	83 35       	cpi	r24, 0x53	; 83
    299c:	09 f0       	breq	.+2      	; 0x29a0 <vfprintf+0x13e>
    299e:	55 c0       	rjmp	.+170    	; 0x2a4a <vfprintf+0x1e8>
    29a0:	20 c0       	rjmp	.+64     	; 0x29e2 <vfprintf+0x180>
    29a2:	f8 01       	movw	r30, r16
    29a4:	80 81       	ld	r24, Z
    29a6:	89 83       	std	Y+1, r24	; 0x01
    29a8:	0e 5f       	subi	r16, 0xFE	; 254
    29aa:	1f 4f       	sbci	r17, 0xFF	; 255
    29ac:	88 24       	eor	r8, r8
    29ae:	83 94       	inc	r8
    29b0:	91 2c       	mov	r9, r1
    29b2:	53 01       	movw	r10, r6
    29b4:	12 c0       	rjmp	.+36     	; 0x29da <vfprintf+0x178>
    29b6:	28 01       	movw	r4, r16
    29b8:	f2 e0       	ldi	r31, 0x02	; 2
    29ba:	4f 0e       	add	r4, r31
    29bc:	51 1c       	adc	r5, r1
    29be:	f8 01       	movw	r30, r16
    29c0:	a0 80       	ld	r10, Z
    29c2:	b1 80       	ldd	r11, Z+1	; 0x01
    29c4:	36 fe       	sbrs	r3, 6
    29c6:	03 c0       	rjmp	.+6      	; 0x29ce <vfprintf+0x16c>
    29c8:	69 2d       	mov	r22, r9
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	02 c0       	rjmp	.+4      	; 0x29d2 <vfprintf+0x170>
    29ce:	6f ef       	ldi	r22, 0xFF	; 255
    29d0:	7f ef       	ldi	r23, 0xFF	; 255
    29d2:	c5 01       	movw	r24, r10
    29d4:	4e d1       	rcall	.+668    	; 0x2c72 <strnlen>
    29d6:	4c 01       	movw	r8, r24
    29d8:	82 01       	movw	r16, r4
    29da:	f3 2d       	mov	r31, r3
    29dc:	ff 77       	andi	r31, 0x7F	; 127
    29de:	3f 2e       	mov	r3, r31
    29e0:	15 c0       	rjmp	.+42     	; 0x2a0c <vfprintf+0x1aa>
    29e2:	28 01       	movw	r4, r16
    29e4:	22 e0       	ldi	r18, 0x02	; 2
    29e6:	42 0e       	add	r4, r18
    29e8:	51 1c       	adc	r5, r1
    29ea:	f8 01       	movw	r30, r16
    29ec:	a0 80       	ld	r10, Z
    29ee:	b1 80       	ldd	r11, Z+1	; 0x01
    29f0:	36 fe       	sbrs	r3, 6
    29f2:	03 c0       	rjmp	.+6      	; 0x29fa <vfprintf+0x198>
    29f4:	69 2d       	mov	r22, r9
    29f6:	70 e0       	ldi	r23, 0x00	; 0
    29f8:	02 c0       	rjmp	.+4      	; 0x29fe <vfprintf+0x19c>
    29fa:	6f ef       	ldi	r22, 0xFF	; 255
    29fc:	7f ef       	ldi	r23, 0xFF	; 255
    29fe:	c5 01       	movw	r24, r10
    2a00:	2d d1       	rcall	.+602    	; 0x2c5c <strnlen_P>
    2a02:	4c 01       	movw	r8, r24
    2a04:	f3 2d       	mov	r31, r3
    2a06:	f0 68       	ori	r31, 0x80	; 128
    2a08:	3f 2e       	mov	r3, r31
    2a0a:	82 01       	movw	r16, r4
    2a0c:	33 fc       	sbrc	r3, 3
    2a0e:	19 c0       	rjmp	.+50     	; 0x2a42 <vfprintf+0x1e0>
    2a10:	82 2d       	mov	r24, r2
    2a12:	90 e0       	ldi	r25, 0x00	; 0
    2a14:	88 16       	cp	r8, r24
    2a16:	99 06       	cpc	r9, r25
    2a18:	a0 f4       	brcc	.+40     	; 0x2a42 <vfprintf+0x1e0>
    2a1a:	b6 01       	movw	r22, r12
    2a1c:	80 e2       	ldi	r24, 0x20	; 32
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	33 d1       	rcall	.+614    	; 0x2c88 <fputc>
    2a22:	2a 94       	dec	r2
    2a24:	f5 cf       	rjmp	.-22     	; 0x2a10 <vfprintf+0x1ae>
    2a26:	f5 01       	movw	r30, r10
    2a28:	37 fc       	sbrc	r3, 7
    2a2a:	85 91       	lpm	r24, Z+
    2a2c:	37 fe       	sbrs	r3, 7
    2a2e:	81 91       	ld	r24, Z+
    2a30:	5f 01       	movw	r10, r30
    2a32:	b6 01       	movw	r22, r12
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	28 d1       	rcall	.+592    	; 0x2c88 <fputc>
    2a38:	21 10       	cpse	r2, r1
    2a3a:	2a 94       	dec	r2
    2a3c:	21 e0       	ldi	r18, 0x01	; 1
    2a3e:	82 1a       	sub	r8, r18
    2a40:	91 08       	sbc	r9, r1
    2a42:	81 14       	cp	r8, r1
    2a44:	91 04       	cpc	r9, r1
    2a46:	79 f7       	brne	.-34     	; 0x2a26 <vfprintf+0x1c4>
    2a48:	e1 c0       	rjmp	.+450    	; 0x2c0c <vfprintf+0x3aa>
    2a4a:	84 36       	cpi	r24, 0x64	; 100
    2a4c:	11 f0       	breq	.+4      	; 0x2a52 <vfprintf+0x1f0>
    2a4e:	89 36       	cpi	r24, 0x69	; 105
    2a50:	39 f5       	brne	.+78     	; 0x2aa0 <vfprintf+0x23e>
    2a52:	f8 01       	movw	r30, r16
    2a54:	37 fe       	sbrs	r3, 7
    2a56:	07 c0       	rjmp	.+14     	; 0x2a66 <vfprintf+0x204>
    2a58:	60 81       	ld	r22, Z
    2a5a:	71 81       	ldd	r23, Z+1	; 0x01
    2a5c:	82 81       	ldd	r24, Z+2	; 0x02
    2a5e:	93 81       	ldd	r25, Z+3	; 0x03
    2a60:	0c 5f       	subi	r16, 0xFC	; 252
    2a62:	1f 4f       	sbci	r17, 0xFF	; 255
    2a64:	08 c0       	rjmp	.+16     	; 0x2a76 <vfprintf+0x214>
    2a66:	60 81       	ld	r22, Z
    2a68:	71 81       	ldd	r23, Z+1	; 0x01
    2a6a:	07 2e       	mov	r0, r23
    2a6c:	00 0c       	add	r0, r0
    2a6e:	88 0b       	sbc	r24, r24
    2a70:	99 0b       	sbc	r25, r25
    2a72:	0e 5f       	subi	r16, 0xFE	; 254
    2a74:	1f 4f       	sbci	r17, 0xFF	; 255
    2a76:	f3 2d       	mov	r31, r3
    2a78:	ff 76       	andi	r31, 0x6F	; 111
    2a7a:	3f 2e       	mov	r3, r31
    2a7c:	97 ff       	sbrs	r25, 7
    2a7e:	09 c0       	rjmp	.+18     	; 0x2a92 <vfprintf+0x230>
    2a80:	90 95       	com	r25
    2a82:	80 95       	com	r24
    2a84:	70 95       	com	r23
    2a86:	61 95       	neg	r22
    2a88:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8a:	8f 4f       	sbci	r24, 0xFF	; 255
    2a8c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a8e:	f0 68       	ori	r31, 0x80	; 128
    2a90:	3f 2e       	mov	r3, r31
    2a92:	2a e0       	ldi	r18, 0x0A	; 10
    2a94:	30 e0       	ldi	r19, 0x00	; 0
    2a96:	a3 01       	movw	r20, r6
    2a98:	33 d1       	rcall	.+614    	; 0x2d00 <__ultoa_invert>
    2a9a:	88 2e       	mov	r8, r24
    2a9c:	86 18       	sub	r8, r6
    2a9e:	44 c0       	rjmp	.+136    	; 0x2b28 <vfprintf+0x2c6>
    2aa0:	85 37       	cpi	r24, 0x75	; 117
    2aa2:	31 f4       	brne	.+12     	; 0x2ab0 <vfprintf+0x24e>
    2aa4:	23 2d       	mov	r18, r3
    2aa6:	2f 7e       	andi	r18, 0xEF	; 239
    2aa8:	b2 2e       	mov	r11, r18
    2aaa:	2a e0       	ldi	r18, 0x0A	; 10
    2aac:	30 e0       	ldi	r19, 0x00	; 0
    2aae:	25 c0       	rjmp	.+74     	; 0x2afa <vfprintf+0x298>
    2ab0:	93 2d       	mov	r25, r3
    2ab2:	99 7f       	andi	r25, 0xF9	; 249
    2ab4:	b9 2e       	mov	r11, r25
    2ab6:	8f 36       	cpi	r24, 0x6F	; 111
    2ab8:	c1 f0       	breq	.+48     	; 0x2aea <vfprintf+0x288>
    2aba:	18 f4       	brcc	.+6      	; 0x2ac2 <vfprintf+0x260>
    2abc:	88 35       	cpi	r24, 0x58	; 88
    2abe:	79 f0       	breq	.+30     	; 0x2ade <vfprintf+0x27c>
    2ac0:	ae c0       	rjmp	.+348    	; 0x2c1e <vfprintf+0x3bc>
    2ac2:	80 37       	cpi	r24, 0x70	; 112
    2ac4:	19 f0       	breq	.+6      	; 0x2acc <vfprintf+0x26a>
    2ac6:	88 37       	cpi	r24, 0x78	; 120
    2ac8:	21 f0       	breq	.+8      	; 0x2ad2 <vfprintf+0x270>
    2aca:	a9 c0       	rjmp	.+338    	; 0x2c1e <vfprintf+0x3bc>
    2acc:	e9 2f       	mov	r30, r25
    2ace:	e0 61       	ori	r30, 0x10	; 16
    2ad0:	be 2e       	mov	r11, r30
    2ad2:	b4 fe       	sbrs	r11, 4
    2ad4:	0d c0       	rjmp	.+26     	; 0x2af0 <vfprintf+0x28e>
    2ad6:	fb 2d       	mov	r31, r11
    2ad8:	f4 60       	ori	r31, 0x04	; 4
    2ada:	bf 2e       	mov	r11, r31
    2adc:	09 c0       	rjmp	.+18     	; 0x2af0 <vfprintf+0x28e>
    2ade:	34 fe       	sbrs	r3, 4
    2ae0:	0a c0       	rjmp	.+20     	; 0x2af6 <vfprintf+0x294>
    2ae2:	29 2f       	mov	r18, r25
    2ae4:	26 60       	ori	r18, 0x06	; 6
    2ae6:	b2 2e       	mov	r11, r18
    2ae8:	06 c0       	rjmp	.+12     	; 0x2af6 <vfprintf+0x294>
    2aea:	28 e0       	ldi	r18, 0x08	; 8
    2aec:	30 e0       	ldi	r19, 0x00	; 0
    2aee:	05 c0       	rjmp	.+10     	; 0x2afa <vfprintf+0x298>
    2af0:	20 e1       	ldi	r18, 0x10	; 16
    2af2:	30 e0       	ldi	r19, 0x00	; 0
    2af4:	02 c0       	rjmp	.+4      	; 0x2afa <vfprintf+0x298>
    2af6:	20 e1       	ldi	r18, 0x10	; 16
    2af8:	32 e0       	ldi	r19, 0x02	; 2
    2afa:	f8 01       	movw	r30, r16
    2afc:	b7 fe       	sbrs	r11, 7
    2afe:	07 c0       	rjmp	.+14     	; 0x2b0e <vfprintf+0x2ac>
    2b00:	60 81       	ld	r22, Z
    2b02:	71 81       	ldd	r23, Z+1	; 0x01
    2b04:	82 81       	ldd	r24, Z+2	; 0x02
    2b06:	93 81       	ldd	r25, Z+3	; 0x03
    2b08:	0c 5f       	subi	r16, 0xFC	; 252
    2b0a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b0c:	06 c0       	rjmp	.+12     	; 0x2b1a <vfprintf+0x2b8>
    2b0e:	60 81       	ld	r22, Z
    2b10:	71 81       	ldd	r23, Z+1	; 0x01
    2b12:	80 e0       	ldi	r24, 0x00	; 0
    2b14:	90 e0       	ldi	r25, 0x00	; 0
    2b16:	0e 5f       	subi	r16, 0xFE	; 254
    2b18:	1f 4f       	sbci	r17, 0xFF	; 255
    2b1a:	a3 01       	movw	r20, r6
    2b1c:	f1 d0       	rcall	.+482    	; 0x2d00 <__ultoa_invert>
    2b1e:	88 2e       	mov	r8, r24
    2b20:	86 18       	sub	r8, r6
    2b22:	fb 2d       	mov	r31, r11
    2b24:	ff 77       	andi	r31, 0x7F	; 127
    2b26:	3f 2e       	mov	r3, r31
    2b28:	36 fe       	sbrs	r3, 6
    2b2a:	0d c0       	rjmp	.+26     	; 0x2b46 <vfprintf+0x2e4>
    2b2c:	23 2d       	mov	r18, r3
    2b2e:	2e 7f       	andi	r18, 0xFE	; 254
    2b30:	a2 2e       	mov	r10, r18
    2b32:	89 14       	cp	r8, r9
    2b34:	58 f4       	brcc	.+22     	; 0x2b4c <vfprintf+0x2ea>
    2b36:	34 fe       	sbrs	r3, 4
    2b38:	0b c0       	rjmp	.+22     	; 0x2b50 <vfprintf+0x2ee>
    2b3a:	32 fc       	sbrc	r3, 2
    2b3c:	09 c0       	rjmp	.+18     	; 0x2b50 <vfprintf+0x2ee>
    2b3e:	83 2d       	mov	r24, r3
    2b40:	8e 7e       	andi	r24, 0xEE	; 238
    2b42:	a8 2e       	mov	r10, r24
    2b44:	05 c0       	rjmp	.+10     	; 0x2b50 <vfprintf+0x2ee>
    2b46:	b8 2c       	mov	r11, r8
    2b48:	a3 2c       	mov	r10, r3
    2b4a:	03 c0       	rjmp	.+6      	; 0x2b52 <vfprintf+0x2f0>
    2b4c:	b8 2c       	mov	r11, r8
    2b4e:	01 c0       	rjmp	.+2      	; 0x2b52 <vfprintf+0x2f0>
    2b50:	b9 2c       	mov	r11, r9
    2b52:	a4 fe       	sbrs	r10, 4
    2b54:	0f c0       	rjmp	.+30     	; 0x2b74 <vfprintf+0x312>
    2b56:	fe 01       	movw	r30, r28
    2b58:	e8 0d       	add	r30, r8
    2b5a:	f1 1d       	adc	r31, r1
    2b5c:	80 81       	ld	r24, Z
    2b5e:	80 33       	cpi	r24, 0x30	; 48
    2b60:	21 f4       	brne	.+8      	; 0x2b6a <vfprintf+0x308>
    2b62:	9a 2d       	mov	r25, r10
    2b64:	99 7e       	andi	r25, 0xE9	; 233
    2b66:	a9 2e       	mov	r10, r25
    2b68:	09 c0       	rjmp	.+18     	; 0x2b7c <vfprintf+0x31a>
    2b6a:	a2 fe       	sbrs	r10, 2
    2b6c:	06 c0       	rjmp	.+12     	; 0x2b7a <vfprintf+0x318>
    2b6e:	b3 94       	inc	r11
    2b70:	b3 94       	inc	r11
    2b72:	04 c0       	rjmp	.+8      	; 0x2b7c <vfprintf+0x31a>
    2b74:	8a 2d       	mov	r24, r10
    2b76:	86 78       	andi	r24, 0x86	; 134
    2b78:	09 f0       	breq	.+2      	; 0x2b7c <vfprintf+0x31a>
    2b7a:	b3 94       	inc	r11
    2b7c:	a3 fc       	sbrc	r10, 3
    2b7e:	10 c0       	rjmp	.+32     	; 0x2ba0 <vfprintf+0x33e>
    2b80:	a0 fe       	sbrs	r10, 0
    2b82:	06 c0       	rjmp	.+12     	; 0x2b90 <vfprintf+0x32e>
    2b84:	b2 14       	cp	r11, r2
    2b86:	80 f4       	brcc	.+32     	; 0x2ba8 <vfprintf+0x346>
    2b88:	28 0c       	add	r2, r8
    2b8a:	92 2c       	mov	r9, r2
    2b8c:	9b 18       	sub	r9, r11
    2b8e:	0d c0       	rjmp	.+26     	; 0x2baa <vfprintf+0x348>
    2b90:	b2 14       	cp	r11, r2
    2b92:	58 f4       	brcc	.+22     	; 0x2baa <vfprintf+0x348>
    2b94:	b6 01       	movw	r22, r12
    2b96:	80 e2       	ldi	r24, 0x20	; 32
    2b98:	90 e0       	ldi	r25, 0x00	; 0
    2b9a:	76 d0       	rcall	.+236    	; 0x2c88 <fputc>
    2b9c:	b3 94       	inc	r11
    2b9e:	f8 cf       	rjmp	.-16     	; 0x2b90 <vfprintf+0x32e>
    2ba0:	b2 14       	cp	r11, r2
    2ba2:	18 f4       	brcc	.+6      	; 0x2baa <vfprintf+0x348>
    2ba4:	2b 18       	sub	r2, r11
    2ba6:	02 c0       	rjmp	.+4      	; 0x2bac <vfprintf+0x34a>
    2ba8:	98 2c       	mov	r9, r8
    2baa:	21 2c       	mov	r2, r1
    2bac:	a4 fe       	sbrs	r10, 4
    2bae:	0f c0       	rjmp	.+30     	; 0x2bce <vfprintf+0x36c>
    2bb0:	b6 01       	movw	r22, r12
    2bb2:	80 e3       	ldi	r24, 0x30	; 48
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	68 d0       	rcall	.+208    	; 0x2c88 <fputc>
    2bb8:	a2 fe       	sbrs	r10, 2
    2bba:	16 c0       	rjmp	.+44     	; 0x2be8 <vfprintf+0x386>
    2bbc:	a1 fc       	sbrc	r10, 1
    2bbe:	03 c0       	rjmp	.+6      	; 0x2bc6 <vfprintf+0x364>
    2bc0:	88 e7       	ldi	r24, 0x78	; 120
    2bc2:	90 e0       	ldi	r25, 0x00	; 0
    2bc4:	02 c0       	rjmp	.+4      	; 0x2bca <vfprintf+0x368>
    2bc6:	88 e5       	ldi	r24, 0x58	; 88
    2bc8:	90 e0       	ldi	r25, 0x00	; 0
    2bca:	b6 01       	movw	r22, r12
    2bcc:	0c c0       	rjmp	.+24     	; 0x2be6 <vfprintf+0x384>
    2bce:	8a 2d       	mov	r24, r10
    2bd0:	86 78       	andi	r24, 0x86	; 134
    2bd2:	51 f0       	breq	.+20     	; 0x2be8 <vfprintf+0x386>
    2bd4:	a1 fe       	sbrs	r10, 1
    2bd6:	02 c0       	rjmp	.+4      	; 0x2bdc <vfprintf+0x37a>
    2bd8:	8b e2       	ldi	r24, 0x2B	; 43
    2bda:	01 c0       	rjmp	.+2      	; 0x2bde <vfprintf+0x37c>
    2bdc:	80 e2       	ldi	r24, 0x20	; 32
    2bde:	a7 fc       	sbrc	r10, 7
    2be0:	8d e2       	ldi	r24, 0x2D	; 45
    2be2:	b6 01       	movw	r22, r12
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	50 d0       	rcall	.+160    	; 0x2c88 <fputc>
    2be8:	89 14       	cp	r8, r9
    2bea:	30 f4       	brcc	.+12     	; 0x2bf8 <vfprintf+0x396>
    2bec:	b6 01       	movw	r22, r12
    2bee:	80 e3       	ldi	r24, 0x30	; 48
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	4a d0       	rcall	.+148    	; 0x2c88 <fputc>
    2bf4:	9a 94       	dec	r9
    2bf6:	f8 cf       	rjmp	.-16     	; 0x2be8 <vfprintf+0x386>
    2bf8:	8a 94       	dec	r8
    2bfa:	f3 01       	movw	r30, r6
    2bfc:	e8 0d       	add	r30, r8
    2bfe:	f1 1d       	adc	r31, r1
    2c00:	80 81       	ld	r24, Z
    2c02:	b6 01       	movw	r22, r12
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	40 d0       	rcall	.+128    	; 0x2c88 <fputc>
    2c08:	81 10       	cpse	r8, r1
    2c0a:	f6 cf       	rjmp	.-20     	; 0x2bf8 <vfprintf+0x396>
    2c0c:	22 20       	and	r2, r2
    2c0e:	09 f4       	brne	.+2      	; 0x2c12 <vfprintf+0x3b0>
    2c10:	4e ce       	rjmp	.-868    	; 0x28ae <vfprintf+0x4c>
    2c12:	b6 01       	movw	r22, r12
    2c14:	80 e2       	ldi	r24, 0x20	; 32
    2c16:	90 e0       	ldi	r25, 0x00	; 0
    2c18:	37 d0       	rcall	.+110    	; 0x2c88 <fputc>
    2c1a:	2a 94       	dec	r2
    2c1c:	f7 cf       	rjmp	.-18     	; 0x2c0c <vfprintf+0x3aa>
    2c1e:	f6 01       	movw	r30, r12
    2c20:	86 81       	ldd	r24, Z+6	; 0x06
    2c22:	97 81       	ldd	r25, Z+7	; 0x07
    2c24:	02 c0       	rjmp	.+4      	; 0x2c2a <vfprintf+0x3c8>
    2c26:	8f ef       	ldi	r24, 0xFF	; 255
    2c28:	9f ef       	ldi	r25, 0xFF	; 255
    2c2a:	2b 96       	adiw	r28, 0x0b	; 11
    2c2c:	0f b6       	in	r0, 0x3f	; 63
    2c2e:	f8 94       	cli
    2c30:	de bf       	out	0x3e, r29	; 62
    2c32:	0f be       	out	0x3f, r0	; 63
    2c34:	cd bf       	out	0x3d, r28	; 61
    2c36:	df 91       	pop	r29
    2c38:	cf 91       	pop	r28
    2c3a:	1f 91       	pop	r17
    2c3c:	0f 91       	pop	r16
    2c3e:	ff 90       	pop	r15
    2c40:	ef 90       	pop	r14
    2c42:	df 90       	pop	r13
    2c44:	cf 90       	pop	r12
    2c46:	bf 90       	pop	r11
    2c48:	af 90       	pop	r10
    2c4a:	9f 90       	pop	r9
    2c4c:	8f 90       	pop	r8
    2c4e:	7f 90       	pop	r7
    2c50:	6f 90       	pop	r6
    2c52:	5f 90       	pop	r5
    2c54:	4f 90       	pop	r4
    2c56:	3f 90       	pop	r3
    2c58:	2f 90       	pop	r2
    2c5a:	08 95       	ret

00002c5c <strnlen_P>:
    2c5c:	fc 01       	movw	r30, r24
    2c5e:	05 90       	lpm	r0, Z+
    2c60:	61 50       	subi	r22, 0x01	; 1
    2c62:	70 40       	sbci	r23, 0x00	; 0
    2c64:	01 10       	cpse	r0, r1
    2c66:	d8 f7       	brcc	.-10     	; 0x2c5e <strnlen_P+0x2>
    2c68:	80 95       	com	r24
    2c6a:	90 95       	com	r25
    2c6c:	8e 0f       	add	r24, r30
    2c6e:	9f 1f       	adc	r25, r31
    2c70:	08 95       	ret

00002c72 <strnlen>:
    2c72:	fc 01       	movw	r30, r24
    2c74:	61 50       	subi	r22, 0x01	; 1
    2c76:	70 40       	sbci	r23, 0x00	; 0
    2c78:	01 90       	ld	r0, Z+
    2c7a:	01 10       	cpse	r0, r1
    2c7c:	d8 f7       	brcc	.-10     	; 0x2c74 <strnlen+0x2>
    2c7e:	80 95       	com	r24
    2c80:	90 95       	com	r25
    2c82:	8e 0f       	add	r24, r30
    2c84:	9f 1f       	adc	r25, r31
    2c86:	08 95       	ret

00002c88 <fputc>:
    2c88:	0f 93       	push	r16
    2c8a:	1f 93       	push	r17
    2c8c:	cf 93       	push	r28
    2c8e:	df 93       	push	r29
    2c90:	fb 01       	movw	r30, r22
    2c92:	23 81       	ldd	r18, Z+3	; 0x03
    2c94:	21 fd       	sbrc	r18, 1
    2c96:	03 c0       	rjmp	.+6      	; 0x2c9e <fputc+0x16>
    2c98:	8f ef       	ldi	r24, 0xFF	; 255
    2c9a:	9f ef       	ldi	r25, 0xFF	; 255
    2c9c:	2c c0       	rjmp	.+88     	; 0x2cf6 <fputc+0x6e>
    2c9e:	22 ff       	sbrs	r18, 2
    2ca0:	16 c0       	rjmp	.+44     	; 0x2cce <fputc+0x46>
    2ca2:	46 81       	ldd	r20, Z+6	; 0x06
    2ca4:	57 81       	ldd	r21, Z+7	; 0x07
    2ca6:	24 81       	ldd	r18, Z+4	; 0x04
    2ca8:	35 81       	ldd	r19, Z+5	; 0x05
    2caa:	42 17       	cp	r20, r18
    2cac:	53 07       	cpc	r21, r19
    2cae:	44 f4       	brge	.+16     	; 0x2cc0 <fputc+0x38>
    2cb0:	a0 81       	ld	r26, Z
    2cb2:	b1 81       	ldd	r27, Z+1	; 0x01
    2cb4:	9d 01       	movw	r18, r26
    2cb6:	2f 5f       	subi	r18, 0xFF	; 255
    2cb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2cba:	31 83       	std	Z+1, r19	; 0x01
    2cbc:	20 83       	st	Z, r18
    2cbe:	8c 93       	st	X, r24
    2cc0:	26 81       	ldd	r18, Z+6	; 0x06
    2cc2:	37 81       	ldd	r19, Z+7	; 0x07
    2cc4:	2f 5f       	subi	r18, 0xFF	; 255
    2cc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2cc8:	37 83       	std	Z+7, r19	; 0x07
    2cca:	26 83       	std	Z+6, r18	; 0x06
    2ccc:	14 c0       	rjmp	.+40     	; 0x2cf6 <fputc+0x6e>
    2cce:	8b 01       	movw	r16, r22
    2cd0:	ec 01       	movw	r28, r24
    2cd2:	fb 01       	movw	r30, r22
    2cd4:	00 84       	ldd	r0, Z+8	; 0x08
    2cd6:	f1 85       	ldd	r31, Z+9	; 0x09
    2cd8:	e0 2d       	mov	r30, r0
    2cda:	09 95       	icall
    2cdc:	89 2b       	or	r24, r25
    2cde:	e1 f6       	brne	.-72     	; 0x2c98 <fputc+0x10>
    2ce0:	d8 01       	movw	r26, r16
    2ce2:	16 96       	adiw	r26, 0x06	; 6
    2ce4:	8d 91       	ld	r24, X+
    2ce6:	9c 91       	ld	r25, X
    2ce8:	17 97       	sbiw	r26, 0x07	; 7
    2cea:	01 96       	adiw	r24, 0x01	; 1
    2cec:	17 96       	adiw	r26, 0x07	; 7
    2cee:	9c 93       	st	X, r25
    2cf0:	8e 93       	st	-X, r24
    2cf2:	16 97       	sbiw	r26, 0x06	; 6
    2cf4:	ce 01       	movw	r24, r28
    2cf6:	df 91       	pop	r29
    2cf8:	cf 91       	pop	r28
    2cfa:	1f 91       	pop	r17
    2cfc:	0f 91       	pop	r16
    2cfe:	08 95       	ret

00002d00 <__ultoa_invert>:
    2d00:	fa 01       	movw	r30, r20
    2d02:	aa 27       	eor	r26, r26
    2d04:	28 30       	cpi	r18, 0x08	; 8
    2d06:	51 f1       	breq	.+84     	; 0x2d5c <__ultoa_invert+0x5c>
    2d08:	20 31       	cpi	r18, 0x10	; 16
    2d0a:	81 f1       	breq	.+96     	; 0x2d6c <__ultoa_invert+0x6c>
    2d0c:	e8 94       	clt
    2d0e:	6f 93       	push	r22
    2d10:	6e 7f       	andi	r22, 0xFE	; 254
    2d12:	6e 5f       	subi	r22, 0xFE	; 254
    2d14:	7f 4f       	sbci	r23, 0xFF	; 255
    2d16:	8f 4f       	sbci	r24, 0xFF	; 255
    2d18:	9f 4f       	sbci	r25, 0xFF	; 255
    2d1a:	af 4f       	sbci	r26, 0xFF	; 255
    2d1c:	b1 e0       	ldi	r27, 0x01	; 1
    2d1e:	3e d0       	rcall	.+124    	; 0x2d9c <__ultoa_invert+0x9c>
    2d20:	b4 e0       	ldi	r27, 0x04	; 4
    2d22:	3c d0       	rcall	.+120    	; 0x2d9c <__ultoa_invert+0x9c>
    2d24:	67 0f       	add	r22, r23
    2d26:	78 1f       	adc	r23, r24
    2d28:	89 1f       	adc	r24, r25
    2d2a:	9a 1f       	adc	r25, r26
    2d2c:	a1 1d       	adc	r26, r1
    2d2e:	68 0f       	add	r22, r24
    2d30:	79 1f       	adc	r23, r25
    2d32:	8a 1f       	adc	r24, r26
    2d34:	91 1d       	adc	r25, r1
    2d36:	a1 1d       	adc	r26, r1
    2d38:	6a 0f       	add	r22, r26
    2d3a:	71 1d       	adc	r23, r1
    2d3c:	81 1d       	adc	r24, r1
    2d3e:	91 1d       	adc	r25, r1
    2d40:	a1 1d       	adc	r26, r1
    2d42:	20 d0       	rcall	.+64     	; 0x2d84 <__ultoa_invert+0x84>
    2d44:	09 f4       	brne	.+2      	; 0x2d48 <__ultoa_invert+0x48>
    2d46:	68 94       	set
    2d48:	3f 91       	pop	r19
    2d4a:	2a e0       	ldi	r18, 0x0A	; 10
    2d4c:	26 9f       	mul	r18, r22
    2d4e:	11 24       	eor	r1, r1
    2d50:	30 19       	sub	r19, r0
    2d52:	30 5d       	subi	r19, 0xD0	; 208
    2d54:	31 93       	st	Z+, r19
    2d56:	de f6       	brtc	.-74     	; 0x2d0e <__ultoa_invert+0xe>
    2d58:	cf 01       	movw	r24, r30
    2d5a:	08 95       	ret
    2d5c:	46 2f       	mov	r20, r22
    2d5e:	47 70       	andi	r20, 0x07	; 7
    2d60:	40 5d       	subi	r20, 0xD0	; 208
    2d62:	41 93       	st	Z+, r20
    2d64:	b3 e0       	ldi	r27, 0x03	; 3
    2d66:	0f d0       	rcall	.+30     	; 0x2d86 <__ultoa_invert+0x86>
    2d68:	c9 f7       	brne	.-14     	; 0x2d5c <__ultoa_invert+0x5c>
    2d6a:	f6 cf       	rjmp	.-20     	; 0x2d58 <__ultoa_invert+0x58>
    2d6c:	46 2f       	mov	r20, r22
    2d6e:	4f 70       	andi	r20, 0x0F	; 15
    2d70:	40 5d       	subi	r20, 0xD0	; 208
    2d72:	4a 33       	cpi	r20, 0x3A	; 58
    2d74:	18 f0       	brcs	.+6      	; 0x2d7c <__ultoa_invert+0x7c>
    2d76:	49 5d       	subi	r20, 0xD9	; 217
    2d78:	31 fd       	sbrc	r19, 1
    2d7a:	40 52       	subi	r20, 0x20	; 32
    2d7c:	41 93       	st	Z+, r20
    2d7e:	02 d0       	rcall	.+4      	; 0x2d84 <__ultoa_invert+0x84>
    2d80:	a9 f7       	brne	.-22     	; 0x2d6c <__ultoa_invert+0x6c>
    2d82:	ea cf       	rjmp	.-44     	; 0x2d58 <__ultoa_invert+0x58>
    2d84:	b4 e0       	ldi	r27, 0x04	; 4
    2d86:	a6 95       	lsr	r26
    2d88:	97 95       	ror	r25
    2d8a:	87 95       	ror	r24
    2d8c:	77 95       	ror	r23
    2d8e:	67 95       	ror	r22
    2d90:	ba 95       	dec	r27
    2d92:	c9 f7       	brne	.-14     	; 0x2d86 <__ultoa_invert+0x86>
    2d94:	00 97       	sbiw	r24, 0x00	; 0
    2d96:	61 05       	cpc	r22, r1
    2d98:	71 05       	cpc	r23, r1
    2d9a:	08 95       	ret
    2d9c:	9b 01       	movw	r18, r22
    2d9e:	ac 01       	movw	r20, r24
    2da0:	0a 2e       	mov	r0, r26
    2da2:	06 94       	lsr	r0
    2da4:	57 95       	ror	r21
    2da6:	47 95       	ror	r20
    2da8:	37 95       	ror	r19
    2daa:	27 95       	ror	r18
    2dac:	ba 95       	dec	r27
    2dae:	c9 f7       	brne	.-14     	; 0x2da2 <__ultoa_invert+0xa2>
    2db0:	62 0f       	add	r22, r18
    2db2:	73 1f       	adc	r23, r19
    2db4:	84 1f       	adc	r24, r20
    2db6:	95 1f       	adc	r25, r21
    2db8:	a0 1d       	adc	r26, r0
    2dba:	08 95       	ret

00002dbc <eeprom_write_word>:
    2dbc:	02 d0       	rcall	.+4      	; 0x2dc2 <eeprom_write_byte>
    2dbe:	27 2f       	mov	r18, r23
    2dc0:	01 c0       	rjmp	.+2      	; 0x2dc4 <eeprom_write_r18>

00002dc2 <eeprom_write_byte>:
    2dc2:	26 2f       	mov	r18, r22

00002dc4 <eeprom_write_r18>:
    2dc4:	f9 99       	sbic	0x1f, 1	; 31
    2dc6:	fe cf       	rjmp	.-4      	; 0x2dc4 <eeprom_write_r18>
    2dc8:	92 bd       	out	0x22, r25	; 34
    2dca:	81 bd       	out	0x21, r24	; 33
    2dcc:	20 bd       	out	0x20, r18	; 32
    2dce:	0f b6       	in	r0, 0x3f	; 63
    2dd0:	f8 94       	cli
    2dd2:	fa 9a       	sbi	0x1f, 2	; 31
    2dd4:	f9 9a       	sbi	0x1f, 1	; 31
    2dd6:	0f be       	out	0x3f, r0	; 63
    2dd8:	01 96       	adiw	r24, 0x01	; 1
    2dda:	08 95       	ret

00002ddc <_exit>:
    2ddc:	f8 94       	cli

00002dde <__stop_program>:
    2dde:	ff cf       	rjmp	.-2      	; 0x2dde <__stop_program>
