
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002ce0  00002d74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ce0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002e54  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002e54  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002ee0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00002f20  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000070a9  00000000  00000000  000034d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ddd  00000000  00000000  0000a579  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000331a  00000000  00000000  0000c356  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001060  00000000  00000000  0000f670  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a2a  00000000  00000000  000106d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000462e  00000000  00000000  000120fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  00016728  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 f3 0c 	jmp	0x19e6	; 0x19e6 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 62 0c 	jmp	0x18c4	; 0x18c4 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 a3 0b 	jmp	0x1746	; 0x1746 <__vector_16>
      44:	0c 94 c6 10 	jmp	0x218c	; 0x218c <__vector_17>
      48:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 91 0a 	jmp	0x1522	; 0x1522 <__vector_21>
      58:	0c 94 73 0a 	jmp	0x14e6	; 0x14e6 <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 ca 0a 	jmp	0x1594	; 0x1594 <__vector_32>
      84:	0c 94 ac 0a 	jmp	0x1558	; 0x1558 <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	49 0e       	add	r4, r25
      96:	4e 0e       	add	r4, r30
      98:	54 0e       	add	r5, r20
      9a:	5a 0e       	add	r5, r26
      9c:	60 0e       	add	r6, r16
      9e:	65 0e       	add	r6, r21
      a0:	6b 0e       	add	r6, r27
      a2:	71 0e       	add	r7, r17

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e0 ee       	ldi	r30, 0xE0	; 224
      b8:	fc e2       	ldi	r31, 0x2C	; 44
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 0c 0b 	call	0x1618	; 0x1618 <main>
      de:	0c 94 6e 16 	jmp	0x2cdc	; 0x2cdc <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 49 16 	call	0x2c92	; 0x2c92 <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 49 16 	call	0x2c92	; 0x2c92 <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 49 16 	call	0x2c92	; 0x2c92 <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	11 f0       	breq	.+4      	; 0x214 <actuator_pwm+0x8>
     210:	75 9a       	sbi	0x0e, 5	; 14
     212:	08 95       	ret
     214:	75 98       	cbi	0x0e, 5	; 14
     216:	08 95       	ret

00000218 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     218:	4f 92       	push	r4
     21a:	5f 92       	push	r5
     21c:	6f 92       	push	r6
     21e:	7f 92       	push	r7
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	ec 01       	movw	r28, r24
     238:	96 2e       	mov	r9, r22
     23a:	c6 01       	movw	r24, r12
     23c:	b5 01       	movw	r22, r10
			3) actuator_duty_cycle
			4) gear_status
*/

	//float kp = 3.8; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     23e:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     242:	87 01       	movw	r16, r14
     244:	06 1b       	sub	r16, r22
     246:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
     248:	b8 01       	movw	r22, r16
     24a:	01 2e       	mov	r0, r17
     24c:	00 0c       	add	r0, r0
     24e:	88 0b       	sbc	r24, r24
     250:	99 0b       	sbc	r25, r25
     252:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     256:	2b 01       	movw	r4, r22
     258:	3c 01       	movw	r6, r24
     25a:	23 e3       	ldi	r18, 0x33	; 51
     25c:	33 e3       	ldi	r19, 0x33	; 51
     25e:	43 e7       	ldi	r20, 0x73	; 115
     260:	50 e4       	ldi	r21, 0x40	; 64
     262:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	45 e8       	ldi	r20, 0x85	; 133
     26c:	52 e4       	ldi	r21, 0x42	; 66
     26e:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     272:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     276:	6b 01       	movw	r12, r22
     278:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 ea       	ldi	r20, 0xA0	; 160
     280:	50 e4       	ldi	r21, 0x40	; 64
     282:	c3 01       	movw	r24, r6
     284:	b2 01       	movw	r22, r4
     286:	0e 94 67 11 	call	0x22ce	; 0x22ce <__cmpsf2>
     28a:	88 23       	and	r24, r24
     28c:	c4 f5       	brge	.+112    	; 0x2fe <actuator_set_position+0xe6>
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	40 ea       	ldi	r20, 0xA0	; 160
     294:	50 ec       	ldi	r21, 0xC0	; 192
     296:	c3 01       	movw	r24, r6
     298:	b2 01       	movw	r22, r4
     29a:	0e 94 b6 12 	call	0x256c	; 0x256c <__gesf2>
     29e:	18 16       	cp	r1, r24
     2a0:	74 f5       	brge	.+92     	; 0x2fe <actuator_set_position+0xe6>
     2a2:	30 c0       	rjmp	.+96     	; 0x304 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2a4:	8c 81       	ldd	r24, Y+4	; 0x04
     2a6:	9d 81       	ldd	r25, Y+5	; 0x05
     2a8:	00 97       	sbiw	r24, 0x00	; 0
     2aa:	29 f0       	breq	.+10     	; 0x2b6 <actuator_set_position+0x9e>
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	89 f4       	brne	.+34     	; 0x2d2 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2b0:	1b 82       	std	Y+3, r1	; 0x03
     2b2:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2b4:	0e c0       	rjmp	.+28     	; 0x2d2 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2b6:	10 16       	cp	r1, r16
     2b8:	11 06       	cpc	r1, r17
     2ba:	2c f4       	brge	.+10     	; 0x2c6 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2c6:	11 23       	and	r17, r17
     2c8:	24 f4       	brge	.+8      	; 0x2d2 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2ca:	82 e0       	ldi	r24, 0x02	; 2
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	9b 83       	std	Y+3, r25	; 0x03
     2d0:	8a 83       	std	Y+2, r24	; 0x02
     2d2:	c6 01       	movw	r24, r12
     2d4:	83 38       	cpi	r24, 0x83	; 131
     2d6:	91 05       	cpc	r25, r1
     2d8:	14 f0       	brlt	.+4      	; 0x2de <actuator_set_position+0xc6>
     2da:	82 e8       	ldi	r24, 0x82	; 130
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	6c 01       	movw	r12, r24
     2e0:	99 23       	and	r25, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <actuator_set_position+0xd0>
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2e8:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2ec:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2f0:	db 86       	std	Y+11, r13	; 0x0b
     2f2:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2f4:	4e 82       	std	Y+6, r4	; 0x06
     2f6:	5f 82       	std	Y+7, r5	; 0x07
     2f8:	68 86       	std	Y+8, r6	; 0x08
     2fa:	79 86       	std	Y+9, r7	; 0x09
}
     2fc:	0c c0       	rjmp	.+24     	; 0x316 <actuator_set_position+0xfe>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		//new_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2fe:	1d 82       	std	Y+5, r1	; 0x05
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	d0 cf       	rjmp	.-96     	; 0x2a4 <actuator_set_position+0x8c>
	int16_t new_duty_cycle = 0;
	new_duty_cycle = (float)KP*position_error + (float)HALF_DUTY_CYCLE;
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9d 83       	std	Y+5, r25	; 0x05
     30a:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     30c:	89 2d       	mov	r24, r9
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	99 83       	std	Y+1, r25	; 0x01
     312:	88 83       	st	Y, r24
     314:	c7 cf       	rjmp	.-114    	; 0x2a4 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	7f 90       	pop	r7
     32e:	6f 90       	pop	r6
     330:	5f 90       	pop	r5
     332:	4f 90       	pop	r4
     334:	08 95       	ret

00000336 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     336:	af 92       	push	r10
     338:	bf 92       	push	r11
     33a:	cf 92       	push	r12
     33c:	df 92       	push	r13
     33e:	ef 92       	push	r14
     340:	ff 92       	push	r15
     342:	0f 93       	push	r16
     344:	1f 93       	push	r17
     346:	fc 01       	movw	r30, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     348:	83 a1       	ldd	r24, Z+35	; 0x23
     34a:	94 a1       	ldd	r25, Z+36	; 0x24
     34c:	89 2b       	or	r24, r25
     34e:	09 f1       	breq	.+66     	; 0x392 <actuator_p_controller+0x5c>
	{
		//ACTUATOR: set actuator position based off current state
		switch(vals->gear_required)
     350:	83 ad       	ldd	r24, Z+59	; 0x3b
     352:	81 30       	cpi	r24, 0x01	; 1
     354:	39 f0       	breq	.+14     	; 0x364 <actuator_p_controller+0x2e>
     356:	18 f0       	brcs	.+6      	; 0x35e <actuator_p_controller+0x28>
     358:	82 30       	cpi	r24, 0x02	; 2
     35a:	39 f0       	breq	.+14     	; 0x36a <actuator_p_controller+0x34>
     35c:	09 c0       	rjmp	.+18     	; 0x370 <actuator_p_controller+0x3a>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     35e:	e4 a8       	ldd	r14, Z+52	; 0x34
     360:	f5 a8       	ldd	r15, Z+53	; 0x35
				break;
     362:	08 c0       	rjmp	.+16     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     364:	e6 a8       	ldd	r14, Z+54	; 0x36
     366:	f7 a8       	ldd	r15, Z+55	; 0x37
				break;
     368:	05 c0       	rjmp	.+10     	; 0x374 <actuator_p_controller+0x3e>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     36a:	e0 ac       	ldd	r14, Z+56	; 0x38
     36c:	f1 ac       	ldd	r15, Z+57	; 0x39
				break;
     36e:	02 c0       	rjmp	.+4      	; 0x374 <actuator_p_controller+0x3e>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     370:	e1 2c       	mov	r14, r1
     372:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     374:	a3 a4       	ldd	r10, Z+43	; 0x2b
     376:	b4 a4       	ldd	r11, Z+44	; 0x2c
     378:	c5 a4       	ldd	r12, Z+45	; 0x2d
     37a:	d6 a4       	ldd	r13, Z+46	; 0x2e
     37c:	07 a5       	ldd	r16, Z+47	; 0x2f
     37e:	27 a1       	ldd	r18, Z+39	; 0x27
     380:	30 a5       	ldd	r19, Z+40	; 0x28
     382:	41 a5       	ldd	r20, Z+41	; 0x29
     384:	52 a5       	ldd	r21, Z+42	; 0x2a
     386:	63 ad       	ldd	r22, Z+59	; 0x3b
     388:	10 e0       	ldi	r17, 0x00	; 0
     38a:	80 ee       	ldi	r24, 0xE0	; 224
     38c:	91 e0       	ldi	r25, 0x01	; 1
     38e:	44 df       	rcall	.-376    	; 0x218 <actuator_set_position>
     390:	10 c0       	rjmp	.+32     	; 0x3b2 <actuator_p_controller+0x7c>
		target_position = vals->position_uart_instruction;
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);

	}
}

     392:	e2 a8       	ldd	r14, Z+50	; 0x32
     394:	f3 a8       	ldd	r15, Z+51	; 0x33

     396:	a3 a4       	ldd	r10, Z+43	; 0x2b
     398:	b4 a4       	ldd	r11, Z+44	; 0x2c
     39a:	c5 a4       	ldd	r12, Z+45	; 0x2d
     39c:	d6 a4       	ldd	r13, Z+46	; 0x2e
     39e:	07 a5       	ldd	r16, Z+47	; 0x2f
     3a0:	27 a1       	ldd	r18, Z+39	; 0x27
     3a2:	30 a5       	ldd	r19, Z+40	; 0x28
     3a4:	41 a5       	ldd	r20, Z+41	; 0x29
     3a6:	52 a5       	ldd	r21, Z+42	; 0x2a
     3a8:	63 ad       	ldd	r22, Z+59	; 0x3b
     3aa:	10 e0       	ldi	r17, 0x00	; 0
     3ac:	80 ee       	ldi	r24, 0xE0	; 224
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	33 df       	rcall	.-410    	; 0x218 <actuator_set_position>
     3b2:	1f 91       	pop	r17
     3b4:	0f 91       	pop	r16
     3b6:	ff 90       	pop	r15
     3b8:	ef 90       	pop	r14
     3ba:	df 90       	pop	r13
     3bc:	cf 90       	pop	r12
     3be:	bf 90       	pop	r11
     3c0:	af 90       	pop	r10
     3c2:	08 95       	ret

000003c4 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3c4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3c8:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3cc:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3d0:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3d4:	08 95       	ret

000003d6 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3d6:	68 2f       	mov	r22, r24
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     3e2:	20 e0       	ldi	r18, 0x00	; 0
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	48 e4       	ldi	r20, 0x48	; 72
     3e8:	52 e4       	ldi	r21, 0x42	; 66
     3ea:	0e 94 02 11 	call	0x2204	; 0x2204 <__subsf3>
     3ee:	27 ed       	ldi	r18, 0xD7	; 215
     3f0:	33 ea       	ldi	r19, 0xA3	; 163
     3f2:	48 e8       	ldi	r20, 0x88	; 136
     3f4:	51 e4       	ldi	r21, 0x41	; 65
     3f6:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     3fa:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     3fe:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     402:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     406:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     40a:	08 95       	ret

0000040c <controller>:
}

void controller(volatile ModuleValues_t *vals){
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     426:	8e 8d       	ldd	r24, Y+30	; 0x1e
     428:	82 30       	cpi	r24, 0x02	; 2
     42a:	21 f4       	brne	.+8      	; 0x434 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     42c:	68 8d       	ldd	r22, Y+24	; 0x18
     42e:	16 2f       	mov	r17, r22
     430:	11 95       	neg	r17
     432:	01 c0       	rjmp	.+2      	; 0x436 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     434:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     436:	8e 8d       	ldd	r24, Y+30	; 0x1e
     438:	81 30       	cpi	r24, 0x01	; 1
     43a:	09 f4       	brne	.+2      	; 0x43e <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     43c:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     43e:	89 a1       	ldd	r24, Y+33	; 0x21
     440:	81 11       	cpse	r24, r1
     442:	7b c0       	rjmp	.+246    	; 0x53a <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     444:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     448:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     44c:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     450:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     454:	20 e0       	ldi	r18, 0x00	; 0
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	4e eb       	ldi	r20, 0xBE	; 190
     45a:	52 e4       	ldi	r21, 0x42	; 66
     45c:	c7 01       	movw	r24, r14
     45e:	b6 01       	movw	r22, r12
     460:	0e 94 b6 12 	call	0x256c	; 0x256c <__gesf2>
     464:	88 23       	and	r24, r24
     466:	54 f4       	brge	.+20     	; 0x47c <controller+0x70>
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	48 e4       	ldi	r20, 0x48	; 72
     46e:	52 e4       	ldi	r21, 0x42	; 66
     470:	c7 01       	movw	r24, r14
     472:	b6 01       	movw	r22, r12
     474:	0e 94 67 11 	call	0x22ce	; 0x22ce <__cmpsf2>
     478:	18 16       	cp	r1, r24
     47a:	6c f0       	brlt	.+26     	; 0x496 <controller+0x8a>
		{
			b_saturation = 1 ;
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     482:	61 2f       	mov	r22, r17
     484:	11 0f       	add	r17, r17
     486:	77 0b       	sbc	r23, r23
     488:	88 0b       	sbc	r24, r24
     48a:	99 0b       	sbc	r25, r25
     48c:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     490:	6b 01       	movw	r12, r22
     492:	7c 01       	movw	r14, r24
     494:	25 c0       	rjmp	.+74     	; 0x4e0 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     496:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     49a:	61 2f       	mov	r22, r17
     49c:	11 0f       	add	r17, r17
     49e:	77 0b       	sbc	r23, r23
     4a0:	88 0b       	sbc	r24, r24
     4a2:	99 0b       	sbc	r25, r25
     4a4:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4ac:	2a e0       	ldi	r18, 0x0A	; 10
     4ae:	37 ed       	ldi	r19, 0xD7	; 215
     4b0:	43 ea       	ldi	r20, 0xA3	; 163
     4b2:	5b e3       	ldi	r21, 0x3B	; 59
     4b4:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     4b8:	9b 01       	movw	r18, r22
     4ba:	ac 01       	movw	r20, r24
     4bc:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4c0:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4c4:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4c8:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4cc:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     4d0:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4d4:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4d8:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     4dc:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     4e0:	27 ed       	ldi	r18, 0xD7	; 215
     4e2:	33 ea       	ldi	r19, 0xA3	; 163
     4e4:	48 e8       	ldi	r20, 0x88	; 136
     4e6:	51 e4       	ldi	r21, 0x41	; 65
     4e8:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4ec:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4f0:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4f4:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4f8:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     4fc:	4b 01       	movw	r8, r22
     4fe:	5c 01       	movw	r10, r24
     500:	27 e8       	ldi	r18, 0x87	; 135
     502:	3f eb       	ldi	r19, 0xBF	; 191
     504:	46 e2       	ldi	r20, 0x26	; 38
     506:	5e e3       	ldi	r21, 0x3E	; 62
     508:	c7 01       	movw	r24, r14
     50a:	b6 01       	movw	r22, r12
     50c:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     510:	9b 01       	movw	r18, r22
     512:	ac 01       	movw	r20, r24
     514:	c5 01       	movw	r24, r10
     516:	b4 01       	movw	r22, r8
     518:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 e4       	ldi	r20, 0x48	; 72
     522:	52 e4       	ldi	r21, 0x42	; 66
     524:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     528:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     52c:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     530:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     534:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     538:	11 c0       	rjmp	.+34     	; 0x55c <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     53a:	89 a1       	ldd	r24, Y+33	; 0x21
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	71 f4       	brne	.+28     	; 0x55c <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     540:	69 8d       	ldd	r22, Y+25	; 0x19
     542:	70 e0       	ldi	r23, 0x00	; 0
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     54c:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     550:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     554:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     558:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     55c:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     560:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     564:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     568:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     56c:	20 e0       	ldi	r18, 0x00	; 0
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	4e eb       	ldi	r20, 0xBE	; 190
     572:	52 e4       	ldi	r21, 0x42	; 66
     574:	c7 01       	movw	r24, r14
     576:	b6 01       	movw	r22, r12
     578:	0e 94 b6 12 	call	0x256c	; 0x256c <__gesf2>
     57c:	18 16       	cp	r1, r24
     57e:	6c f4       	brge	.+26     	; 0x59a <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	ae eb       	ldi	r26, 0xBE	; 190
     586:	b2 e4       	ldi	r27, 0x42	; 66
     588:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     58c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     590:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     594:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     598:	16 c0       	rjmp	.+44     	; 0x5c6 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	48 e4       	ldi	r20, 0x48	; 72
     5a0:	52 e4       	ldi	r21, 0x42	; 66
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 67 11 	call	0x22ce	; 0x22ce <__cmpsf2>
     5aa:	88 23       	and	r24, r24
     5ac:	64 f4       	brge	.+24     	; 0x5c6 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	a8 e4       	ldi	r26, 0x48	; 72
     5b4:	b2 e4       	ldi	r27, 0x42	; 66
     5b6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5ba:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5be:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5c2:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5c6:	06 e9       	ldi	r16, 0x96	; 150
     5c8:	10 e0       	ldi	r17, 0x00	; 0
     5ca:	f8 01       	movw	r30, r16
     5cc:	e0 80       	ld	r14, Z
     5ce:	f1 80       	ldd	r15, Z+1	; 0x01
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	48 ec       	ldi	r20, 0xC8	; 200
     5d6:	52 e4       	ldi	r21, 0x42	; 66
     5d8:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5dc:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5e0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     5e4:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     5e8:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     5ec:	4b 01       	movw	r8, r22
     5ee:	5c 01       	movw	r10, r24
     5f0:	b7 01       	movw	r22, r14
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	90 e0       	ldi	r25, 0x00	; 0
     5f6:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     5fa:	9b 01       	movw	r18, r22
     5fc:	ac 01       	movw	r20, r24
     5fe:	c5 01       	movw	r24, r10
     600:	b4 01       	movw	r22, r8
     602:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     606:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     60a:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     60e:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     612:	f8 01       	movw	r30, r16
     614:	60 81       	ld	r22, Z
     616:	71 81       	ldd	r23, Z+1	; 0x01
     618:	00 81       	ld	r16, Z
     61a:	11 81       	ldd	r17, Z+1	; 0x01
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     624:	6b 01       	movw	r12, r22
     626:	7c 01       	movw	r14, r24
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	48 ec       	ldi	r20, 0xC8	; 200
     62e:	52 e4       	ldi	r21, 0x42	; 66
     630:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     634:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     638:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     63c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     640:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     644:	4b 01       	movw	r8, r22
     646:	5c 01       	movw	r10, r24
     648:	b8 01       	movw	r22, r16
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     652:	9b 01       	movw	r18, r22
     654:	ac 01       	movw	r20, r24
     656:	c5 01       	movw	r24, r10
     658:	b4 01       	movw	r22, r8
     65a:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     65e:	9b 01       	movw	r18, r22
     660:	ac 01       	movw	r20, r24
     662:	c7 01       	movw	r24, r14
     664:	b6 01       	movw	r22, r12
     666:	0e 94 02 11 	call	0x2204	; 0x2204 <__subsf3>
     66a:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     66e:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     672:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     676:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     67a:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     67e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     682:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     686:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
     68a:	69 8f       	std	Y+25, r22	; 0x19

}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	1f 91       	pop	r17
     692:	0f 91       	pop	r16
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14
     698:	df 90       	pop	r13
     69a:	cf 90       	pop	r12
     69c:	bf 90       	pop	r11
     69e:	af 90       	pop	r10
     6a0:	9f 90       	pop	r9
     6a2:	8f 90       	pop	r8
     6a4:	08 95       	ret

000006a6 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6a6:	53 9a       	sbi	0x0a, 3	; 10
     6a8:	08 95       	ret

000006aa <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	11 f4       	brne	.+4      	; 0x6b2 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6ae:	5b 9a       	sbi	0x0b, 3	; 11
     6b0:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6b2:	5b 98       	cbi	0x0b, 3	; 11
     6b4:	08 95       	ret

000006b6 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6bc:	6a ef       	ldi	r22, 0xFA	; 250
     6be:	71 e0       	ldi	r23, 0x01	; 1
     6c0:	80 e0       	ldi	r24, 0x00	; 0
     6c2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6c6:	21 e0       	ldi	r18, 0x01	; 1
     6c8:	43 e0       	ldi	r20, 0x03	; 3
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	67 ef       	ldi	r22, 0xF7	; 247
     6ce:	71 e0       	ldi	r23, 0x01	; 1
     6d0:	8a ef       	ldi	r24, 0xFA	; 250
     6d2:	91 e0       	ldi	r25, 0x01	; 1
     6d4:	0e 94 a2 10 	call	0x2144	; 0x2144 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6d8:	e7 ef       	ldi	r30, 0xF7	; 247
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	61 81       	ldd	r22, Z+1	; 0x01
     6de:	6f 71       	andi	r22, 0x1F	; 31
     6e0:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - (float)CORRECTION_OFFSET_BAT_VOLTAGE);
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	76 2f       	mov	r23, r22
     6e6:	66 27       	eor	r22, r22
     6e8:	82 81       	ldd	r24, Z+2	; 0x02
     6ea:	68 2b       	or	r22, r24
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     6f4:	20 e0       	ldi	r18, 0x00	; 0
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	49 e8       	ldi	r20, 0x89	; 137
     6fa:	52 e4       	ldi	r21, 0x42	; 66
     6fc:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	40 e2       	ldi	r20, 0x20	; 32
     706:	51 e4       	ldi	r21, 0x41	; 65
     708:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     70c:	20 e0       	ldi	r18, 0x00	; 0
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	48 e8       	ldi	r20, 0x88	; 136
     712:	51 e4       	ldi	r21, 0x41	; 65
     714:	0e 94 02 11 	call	0x2204	; 0x2204 <__subsf3>
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     722:	68 83       	st	Y, r22
     724:	79 83       	std	Y+1, r23	; 0x01
     726:	8a 83       	std	Y+2, r24	; 0x02
     728:	9b 83       	std	Y+3, r25	; 0x03
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	08 95       	ret

00000730 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     736:	6a ef       	ldi	r22, 0xFA	; 250
     738:	71 e0       	ldi	r23, 0x01	; 1
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     740:	21 e0       	ldi	r18, 0x01	; 1
     742:	43 e0       	ldi	r20, 0x03	; 3
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	67 ef       	ldi	r22, 0xF7	; 247
     748:	71 e0       	ldi	r23, 0x01	; 1
     74a:	8a ef       	ldi	r24, 0xFA	; 250
     74c:	91 e0       	ldi	r25, 0x01	; 1
     74e:	0e 94 a2 10 	call	0x2144	; 0x2144 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     752:	e7 ef       	ldi	r30, 0xF7	; 247
     754:	f1 e0       	ldi	r31, 0x01	; 1
     756:	61 81       	ldd	r22, Z+1	; 0x01
     758:	6f 71       	andi	r22, 0x1F	; 31
     75a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     75c:	70 e0       	ldi	r23, 0x00	; 0
     75e:	76 2f       	mov	r23, r22
     760:	66 27       	eor	r22, r22
     762:	82 81       	ldd	r24, Z+2	; 0x02
     764:	68 2b       	or	r22, r24
     766:	41 e0       	ldi	r20, 0x01	; 1
     768:	ce 01       	movw	r24, r28
     76a:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <handle_current_sensor>
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	08 95       	ret

00000774 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     77a:	6a ef       	ldi	r22, 0xFA	; 250
     77c:	71 e0       	ldi	r23, 0x01	; 1
     77e:	84 e0       	ldi	r24, 0x04	; 4
     780:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     784:	21 e0       	ldi	r18, 0x01	; 1
     786:	43 e0       	ldi	r20, 0x03	; 3
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	67 ef       	ldi	r22, 0xF7	; 247
     78c:	71 e0       	ldi	r23, 0x01	; 1
     78e:	8a ef       	ldi	r24, 0xFA	; 250
     790:	91 e0       	ldi	r25, 0x01	; 1
     792:	0e 94 a2 10 	call	0x2144	; 0x2144 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     796:	e7 ef       	ldi	r30, 0xF7	; 247
     798:	f1 e0       	ldi	r31, 0x01	; 1
     79a:	61 81       	ldd	r22, Z+1	; 0x01
     79c:	6f 71       	andi	r22, 0x1F	; 31
     79e:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7a0:	70 e0       	ldi	r23, 0x00	; 0
     7a2:	76 2f       	mov	r23, r22
     7a4:	66 27       	eor	r22, r22
     7a6:	82 81       	ldd	r24, Z+2	; 0x02
     7a8:	68 2b       	or	r22, r24
     7aa:	ce 01       	movw	r24, r28
     7ac:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <handle_temp_sensor>
}
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	08 95       	ret

000007b6 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7b6:	0f 93       	push	r16
     7b8:	1f 93       	push	r17
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	00 d0       	rcall	.+0      	; 0x7c0 <SPI_handler_6+0xa>
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <SPI_handler_6+0xc>
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
     7c6:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7c8:	6a ef       	ldi	r22, 0xFA	; 250
     7ca:	71 e0       	ldi	r23, 0x01	; 1
     7cc:	86 e0       	ldi	r24, 0x06	; 6
     7ce:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	43 e0       	ldi	r20, 0x03	; 3
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	67 ef       	ldi	r22, 0xF7	; 247
     7da:	71 e0       	ldi	r23, 0x01	; 1
     7dc:	8a ef       	ldi	r24, 0xFA	; 250
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	0e 94 a2 10 	call	0x2144	; 0x2144 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7e4:	e7 ef       	ldi	r30, 0xF7	; 247
     7e6:	f1 e0       	ldi	r31, 0x01	; 1
     7e8:	61 81       	ldd	r22, Z+1	; 0x01
     7ea:	6f 71       	andi	r22, 0x1F	; 31
     7ec:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     7ee:	70 e0       	ldi	r23, 0x00	; 0
     7f0:	76 2f       	mov	r23, r22
     7f2:	66 27       	eor	r22, r22
     7f4:	82 81       	ldd	r24, Z+2	; 0x02
     7f6:	68 2b       	or	r22, r24
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     800:	20 e0       	ldi	r18, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	40 ea       	ldi	r20, 0xA0	; 160
     806:	50 e4       	ldi	r21, 0x40	; 64
     808:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     80c:	20 e0       	ldi	r18, 0x00	; 0
     80e:	30 e0       	ldi	r19, 0x00	; 0
     810:	40 e8       	ldi	r20, 0x80	; 128
     812:	59 e3       	ldi	r21, 0x39	; 57
     814:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     818:	69 83       	std	Y+1, r22	; 0x01
     81a:	7a 83       	std	Y+2, r23	; 0x02
     81c:	8b 83       	std	Y+3, r24	; 0x03
     81e:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     820:	69 81       	ldd	r22, Y+1	; 0x01
     822:	7a 81       	ldd	r23, Y+2	; 0x02
     824:	8b 81       	ldd	r24, Y+3	; 0x03
     826:	9c 81       	ldd	r25, Y+4	; 0x04
     828:	20 e0       	ldi	r18, 0x00	; 0
     82a:	30 e0       	ldi	r19, 0x00	; 0
     82c:	48 ec       	ldi	r20, 0xC8	; 200
     82e:	52 e4       	ldi	r21, 0x42	; 66
     830:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     834:	20 e0       	ldi	r18, 0x00	; 0
     836:	30 e0       	ldi	r19, 0x00	; 0
     838:	48 ec       	ldi	r20, 0xC8	; 200
     83a:	51 e4       	ldi	r21, 0x41	; 65
     83c:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     840:	f8 01       	movw	r30, r16
     842:	60 83       	st	Z, r22
     844:	71 83       	std	Z+1, r23	; 0x01
     846:	82 83       	std	Z+2, r24	; 0x02
     848:	93 83       	std	Z+3, r25	; 0x03
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	0f 90       	pop	r0
     850:	0f 90       	pop	r0
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	08 95       	ret

0000085c <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     85c:	cf 93       	push	r28
     85e:	df 93       	push	r29
     860:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     862:	6a ef       	ldi	r22, 0xFA	; 250
     864:	71 e0       	ldi	r23, 0x01	; 1
     866:	87 e0       	ldi	r24, 0x07	; 7
     868:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     86c:	21 e0       	ldi	r18, 0x01	; 1
     86e:	43 e0       	ldi	r20, 0x03	; 3
     870:	50 e0       	ldi	r21, 0x00	; 0
     872:	67 ef       	ldi	r22, 0xF7	; 247
     874:	71 e0       	ldi	r23, 0x01	; 1
     876:	8a ef       	ldi	r24, 0xFA	; 250
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	0e 94 a2 10 	call	0x2144	; 0x2144 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     87e:	e7 ef       	ldi	r30, 0xF7	; 247
     880:	f1 e0       	ldi	r31, 0x01	; 1
     882:	61 81       	ldd	r22, Z+1	; 0x01
     884:	6f 71       	andi	r22, 0x1F	; 31
     886:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	76 2f       	mov	r23, r22
     88c:	66 27       	eor	r22, r22
     88e:	82 81       	ldd	r24, Z+2	; 0x02
     890:	68 2b       	or	r22, r24
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	ce 01       	movw	r24, r28
     896:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <handle_current_sensor>
}
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	8c 01       	movw	r16, r24
     8aa:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8ac:	cb 01       	movw	r24, r22
     8ae:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <can_read_message_if_new>
     8b2:	88 23       	and	r24, r24
     8b4:	09 f4       	brne	.+2      	; 0x8b8 <handle_can+0x18>
     8b6:	46 c0       	rjmp	.+140    	; 0x944 <handle_can+0xa4>
     8b8:	f8 01       	movw	r30, r16
     8ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     8bc:	84 30       	cpi	r24, 0x04	; 4
     8be:	09 f4       	brne	.+2      	; 0x8c2 <handle_can+0x22>
     8c0:	41 c0       	rjmp	.+130    	; 0x944 <handle_can+0xa4>
		switch (rx->id){
     8c2:	88 81       	ld	r24, Y
     8c4:	99 81       	ldd	r25, Y+1	; 0x01
     8c6:	80 32       	cpi	r24, 0x20	; 32
     8c8:	f1 e0       	ldi	r31, 0x01	; 1
     8ca:	9f 07       	cpc	r25, r31
     8cc:	91 f1       	breq	.+100    	; 0x932 <handle_can+0x92>
     8ce:	80 33       	cpi	r24, 0x30	; 48
     8d0:	92 40       	sbci	r25, 0x02	; 2
     8d2:	c1 f5       	brne	.+112    	; 0x944 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	f8 01       	movw	r30, r16
     8d8:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     8da:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     8dc:	82 e3       	ldi	r24, 0x32	; 50
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	93 8f       	std	Z+27, r25	; 0x1b
     8e2:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     8e4:	8e 81       	ldd	r24, Y+6	; 0x06
     8e6:	89 30       	cpi	r24, 0x09	; 9
     8e8:	40 f0       	brcs	.+16     	; 0x8fa <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     8ea:	86 95       	lsr	r24
     8ec:	86 95       	lsr	r24
     8ee:	86 95       	lsr	r24
     8f0:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     8f2:	8e e1       	ldi	r24, 0x1E	; 30
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	95 8f       	std	Z+29, r25	; 0x1d
     8f8:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     8fa:	8f 81       	ldd	r24, Y+7	; 0x07
     8fc:	89 30       	cpi	r24, 0x09	; 9
     8fe:	88 f0       	brcs	.+34     	; 0x922 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     900:	8d 81       	ldd	r24, Y+5	; 0x05
     902:	9d ec       	ldi	r25, 0xCD	; 205
     904:	89 9f       	mul	r24, r25
     906:	81 2d       	mov	r24, r1
     908:	11 24       	eor	r1, r1
     90a:	86 95       	lsr	r24
     90c:	86 95       	lsr	r24
     90e:	86 95       	lsr	r24
     910:	f8 01       	movw	r30, r16
     912:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     914:	8e e1       	ldi	r24, 0x1E	; 30
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	95 8f       	std	Z+29, r25	; 0x1d
     91a:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     91c:	8f 81       	ldd	r24, Y+7	; 0x07
     91e:	89 30       	cpi	r24, 0x09	; 9
     920:	10 f4       	brcc	.+4      	; 0x926 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     922:	f8 01       	movw	r30, r16
     924:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     926:	8e 81       	ldd	r24, Y+6	; 0x06
     928:	89 30       	cpi	r24, 0x09	; 9
     92a:	60 f4       	brcc	.+24     	; 0x944 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     92c:	f8 01       	movw	r30, r16
     92e:	17 8a       	std	Z+23, r1	; 0x17
     930:	09 c0       	rjmp	.+18     	; 0x944 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	f8 01       	movw	r30, r16
     936:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	96 8b       	std	Z+22, r25	; 0x16
     93e:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     940:	8d 81       	ldd	r24, Y+5	; 0x05
     942:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	1f 91       	pop	r17
     94a:	0f 91       	pop	r16
     94c:	08 95       	ret

0000094e <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     94e:	0f 93       	push	r16
     950:	1f 93       	push	r17
     952:	cf 93       	push	r28
     954:	df 93       	push	r29
     956:	cd b7       	in	r28, 0x3d	; 61
     958:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     95a:	08 eb       	ldi	r16, 0xB8	; 184
     95c:	13 e0       	ldi	r17, 0x03	; 3
     95e:	80 e5       	ldi	r24, 0x50	; 80
     960:	92 e0       	ldi	r25, 0x02	; 2
     962:	f8 01       	movw	r30, r16
     964:	91 83       	std	Z+1, r25	; 0x01
     966:	80 83       	st	Z, r24
	txFrame.length = 8;
     968:	88 e0       	ldi	r24, 0x08	; 8
     96a:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     96c:	8d a1       	ldd	r24, Y+37	; 0x25
     96e:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     970:	69 85       	ldd	r22, Y+9	; 0x09
     972:	7a 85       	ldd	r23, Y+10	; 0x0a
     974:	8b 85       	ldd	r24, Y+11	; 0x0b
     976:	9c 85       	ldd	r25, Y+12	; 0x0c
     978:	20 e0       	ldi	r18, 0x00	; 0
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	40 e2       	ldi	r20, 0x20	; 32
     97e:	51 e4       	ldi	r21, 0x41	; 65
     980:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     984:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     988:	f8 01       	movw	r30, r16
     98a:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     98c:	69 89       	ldd	r22, Y+17	; 0x11
     98e:	7a 89       	ldd	r23, Y+18	; 0x12
     990:	8b 89       	ldd	r24, Y+19	; 0x13
     992:	9c 89       	ldd	r25, Y+20	; 0x14
     994:	20 e0       	ldi	r18, 0x00	; 0
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	40 e2       	ldi	r20, 0x20	; 32
     99a:	51 e4       	ldi	r21, 0x41	; 65
     99c:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     9a0:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
     9a4:	f8 01       	movw	r30, r16
     9a6:	76 83       	std	Z+6, r23	; 0x06
     9a8:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9aa:	6d 89       	ldd	r22, Y+21	; 0x15
     9ac:	7e 89       	ldd	r23, Y+22	; 0x16
     9ae:	8f 89       	ldd	r24, Y+23	; 0x17
     9b0:	98 8d       	ldd	r25, Y+24	; 0x18
     9b2:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     9b6:	07 2e       	mov	r0, r23
     9b8:	00 0c       	add	r0, r0
     9ba:	88 0b       	sbc	r24, r24
     9bc:	99 0b       	sbc	r25, r25
     9be:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	48 ec       	ldi	r20, 0xC8	; 200
     9c8:	52 e4       	ldi	r21, 0x42	; 66
     9ca:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     9ce:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     9d2:	9b 01       	movw	r18, r22
     9d4:	77 23       	and	r23, r23
     9d6:	24 f4       	brge	.+8      	; 0x9e0 <handle_motor_status_can_msg+0x92>
     9d8:	22 27       	eor	r18, r18
     9da:	33 27       	eor	r19, r19
     9dc:	26 1b       	sub	r18, r22
     9de:	37 0b       	sbc	r19, r23
     9e0:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     9e4:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     9e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
     9ea:	7b 8d       	ldd	r23, Y+27	; 0x1b
     9ec:	08 eb       	ldi	r16, 0xB8	; 184
     9ee:	13 e0       	ldi	r17, 0x03	; 3
     9f0:	80 e0       	ldi	r24, 0x00	; 0
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     9f8:	26 e6       	ldi	r18, 0x66	; 102
     9fa:	36 e6       	ldi	r19, 0x66	; 102
     9fc:	46 e6       	ldi	r20, 0x66	; 102
     9fe:	50 e4       	ldi	r21, 0x40	; 64
     a00:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     a04:	20 e0       	ldi	r18, 0x00	; 0
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	5f e3       	ldi	r21, 0x3F	; 63
     a0c:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     a10:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
     a14:	f8 01       	movw	r30, r16
     a16:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a18:	89 8d       	ldd	r24, Y+25	; 0x19
     a1a:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a1c:	c8 01       	movw	r24, r16
     a1e:	0e 94 00 10 	call	0x2000	; 0x2000 <can_send_message>
}
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	08 95       	ret

00000a2c <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a34:	ed ea       	ldi	r30, 0xAD	; 173
     a36:	f3 e0       	ldi	r31, 0x03	; 3
     a38:	81 e5       	ldi	r24, 0x51	; 81
     a3a:	92 e0       	ldi	r25, 0x02	; 2
     a3c:	91 83       	std	Z+1, r25	; 0x01
     a3e:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a44:	21 96       	adiw	r28, 0x01	; 1
     a46:	8f ad       	ldd	r24, Y+63	; 0x3f
     a48:	21 97       	sbiw	r28, 0x01	; 1
     a4a:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a4c:	cf 01       	movw	r24, r30
     a4e:	0e 94 00 10 	call	0x2000	; 0x2000 <can_send_message>
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a58:	af 92       	push	r10
     a5a:	bf 92       	push	r11
     a5c:	cf 92       	push	r12
     a5e:	df 92       	push	r13
     a60:	ef 92       	push	r14
     a62:	ff 92       	push	r15
     a64:	0f 93       	push	r16
     a66:	1f 93       	push	r17
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	66 97       	sbiw	r28, 0x16	; 22
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     a7e:	fe 01       	movw	r30, r28
     a80:	31 96       	adiw	r30, 0x01	; 1
     a82:	96 e1       	ldi	r25, 0x16	; 22
     a84:	df 01       	movw	r26, r30
     a86:	1d 92       	st	X+, r1
     a88:	9a 95       	dec	r25
     a8a:	e9 f7       	brne	.-6      	; 0xa86 <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     a8c:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     a90:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     a94:	92 1b       	sub	r25, r18
     a96:	9f 71       	andi	r25, 0x1F	; 31
     a98:	09 f4       	brne	.+2      	; 0xa9c <receive_uart+0x44>
     a9a:	4e c1       	rjmp	.+668    	; 0xd38 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     a9c:	f6 01       	movw	r30, r12
     a9e:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     aa0:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     aa2:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     aa4:	66 e1       	ldi	r22, 0x16	; 22
     aa6:	ce 01       	movw	r24, r28
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	b6 d4       	rcall	.+2412   	; 0x1418 <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     aac:	ce 01       	movw	r24, r28
     aae:	01 96       	adiw	r24, 0x01	; 1
     ab0:	0e 94 26 13 	call	0x264c	; 0x264c <atoi>
     ab4:	5c 01       	movw	r10, r24
     ab6:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ab8:	d6 01       	movw	r26, r12
     aba:	8d 91       	ld	r24, X+
     abc:	9c 91       	ld	r25, X
     abe:	89 2b       	or	r24, r25
     ac0:	71 f4       	brne	.+28     	; 0xade <receive_uart+0x86>
     ac2:	6f e4       	ldi	r22, 0x4F	; 79
     ac4:	71 e0       	ldi	r23, 0x01	; 1
     ac6:	ce 01       	movw	r24, r28
     ac8:	01 96       	adiw	r24, 0x01	; 1
     aca:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     ace:	89 2b       	or	r24, r25
     ad0:	31 f4       	brne	.+12     	; 0xade <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     ad2:	f6 01       	movw	r30, r12
     ad4:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	91 83       	std	Z+1, r25	; 0x01
     adc:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     ade:	d6 01       	movw	r26, r12
     ae0:	8d 91       	ld	r24, X+
     ae2:	9c 91       	ld	r25, X
     ae4:	89 2b       	or	r24, r25
     ae6:	71 f0       	breq	.+28     	; 0xb04 <receive_uart+0xac>
     ae8:	61 e6       	ldi	r22, 0x61	; 97
     aea:	71 e0       	ldi	r23, 0x01	; 1
     aec:	ce 01       	movw	r24, r28
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     af4:	89 2b       	or	r24, r25
     af6:	31 f4       	brne	.+12     	; 0xb04 <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     af8:	f6 01       	movw	r30, r12
     afa:	11 82       	std	Z+1, r1	; 0x01
     afc:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     afe:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b00:	15 8e       	std	Z+29, r1	; 0x1d
     b02:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b04:	62 e7       	ldi	r22, 0x72	; 114
     b06:	71 e0       	ldi	r23, 0x01	; 1
     b08:	ce 01       	movw	r24, r28
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     b10:	89 2b       	or	r24, r25
     b12:	11 f5       	brne	.+68     	; 0xb58 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b14:	d6 01       	movw	r26, r12
     b16:	94 96       	adiw	r26, 0x24	; 36
     b18:	1c 92       	st	X, r1
     b1a:	1e 92       	st	-X, r1
     b1c:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b1e:	da 96       	adiw	r26, 0x3a	; 58
     b20:	8c 91       	ld	r24, X
     b22:	81 30       	cpi	r24, 0x01	; 1
     b24:	51 f0       	breq	.+20     	; 0xb3a <receive_uart+0xe2>
     b26:	18 f0       	brcs	.+6      	; 0xb2e <receive_uart+0xd6>
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	89 f0       	breq	.+34     	; 0xb4e <receive_uart+0xf6>
     b2c:	15 c0       	rjmp	.+42     	; 0xb58 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b2e:	f6 01       	movw	r30, r12
     b30:	84 a9       	ldd	r24, Z+52	; 0x34
     b32:	95 a9       	ldd	r25, Z+53	; 0x35
     b34:	93 ab       	std	Z+51, r25	; 0x33
     b36:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b38:	0f c0       	rjmp	.+30     	; 0xb58 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b3a:	d6 01       	movw	r26, r12
     b3c:	d6 96       	adiw	r26, 0x36	; 54
     b3e:	8d 91       	ld	r24, X+
     b40:	9c 91       	ld	r25, X
     b42:	d7 97       	sbiw	r26, 0x37	; 55
     b44:	d3 96       	adiw	r26, 0x33	; 51
     b46:	9c 93       	st	X, r25
     b48:	8e 93       	st	-X, r24
     b4a:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b4c:	05 c0       	rjmp	.+10     	; 0xb58 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b4e:	f6 01       	movw	r30, r12
     b50:	80 ad       	ldd	r24, Z+56	; 0x38
     b52:	91 ad       	ldd	r25, Z+57	; 0x39
     b54:	93 ab       	std	Z+51, r25	; 0x33
     b56:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b58:	65 e8       	ldi	r22, 0x85	; 133
     b5a:	71 e0       	ldi	r23, 0x01	; 1
     b5c:	ce 01       	movw	r24, r28
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     b64:	89 2b       	or	r24, r25
     b66:	39 f4       	brne	.+14     	; 0xb76 <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	d6 01       	movw	r26, r12
     b6e:	94 96       	adiw	r26, 0x24	; 36
     b70:	9c 93       	st	X, r25
     b72:	8e 93       	st	-X, r24
     b74:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b76:	f6 01       	movw	r30, r12
     b78:	80 81       	ld	r24, Z
     b7a:	91 81       	ldd	r25, Z+1	; 0x01
     b7c:	89 2b       	or	r24, r25
     b7e:	39 f0       	breq	.+14     	; 0xb8e <receive_uart+0x136>
     b80:	c5 01       	movw	r24, r10
     b82:	0b 97       	sbiw	r24, 0x0b	; 11
     b84:	0a 97       	sbiw	r24, 0x0a	; 10
     b86:	18 f4       	brcc	.+6      	; 0xb8e <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     b88:	86 ef       	ldi	r24, 0xF6	; 246
     b8a:	8a 0d       	add	r24, r10
     b8c:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     b8e:	d6 01       	movw	r26, r12
     b90:	8d 91       	ld	r24, X+
     b92:	9c 91       	ld	r25, X
     b94:	11 97       	sbiw	r26, 0x01	; 1
     b96:	89 2b       	or	r24, r25
     b98:	39 f0       	breq	.+14     	; 0xba8 <receive_uart+0x150>
     b9a:	0a 30       	cpi	r16, 0x0A	; 10
     b9c:	11 05       	cpc	r17, r1
     b9e:	20 f4       	brcc	.+8      	; 0xba8 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     ba0:	8a e0       	ldi	r24, 0x0A	; 10
     ba2:	8a 19       	sub	r24, r10
     ba4:	58 96       	adiw	r26, 0x18	; 24
     ba6:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     ba8:	f6 01       	movw	r30, r12
     baa:	80 81       	ld	r24, Z
     bac:	91 81       	ldd	r25, Z+1	; 0x01
     bae:	89 2b       	or	r24, r25
     bb0:	31 f0       	breq	.+12     	; 0xbbe <receive_uart+0x166>
     bb2:	01 2b       	or	r16, r17
     bb4:	21 f4       	brne	.+8      	; 0xbbe <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bb6:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bb8:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bba:	82 e3       	ldi	r24, 0x32	; 50
     bbc:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bbe:	d6 01       	movw	r26, r12
     bc0:	93 96       	adiw	r26, 0x23	; 35
     bc2:	8d 91       	ld	r24, X+
     bc4:	9c 91       	ld	r25, X
     bc6:	94 97       	sbiw	r26, 0x24	; 36
     bc8:	01 97       	sbiw	r24, 0x01	; 1
     bca:	51 f4       	brne	.+20     	; 0xbe0 <receive_uart+0x188>
     bcc:	67 e9       	ldi	r22, 0x97	; 151
     bce:	71 e0       	ldi	r23, 0x01	; 1
     bd0:	ce 01       	movw	r24, r28
     bd2:	01 96       	adiw	r24, 0x01	; 1
     bd4:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     bd8:	89 2b       	or	r24, r25
     bda:	11 f4       	brne	.+4      	; 0xbe0 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     bdc:	f6 01       	movw	r30, r12
     bde:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     be0:	d6 01       	movw	r26, r12
     be2:	93 96       	adiw	r26, 0x23	; 35
     be4:	8d 91       	ld	r24, X+
     be6:	9c 91       	ld	r25, X
     be8:	94 97       	sbiw	r26, 0x24	; 36
     bea:	01 97       	sbiw	r24, 0x01	; 1
     bec:	59 f4       	brne	.+22     	; 0xc04 <receive_uart+0x1ac>
     bee:	69 e9       	ldi	r22, 0x99	; 153
     bf0:	71 e0       	ldi	r23, 0x01	; 1
     bf2:	ce 01       	movw	r24, r28
     bf4:	01 96       	adiw	r24, 0x01	; 1
     bf6:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     bfa:	89 2b       	or	r24, r25
     bfc:	19 f4       	brne	.+6      	; 0xc04 <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	f6 01       	movw	r30, r12
     c02:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c04:	d6 01       	movw	r26, r12
     c06:	93 96       	adiw	r26, 0x23	; 35
     c08:	8d 91       	ld	r24, X+
     c0a:	9c 91       	ld	r25, X
     c0c:	94 97       	sbiw	r26, 0x24	; 36
     c0e:	01 97       	sbiw	r24, 0x01	; 1
     c10:	59 f4       	brne	.+22     	; 0xc28 <receive_uart+0x1d0>
     c12:	65 eb       	ldi	r22, 0xB5	; 181
     c14:	71 e0       	ldi	r23, 0x01	; 1
     c16:	ce 01       	movw	r24, r28
     c18:	01 96       	adiw	r24, 0x01	; 1
     c1a:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     c1e:	89 2b       	or	r24, r25
     c20:	19 f4       	brne	.+6      	; 0xc28 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c22:	82 e0       	ldi	r24, 0x02	; 2
     c24:	f6 01       	movw	r30, r12
     c26:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c28:	d6 01       	movw	r26, r12
     c2a:	93 96       	adiw	r26, 0x23	; 35
     c2c:	8d 91       	ld	r24, X+
     c2e:	9c 91       	ld	r25, X
     c30:	94 97       	sbiw	r26, 0x24	; 36
     c32:	89 2b       	or	r24, r25
     c34:	59 f4       	brne	.+22     	; 0xc4c <receive_uart+0x1f4>
     c36:	6b e9       	ldi	r22, 0x9B	; 155
     c38:	71 e0       	ldi	r23, 0x01	; 1
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     c42:	89 2b       	or	r24, r25
     c44:	19 f4       	brne	.+6      	; 0xc4c <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	e0 da       	rcall	.-2624   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c4c:	f6 01       	movw	r30, r12
     c4e:	83 a1       	ldd	r24, Z+35	; 0x23
     c50:	94 a1       	ldd	r25, Z+36	; 0x24
     c52:	89 2b       	or	r24, r25
     c54:	59 f4       	brne	.+22     	; 0xc6c <receive_uart+0x214>
     c56:	63 ea       	ldi	r22, 0xA3	; 163
     c58:	71 e0       	ldi	r23, 0x01	; 1
     c5a:	ce 01       	movw	r24, r28
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     c62:	89 2b       	or	r24, r25
     c64:	19 f4       	brne	.+6      	; 0xc6c <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	d0 da       	rcall	.-2656   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c6c:	d6 01       	movw	r26, r12
     c6e:	93 96       	adiw	r26, 0x23	; 35
     c70:	8d 91       	ld	r24, X+
     c72:	9c 91       	ld	r25, X
     c74:	94 97       	sbiw	r26, 0x24	; 36
     c76:	89 2b       	or	r24, r25
     c78:	a9 f4       	brne	.+42     	; 0xca4 <receive_uart+0x24c>
     c7a:	69 ea       	ldi	r22, 0xA9	; 169
     c7c:	71 e0       	ldi	r23, 0x01	; 1
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     c86:	89 2b       	or	r24, r25
     c88:	69 f4       	brne	.+26     	; 0xca4 <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     c8a:	f6 01       	movw	r30, r12
     c8c:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     c8e:	e0 ac       	ldd	r14, Z+56	; 0x38
     c90:	f1 ac       	ldd	r15, Z+57	; 0x39
     c92:	06 a9       	ldd	r16, Z+54	; 0x36
     c94:	17 a9       	ldd	r17, Z+55	; 0x37
     c96:	24 a9       	ldd	r18, Z+52	; 0x34
     c98:	35 a9       	ldd	r19, Z+53	; 0x35
     c9a:	42 a9       	ldd	r20, Z+50	; 0x32
     c9c:	53 a9       	ldd	r21, Z+51	; 0x33
     c9e:	62 ad       	ldd	r22, Z+58	; 0x3a
     ca0:	83 ad       	ldd	r24, Z+59	; 0x3b
     ca2:	81 da       	rcall	.-2814   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     ca4:	d6 01       	movw	r26, r12
     ca6:	93 96       	adiw	r26, 0x23	; 35
     ca8:	8d 91       	ld	r24, X+
     caa:	9c 91       	ld	r25, X
     cac:	94 97       	sbiw	r26, 0x24	; 36
     cae:	89 2b       	or	r24, r25
     cb0:	b1 f4       	brne	.+44     	; 0xcde <receive_uart+0x286>
     cb2:	67 eb       	ldi	r22, 0xB7	; 183
     cb4:	71 e0       	ldi	r23, 0x01	; 1
     cb6:	ce 01       	movw	r24, r28
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     cbe:	89 2b       	or	r24, r25
     cc0:	71 f4       	brne	.+28     	; 0xcde <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	f6 01       	movw	r30, r12
     cc6:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cc8:	e0 ac       	ldd	r14, Z+56	; 0x38
     cca:	f1 ac       	ldd	r15, Z+57	; 0x39
     ccc:	06 a9       	ldd	r16, Z+54	; 0x36
     cce:	17 a9       	ldd	r17, Z+55	; 0x37
     cd0:	24 a9       	ldd	r18, Z+52	; 0x34
     cd2:	35 a9       	ldd	r19, Z+53	; 0x35
     cd4:	42 a9       	ldd	r20, Z+50	; 0x32
     cd6:	53 a9       	ldd	r21, Z+51	; 0x33
     cd8:	62 ad       	ldd	r22, Z+58	; 0x3a
     cda:	83 ad       	ldd	r24, Z+59	; 0x3b
     cdc:	64 da       	rcall	.-2872   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cde:	d6 01       	movw	r26, r12
     ce0:	93 96       	adiw	r26, 0x23	; 35
     ce2:	8d 91       	ld	r24, X+
     ce4:	9c 91       	ld	r25, X
     ce6:	94 97       	sbiw	r26, 0x24	; 36
     ce8:	89 2b       	or	r24, r25
     cea:	b1 f4       	brne	.+44     	; 0xd18 <receive_uart+0x2c0>
     cec:	67 ec       	ldi	r22, 0xC7	; 199
     cee:	71 e0       	ldi	r23, 0x01	; 1
     cf0:	ce 01       	movw	r24, r28
     cf2:	01 96       	adiw	r24, 0x01	; 1
     cf4:	0e 94 43 13 	call	0x2686	; 0x2686 <strcmp>
     cf8:	89 2b       	or	r24, r25
     cfa:	71 f4       	brne	.+28     	; 0xd18 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     cfc:	82 e0       	ldi	r24, 0x02	; 2
     cfe:	f6 01       	movw	r30, r12
     d00:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d02:	e0 ac       	ldd	r14, Z+56	; 0x38
     d04:	f1 ac       	ldd	r15, Z+57	; 0x39
     d06:	06 a9       	ldd	r16, Z+54	; 0x36
     d08:	17 a9       	ldd	r17, Z+55	; 0x37
     d0a:	24 a9       	ldd	r18, Z+52	; 0x34
     d0c:	35 a9       	ldd	r19, Z+53	; 0x35
     d0e:	42 a9       	ldd	r20, Z+50	; 0x32
     d10:	53 a9       	ldd	r21, Z+51	; 0x33
     d12:	62 ad       	ldd	r22, Z+58	; 0x3a
     d14:	83 ad       	ldd	r24, Z+59	; 0x3b
     d16:	47 da       	rcall	.-2930   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d18:	d6 01       	movw	r26, r12
     d1a:	93 96       	adiw	r26, 0x23	; 35
     d1c:	8d 91       	ld	r24, X+
     d1e:	9c 91       	ld	r25, X
     d20:	94 97       	sbiw	r26, 0x24	; 36
     d22:	89 2b       	or	r24, r25
     d24:	41 f4       	brne	.+16     	; 0xd36 <receive_uart+0x2de>
     d26:	c5 01       	movw	r24, r10
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	87 3e       	cpi	r24, 0xE7	; 231
     d2c:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d2e:	18 f4       	brcc	.+6      	; 0xd36 <receive_uart+0x2de>
     d30:	f6 01       	movw	r30, r12
     d32:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d34:	a2 aa       	std	Z+50, r10	; 0x32
     d36:	26 d3       	rcall	.+1612   	; 0x1384 <uart0_flush>
	}
}
     d38:	66 96       	adiw	r28, 0x16	; 22
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	f8 94       	cli
     d3e:	de bf       	out	0x3e, r29	; 62
     d40:	0f be       	out	0x3f, r0	; 63
     d42:	cd bf       	out	0x3d, r28	; 61
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	bf 90       	pop	r11
     d56:	af 90       	pop	r10
     d58:	08 95       	ret

00000d5a <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d5a:	0f 93       	push	r16
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	cd b7       	in	r28, 0x3d	; 61
     d64:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d66:	88 ed       	ldi	r24, 0xD8	; 216
     d68:	91 e0       	ldi	r25, 0x01	; 1
     d6a:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <puts>
	//printf(",");
	//printf("%u", vals.gear_required);
	//printf(",");
	//printf("%u",vals.gear_status);
	//printf(",");
	printf("%u", vals.motor_status);
     d6e:	8d a1       	ldd	r24, Y+37	; 0x25
     d70:	1f 92       	push	r1
     d72:	8f 93       	push	r24
     d74:	0a ed       	ldi	r16, 0xDA	; 218
     d76:	11 e0       	ldi	r17, 0x01	; 1
     d78:	1f 93       	push	r17
     d7a:	0f 93       	push	r16
     d7c:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     d80:	8c e2       	ldi	r24, 0x2C	; 44
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	printf("%u",vals.message_mode);
     d88:	8e a1       	ldd	r24, Y+38	; 0x26
     d8a:	1f 92       	push	r1
     d8c:	8f 93       	push	r24
     d8e:	1f 93       	push	r17
     d90:	0f 93       	push	r16
     d92:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     d96:	8c e2       	ldi	r24, 0x2C	; 44
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	printf("%u",vals.u8_duty_cycle);
     d9e:	88 a1       	ldd	r24, Y+32	; 0x20
     da0:	1f 92       	push	r1
     da2:	8f 93       	push	r24
     da4:	1f 93       	push	r17
     da6:	0f 93       	push	r16
     da8:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     dac:	8c e2       	ldi	r24, 0x2C	; 44
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     db4:	69 89       	ldd	r22, Y+17	; 0x11
     db6:	7a 89       	ldd	r23, Y+18	; 0x12
     db8:	8b 89       	ldd	r24, Y+19	; 0x13
     dba:	9c 89       	ldd	r25, Y+20	; 0x14
     dbc:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     dc0:	7f 93       	push	r23
     dc2:	6f 93       	push	r22
     dc4:	0d ed       	ldi	r16, 0xDD	; 221
     dc6:	11 e0       	ldi	r17, 0x01	; 1
     dc8:	1f 93       	push	r17
     dca:	0f 93       	push	r16
     dcc:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     dd0:	8c e2       	ldi	r24, 0x2C	; 44
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	printf("%i",(int16_t)(vals.f32_motor_current*1000));
     dd8:	69 85       	ldd	r22, Y+9	; 0x09
     dda:	7a 85       	ldd	r23, Y+10	; 0x0a
     ddc:	8b 85       	ldd	r24, Y+11	; 0x0b
     dde:	9c 85       	ldd	r25, Y+12	; 0x0c
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	4a e7       	ldi	r20, 0x7A	; 122
     de6:	54 e4       	ldi	r21, 0x44	; 68
     de8:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     dec:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     df0:	7f 93       	push	r23
     df2:	6f 93       	push	r22
     df4:	1f 93       	push	r17
     df6:	0f 93       	push	r16
     df8:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(","); 
     dfc:	8c e2       	ldi	r24, 0x2C	; 44
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	printf("%i",(int16_t)(vals.f32_batt_current*1000));
     e04:	6d 85       	ldd	r22, Y+13	; 0x0d
     e06:	7e 85       	ldd	r23, Y+14	; 0x0e
     e08:	8f 85       	ldd	r24, Y+15	; 0x0f
     e0a:	98 89       	ldd	r25, Y+16	; 0x10
     e0c:	20 e0       	ldi	r18, 0x00	; 0
     e0e:	30 e0       	ldi	r19, 0x00	; 0
     e10:	4a e7       	ldi	r20, 0x7A	; 122
     e12:	54 e4       	ldi	r21, 0x44	; 68
     e14:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     e18:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     e1c:	7f 93       	push	r23
     e1e:	6f 93       	push	r22
     e20:	1f 93       	push	r17
     e22:	0f 93       	push	r16
     e24:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     e28:	8c e2       	ldi	r24, 0x2C	; 44
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e30:	6a a9       	ldd	r22, Y+50	; 0x32
     e32:	7b a9       	ldd	r23, Y+51	; 0x33
     e34:	8c a9       	ldd	r24, Y+52	; 0x34
     e36:	9d a9       	ldd	r25, Y+53	; 0x35
     e38:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
     e3c:	7f 93       	push	r23
     e3e:	6f 93       	push	r22
     e40:	1f 93       	push	r17
     e42:	0f 93       	push	r16
     e44:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     e48:	8c e2       	ldi	r24, 0x2C	; 44
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e50:	8f 81       	ldd	r24, Y+7	; 0x07
     e52:	98 85       	ldd	r25, Y+8	; 0x08
     e54:	9f 93       	push	r25
     e56:	8f 93       	push	r24
     e58:	1f 93       	push	r17
     e5a:	0f 93       	push	r16
     e5c:	0e 94 54 13 	call	0x26a8	; 0x26a8 <printf>
	printf(",");
     e60:	0f b6       	in	r0, 0x3f	; 63
     e62:	f8 94       	cli
     e64:	de bf       	out	0x3e, r29	; 62
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	cd bf       	out	0x3d, r28	; 61
     e6a:	8c e2       	ldi	r24, 0x2C	; 44
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 67 13 	call	0x26ce	; 0x26ce <putchar>
	//printf(",");
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	//printf("%i", (int16_t)vals.uart_debug);
	
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	1f 91       	pop	r17
     e78:	0f 91       	pop	r16
     e7a:	08 95       	ret

00000e7c <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     e84:	8b a1       	ldd	r24, Y+35	; 0x23
     e86:	82 30       	cpi	r24, 0x02	; 2
     e88:	91 f1       	breq	.+100    	; 0xeee <manage_LEDs+0x72>
     e8a:	28 f4       	brcc	.+10     	; 0xe96 <manage_LEDs+0x1a>
     e8c:	88 23       	and	r24, r24
     e8e:	49 f0       	breq	.+18     	; 0xea2 <manage_LEDs+0x26>
     e90:	81 30       	cpi	r24, 0x01	; 1
     e92:	19 f1       	breq	.+70     	; 0xeda <manage_LEDs+0x5e>
     e94:	49 c0       	rjmp	.+146    	; 0xf28 <manage_LEDs+0xac>
     e96:	84 30       	cpi	r24, 0x04	; 4
     e98:	f1 f1       	breq	.+124    	; 0xf16 <manage_LEDs+0x9a>
     e9a:	98 f1       	brcs	.+102    	; 0xf02 <manage_LEDs+0x86>
     e9c:	85 30       	cpi	r24, 0x05	; 5
     e9e:	99 f0       	breq	.+38     	; 0xec6 <manage_LEDs+0x4a>
     ea0:	43 c0       	rjmp	.+134    	; 0xf28 <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     ea2:	80 e4       	ldi	r24, 0x40	; 64
     ea4:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     ea8:	80 e8       	ldi	r24, 0x80	; 128
     eaa:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     eae:	8f 8d       	ldd	r24, Y+31	; 0x1f
     eb0:	98 a1       	ldd	r25, Y+32	; 0x20
     eb2:	89 2b       	or	r24, r25
     eb4:	21 f4       	brne	.+8      	; 0xebe <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     eb6:	80 e2       	ldi	r24, 0x20	; 32
     eb8:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
     ebc:	35 c0       	rjmp	.+106    	; 0xf28 <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     ebe:	80 e2       	ldi	r24, 0x20	; 32
     ec0:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
     ec4:	31 c0       	rjmp	.+98     	; 0xf28 <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     ec6:	80 e2       	ldi	r24, 0x20	; 32
     ec8:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     ecc:	80 e4       	ldi	r24, 0x40	; 64
     ece:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     ed2:	80 e8       	ldi	r24, 0x80	; 128
     ed4:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
		break ;
     ed8:	27 c0       	rjmp	.+78     	; 0xf28 <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     eda:	80 e2       	ldi	r24, 0x20	; 32
     edc:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     ee0:	80 e8       	ldi	r24, 0x80	; 128
     ee2:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     ee6:	80 e4       	ldi	r24, 0x40	; 64
     ee8:	0e 94 8d 10 	call	0x211a	; 0x211a <rgbled_toggle>
		break;
     eec:	1d c0       	rjmp	.+58     	; 0xf28 <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     eee:	80 e8       	ldi	r24, 0x80	; 128
     ef0:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     ef4:	80 e4       	ldi	r24, 0x40	; 64
     ef6:	0e 94 8d 10 	call	0x211a	; 0x211a <rgbled_toggle>
			rgbled_toggle(LED_RED);
     efa:	80 e2       	ldi	r24, 0x20	; 32
     efc:	0e 94 8d 10 	call	0x211a	; 0x211a <rgbled_toggle>
		break;
     f00:	13 c0       	rjmp	.+38     	; 0xf28 <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     f02:	80 e2       	ldi	r24, 0x20	; 32
     f04:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f08:	80 e8       	ldi	r24, 0x80	; 128
     f0a:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f0e:	80 e4       	ldi	r24, 0x40	; 64
     f10:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
		break;
     f14:	09 c0       	rjmp	.+18     	; 0xf28 <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     f16:	80 e4       	ldi	r24, 0x40	; 64
     f18:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f1c:	80 e8       	ldi	r24, 0x80	; 128
     f1e:	0e 94 7e 10 	call	0x20fc	; 0x20fc <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     f22:	80 e2       	ldi	r24, 0x20	; 32
     f24:	0e 94 88 10 	call	0x2110	; 0x2110 <rgbled_turn_on>
		break;
	}
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	08 95       	ret

00000f2e <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     f2e:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     f30:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     f32:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     f34:	e9 e6       	ldi	r30, 0x69	; 105
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	84 60       	ori	r24, 0x04	; 4
     f3c:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
     f3e:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
     f40:	e9 9a       	sbi	0x1d, 1	; 29
     f42:	08 95       	ret

00000f44 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
     f44:	0f 93       	push	r16
     f46:	1f 93       	push	r17
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
	
	if (*u16_counter > 70)
     f4c:	fb 01       	movw	r30, r22
     f4e:	20 81       	ld	r18, Z
     f50:	31 81       	ldd	r19, Z+1	; 0x01
     f52:	27 34       	cpi	r18, 0x47	; 71
     f54:	31 05       	cpc	r19, r1
     f56:	b8 f0       	brcs	.+46     	; 0xf86 <handle_speed_sensor+0x42>
     f58:	eb 01       	movw	r28, r22
     f5a:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
     f5c:	60 81       	ld	r22, Z
     f5e:	71 81       	ldd	r23, Z+1	; 0x01
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
     f68:	9b 01       	movw	r18, r22
     f6a:	ac 01       	movw	r20, r24
     f6c:	60 e0       	ldi	r22, 0x00	; 0
     f6e:	76 e7       	ldi	r23, 0x76	; 118
     f70:	88 e8       	ldi	r24, 0x88	; 136
     f72:	96 e4       	ldi	r25, 0x46	; 70
     f74:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     f78:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
     f7c:	f8 01       	movw	r30, r16
     f7e:	71 83       	std	Z+1, r23	; 0x01
     f80:	60 83       	st	Z, r22
		*u16_counter = 0 ;
     f82:	19 82       	std	Y+1, r1	; 0x01
     f84:	18 82       	st	Y, r1
	}	
}
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	1f 91       	pop	r17
     f8c:	0f 91       	pop	r16
     f8e:	08 95       	ret

00000f90 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
     f90:	cf 92       	push	r12
     f92:	df 92       	push	r13
     f94:	ef 92       	push	r14
     f96:	ff 92       	push	r15
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	1f 92       	push	r1
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
     fa2:	89 83       	std	Y+1, r24	; 0x01
     fa4:	69 01       	movw	r12, r18
     fa6:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
     fa8:	61 30       	cpi	r22, 0x01	; 1
     faa:	19 f5       	brne	.+70     	; 0xff2 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
     fac:	69 81       	ldd	r22, Y+1	; 0x01
     fae:	70 e0       	ldi	r23, 0x00	; 0
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
     fb8:	22 e1       	ldi	r18, 0x12	; 18
     fba:	35 e8       	ldi	r19, 0x85	; 133
     fbc:	41 e6       	ldi	r20, 0x61	; 97
     fbe:	5e e3       	ldi	r21, 0x3E	; 62
     fc0:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     fc4:	a7 01       	movw	r20, r14
     fc6:	96 01       	movw	r18, r12
     fc8:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
     fcc:	20 e0       	ldi	r18, 0x00	; 0
     fce:	30 e0       	ldi	r19, 0x00	; 0
     fd0:	48 ec       	ldi	r20, 0xC8	; 200
     fd2:	52 e4       	ldi	r21, 0x42	; 66
     fd4:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	48 e4       	ldi	r20, 0x48	; 72
     fde:	52 e4       	ldi	r21, 0x42	; 66
     fe0:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
     fe4:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
     fe8:	86 2f       	mov	r24, r22
		if (Duty == 50)
     fea:	62 33       	cpi	r22, 0x32	; 50
     fec:	29 f5       	brne	.+74     	; 0x1038 <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
     fee:	84 e3       	ldi	r24, 0x34	; 52
     ff0:	23 c0       	rjmp	.+70     	; 0x1038 <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
     ff2:	62 30       	cpi	r22, 0x02	; 2
     ff4:	01 f5       	brne	.+64     	; 0x1036 <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
     ff6:	69 81       	ldd	r22, Y+1	; 0x01
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0e 94 06 12 	call	0x240c	; 0x240c <__floatsisf>
    1002:	23 ee       	ldi	r18, 0xE3	; 227
    1004:	3e ee       	ldi	r19, 0xEE	; 238
    1006:	4b e3       	ldi	r20, 0x3B	; 59
    1008:	5e e3       	ldi	r21, 0x3E	; 62
    100a:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
    100e:	a7 01       	movw	r20, r14
    1010:	96 01       	movw	r18, r12
    1012:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__divsf3>
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	48 ec       	ldi	r20, 0xC8	; 200
    101c:	52 e4       	ldi	r21, 0x42	; 66
    101e:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	48 e4       	ldi	r20, 0x48	; 72
    1028:	52 e4       	ldi	r21, 0x42	; 66
    102a:	0e 94 03 11 	call	0x2206	; 0x2206 <__addsf3>
    102e:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <__fixunssfsi>
    1032:	86 2f       	mov	r24, r22
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    1036:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    1038:	0f 90       	pop	r0
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	ff 90       	pop	r15
    1040:	ef 90       	pop	r14
    1042:	df 90       	pop	r13
    1044:	cf 90       	pop	r12
    1046:	08 95       	ret

00001048 <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    104e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1050:	81 11       	cpse	r24, r1
    1052:	08 c0       	rjmp	.+16     	; 0x1064 <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    1054:	82 e3       	ldi	r24, 0x32	; 50
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	9b 8f       	std	Y+27, r25	; 0x1b
    105a:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    105c:	8e e1       	ldi	r24, 0x1E	; 30
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	9d 8f       	std	Y+29, r25	; 0x1d
    1062:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1064:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    1068:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    106c:	00 97       	sbiw	r24, 0x00	; 0
    106e:	31 f0       	breq	.+12     	; 0x107c <state_handler+0x34>
	{
		fault_timeout -- ;
    1070:	01 97       	sbiw	r24, 0x01	; 1
    1072:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    1076:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    107a:	05 c0       	rjmp	.+10     	; 0x1086 <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    107c:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1080:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1082:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    1086:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1088:	82 30       	cpi	r24, 0x02	; 2
    108a:	09 f4       	brne	.+2      	; 0x108e <state_handler+0x46>
    108c:	b7 c0       	rjmp	.+366    	; 0x11fc <__stack+0xfd>
    108e:	30 f4       	brcc	.+12     	; 0x109c <state_handler+0x54>
    1090:	88 23       	and	r24, r24
    1092:	61 f0       	breq	.+24     	; 0x10ac <state_handler+0x64>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	09 f4       	brne	.+2      	; 0x109a <state_handler+0x52>
    1098:	8f c0       	rjmp	.+286    	; 0x11b8 <__stack+0xb9>
    109a:	e1 c0       	rjmp	.+450    	; 0x125e <__stack+0x15f>
    109c:	84 30       	cpi	r24, 0x04	; 4
    109e:	09 f4       	brne	.+2      	; 0x10a2 <state_handler+0x5a>
    10a0:	cf c0       	rjmp	.+414    	; 0x1240 <__stack+0x141>
    10a2:	a0 f0       	brcs	.+40     	; 0x10cc <state_handler+0x84>
    10a4:	85 30       	cpi	r24, 0x05	; 5
    10a6:	09 f4       	brne	.+2      	; 0x10aa <state_handler+0x62>
    10a8:	51 c0       	rjmp	.+162    	; 0x114c <__stack+0x4d>
    10aa:	d9 c0       	rjmp	.+434    	; 0x125e <__stack+0x15f>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    10ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10b0:	89 2b       	or	r24, r25
    10b2:	11 f0       	breq	.+4      	; 0x10b8 <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    10b4:	83 e0       	ldi	r24, 0x03	; 3
    10b6:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	f7 da       	rcall	.-2578   	; 0x6aa <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    10bc:	18 a2       	std	Y+32, r1	; 0x20
    10be:	82 d9       	rcall	.-3324   	; 0x3c4 <reset_I>
			vals->u8_brake_cmd = 0;
    10c0:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    10c2:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    10c4:	82 e3       	ldi	r24, 0x32	; 50
    10c6:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    10c8:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    10ca:	c9 c0       	rjmp	.+402    	; 0x125e <__stack+0x15f>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    10cc:	8a a1       	ldd	r24, Y+34	; 0x22
    10ce:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    10d0:	24 c0       	rjmp	.+72     	; 0x111a <__stack+0x1b>
    10d2:	eb da       	rcall	.-2602   	; 0x6aa <drivers>
				reset_I();
    10d4:	77 d9       	rcall	.-3346   	; 0x3c4 <reset_I>
    10d6:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    10d8:	89 8f       	std	Y+25, r24	; 0x19
    10da:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    10dc:	88 23       	and	r24, r24
    10de:	69 f0       	breq	.+26     	; 0x10fa <state_handler+0xb2>
    10e0:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    10e2:	3b 85       	ldd	r19, Y+11	; 0x0b
    10e4:	4c 85       	ldd	r20, Y+12	; 0x0c
    10e6:	5d 85       	ldd	r21, Y+13	; 0x0d
    10e8:	8b 89       	ldd	r24, Y+19	; 0x13
    10ea:	9c 89       	ldd	r25, Y+20	; 0x14
    10ec:	62 e0       	ldi	r22, 0x02	; 2
    10ee:	50 df       	rcall	.-352    	; 0xf90 <compute_synch_duty>
    10f0:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    10f2:	89 8d       	ldd	r24, Y+25	; 0x19
    10f4:	70 d9       	rcall	.-3360   	; 0x3d6 <set_I>
    10f6:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    10f8:	8e 8f       	std	Y+30, r24	; 0x1e
    10fa:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    10fc:	88 23       	and	r24, r24
    10fe:	69 f0       	breq	.+26     	; 0x111a <__stack+0x1b>
    1100:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    1102:	3b 85       	ldd	r19, Y+11	; 0x0b
    1104:	4c 85       	ldd	r20, Y+12	; 0x0c
    1106:	5d 85       	ldd	r21, Y+13	; 0x0d
    1108:	8b 89       	ldd	r24, Y+19	; 0x13
    110a:	9c 89       	ldd	r25, Y+20	; 0x14
    110c:	62 e0       	ldi	r22, 0x02	; 2
    110e:	40 df       	rcall	.-384    	; 0xf90 <compute_synch_duty>
    1110:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    1112:	89 8d       	ldd	r24, Y+25	; 0x19
    1114:	60 d9       	rcall	.-3392   	; 0x3d6 <set_I>
    1116:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    1118:	8e 8f       	std	Y+30, r24	; 0x1e
    111a:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    111c:	81 30       	cpi	r24, 0x01	; 1
    111e:	09 f0       	breq	.+2      	; 0x1122 <__stack+0x23>
    1120:	9e c0       	rjmp	.+316    	; 0x125e <__stack+0x15f>
    1122:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    1124:	81 11       	cpse	r24, r1
    1126:	03 c0       	rjmp	.+6      	; 0x112e <__stack+0x2f>
    1128:	88 8d       	ldd	r24, Y+24	; 0x18
    112a:	88 23       	and	r24, r24
    112c:	41 f0       	breq	.+16     	; 0x113e <__stack+0x3f>
    112e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1130:	81 11       	cpse	r24, r1
    1132:	05 c0       	rjmp	.+10     	; 0x113e <__stack+0x3f>
				{
					vals->motor_status = ENGAGE;
    1134:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    1136:	8e 8f       	std	Y+30, r24	; 0x1e
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    113e:	80 e0       	ldi	r24, 0x00	; 0
    1140:	b4 da       	rcall	.-2712   	; 0x6aa <drivers>
				vals->gear_required = NEUTRAL ;
    1142:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    1144:	3f d9       	rcall	.-3458   	; 0x3c4 <reset_I>
    1146:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1148:	89 8f       	std	Y+25, r24	; 0x19
    114a:	89 c0       	rjmp	.+274    	; 0x125e <__stack+0x15f>
    114c:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    114e:	8b af       	std	Y+59, r24	; 0x3b
    1150:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    1154:	88 23       	and	r24, r24
    1156:	69 f0       	breq	.+26     	; 0x1172 <__stack+0x73>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    1158:	2a 85       	ldd	r18, Y+10	; 0x0a
    115a:	3b 85       	ldd	r19, Y+11	; 0x0b
    115c:	4c 85       	ldd	r20, Y+12	; 0x0c
    115e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1160:	6b ad       	ldd	r22, Y+59	; 0x3b
    1162:	8b 89       	ldd	r24, Y+19	; 0x13
    1164:	9c 89       	ldd	r25, Y+20	; 0x14
    1166:	14 df       	rcall	.-472    	; 0xf90 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    1168:	89 8f       	std	Y+25, r24	; 0x19
    116a:	89 8d       	ldd	r24, Y+25	; 0x19
    116c:	34 d9       	rcall	.-3480   	; 0x3d6 <set_I>
				starting_engage = 0;
    116e:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    1176:	ce 01       	movw	r24, r28
    1178:	49 d9       	rcall	.-3438   	; 0x40c <controller>
    117a:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    117c:	96 da       	rcall	.-2772   	; 0x6aa <drivers>
    117e:	88 8d       	ldd	r24, Y+24	; 0x18
    1180:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1182:	29 f0       	breq	.+10     	; 0x118e <__stack+0x8f>
    1184:	8a ad       	ldd	r24, Y+58	; 0x3a
    1186:	81 30       	cpi	r24, 0x01	; 1
    1188:	11 f4       	brne	.+4      	; 0x118e <__stack+0x8f>
    118a:	82 e0       	ldi	r24, 0x02	; 2
    118c:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    118e:	8f 89       	ldd	r24, Y+23	; 0x17
    1190:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1192:	21 f0       	breq	.+8      	; 0x119c <__stack+0x9d>
    1194:	8a ad       	ldd	r24, Y+58	; 0x3a
    1196:	81 30       	cpi	r24, 0x01	; 1
    1198:	09 f4       	brne	.+2      	; 0x119c <__stack+0x9d>
    119a:	8e 8f       	std	Y+30, r24	; 0x1e
    119c:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    119e:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    11a0:	5e c0       	rjmp	.+188    	; 0x125e <__stack+0x15f>
    11a2:	88 8d       	ldd	r24, Y+24	; 0x18
    11a4:	81 11       	cpse	r24, r1
    11a6:	5b c0       	rjmp	.+182    	; 0x125e <__stack+0x15f>
    11a8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11aa:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11ac:	89 2b       	or	r24, r25
    11ae:	09 f0       	breq	.+2      	; 0x11b2 <__stack+0xb3>
    11b0:	56 c0       	rjmp	.+172    	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = IDLE;
    11b2:	83 e0       	ldi	r24, 0x03	; 3
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
    11b6:	53 c0       	rjmp	.+166    	; 0x125e <__stack+0x15f>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    11b8:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    11ba:	ce 01       	movw	r24, r28
    11bc:	27 d9       	rcall	.-3506   	; 0x40c <controller>
    11be:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    11c0:	74 da       	rcall	.-2840   	; 0x6aa <drivers>
    11c2:	8f 89       	ldd	r24, Y+23	; 0x17
    11c4:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    11c6:	06 c0       	rjmp	.+12     	; 0x11d4 <__stack+0xd5>
    11c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    11cc:	89 2b       	or	r24, r25
    11ce:	11 f4       	brne	.+4      	; 0x11d4 <__stack+0xd5>
    11d0:	83 e0       	ldi	r24, 0x03	; 3
    11d2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    11d4:	8a a1       	ldd	r24, Y+34	; 0x22
    11d6:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    11d8:	41 f4       	brne	.+16     	; 0x11ea <__stack+0xeb>
    11da:	8a ad       	ldd	r24, Y+58	; 0x3a
    11dc:	81 11       	cpse	r24, r1
    11de:	05 c0       	rjmp	.+10     	; 0x11ea <__stack+0xeb>
    11e0:	85 e0       	ldi	r24, 0x05	; 5
    11e2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    11e4:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    11e6:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    11ea:	88 8d       	ldd	r24, Y+24	; 0x18
    11ec:	88 23       	and	r24, r24
    11ee:	b9 f1       	breq	.+110    	; 0x125e <__stack+0x15f>
    11f0:	8f 89       	ldd	r24, Y+23	; 0x17
    11f2:	81 11       	cpse	r24, r1
    11f4:	34 c0       	rjmp	.+104    	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = BRAKE;
    11f6:	82 e0       	ldi	r24, 0x02	; 2
    11f8:	8e 8f       	std	Y+30, r24	; 0x1e
    11fa:	31 c0       	rjmp	.+98     	; 0x125e <__stack+0x15f>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    11fc:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    11fe:	ce 01       	movw	r24, r28
    1200:	05 d9       	rcall	.-3574   	; 0x40c <controller>
    1202:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1204:	52 da       	rcall	.-2908   	; 0x6aa <drivers>
    1206:	88 8d       	ldd	r24, Y+24	; 0x18
    1208:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    120a:	06 c0       	rjmp	.+12     	; 0x1218 <__stack+0x119>
    120c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    120e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1210:	89 2b       	or	r24, r25
    1212:	11 f4       	brne	.+4      	; 0x1218 <__stack+0x119>
    1214:	83 e0       	ldi	r24, 0x03	; 3
    1216:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1218:	8a a1       	ldd	r24, Y+34	; 0x22
    121a:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    121c:	41 f4       	brne	.+16     	; 0x122e <__stack+0x12f>
    121e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1220:	81 11       	cpse	r24, r1
    1222:	05 c0       	rjmp	.+10     	; 0x122e <__stack+0x12f>
    1224:	85 e0       	ldi	r24, 0x05	; 5
    1226:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    122e:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    1230:	81 11       	cpse	r24, r1
    1232:	15 c0       	rjmp	.+42     	; 0x125e <__stack+0x15f>
    1234:	8f 89       	ldd	r24, Y+23	; 0x17
    1236:	88 23       	and	r24, r24
    1238:	91 f0       	breq	.+36     	; 0x125e <__stack+0x15f>
			{
				vals->motor_status = ACCEL;
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	8e 8f       	std	Y+30, r24	; 0x1e
    123e:	0f c0       	rjmp	.+30     	; 0x125e <__stack+0x15f>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1240:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1244:	81 11       	cpse	r24, r1
    1246:	02 c0       	rjmp	.+4      	; 0x124c <__stack+0x14d>
			{
				vals->motor_status = IDLE;
    1248:	83 e0       	ldi	r24, 0x03	; 3
    124a:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	2d da       	rcall	.-2982   	; 0x6aa <drivers>
    1250:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    1252:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    1254:	b7 d8       	rcall	.-3730   	; 0x3c4 <reset_I>
			reset_I(); //reset integrator
    1256:	18 8e       	std	Y+24, r1	; 0x18
    1258:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    125a:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    125c:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    125e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1260:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1262:	49 f0       	breq	.+18     	; 0x1276 <__stack+0x177>
    1264:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1266:	81 30       	cpi	r24, 0x01	; 1
    1268:	31 f0       	breq	.+12     	; 0x1276 <__stack+0x177>
    126a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    126c:	82 30       	cpi	r24, 0x02	; 2
    126e:	19 f0       	breq	.+6      	; 0x1276 <__stack+0x177>
    1270:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1272:	85 30       	cpi	r24, 0x05	; 5
    1274:	29 f4       	brne	.+10     	; 0x1280 <__stack+0x181>
    1276:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1278:	9b 8d       	ldd	r25, Y+27	; 0x1b
    127a:	89 2b       	or	r24, r25
    127c:	09 f4       	brne	.+2      	; 0x1280 <__stack+0x181>
    127e:	1e 8e       	std	Y+30, r1	; 0x1e
    1280:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1282:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1284:	08 95       	ret

00001286 <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    128a:	8e b1       	in	r24, 0x0e	; 14
    128c:	87 7c       	andi	r24, 0xC7	; 199
    128e:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1290:	8d b1       	in	r24, 0x0d	; 13
    1292:	88 63       	ori	r24, 0x38	; 56
    1294:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    1296:	a1 e9       	ldi	r26, 0x91	; 145
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	8c 91       	ld	r24, X
    129c:	80 61       	ori	r24, 0x10	; 16
    129e:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    12a0:	8c 91       	ld	r24, X
    12a2:	87 7f       	andi	r24, 0xF7	; 247
    12a4:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    12a6:	e0 e9       	ldi	r30, 0x90	; 144
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	80 81       	ld	r24, Z
    12ac:	82 60       	ori	r24, 0x02	; 2
    12ae:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    12b0:	80 81       	ld	r24, Z
    12b2:	8e 7f       	andi	r24, 0xFE	; 254
    12b4:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    12b6:	80 81       	ld	r24, Z
    12b8:	80 68       	ori	r24, 0x80	; 128
    12ba:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    12bc:	80 81       	ld	r24, Z
    12be:	8f 7b       	andi	r24, 0xBF	; 191
    12c0:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    12c2:	80 81       	ld	r24, Z
    12c4:	80 62       	ori	r24, 0x20	; 32
    12c6:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    12c8:	80 81       	ld	r24, Z
    12ca:	8f 7e       	andi	r24, 0xEF	; 239
    12cc:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    12ce:	80 81       	ld	r24, Z
    12d0:	88 60       	ori	r24, 0x08	; 8
    12d2:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    12d4:	80 81       	ld	r24, Z
    12d6:	8b 7f       	andi	r24, 0xFB	; 251
    12d8:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    12da:	8c 91       	ld	r24, X
    12dc:	81 60       	ori	r24, 0x01	; 1
    12de:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    12e0:	8c 91       	ld	r24, X
    12e2:	89 7f       	andi	r24, 0xF9	; 249
    12e4:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    12e6:	c6 e9       	ldi	r28, 0x96	; 150
    12e8:	d0 e0       	ldi	r29, 0x00	; 0
    12ea:	85 e8       	ldi	r24, 0x85	; 133
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	99 83       	std	Y+1, r25	; 0x01
    12f0:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    12f2:	68 81       	ld	r22, Y
    12f4:	79 81       	ldd	r23, Y+1	; 0x01
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
    12fe:	20 e0       	ldi	r18, 0x00	; 0
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	40 e0       	ldi	r20, 0x00	; 0
    1304:	5f e3       	ldi	r21, 0x3F	; 63
    1306:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
    130a:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
    130e:	e8 e9       	ldi	r30, 0x98	; 152
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	71 83       	std	Z+1, r23	; 0x01
    1314:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    1316:	88 81       	ld	r24, Y
    1318:	99 81       	ldd	r25, Y+1	; 0x01
    131a:	20 81       	ld	r18, Z
    131c:	31 81       	ldd	r19, Z+1	; 0x01
    131e:	82 1b       	sub	r24, r18
    1320:	93 0b       	sbc	r25, r19
    1322:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    1326:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    132a:	68 81       	ld	r22, Y
    132c:	79 81       	ldd	r23, Y+1	; 0x01
    132e:	80 e0       	ldi	r24, 0x00	; 0
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	0e 94 04 12 	call	0x2408	; 0x2408 <__floatunsisf>
    1336:	20 e0       	ldi	r18, 0x00	; 0
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	40 e0       	ldi	r20, 0x00	; 0
    133c:	5f e3       	ldi	r21, 0x3F	; 63
    133e:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3>
    1342:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <__fixsfsi>
    1346:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    134a:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	08 95       	ret

00001354 <uart0_putc>:
    1354:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    1358:	9f 5f       	subi	r25, 0xFF	; 255
    135a:	9f 71       	andi	r25, 0x1F	; 31
    135c:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1360:	92 17       	cp	r25, r18
    1362:	e1 f3       	breq	.-8      	; 0x135c <uart0_putc+0x8>
    1364:	e9 2f       	mov	r30, r25
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	e5 5d       	subi	r30, 0xD5	; 213
    136a:	fb 4f       	sbci	r31, 0xFB	; 251
    136c:	80 83       	st	Z, r24
    136e:	2f b7       	in	r18, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    1376:	e1 ec       	ldi	r30, 0xC1	; 193
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	80 62       	ori	r24, 0x20	; 32
    137e:	80 83       	st	Z, r24
    1380:	2f bf       	out	0x3f, r18	; 63
    1382:	08 95       	ret

00001384 <uart0_flush>:
    1384:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    1388:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    138c:	98 13       	cpse	r25, r24
    138e:	fa cf       	rjmp	.-12     	; 0x1384 <uart0_flush>
    1390:	08 95       	ret

00001392 <uart1_putc>:
    1392:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    1396:	9f 5f       	subi	r25, 0xFF	; 255
    1398:	9f 71       	andi	r25, 0x1F	; 31
    139a:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    139e:	92 17       	cp	r25, r18
    13a0:	e1 f3       	breq	.-8      	; 0x139a <uart1_putc+0x8>
    13a2:	e9 2f       	mov	r30, r25
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	ea 51       	subi	r30, 0x1A	; 26
    13a8:	fc 4f       	sbci	r31, 0xFC	; 252
    13aa:	80 83       	st	Z, r24
    13ac:	2f b7       	in	r18, 0x3f	; 63
    13ae:	f8 94       	cli
    13b0:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    13b4:	e9 ec       	ldi	r30, 0xC9	; 201
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	80 81       	ld	r24, Z
    13ba:	80 62       	ori	r24, 0x20	; 32
    13bc:	80 83       	st	Z, r24
    13be:	2f bf       	out	0x3f, r18	; 63
    13c0:	08 95       	ret

000013c2 <uart_putchar>:
    13c2:	cf 93       	push	r28
    13c4:	c8 2f       	mov	r28, r24
    13c6:	fb 01       	movw	r30, r22
    13c8:	84 85       	ldd	r24, Z+12	; 0x0c
    13ca:	95 85       	ldd	r25, Z+13	; 0x0d
    13cc:	01 97       	sbiw	r24, 0x01	; 1
    13ce:	39 f0       	breq	.+14     	; 0x13de <uart_putchar+0x1c>
    13d0:	ca 30       	cpi	r28, 0x0A	; 10
    13d2:	11 f4       	brne	.+4      	; 0x13d8 <uart_putchar+0x16>
    13d4:	8d e0       	ldi	r24, 0x0D	; 13
    13d6:	be df       	rcall	.-132    	; 0x1354 <uart0_putc>
    13d8:	8c 2f       	mov	r24, r28
    13da:	bc df       	rcall	.-136    	; 0x1354 <uart0_putc>
    13dc:	06 c0       	rjmp	.+12     	; 0x13ea <uart_putchar+0x28>
    13de:	ca 30       	cpi	r28, 0x0A	; 10
    13e0:	11 f4       	brne	.+4      	; 0x13e6 <uart_putchar+0x24>
    13e2:	8d e0       	ldi	r24, 0x0D	; 13
    13e4:	d6 df       	rcall	.-84     	; 0x1392 <uart1_putc>
    13e6:	8c 2f       	mov	r24, r28
    13e8:	d4 df       	rcall	.-88     	; 0x1392 <uart1_putc>
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	cf 91       	pop	r28
    13f0:	08 95       	ret

000013f2 <uart0_getc>:
    13f2:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    13f6:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    13fa:	89 17       	cp	r24, r25
    13fc:	59 f0       	breq	.+22     	; 0x1414 <uart0_getc+0x22>
    13fe:	8f 5f       	subi	r24, 0xFF	; 255
    1400:	98 2f       	mov	r25, r24
    1402:	9f 71       	andi	r25, 0x1F	; 31
    1404:	e9 2f       	mov	r30, r25
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	ed 53       	subi	r30, 0x3D	; 61
    140a:	fc 4f       	sbci	r31, 0xFC	; 252
    140c:	80 81       	ld	r24, Z
    140e:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    1412:	08 95       	ret
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	08 95       	ret

00001418 <uart0_getln>:
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	ec 01       	movw	r28, r24
    1422:	61 30       	cpi	r22, 0x01	; 1
    1424:	b1 f0       	breq	.+44     	; 0x1452 <uart0_getln+0x3a>
    1426:	62 50       	subi	r22, 0x02	; 2
    1428:	06 2f       	mov	r16, r22
    142a:	10 e0       	ldi	r17, 0x00	; 0
    142c:	0f 5f       	subi	r16, 0xFF	; 255
    142e:	1f 4f       	sbci	r17, 0xFF	; 255
    1430:	08 0f       	add	r16, r24
    1432:	19 1f       	adc	r17, r25
    1434:	de df       	rcall	.-68     	; 0x13f2 <uart0_getc>
    1436:	88 83       	st	Y, r24
    1438:	88 23       	and	r24, r24
    143a:	e1 f3       	breq	.-8      	; 0x1434 <uart0_getln+0x1c>
    143c:	8d 30       	cpi	r24, 0x0D	; 13
    143e:	21 f4       	brne	.+8      	; 0x1448 <uart0_getln+0x30>
    1440:	d8 df       	rcall	.-80     	; 0x13f2 <uart0_getc>
    1442:	88 23       	and	r24, r24
    1444:	e9 f3       	breq	.-6      	; 0x1440 <uart0_getln+0x28>
    1446:	05 c0       	rjmp	.+10     	; 0x1452 <uart0_getln+0x3a>
    1448:	21 96       	adiw	r28, 0x01	; 1
    144a:	c0 17       	cp	r28, r16
    144c:	d1 07       	cpc	r29, r17
    144e:	91 f7       	brne	.-28     	; 0x1434 <uart0_getln+0x1c>
    1450:	e8 01       	movw	r28, r16
    1452:	18 82       	st	Y, r1
    1454:	df 91       	pop	r29
    1456:	cf 91       	pop	r28
    1458:	1f 91       	pop	r17
    145a:	0f 91       	pop	r16
    145c:	08 95       	ret

0000145e <uart0_getData>:
    145e:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1462:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    1466:	89 17       	cp	r24, r25
    1468:	61 f0       	breq	.+24     	; 0x1482 <uart0_getData+0x24>
    146a:	8f 5f       	subi	r24, 0xFF	; 255
    146c:	8f 71       	andi	r24, 0x1F	; 31
    146e:	e8 2f       	mov	r30, r24
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	ed 53       	subi	r30, 0x3D	; 61
    1474:	fc 4f       	sbci	r31, 0xFC	; 252
    1476:	90 81       	ld	r25, Z
    1478:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    147c:	89 2f       	mov	r24, r25
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	08 95       	ret
    1482:	8f ef       	ldi	r24, 0xFF	; 255
    1484:	9f ef       	ldi	r25, 0xFF	; 255
    1486:	08 95       	ret

00001488 <uart1_getData>:
    1488:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    148c:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1490:	89 17       	cp	r24, r25
    1492:	61 f0       	breq	.+24     	; 0x14ac <uart1_getData+0x24>
    1494:	8f 5f       	subi	r24, 0xFF	; 255
    1496:	8f 71       	andi	r24, 0x1F	; 31
    1498:	e8 2f       	mov	r30, r24
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	e9 5f       	subi	r30, 0xF9	; 249
    149e:	fb 4f       	sbci	r31, 0xFB	; 251
    14a0:	90 81       	ld	r25, Z
    14a2:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    14a6:	89 2f       	mov	r24, r25
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	08 95       	ret
    14ac:	8f ef       	ldi	r24, 0xFF	; 255
    14ae:	9f ef       	ldi	r25, 0xFF	; 255
    14b0:	08 95       	ret

000014b2 <uart_getchar>:
    14b2:	cf 93       	push	r28
    14b4:	df 93       	push	r29
    14b6:	fc 01       	movw	r30, r24
    14b8:	84 85       	ldd	r24, Z+12	; 0x0c
    14ba:	95 85       	ldd	r25, Z+13	; 0x0d
    14bc:	01 97       	sbiw	r24, 0x01	; 1
    14be:	41 f0       	breq	.+16     	; 0x14d0 <uart_getchar+0x1e>
    14c0:	ce df       	rcall	.-100    	; 0x145e <uart0_getData>
    14c2:	ec 01       	movw	r28, r24
    14c4:	99 23       	and	r25, r25
    14c6:	e4 f3       	brlt	.-8      	; 0x14c0 <uart_getchar+0xe>
    14c8:	45 df       	rcall	.-374    	; 0x1354 <uart0_putc>
    14ca:	ce 01       	movw	r24, r28
    14cc:	99 27       	eor	r25, r25
    14ce:	07 c0       	rjmp	.+14     	; 0x14de <uart_getchar+0x2c>
    14d0:	db df       	rcall	.-74     	; 0x1488 <uart1_getData>
    14d2:	ec 01       	movw	r28, r24
    14d4:	99 23       	and	r25, r25
    14d6:	e4 f3       	brlt	.-8      	; 0x14d0 <uart_getchar+0x1e>
    14d8:	5c df       	rcall	.-328    	; 0x1392 <uart1_putc>
    14da:	ce 01       	movw	r24, r28
    14dc:	99 27       	eor	r25, r25
    14de:	99 27       	eor	r25, r25
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	08 95       	ret

000014e6 <__vector_22>:
    14e6:	0f 93       	push	r16
    14e8:	0f b7       	in	r16, 0x3f	; 63
    14ea:	ef 93       	push	r30
    14ec:	ff 93       	push	r31
    14ee:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    14f2:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    14f6:	e3 95       	inc	r30
    14f8:	ef 71       	andi	r30, 0x1F	; 31
    14fa:	ef 13       	cpse	r30, r31
    14fc:	05 c0       	rjmp	.+10     	; 0x1508 <USART0_TX_CONTINUE>
    14fe:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1502:	ff 7d       	andi	r31, 0xDF	; 223
    1504:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

00001508 <USART0_TX_CONTINUE>:
    1508:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	e5 5d       	subi	r30, 0xD5	; 213
    1510:	fb 4f       	sbci	r31, 0xFB	; 251
    1512:	e0 81       	ld	r30, Z
    1514:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

00001518 <USART0_TX_EXIT>:
    1518:	ff 91       	pop	r31
    151a:	ef 91       	pop	r30
    151c:	0f bf       	out	0x3f, r16	; 63
    151e:	0f 91       	pop	r16
    1520:	18 95       	reti

00001522 <__vector_21>:
    1522:	0f 93       	push	r16
    1524:	0f b7       	in	r16, 0x3f	; 63
    1526:	9f 93       	push	r25
    1528:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    152c:	ef 93       	push	r30
    152e:	ff 93       	push	r31
    1530:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    1534:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    1538:	e3 95       	inc	r30
    153a:	ef 71       	andi	r30, 0x1F	; 31
    153c:	fe 17       	cp	r31, r30
    153e:	31 f0       	breq	.+12     	; 0x154c <USART0_RX_EXIT>
    1540:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	ed 53       	subi	r30, 0x3D	; 61
    1548:	fc 4f       	sbci	r31, 0xFC	; 252
    154a:	90 83       	st	Z, r25

0000154c <USART0_RX_EXIT>:
    154c:	ff 91       	pop	r31
    154e:	ef 91       	pop	r30
    1550:	9f 91       	pop	r25
    1552:	0f bf       	out	0x3f, r16	; 63
    1554:	0f 91       	pop	r16
    1556:	18 95       	reti

00001558 <__vector_33>:
    1558:	0f 93       	push	r16
    155a:	0f b7       	in	r16, 0x3f	; 63
    155c:	ef 93       	push	r30
    155e:	ff 93       	push	r31
    1560:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1564:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    1568:	e3 95       	inc	r30
    156a:	ef 71       	andi	r30, 0x1F	; 31
    156c:	ef 13       	cpse	r30, r31
    156e:	05 c0       	rjmp	.+10     	; 0x157a <USART1_TX_CONTINUE>
    1570:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1574:	ff 7d       	andi	r31, 0xDF	; 223
    1576:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

0000157a <USART1_TX_CONTINUE>:
    157a:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    157e:	f0 e0       	ldi	r31, 0x00	; 0
    1580:	ea 51       	subi	r30, 0x1A	; 26
    1582:	fc 4f       	sbci	r31, 0xFC	; 252
    1584:	e0 81       	ld	r30, Z
    1586:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

0000158a <USART1_TX_EXIT>:
    158a:	ff 91       	pop	r31
    158c:	ef 91       	pop	r30
    158e:	0f bf       	out	0x3f, r16	; 63
    1590:	0f 91       	pop	r16
    1592:	18 95       	reti

00001594 <__vector_32>:
    1594:	0f 93       	push	r16
    1596:	0f b7       	in	r16, 0x3f	; 63
    1598:	9f 93       	push	r25
    159a:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    159e:	ef 93       	push	r30
    15a0:	ff 93       	push	r31
    15a2:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    15a6:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    15aa:	e3 95       	inc	r30
    15ac:	ef 71       	andi	r30, 0x1F	; 31
    15ae:	fe 17       	cp	r31, r30
    15b0:	31 f0       	breq	.+12     	; 0x15be <USART1_RX_EXIT>
    15b2:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    15b6:	f0 e0       	ldi	r31, 0x00	; 0
    15b8:	e9 5f       	subi	r30, 0xF9	; 249
    15ba:	fb 4f       	sbci	r31, 0xFB	; 251
    15bc:	90 83       	st	Z, r25

000015be <USART1_RX_EXIT>:
    15be:	ff 91       	pop	r31
    15c0:	ef 91       	pop	r30
    15c2:	9f 91       	pop	r25
    15c4:	0f bf       	out	0x3f, r16	; 63
    15c6:	0f 91       	pop	r16
    15c8:	18 95       	reti

000015ca <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    15ca:	e1 e8       	ldi	r30, 0x81	; 129
    15cc:	f0 e0       	ldi	r31, 0x00	; 0
    15ce:	80 81       	ld	r24, Z
    15d0:	83 60       	ori	r24, 0x03	; 3
    15d2:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    15d4:	80 81       	ld	r24, Z
    15d6:	88 60       	ori	r24, 0x08	; 8
    15d8:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    15da:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    15de:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    15e2:	ef e6       	ldi	r30, 0x6F	; 111
    15e4:	f0 e0       	ldi	r31, 0x00	; 0
    15e6:	80 81       	ld	r24, Z
    15e8:	82 60       	ori	r24, 0x02	; 2
    15ea:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    15ec:	8d e7       	ldi	r24, 0x7D	; 125
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    15f4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    15f8:	08 95       	ret

000015fa <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    15fa:	84 b5       	in	r24, 0x24	; 36
    15fc:	85 60       	ori	r24, 0x05	; 5
    15fe:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    1600:	84 b5       	in	r24, 0x24	; 36
    1602:	88 60       	ori	r24, 0x08	; 8
    1604:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    1606:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    1608:	ee e6       	ldi	r30, 0x6E	; 110
    160a:	f0 e0       	ldi	r31, 0x00	; 0
    160c:	80 81       	ld	r24, Z
    160e:	82 60       	ori	r24, 0x02	; 2
    1610:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    1612:	87 e2       	ldi	r24, 0x27	; 39
    1614:	87 bd       	out	0x27, r24	; 39
    1616:	08 95       	ret

00001618 <main>:
};


int main(void)	
{
	cli();
    1618:	f8 94       	cli
	rgbled_init();
    161a:	74 d5       	rcall	.+2792   	; 0x2104 <rgbled_init>
	DWC_init();
    161c:	0f d2       	rcall	.+1054   	; 0x1a3c <DWC_init>
	pwm_init();
    161e:	33 de       	rcall	.-922    	; 0x1286 <pwm_init>
    1620:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    1622:	70 e0       	ldi	r23, 0x00	; 0
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    1628:	53 d4       	rcall	.+2214   	; 0x1ed0 <can_init>
	timer0_init_ts();
    162a:	cf df       	rcall	.-98     	; 0x15ca <timer1_init_ts>
    162c:	e6 df       	rcall	.-52     	; 0x15fa <timer0_init_ts>
	speed_init();
    162e:	7f dc       	rcall	.-1794   	; 0xf2e <speed_init>
    1630:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    1632:	77 d5       	rcall	.+2798   	; 0x2122 <spi_init>
    1634:	82 e1       	ldi	r24, 0x12	; 18
    1636:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    1638:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    163c:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    1640:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1644:	88 e9       	ldi	r24, 0x98	; 152
    1646:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    164a:	eb e4       	ldi	r30, 0x4B	; 75
    164c:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    164e:	84 e0       	ldi	r24, 0x04	; 4
    1650:	91 e0       	ldi	r25, 0x01	; 1
    1652:	93 83       	std	Z+3, r25	; 0x03
    1654:	82 83       	std	Z+2, r24	; 0x02
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    1656:	91 83       	std	Z+1, r25	; 0x01
    1658:	80 83       	st	Z, r24
	drivers_init();
    165a:	25 d8       	rcall	.-4022   	; 0x6a6 <drivers_init>
    165c:	80 e0       	ldi	r24, 0x00	; 0
	drivers(0);
    165e:	25 d8       	rcall	.-4022   	; 0x6aa <drivers>
    1660:	78 94       	sei
	sei();
    1662:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    1664:	67 e9       	ldi	r22, 0x97	; 151
    1666:	73 e0       	ldi	r23, 0x03	; 3
    1668:	82 e1       	ldi	r24, 0x12	; 18
    166a:	91 e0       	ldi	r25, 0x01	; 1
    166c:	19 d9       	rcall	.-3534   	; 0x8a0 <handle_can>
    166e:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1670:	91 e0       	ldi	r25, 0x01	; 1
    1672:	f2 d9       	rcall	.-3100   	; 0xa58 <receive_uart>
    1674:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1678:	88 23       	and	r24, r24
    167a:	09 f4       	brne	.+2      	; 0x167e <main+0x66>
    167c:	41 c0       	rjmp	.+130    	; 0x1700 <main+0xe8>
    167e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1682:	88 23       	and	r24, r24
    1684:	f1 f0       	breq	.+60     	; 0x16c2 <main+0xaa>
    1686:	8d b7       	in	r24, 0x3d	; 61
    1688:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    168a:	cd 97       	sbiw	r24, 0x3d	; 61
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	9e bf       	out	0x3e, r25	; 62
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	8d bf       	out	0x3d, r24	; 61
    1696:	ad b7       	in	r26, 0x3d	; 61
    1698:	be b7       	in	r27, 0x3e	; 62
    169a:	11 96       	adiw	r26, 0x01	; 1
    169c:	8d e3       	ldi	r24, 0x3D	; 61
    169e:	e2 e1       	ldi	r30, 0x12	; 18
    16a0:	f1 e0       	ldi	r31, 0x01	; 1
    16a2:	01 90       	ld	r0, Z+
    16a4:	0d 92       	st	X+, r0
    16a6:	8a 95       	dec	r24
    16a8:	e1 f7       	brne	.-8      	; 0x16a2 <main+0x8a>
    16aa:	51 d9       	rcall	.-3422   	; 0x94e <handle_motor_status_can_msg>
    16ac:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    16b0:	8d b7       	in	r24, 0x3d	; 61
    16b2:	9e b7       	in	r25, 0x3e	; 62
    16b4:	cd 96       	adiw	r24, 0x3d	; 61
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	9e bf       	out	0x3e, r25	; 62
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	8d bf       	out	0x3d, r24	; 61
    16c0:	1d c0       	rjmp	.+58     	; 0x16fc <main+0xe4>
    16c2:	8d b7       	in	r24, 0x3d	; 61
    16c4:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    16c6:	cd 97       	sbiw	r24, 0x3d	; 61
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	9e bf       	out	0x3e, r25	; 62
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	8d bf       	out	0x3d, r24	; 61
    16d2:	ad b7       	in	r26, 0x3d	; 61
    16d4:	be b7       	in	r27, 0x3e	; 62
    16d6:	11 96       	adiw	r26, 0x01	; 1
    16d8:	8d e3       	ldi	r24, 0x3D	; 61
    16da:	e2 e1       	ldi	r30, 0x12	; 18
    16dc:	f1 e0       	ldi	r31, 0x01	; 1
    16de:	01 90       	ld	r0, Z+
    16e0:	0d 92       	st	X+, r0
    16e2:	8a 95       	dec	r24
    16e4:	e1 f7       	brne	.-8      	; 0x16de <main+0xc6>
    16e6:	a2 d9       	rcall	.-3260   	; 0xa2c <handle_clutch_cmd_can_msg>
    16e8:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    16ec:	8d b7       	in	r24, 0x3d	; 61
    16ee:	9e b7       	in	r25, 0x3e	; 62
    16f0:	cd 96       	adiw	r24, 0x3d	; 61
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	9e bf       	out	0x3e, r25	; 62
    16f8:	0f be       	out	0x3f, r0	; 63
    16fa:	8d bf       	out	0x3d, r24	; 61
    16fc:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    1700:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    1704:	88 23       	and	r24, r24
    1706:	09 f4       	brne	.+2      	; 0x170a <main+0xf2>
    1708:	ad cf       	rjmp	.-166    	; 0x1664 <main+0x4c>
    170a:	8d b7       	in	r24, 0x3d	; 61
    170c:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    170e:	cd 97       	sbiw	r24, 0x3d	; 61
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	9e bf       	out	0x3e, r25	; 62
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	8d bf       	out	0x3d, r24	; 61
    171a:	ad b7       	in	r26, 0x3d	; 61
    171c:	be b7       	in	r27, 0x3e	; 62
    171e:	11 96       	adiw	r26, 0x01	; 1
    1720:	8d e3       	ldi	r24, 0x3D	; 61
    1722:	e2 e1       	ldi	r30, 0x12	; 18
    1724:	f1 e0       	ldi	r31, 0x01	; 1
    1726:	01 90       	ld	r0, Z+
    1728:	0d 92       	st	X+, r0
    172a:	8a 95       	dec	r24
    172c:	e1 f7       	brne	.-8      	; 0x1726 <main+0x10e>
    172e:	15 db       	rcall	.-2518   	; 0xd5a <send_uart>
    1730:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    1734:	8d b7       	in	r24, 0x3d	; 61
    1736:	9e b7       	in	r25, 0x3e	; 62
    1738:	cd 96       	adiw	r24, 0x3d	; 61
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	9e bf       	out	0x3e, r25	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	8d bf       	out	0x3d, r24	; 61
    1744:	8f cf       	rjmp	.-226    	; 0x1664 <main+0x4c>

00001746 <__vector_16>:
    1746:	1f 92       	push	r1
    1748:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	0f 92       	push	r0
    174e:	11 24       	eor	r1, r1
    1750:	0b b6       	in	r0, 0x3b	; 59
    1752:	0f 92       	push	r0
    1754:	ef 92       	push	r14
    1756:	0f 93       	push	r16
    1758:	1f 93       	push	r17
    175a:	2f 93       	push	r18
    175c:	3f 93       	push	r19
    175e:	4f 93       	push	r20
    1760:	5f 93       	push	r21
    1762:	6f 93       	push	r22
    1764:	7f 93       	push	r23
    1766:	8f 93       	push	r24
    1768:	9f 93       	push	r25
    176a:	af 93       	push	r26
    176c:	bf 93       	push	r27
    176e:	ef 93       	push	r30
    1770:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1772:	82 e1       	ldi	r24, 0x12	; 18
    1774:	91 e0       	ldi	r25, 0x01	; 1
    1776:	63 d1       	rcall	.+710    	; 0x1a3e <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1778:	82 e1       	ldi	r24, 0x12	; 18
    177a:	91 e0       	ldi	r25, 0x01	; 1
    177c:	65 dc       	rcall	.-1846   	; 0x1048 <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    177e:	82 e1       	ldi	r24, 0x12	; 18
    1780:	91 e0       	ldi	r25, 0x01	; 1
    1782:	0e 94 9b 01 	call	0x336	; 0x336 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    1786:	82 e1       	ldi	r24, 0x12	; 18
    1788:	91 e0       	ldi	r25, 0x01	; 1
    178a:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    178e:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1792:	87 30       	cpi	r24, 0x07	; 7
    1794:	09 f0       	breq	.+2      	; 0x1798 <__vector_16+0x52>
    1796:	51 c0       	rjmp	.+162    	; 0x183a <__vector_16+0xf4>
	{
		b_send_can = 1;
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    179e:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    17a2:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    17a6:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    17aa:	89 2b       	or	r24, r25
    17ac:	b1 f0       	breq	.+44     	; 0x17da <__vector_16+0x94>
    17ae:	e2 e1       	ldi	r30, 0x12	; 18
    17b0:	f1 e0       	ldi	r31, 0x01	; 1
    17b2:	97 8d       	ldd	r25, Z+31	; 0x1f
    17b4:	27 8d       	ldd	r18, Z+31	; 0x1f
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	91 30       	cpi	r25, 0x01	; 1
    17ba:	09 f0       	breq	.+2      	; 0x17be <__vector_16+0x78>
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	81 11       	cpse	r24, r1
    17c0:	05 c0       	rjmp	.+10     	; 0x17cc <__vector_16+0x86>
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	21 11       	cpse	r18, r1
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	88 23       	and	r24, r24
    17ca:	39 f0       	breq	.+14     	; 0x17da <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    17cc:	e2 e1       	ldi	r30, 0x12	; 18
    17ce:	f1 e0       	ldi	r31, 0x01	; 1
    17d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    17d2:	93 8d       	ldd	r25, Z+27	; 0x1b
    17d4:	01 97       	sbiw	r24, 0x01	; 1
    17d6:	93 8f       	std	Z+27, r25	; 0x1b
    17d8:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    17da:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    17de:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    17e2:	89 2b       	or	r24, r25
    17e4:	b1 f0       	breq	.+44     	; 0x1812 <__vector_16+0xcc>
    17e6:	e2 e1       	ldi	r30, 0x12	; 18
    17e8:	f1 e0       	ldi	r31, 0x01	; 1
    17ea:	97 8d       	ldd	r25, Z+31	; 0x1f
    17ec:	27 8d       	ldd	r18, Z+31	; 0x1f
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	91 30       	cpi	r25, 0x01	; 1
    17f2:	09 f0       	breq	.+2      	; 0x17f6 <__vector_16+0xb0>
    17f4:	80 e0       	ldi	r24, 0x00	; 0
    17f6:	81 11       	cpse	r24, r1
    17f8:	05 c0       	rjmp	.+10     	; 0x1804 <__vector_16+0xbe>
    17fa:	81 e0       	ldi	r24, 0x01	; 1
    17fc:	21 11       	cpse	r18, r1
    17fe:	80 e0       	ldi	r24, 0x00	; 0
    1800:	88 23       	and	r24, r24
    1802:	39 f0       	breq	.+14     	; 0x1812 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    1804:	e2 e1       	ldi	r30, 0x12	; 18
    1806:	f1 e0       	ldi	r31, 0x01	; 1
    1808:	84 8d       	ldd	r24, Z+28	; 0x1c
    180a:	95 8d       	ldd	r25, Z+29	; 0x1d
    180c:	01 97       	sbiw	r24, 0x01	; 1
    180e:	95 8f       	std	Z+29, r25	; 0x1d
    1810:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    1812:	e2 e1       	ldi	r30, 0x12	; 18
    1814:	f1 e0       	ldi	r31, 0x01	; 1
    1816:	02 85       	ldd	r16, Z+10	; 0x0a
    1818:	13 85       	ldd	r17, Z+11	; 0x0b
    181a:	24 85       	ldd	r18, Z+12	; 0x0c
    181c:	35 85       	ldd	r19, Z+13	; 0x0d
    181e:	46 81       	ldd	r20, Z+6	; 0x06
    1820:	57 81       	ldd	r21, Z+7	; 0x07
    1822:	60 85       	ldd	r22, Z+8	; 0x08
    1824:	71 85       	ldd	r23, Z+9	; 0x09
    1826:	0f 2e       	mov	r0, r31
    1828:	f9 e2       	ldi	r31, 0x29	; 41
    182a:	ef 2e       	mov	r14, r31
    182c:	f0 2d       	mov	r31, r0
    182e:	80 e2       	ldi	r24, 0x20	; 32
    1830:	91 e0       	ldi	r25, 0x01	; 1
    1832:	ca d1       	rcall	.+916    	; 0x1bc8 <handle_joulemeter>
		systic_counter_fast = 0;
    1834:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    1838:	03 c0       	rjmp	.+6      	; 0x1840 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    183a:	8f 5f       	subi	r24, 0xFF	; 255
    183c:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1840:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    1844:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    1848:	84 36       	cpi	r24, 0x64	; 100
    184a:	91 05       	cpc	r25, r1
    184c:	01 f5       	brne	.+64     	; 0x188e <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    184e:	8d b7       	in	r24, 0x3d	; 61
    1850:	9e b7       	in	r25, 0x3e	; 62
    1852:	cd 97       	sbiw	r24, 0x3d	; 61
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	9e bf       	out	0x3e, r25	; 62
    185a:	0f be       	out	0x3f, r0	; 63
    185c:	8d bf       	out	0x3d, r24	; 61
    185e:	ad b7       	in	r26, 0x3d	; 61
    1860:	be b7       	in	r27, 0x3e	; 62
    1862:	11 96       	adiw	r26, 0x01	; 1
    1864:	8d e3       	ldi	r24, 0x3D	; 61
    1866:	e2 e1       	ldi	r30, 0x12	; 18
    1868:	f1 e0       	ldi	r31, 0x01	; 1
    186a:	01 90       	ld	r0, Z+
    186c:	0d 92       	st	X+, r0
    186e:	8a 95       	dec	r24
    1870:	e1 f7       	brne	.-8      	; 0x186a <__vector_16+0x124>
    1872:	04 db       	rcall	.-2552   	; 0xe7c <manage_LEDs>
		systic_counter_slow = 0;
    1874:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1878:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    187c:	8d b7       	in	r24, 0x3d	; 61
    187e:	9e b7       	in	r25, 0x3e	; 62
    1880:	cd 96       	adiw	r24, 0x3d	; 61
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	9e bf       	out	0x3e, r25	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	8d bf       	out	0x3d, r24	; 61
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    188e:	01 96       	adiw	r24, 0x01	; 1
    1890:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    1894:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1898:	ff 91       	pop	r31
    189a:	ef 91       	pop	r30
    189c:	bf 91       	pop	r27
    189e:	af 91       	pop	r26
    18a0:	9f 91       	pop	r25
    18a2:	8f 91       	pop	r24
    18a4:	7f 91       	pop	r23
    18a6:	6f 91       	pop	r22
    18a8:	5f 91       	pop	r21
    18aa:	4f 91       	pop	r20
    18ac:	3f 91       	pop	r19
    18ae:	2f 91       	pop	r18
    18b0:	1f 91       	pop	r17
    18b2:	0f 91       	pop	r16
    18b4:	ef 90       	pop	r14
    18b6:	0f 90       	pop	r0
    18b8:	0b be       	out	0x3b, r0	; 59
    18ba:	0f 90       	pop	r0
    18bc:	0f be       	out	0x3f, r0	; 63
    18be:	0f 90       	pop	r0
    18c0:	1f 90       	pop	r1
    18c2:	18 95       	reti

000018c4 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    18c4:	1f 92       	push	r1
    18c6:	0f 92       	push	r0
    18c8:	0f b6       	in	r0, 0x3f	; 63
    18ca:	0f 92       	push	r0
    18cc:	11 24       	eor	r1, r1
    18ce:	0b b6       	in	r0, 0x3b	; 59
    18d0:	0f 92       	push	r0
    18d2:	2f 93       	push	r18
    18d4:	3f 93       	push	r19
    18d6:	4f 93       	push	r20
    18d8:	5f 93       	push	r21
    18da:	6f 93       	push	r22
    18dc:	7f 93       	push	r23
    18de:	8f 93       	push	r24
    18e0:	9f 93       	push	r25
    18e2:	af 93       	push	r26
    18e4:	bf 93       	push	r27
    18e6:	ef 93       	push	r30
    18e8:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    18ea:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    18ee:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    18f2:	80 3d       	cpi	r24, 0xD0	; 208
    18f4:	97 40       	sbci	r25, 0x07	; 7
    18f6:	50 f4       	brcc	.+20     	; 0x190c <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    18f8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    18fc:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    1900:	01 96       	adiw	r24, 0x01	; 1
    1902:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    1906:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    190a:	08 c0       	rjmp	.+16     	; 0x191c <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    190c:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    1910:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    1914:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    1918:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    191c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1920:	87 30       	cpi	r24, 0x07	; 7
    1922:	41 f4       	brne	.+16     	; 0x1934 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    1924:	84 e1       	ldi	r24, 0x14	; 20
    1926:	91 e0       	ldi	r25, 0x01	; 1
    1928:	0e 94 2e 04 	call	0x85c	; 0x85c <SPI_handler_7>
		u8_SPI_count = 0 ;
    192c:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    1930:	80 e0       	ldi	r24, 0x00	; 0
    1932:	13 c0       	rjmp	.+38     	; 0x195a <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1934:	86 30       	cpi	r24, 0x06	; 6
    1936:	49 f4       	brne	.+18     	; 0x194a <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1938:	8d e3       	ldi	r24, 0x3D	; 61
    193a:	91 e0       	ldi	r25, 0x01	; 1
    193c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <SPI_handler_6>
		u8_SPI_count ++ ;
    1940:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1944:	8f 5f       	subi	r24, 0xFF	; 255
    1946:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    194a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    194e:	85 30       	cpi	r24, 0x05	; 5
    1950:	21 f4       	brne	.+8      	; 0x195a <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1952:	86 e0       	ldi	r24, 0x06	; 6
    1954:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1958:	13 c0       	rjmp	.+38     	; 0x1980 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    195a:	84 30       	cpi	r24, 0x04	; 4
    195c:	49 f4       	brne	.+18     	; 0x1970 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    195e:	84 e2       	ldi	r24, 0x24	; 36
    1960:	91 e0       	ldi	r25, 0x01	; 1
    1962:	0e 94 ba 03 	call	0x774	; 0x774 <SPI_handler_4>
		u8_SPI_count ++ ;
    1966:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    196a:	8f 5f       	subi	r24, 0xFF	; 255
    196c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1970:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1974:	83 30       	cpi	r24, 0x03	; 3
    1976:	21 f4       	brne	.+8      	; 0x1980 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1978:	84 e0       	ldi	r24, 0x04	; 4
    197a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    197e:	13 c0       	rjmp	.+38     	; 0x19a6 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1980:	82 30       	cpi	r24, 0x02	; 2
    1982:	21 f4       	brne	.+8      	; 0x198c <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1984:	83 e0       	ldi	r24, 0x03	; 3
    1986:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    198a:	1a c0       	rjmp	.+52     	; 0x19c0 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    198c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1990:	81 30       	cpi	r24, 0x01	; 1
    1992:	49 f4       	brne	.+18     	; 0x19a6 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1994:	88 e1       	ldi	r24, 0x18	; 24
    1996:	91 e0       	ldi	r25, 0x01	; 1
    1998:	0e 94 98 03 	call	0x730	; 0x730 <SPI_handler_1>
		u8_SPI_count ++ ;
    199c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19a0:	8f 5f       	subi	r24, 0xFF	; 255
    19a2:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    19a6:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19aa:	81 11       	cpse	r24, r1
    19ac:	09 c0       	rjmp	.+18     	; 0x19c0 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    19ae:	8c e1       	ldi	r24, 0x1C	; 28
    19b0:	91 e0       	ldi	r25, 0x01	; 1
    19b2:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <SPI_handler_0>
		u8_SPI_count ++ ;
    19b6:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19ba:	8f 5f       	subi	r24, 0xFF	; 255
    19bc:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    19c0:	ff 91       	pop	r31
    19c2:	ef 91       	pop	r30
    19c4:	bf 91       	pop	r27
    19c6:	af 91       	pop	r26
    19c8:	9f 91       	pop	r25
    19ca:	8f 91       	pop	r24
    19cc:	7f 91       	pop	r23
    19ce:	6f 91       	pop	r22
    19d0:	5f 91       	pop	r21
    19d2:	4f 91       	pop	r20
    19d4:	3f 91       	pop	r19
    19d6:	2f 91       	pop	r18
    19d8:	0f 90       	pop	r0
    19da:	0b be       	out	0x3b, r0	; 59
    19dc:	0f 90       	pop	r0
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	0f 90       	pop	r0
    19e2:	1f 90       	pop	r1
    19e4:	18 95       	reti

000019e6 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    19e6:	1f 92       	push	r1
    19e8:	0f 92       	push	r0
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	0f 92       	push	r0
    19ee:	11 24       	eor	r1, r1
    19f0:	0b b6       	in	r0, 0x3b	; 59
    19f2:	0f 92       	push	r0
    19f4:	2f 93       	push	r18
    19f6:	3f 93       	push	r19
    19f8:	4f 93       	push	r20
    19fa:	5f 93       	push	r21
    19fc:	6f 93       	push	r22
    19fe:	7f 93       	push	r23
    1a00:	8f 93       	push	r24
    1a02:	9f 93       	push	r25
    1a04:	af 93       	push	r26
    1a06:	bf 93       	push	r27
    1a08:	ef 93       	push	r30
    1a0a:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1a0c:	60 e0       	ldi	r22, 0x00	; 0
    1a0e:	72 e0       	ldi	r23, 0x02	; 2
    1a10:	85 e2       	ldi	r24, 0x25	; 37
    1a12:	91 e0       	ldi	r25, 0x01	; 1
    1a14:	97 da       	rcall	.-2770   	; 0xf44 <handle_speed_sensor>
}
    1a16:	ff 91       	pop	r31
    1a18:	ef 91       	pop	r30
    1a1a:	bf 91       	pop	r27
    1a1c:	af 91       	pop	r26
    1a1e:	9f 91       	pop	r25
    1a20:	8f 91       	pop	r24
    1a22:	7f 91       	pop	r23
    1a24:	6f 91       	pop	r22
    1a26:	5f 91       	pop	r21
    1a28:	4f 91       	pop	r20
    1a2a:	3f 91       	pop	r19
    1a2c:	2f 91       	pop	r18
    1a2e:	0f 90       	pop	r0
    1a30:	0b be       	out	0x3b, r0	; 59
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	0f 90       	pop	r0
    1a38:	1f 90       	pop	r1
    1a3a:	18 95       	reti

00001a3c <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1a3c:	08 95       	ret

00001a3e <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1a3e:	7a 99       	sbic	0x0f, 2	; 15
    1a40:	03 c0       	rjmp	.+6      	; 0x1a48 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1a42:	fc 01       	movw	r30, r24
    1a44:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1a46:	10 8e       	std	Z+24, r1	; 0x18
    1a48:	08 95       	ret

00001a4a <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1a4a:	ff 92       	push	r15
    1a4c:	0f 93       	push	r16
    1a4e:	1f 93       	push	r17
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <handle_current_sensor+0xc>
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <handle_current_sensor+0xe>
    1a58:	cd b7       	in	r28, 0x3d	; 61
    1a5a:	de b7       	in	r29, 0x3e	; 62
    1a5c:	8c 01       	movw	r16, r24
    1a5e:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	d1 d4       	rcall	.+2466   	; 0x2408 <__floatunsisf>
    1a66:	20 e0       	ldi	r18, 0x00	; 0
    1a68:	30 e0       	ldi	r19, 0x00	; 0
    1a6a:	40 ea       	ldi	r20, 0xA0	; 160
    1a6c:	50 e4       	ldi	r21, 0x40	; 64
    1a6e:	82 d5       	rcall	.+2820   	; 0x2574 <__mulsf3>
    1a70:	20 e0       	ldi	r18, 0x00	; 0
    1a72:	30 e0       	ldi	r19, 0x00	; 0
    1a74:	40 e8       	ldi	r20, 0x80	; 128
    1a76:	59 e3       	ldi	r21, 0x39	; 57
    1a78:	7d d5       	rcall	.+2810   	; 0x2574 <__mulsf3>
    1a7a:	20 e0       	ldi	r18, 0x00	; 0
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	40 e0       	ldi	r20, 0x00	; 0
    1a80:	51 e4       	ldi	r21, 0x41	; 65
    1a82:	78 d5       	rcall	.+2800   	; 0x2574 <__mulsf3>
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	40 ea       	ldi	r20, 0xA0	; 160
    1a8a:	51 e4       	ldi	r21, 0x41	; 65
    1a8c:	bb d3       	rcall	.+1910   	; 0x2204 <__subsf3>
    1a8e:	69 83       	std	Y+1, r22	; 0x01
    1a90:	7a 83       	std	Y+2, r23	; 0x02
    1a92:	8b 83       	std	Y+3, r24	; 0x03
    1a94:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1a96:	ff 20       	and	r15, r15
    1a98:	71 f0       	breq	.+28     	; 0x1ab6 <handle_current_sensor+0x6c>
	{//batt
		f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
    1a9a:	69 81       	ldd	r22, Y+1	; 0x01
    1a9c:	7a 81       	ldd	r23, Y+2	; 0x02
    1a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa2:	2a e9       	ldi	r18, 0x9A	; 154
    1aa4:	39 e9       	ldi	r19, 0x99	; 153
    1aa6:	49 e9       	ldi	r20, 0x99	; 153
    1aa8:	5e e3       	ldi	r21, 0x3E	; 62
    1aaa:	ad d3       	rcall	.+1882   	; 0x2206 <__addsf3>
    1aac:	69 83       	std	Y+1, r22	; 0x01
    1aae:	7a 83       	std	Y+2, r23	; 0x02
    1ab0:	8b 83       	std	Y+3, r24	; 0x03
    1ab2:	9c 83       	std	Y+4, r25	; 0x04
    1ab4:	0d c0       	rjmp	.+26     	; 0x1ad0 <handle_current_sensor+0x86>
	}else{
		f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
    1ab6:	69 81       	ldd	r22, Y+1	; 0x01
    1ab8:	7a 81       	ldd	r23, Y+2	; 0x02
    1aba:	8b 81       	ldd	r24, Y+3	; 0x03
    1abc:	9c 81       	ldd	r25, Y+4	; 0x04
    1abe:	2a e9       	ldi	r18, 0x9A	; 154
    1ac0:	39 e9       	ldi	r19, 0x99	; 153
    1ac2:	49 e9       	ldi	r20, 0x99	; 153
    1ac4:	5e e3       	ldi	r21, 0x3E	; 62
    1ac6:	9f d3       	rcall	.+1854   	; 0x2206 <__addsf3>
    1ac8:	69 83       	std	Y+1, r22	; 0x01
    1aca:	7a 83       	std	Y+2, r23	; 0x02
    1acc:	8b 83       	std	Y+3, r24	; 0x03
    1ace:	9c 83       	std	Y+4, r25	; 0x04
	}
	*f32_current = f_new_current;
    1ad0:	89 81       	ldd	r24, Y+1	; 0x01
    1ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad4:	ab 81       	ldd	r26, Y+3	; 0x03
    1ad6:	bc 81       	ldd	r27, Y+4	; 0x04
    1ad8:	f8 01       	movw	r30, r16
    1ada:	80 83       	st	Z, r24
    1adc:	91 83       	std	Z+1, r25	; 0x01
    1ade:	a2 83       	std	Z+2, r26	; 0x02
    1ae0:	b3 83       	std	Z+3, r27	; 0x03
	
	//*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
}
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	0f 90       	pop	r0
    1ae8:	0f 90       	pop	r0
    1aea:	df 91       	pop	r29
    1aec:	cf 91       	pop	r28
    1aee:	1f 91       	pop	r17
    1af0:	0f 91       	pop	r16
    1af2:	ff 90       	pop	r15
    1af4:	08 95       	ret

00001af6 <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1af6:	cf 92       	push	r12
    1af8:	df 92       	push	r13
    1afa:	ef 92       	push	r14
    1afc:	ff 92       	push	r15
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1b04:	80 e0       	ldi	r24, 0x00	; 0
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	7f d4       	rcall	.+2302   	; 0x2408 <__floatunsisf>
    1b0a:	20 e0       	ldi	r18, 0x00	; 0
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	40 ea       	ldi	r20, 0xA0	; 160
    1b10:	50 e4       	ldi	r21, 0x40	; 64
    1b12:	30 d5       	rcall	.+2656   	; 0x2574 <__mulsf3>
    1b14:	20 e0       	ldi	r18, 0x00	; 0
    1b16:	30 e0       	ldi	r19, 0x00	; 0
    1b18:	40 e8       	ldi	r20, 0x80	; 128
    1b1a:	59 e3       	ldi	r21, 0x39	; 57
    1b1c:	2b d5       	rcall	.+2646   	; 0x2574 <__mulsf3>
    1b1e:	6b 01       	movw	r12, r22
    1b20:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1b22:	2d ec       	ldi	r18, 0xCD	; 205
    1b24:	3c ec       	ldi	r19, 0xCC	; 204
    1b26:	4c e6       	ldi	r20, 0x6C	; 108
    1b28:	50 e4       	ldi	r21, 0x40	; 64
    1b2a:	d1 d3       	rcall	.+1954   	; 0x22ce <__cmpsf2>
    1b2c:	18 16       	cp	r1, r24
    1b2e:	74 f0       	brlt	.+28     	; 0x1b4c <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1b30:	20 e0       	ldi	r18, 0x00	; 0
    1b32:	30 e0       	ldi	r19, 0x00	; 0
    1b34:	40 ea       	ldi	r20, 0xA0	; 160
    1b36:	51 e4       	ldi	r21, 0x41	; 65
    1b38:	c7 01       	movw	r24, r14
    1b3a:	b6 01       	movw	r22, r12
    1b3c:	1b d5       	rcall	.+2614   	; 0x2574 <__mulsf3>
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	40 eb       	ldi	r20, 0xB0	; 176
    1b44:	51 e4       	ldi	r21, 0x41	; 65
    1b46:	5e d3       	rcall	.+1724   	; 0x2204 <__subsf3>
    1b48:	33 d4       	rcall	.+2150   	; 0x23b0 <__fixunssfsi>
    1b4a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1b4c:	26 e6       	ldi	r18, 0x66	; 102
    1b4e:	36 e6       	ldi	r19, 0x66	; 102
    1b50:	46 e9       	ldi	r20, 0x96	; 150
    1b52:	50 e4       	ldi	r21, 0x40	; 64
    1b54:	c7 01       	movw	r24, r14
    1b56:	b6 01       	movw	r22, r12
    1b58:	ba d3       	rcall	.+1908   	; 0x22ce <__cmpsf2>
    1b5a:	18 16       	cp	r1, r24
    1b5c:	bc f0       	brlt	.+46     	; 0x1b8c <handle_temp_sensor+0x96>
    1b5e:	2d ec       	ldi	r18, 0xCD	; 205
    1b60:	3c ec       	ldi	r19, 0xCC	; 204
    1b62:	4c e6       	ldi	r20, 0x6C	; 108
    1b64:	50 e4       	ldi	r21, 0x40	; 64
    1b66:	c7 01       	movw	r24, r14
    1b68:	b6 01       	movw	r22, r12
    1b6a:	00 d5       	rcall	.+2560   	; 0x256c <__gesf2>
    1b6c:	18 16       	cp	r1, r24
    1b6e:	74 f4       	brge	.+28     	; 0x1b8c <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1b70:	20 e0       	ldi	r18, 0x00	; 0
    1b72:	30 e0       	ldi	r19, 0x00	; 0
    1b74:	4e e5       	ldi	r20, 0x5E	; 94
    1b76:	52 e4       	ldi	r21, 0x42	; 66
    1b78:	c7 01       	movw	r24, r14
    1b7a:	b6 01       	movw	r22, r12
    1b7c:	fb d4       	rcall	.+2550   	; 0x2574 <__mulsf3>
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	30 e8       	ldi	r19, 0x80	; 128
    1b82:	4b e1       	ldi	r20, 0x1B	; 27
    1b84:	53 e4       	ldi	r21, 0x43	; 67
    1b86:	3e d3       	rcall	.+1660   	; 0x2204 <__subsf3>
    1b88:	13 d4       	rcall	.+2086   	; 0x23b0 <__fixunssfsi>
    1b8a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1b8c:	26 e6       	ldi	r18, 0x66	; 102
    1b8e:	36 e6       	ldi	r19, 0x66	; 102
    1b90:	46 e9       	ldi	r20, 0x96	; 150
    1b92:	50 e4       	ldi	r21, 0x40	; 64
    1b94:	c7 01       	movw	r24, r14
    1b96:	b6 01       	movw	r22, r12
    1b98:	e9 d4       	rcall	.+2514   	; 0x256c <__gesf2>
    1b9a:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1b9c:	74 f4       	brge	.+28     	; 0x1bba <handle_temp_sensor+0xc4>
    1b9e:	20 e0       	ldi	r18, 0x00	; 0
    1ba0:	30 e0       	ldi	r19, 0x00	; 0
    1ba2:	48 e4       	ldi	r20, 0x48	; 72
    1ba4:	53 e4       	ldi	r21, 0x43	; 67
    1ba6:	c7 01       	movw	r24, r14
    1ba8:	b6 01       	movw	r22, r12
    1baa:	e4 d4       	rcall	.+2504   	; 0x2574 <__mulsf3>
    1bac:	20 e0       	ldi	r18, 0x00	; 0
    1bae:	30 e0       	ldi	r19, 0x00	; 0
    1bb0:	42 e5       	ldi	r20, 0x52	; 82
    1bb2:	54 e4       	ldi	r21, 0x44	; 68
    1bb4:	27 d3       	rcall	.+1614   	; 0x2204 <__subsf3>
    1bb6:	fc d3       	rcall	.+2040   	; 0x23b0 <__fixunssfsi>
    1bb8:	68 83       	st	Y, r22
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
	}
}
    1bbe:	ff 90       	pop	r15
    1bc0:	ef 90       	pop	r14
    1bc2:	df 90       	pop	r13
    1bc4:	cf 90       	pop	r12
    1bc6:	08 95       	ret

00001bc8 <handle_joulemeter>:
    1bc8:	4f 92       	push	r4
    1bca:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1bcc:	6f 92       	push	r6
    1bce:	7f 92       	push	r7
    1bd0:	8f 92       	push	r8
    1bd2:	9f 92       	push	r9
    1bd4:	af 92       	push	r10
    1bd6:	bf 92       	push	r11
    1bd8:	cf 92       	push	r12
    1bda:	df 92       	push	r13
    1bdc:	ef 92       	push	r14
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	cd b7       	in	r28, 0x3d	; 61
    1be8:	de b7       	in	r29, 0x3e	; 62
    1bea:	28 97       	sbiw	r28, 0x08	; 8
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	de bf       	out	0x3e, r29	; 62
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	6c 01       	movw	r12, r24
    1bf8:	49 83       	std	Y+1, r20	; 0x01
    1bfa:	5a 83       	std	Y+2, r21	; 0x02
    1bfc:	6b 83       	std	Y+3, r22	; 0x03
    1bfe:	7c 83       	std	Y+4, r23	; 0x04
    1c00:	0d 83       	std	Y+5, r16	; 0x05
    1c02:	1e 83       	std	Y+6, r17	; 0x06
    1c04:	2f 83       	std	Y+7, r18	; 0x07
    1c06:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1c08:	6d 81       	ldd	r22, Y+5	; 0x05
    1c0a:	7e 81       	ldd	r23, Y+6	; 0x06
    1c0c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c0e:	98 85       	ldd	r25, Y+8	; 0x08
    1c10:	29 81       	ldd	r18, Y+1	; 0x01
    1c12:	3a 81       	ldd	r19, Y+2	; 0x02
    1c14:	4b 81       	ldd	r20, Y+3	; 0x03
    1c16:	5c 81       	ldd	r21, Y+4	; 0x04
    1c18:	f6 01       	movw	r30, r12
    1c1a:	80 80       	ld	r8, Z
    1c1c:	91 80       	ldd	r9, Z+1	; 0x01
    1c1e:	a2 80       	ldd	r10, Z+2	; 0x02
    1c20:	b3 80       	ldd	r11, Z+3	; 0x03
    1c22:	a8 d4       	rcall	.+2384   	; 0x2574 <__mulsf3>
    1c24:	2b 01       	movw	r4, r22
    1c26:	3c 01       	movw	r6, r24
    1c28:	6e 2d       	mov	r22, r14
    1c2a:	70 e0       	ldi	r23, 0x00	; 0
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	eb d3       	rcall	.+2006   	; 0x2408 <__floatunsisf>
    1c32:	9b 01       	movw	r18, r22
    1c34:	ac 01       	movw	r20, r24
    1c36:	c3 01       	movw	r24, r6
    1c38:	b2 01       	movw	r22, r4
    1c3a:	9c d4       	rcall	.+2360   	; 0x2574 <__mulsf3>
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	4a e7       	ldi	r20, 0x7A	; 122
    1c42:	54 e4       	ldi	r21, 0x44	; 68
    1c44:	48 d3       	rcall	.+1680   	; 0x22d6 <__divsf3>
    1c46:	a5 01       	movw	r20, r10
    1c48:	94 01       	movw	r18, r8
    1c4a:	dd d2       	rcall	.+1466   	; 0x2206 <__addsf3>
    1c4c:	f6 01       	movw	r30, r12
    1c4e:	60 83       	st	Z, r22
    1c50:	71 83       	std	Z+1, r23	; 0x01
    1c52:	82 83       	std	Z+2, r24	; 0x02
    1c54:	93 83       	std	Z+3, r25	; 0x03
}
    1c56:	28 96       	adiw	r28, 0x08	; 8
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	de bf       	out	0x3e, r29	; 62
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	cd bf       	out	0x3d, r28	; 61
    1c62:	df 91       	pop	r29
    1c64:	cf 91       	pop	r28
    1c66:	1f 91       	pop	r17
    1c68:	0f 91       	pop	r16
    1c6a:	ef 90       	pop	r14
    1c6c:	df 90       	pop	r13
    1c6e:	cf 90       	pop	r12
    1c70:	bf 90       	pop	r11
    1c72:	af 90       	pop	r10
    1c74:	9f 90       	pop	r9
    1c76:	8f 90       	pop	r8
    1c78:	7f 90       	pop	r7
    1c7a:	6f 90       	pop	r6
    1c7c:	5f 90       	pop	r5
    1c7e:	4f 90       	pop	r4
    1c80:	08 95       	ret

00001c82 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	88 30       	cpi	r24, 0x08	; 8
    1c86:	91 05       	cpc	r25, r1
    1c88:	88 f5       	brcc	.+98     	; 0x1cec <Set_ADC_Channel_ext+0x6a>
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	e6 5b       	subi	r30, 0xB6	; 182
    1c8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c90:	d4 c4       	rjmp	.+2472   	; 0x263a <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1c92:	86 e0       	ldi	r24, 0x06	; 6
    1c94:	fb 01       	movw	r30, r22
    1c96:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1c98:	11 82       	std	Z+1, r1	; 0x01
		break;
    1c9a:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1c9c:	86 e0       	ldi	r24, 0x06	; 6
    1c9e:	fb 01       	movw	r30, r22
    1ca0:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1ca2:	80 e4       	ldi	r24, 0x40	; 64
    1ca4:	81 83       	std	Z+1, r24	; 0x01
		break;
    1ca6:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1ca8:	86 e0       	ldi	r24, 0x06	; 6
    1caa:	fb 01       	movw	r30, r22
    1cac:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1cae:	80 e8       	ldi	r24, 0x80	; 128
    1cb0:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cb2:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1cb4:	86 e0       	ldi	r24, 0x06	; 6
    1cb6:	fb 01       	movw	r30, r22
    1cb8:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1cba:	80 ec       	ldi	r24, 0xC0	; 192
    1cbc:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cbe:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1cc0:	87 e0       	ldi	r24, 0x07	; 7
    1cc2:	fb 01       	movw	r30, r22
    1cc4:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1cc6:	11 82       	std	Z+1, r1	; 0x01
		break;
    1cc8:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1cca:	87 e0       	ldi	r24, 0x07	; 7
    1ccc:	fb 01       	movw	r30, r22
    1cce:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1cd0:	80 e4       	ldi	r24, 0x40	; 64
    1cd2:	81 83       	std	Z+1, r24	; 0x01
		break;
    1cd4:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1cd6:	87 e0       	ldi	r24, 0x07	; 7
    1cd8:	fb 01       	movw	r30, r22
    1cda:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1cdc:	80 e8       	ldi	r24, 0x80	; 128
    1cde:	81 83       	std	Z+1, r24	; 0x01
		break;
    1ce0:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1ce2:	87 e0       	ldi	r24, 0x07	; 7
    1ce4:	fb 01       	movw	r30, r22
    1ce6:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1ce8:	80 ec       	ldi	r24, 0xC0	; 192
    1cea:	81 83       	std	Z+1, r24	; 0x01
    1cec:	08 95       	ret

00001cee <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1cee:	1f 92       	push	r1
    1cf0:	0f 92       	push	r0
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	0f 92       	push	r0
    1cf6:	11 24       	eor	r1, r1
    1cf8:	0b b6       	in	r0, 0x3b	; 59
    1cfa:	0f 92       	push	r0
    1cfc:	2f 93       	push	r18
    1cfe:	3f 93       	push	r19
    1d00:	4f 93       	push	r20
    1d02:	5f 93       	push	r21
    1d04:	6f 93       	push	r22
    1d06:	8f 93       	push	r24
    1d08:	9f 93       	push	r25
    1d0a:	af 93       	push	r26
    1d0c:	bf 93       	push	r27
    1d0e:	ef 93       	push	r30
    1d10:	ff 93       	push	r31
    1d12:	cf 93       	push	r28
    1d14:	df 93       	push	r29
    1d16:	1f 92       	push	r1
    1d18:	cd b7       	in	r28, 0x3d	; 61
    1d1a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1d1c:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1d20:	80 ff       	sbrs	r24, 0
    1d22:	47 c0       	rjmp	.+142    	; 0x1db2 <__vector_18+0xc4>
    1d24:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1d28:	90 ff       	sbrs	r25, 0
    1d2a:	43 c0       	rjmp	.+134    	; 0x1db2 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1d2c:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1d30:	ee ee       	ldi	r30, 0xEE	; 238
    1d32:	f0 e0       	ldi	r31, 0x00	; 0
    1d34:	80 81       	ld	r24, Z
    1d36:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1d38:	80 81       	ld	r24, Z
    1d3a:	8f 7b       	andi	r24, 0xBF	; 191
    1d3c:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1d3e:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1d42:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1d46:	98 17       	cp	r25, r24
    1d48:	89 f1       	breq	.+98     	; 0x1dac <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1d4a:	8f 70       	andi	r24, 0x0F	; 15
    1d4c:	2b e0       	ldi	r18, 0x0B	; 11
    1d4e:	82 9f       	mul	r24, r18
    1d50:	c0 01       	movw	r24, r0
    1d52:	11 24       	eor	r1, r1
    1d54:	fc 01       	movw	r30, r24
    1d56:	e1 54       	subi	r30, 0x41	; 65
    1d58:	fd 4f       	sbci	r31, 0xFD	; 253
    1d5a:	20 81       	ld	r18, Z
    1d5c:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1d60:	20 81       	ld	r18, Z
    1d62:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1d66:	21 81       	ldd	r18, Z+1	; 0x01
    1d68:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1d6c:	23 81       	ldd	r18, Z+3	; 0x03
    1d6e:	aa ef       	ldi	r26, 0xFA	; 250
    1d70:	b0 e0       	ldi	r27, 0x00	; 0
    1d72:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1d74:	24 81       	ldd	r18, Z+4	; 0x04
    1d76:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1d78:	25 81       	ldd	r18, Z+5	; 0x05
    1d7a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1d7c:	26 81       	ldd	r18, Z+6	; 0x06
    1d7e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1d80:	27 81       	ldd	r18, Z+7	; 0x07
    1d82:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1d84:	20 85       	ldd	r18, Z+8	; 0x08
    1d86:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1d88:	21 85       	ldd	r18, Z+9	; 0x09
    1d8a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1d8c:	22 85       	ldd	r18, Z+10	; 0x0a
    1d8e:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1d90:	fc 01       	movw	r30, r24
    1d92:	ef 53       	subi	r30, 0x3F	; 63
    1d94:	fd 4f       	sbci	r31, 0xFD	; 253
    1d96:	80 81       	ld	r24, Z
    1d98:	8f 70       	andi	r24, 0x0F	; 15
    1d9a:	80 64       	ori	r24, 0x40	; 64
    1d9c:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1da0:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1daa:	7d c0       	rjmp	.+250    	; 0x1ea6 <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1dac:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1db0:	7a c0       	rjmp	.+244    	; 0x1ea6 <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1db2:	81 ff       	sbrs	r24, 1
    1db4:	78 c0       	rjmp	.+240    	; 0x1ea6 <__vector_18+0x1b8>
    1db6:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1dba:	81 ff       	sbrs	r24, 1
    1dbc:	74 c0       	rjmp	.+232    	; 0x1ea6 <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1dbe:	80 e1       	ldi	r24, 0x10	; 16
    1dc0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1dc4:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1dc8:	28 2f       	mov	r18, r24
    1dca:	30 e0       	ldi	r19, 0x00	; 0
    1dcc:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1dd0:	29 1b       	sub	r18, r25
    1dd2:	31 09       	sbc	r19, r1
    1dd4:	2f 77       	andi	r18, 0x7F	; 127
    1dd6:	33 27       	eor	r19, r19
    1dd8:	20 31       	cpi	r18, 0x10	; 16
    1dda:	31 05       	cpc	r19, r1
    1ddc:	0c f0       	brlt	.+2      	; 0x1de0 <__vector_18+0xf2>
    1dde:	58 c0       	rjmp	.+176    	; 0x1e90 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1de0:	e8 2f       	mov	r30, r24
    1de2:	ef 70       	andi	r30, 0x0F	; 15
    1de4:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1de8:	2e 2f       	mov	r18, r30
    1dea:	30 e0       	ldi	r19, 0x00	; 0
    1dec:	4b e0       	ldi	r20, 0x0B	; 11
    1dee:	e4 9f       	mul	r30, r20
    1df0:	f0 01       	movw	r30, r0
    1df2:	11 24       	eor	r1, r1
    1df4:	e1 5f       	subi	r30, 0xF1	; 241
    1df6:	fd 4f       	sbci	r31, 0xFD	; 253
    1df8:	9f 70       	andi	r25, 0x0F	; 15
    1dfa:	42 81       	ldd	r20, Z+2	; 0x02
    1dfc:	40 7f       	andi	r20, 0xF0	; 240
    1dfe:	94 2b       	or	r25, r20
    1e00:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1e02:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1e06:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1e0a:	40 7e       	andi	r20, 0xE0	; 224
    1e0c:	97 70       	andi	r25, 0x07	; 7
    1e0e:	94 2b       	or	r25, r20
    1e10:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1e12:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1e16:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1e18:	aa ef       	ldi	r26, 0xFA	; 250
    1e1a:	b0 e0       	ldi	r27, 0x00	; 0
    1e1c:	9c 91       	ld	r25, X
    1e1e:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1e20:	9c 91       	ld	r25, X
    1e22:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1e24:	9c 91       	ld	r25, X
    1e26:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1e28:	9c 91       	ld	r25, X
    1e2a:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1e2c:	9c 91       	ld	r25, X
    1e2e:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1e30:	9c 91       	ld	r25, X
    1e32:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1e34:	9c 91       	ld	r25, X
    1e36:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1e38:	9c 91       	ld	r25, X
    1e3a:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1e3c:	8f 5f       	subi	r24, 0xFF	; 255
    1e3e:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1e42:	40 81       	ld	r20, Z
    1e44:	42 95       	swap	r20
    1e46:	46 95       	lsr	r20
    1e48:	47 70       	andi	r20, 0x07	; 7
    1e4a:	51 81       	ldd	r21, Z+1	; 0x01
    1e4c:	65 2f       	mov	r22, r21
    1e4e:	66 0f       	add	r22, r22
    1e50:	66 0f       	add	r22, r22
    1e52:	66 0f       	add	r22, r22
    1e54:	86 2f       	mov	r24, r22
    1e56:	84 2b       	or	r24, r20
    1e58:	95 2f       	mov	r25, r21
    1e5a:	92 95       	swap	r25
    1e5c:	96 95       	lsr	r25
    1e5e:	97 70       	andi	r25, 0x07	; 7
    1e60:	89 2b       	or	r24, r25
    1e62:	b1 f4       	brne	.+44     	; 0x1e90 <__vector_18+0x1a2>
    1e64:	8b e0       	ldi	r24, 0x0B	; 11
    1e66:	82 9f       	mul	r24, r18
    1e68:	f0 01       	movw	r30, r0
    1e6a:	83 9f       	mul	r24, r19
    1e6c:	f0 0d       	add	r31, r0
    1e6e:	11 24       	eor	r1, r1
    1e70:	e1 5f       	subi	r30, 0xF1	; 241
    1e72:	fd 4f       	sbci	r31, 0xFD	; 253
    1e74:	83 81       	ldd	r24, Z+3	; 0x03
    1e76:	83 30       	cpi	r24, 0x03	; 3
    1e78:	59 f4       	brne	.+22     	; 0x1e90 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1e7a:	98 e0       	ldi	r25, 0x08	; 8
    1e7c:	88 e1       	ldi	r24, 0x18	; 24
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	a8 95       	wdr
    1e84:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1e8e:	ff cf       	rjmp	.-2      	; 0x1e8e <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1e90:	ee ee       	ldi	r30, 0xEE	; 238
    1e92:	f0 e0       	ldi	r31, 0x00	; 0
    1e94:	80 81       	ld	r24, Z
    1e96:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1e98:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1e9a:	80 81       	ld	r24, Z
    1e9c:	8f 7d       	andi	r24, 0xDF	; 223
    1e9e:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1ea0:	80 e8       	ldi	r24, 0x80	; 128
    1ea2:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1ea6:	0f 90       	pop	r0
    1ea8:	df 91       	pop	r29
    1eaa:	cf 91       	pop	r28
    1eac:	ff 91       	pop	r31
    1eae:	ef 91       	pop	r30
    1eb0:	bf 91       	pop	r27
    1eb2:	af 91       	pop	r26
    1eb4:	9f 91       	pop	r25
    1eb6:	8f 91       	pop	r24
    1eb8:	6f 91       	pop	r22
    1eba:	5f 91       	pop	r21
    1ebc:	4f 91       	pop	r20
    1ebe:	3f 91       	pop	r19
    1ec0:	2f 91       	pop	r18
    1ec2:	0f 90       	pop	r0
    1ec4:	0b be       	out	0x3b, r0	; 59
    1ec6:	0f 90       	pop	r0
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	0f 90       	pop	r0
    1ecc:	1f 90       	pop	r1
    1ece:	18 95       	reti

00001ed0 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1ed0:	cf 93       	push	r28
    1ed2:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1ed4:	e8 ed       	ldi	r30, 0xD8	; 216
    1ed6:	f0 e0       	ldi	r31, 0x00	; 0
    1ed8:	21 e0       	ldi	r18, 0x01	; 1
    1eda:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1edc:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1ee0:	2c e0       	ldi	r18, 0x0C	; 12
    1ee2:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1ee6:	27 e3       	ldi	r18, 0x37	; 55
    1ee8:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1eec:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1ef0:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1ef4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1ef8:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1efc:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1f00:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    1f04:	cd ee       	ldi	r28, 0xED	; 237
    1f06:	d0 e0       	ldi	r29, 0x00	; 0
    1f08:	18 82       	st	Y, r1
	CANSTMOB = 0;
    1f0a:	ae ee       	ldi	r26, 0xEE	; 238
    1f0c:	b0 e0       	ldi	r27, 0x00	; 0
    1f0e:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    1f10:	20 e1       	ldi	r18, 0x10	; 16
    1f12:	28 83       	st	Y, r18
	CANSTMOB = 0;
    1f14:	1c 92       	st	X, r1
	CANIDM4 = 0;
    1f16:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    1f1a:	28 2f       	mov	r18, r24
    1f1c:	22 95       	swap	r18
    1f1e:	22 0f       	add	r18, r18
    1f20:	20 7e       	andi	r18, 0xE0	; 224
    1f22:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    1f26:	96 95       	lsr	r25
    1f28:	87 95       	ror	r24
    1f2a:	96 95       	lsr	r25
    1f2c:	87 95       	ror	r24
    1f2e:	96 95       	lsr	r25
    1f30:	87 95       	ror	r24
    1f32:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    1f36:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    1f3a:	86 2f       	mov	r24, r22
    1f3c:	82 95       	swap	r24
    1f3e:	88 0f       	add	r24, r24
    1f40:	80 7e       	andi	r24, 0xE0	; 224
    1f42:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    1f46:	76 95       	lsr	r23
    1f48:	67 95       	ror	r22
    1f4a:	76 95       	lsr	r23
    1f4c:	67 95       	ror	r22
    1f4e:	76 95       	lsr	r23
    1f50:	67 95       	ror	r22
    1f52:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    1f56:	80 e8       	ldi	r24, 0x80	; 128
    1f58:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    1f5c:	83 e0       	ldi	r24, 0x03	; 3
    1f5e:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    1f62:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    1f66:	80 eb       	ldi	r24, 0xB0	; 176
    1f68:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    1f6c:	82 e0       	ldi	r24, 0x02	; 2
    1f6e:	80 83       	st	Z, r24

	reset = 0;
    1f70:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    1f74:	df 91       	pop	r29
    1f76:	cf 91       	pop	r28
    1f78:	08 95       	ret

00001f7a <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    1f7a:	cf 93       	push	r28
    1f7c:	df 93       	push	r29
    1f7e:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    1f80:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    1f84:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    1f88:	24 17       	cp	r18, r20
    1f8a:	89 f1       	breq	.+98     	; 0x1fee <can_read_message_if_new+0x74>
    1f8c:	a4 2f       	mov	r26, r20
    1f8e:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    1f90:	8b e0       	ldi	r24, 0x0B	; 11
    1f92:	a8 9f       	mul	r26, r24
    1f94:	b0 01       	movw	r22, r0
    1f96:	11 24       	eor	r1, r1
    1f98:	fb 01       	movw	r30, r22
    1f9a:	e1 5f       	subi	r30, 0xF1	; 241
    1f9c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f9e:	20 81       	ld	r18, Z
    1fa0:	22 95       	swap	r18
    1fa2:	26 95       	lsr	r18
    1fa4:	27 70       	andi	r18, 0x07	; 7
    1fa6:	31 81       	ldd	r19, Z+1	; 0x01
    1fa8:	53 2f       	mov	r21, r19
    1faa:	55 0f       	add	r21, r21
    1fac:	55 0f       	add	r21, r21
    1fae:	55 0f       	add	r21, r21
    1fb0:	25 2b       	or	r18, r21
    1fb2:	32 95       	swap	r19
    1fb4:	36 95       	lsr	r19
    1fb6:	37 70       	andi	r19, 0x07	; 7
    1fb8:	28 83       	st	Y, r18
    1fba:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    1fbc:	fb 01       	movw	r30, r22
    1fbe:	ef 5e       	subi	r30, 0xEF	; 239
    1fc0:	fd 4f       	sbci	r31, 0xFD	; 253
    1fc2:	20 81       	ld	r18, Z
    1fc4:	2f 70       	andi	r18, 0x0F	; 15
    1fc6:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    1fc8:	22 23       	and	r18, r18
    1fca:	99 f0       	breq	.+38     	; 0x1ff2 <can_read_message_if_new+0x78>
    1fcc:	db 01       	movw	r26, r22
    1fce:	ae 5e       	subi	r26, 0xEE	; 238
    1fd0:	bd 4f       	sbci	r27, 0xFD	; 253
    1fd2:	fe 01       	movw	r30, r28
    1fd4:	33 96       	adiw	r30, 0x03	; 3
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	2d 5f       	subi	r18, 0xFD	; 253
    1fda:	3f 4f       	sbci	r19, 0xFF	; 255
    1fdc:	ce 01       	movw	r24, r28
    1fde:	82 0f       	add	r24, r18
    1fe0:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    1fe2:	2d 91       	ld	r18, X+
    1fe4:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    1fe6:	e8 17       	cp	r30, r24
    1fe8:	f9 07       	cpc	r31, r25
    1fea:	d9 f7       	brne	.-10     	; 0x1fe2 <can_read_message_if_new+0x68>
    1fec:	02 c0       	rjmp	.+4      	; 0x1ff2 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    1fee:	80 e0       	ldi	r24, 0x00	; 0
    1ff0:	04 c0       	rjmp	.+8      	; 0x1ffa <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    1ff2:	4f 5f       	subi	r20, 0xFF	; 255
    1ff4:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
}
    1ffa:	df 91       	pop	r29
    1ffc:	cf 91       	pop	r28
    1ffe:	08 95       	ret

00002000 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    2006:	ab ed       	ldi	r26, 0xDB	; 219
    2008:	b0 e0       	ldi	r27, 0x00	; 0
    200a:	8c 91       	ld	r24, X
    200c:	8f 77       	andi	r24, 0x7F	; 127
    200e:	8c 93       	st	X, r24

	if (!tx_busy) {
    2010:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    2014:	81 11       	cpse	r24, r1
    2016:	27 c0       	rjmp	.+78     	; 0x2066 <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2018:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    201c:	80 81       	ld	r24, Z
    201e:	82 95       	swap	r24
    2020:	88 0f       	add	r24, r24
    2022:	80 7e       	andi	r24, 0xE0	; 224
    2024:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2028:	80 81       	ld	r24, Z
    202a:	91 81       	ldd	r25, Z+1	; 0x01
    202c:	96 95       	lsr	r25
    202e:	87 95       	ror	r24
    2030:	96 95       	lsr	r25
    2032:	87 95       	ror	r24
    2034:	96 95       	lsr	r25
    2036:	87 95       	ror	r24
    2038:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    203c:	df 01       	movw	r26, r30
    203e:	13 96       	adiw	r26, 0x03	; 3
    2040:	9f 01       	movw	r18, r30
    2042:	25 5f       	subi	r18, 0xF5	; 245
    2044:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    2046:	ca ef       	ldi	r28, 0xFA	; 250
    2048:	d0 e0       	ldi	r29, 0x00	; 0
    204a:	9d 91       	ld	r25, X+
    204c:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    204e:	a2 17       	cp	r26, r18
    2050:	b3 07       	cpc	r27, r19
    2052:	d9 f7       	brne	.-10     	; 0x204a <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    205a:	82 81       	ldd	r24, Z+2	; 0x02
    205c:	80 64       	ori	r24, 0x40	; 64
    205e:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    2062:	81 e0       	ldi	r24, 0x01	; 1
    2064:	43 c0       	rjmp	.+134    	; 0x20ec <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    2066:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    206a:	82 2f       	mov	r24, r18
    206c:	90 e0       	ldi	r25, 0x00	; 0
    206e:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    2072:	83 1b       	sub	r24, r19
    2074:	91 09       	sbc	r25, r1
    2076:	8f 77       	andi	r24, 0x7F	; 127
    2078:	99 27       	eor	r25, r25
    207a:	40 97       	sbiw	r24, 0x10	; 16
    207c:	b1 f1       	breq	.+108    	; 0x20ea <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    207e:	a2 2f       	mov	r26, r18
    2080:	af 70       	andi	r26, 0x0F	; 15
    2082:	8b e0       	ldi	r24, 0x0B	; 11
    2084:	a8 9f       	mul	r26, r24
    2086:	d0 01       	movw	r26, r0
    2088:	11 24       	eor	r1, r1
    208a:	ed 01       	movw	r28, r26
    208c:	c1 54       	subi	r28, 0x41	; 65
    208e:	dd 4f       	sbci	r29, 0xFD	; 253
    2090:	80 81       	ld	r24, Z
    2092:	98 2f       	mov	r25, r24
    2094:	92 95       	swap	r25
    2096:	99 0f       	add	r25, r25
    2098:	90 7e       	andi	r25, 0xE0	; 224
    209a:	88 81       	ld	r24, Y
    209c:	8f 71       	andi	r24, 0x1F	; 31
    209e:	89 2b       	or	r24, r25
    20a0:	88 83       	st	Y, r24
    20a2:	80 81       	ld	r24, Z
    20a4:	98 2f       	mov	r25, r24
    20a6:	96 95       	lsr	r25
    20a8:	96 95       	lsr	r25
    20aa:	96 95       	lsr	r25
    20ac:	89 81       	ldd	r24, Y+1	; 0x01
    20ae:	80 7e       	andi	r24, 0xE0	; 224
    20b0:	89 2b       	or	r24, r25
    20b2:	89 83       	std	Y+1, r24	; 0x01
    20b4:	91 81       	ldd	r25, Z+1	; 0x01
    20b6:	92 95       	swap	r25
    20b8:	99 0f       	add	r25, r25
    20ba:	90 7e       	andi	r25, 0xE0	; 224
    20bc:	8f 71       	andi	r24, 0x1F	; 31
    20be:	89 2b       	or	r24, r25
    20c0:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    20c2:	82 81       	ldd	r24, Z+2	; 0x02
    20c4:	98 2f       	mov	r25, r24
    20c6:	9f 70       	andi	r25, 0x0F	; 15
    20c8:	8a 81       	ldd	r24, Y+2	; 0x02
    20ca:	80 7f       	andi	r24, 0xF0	; 240
    20cc:	89 2b       	or	r24, r25
    20ce:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    20d0:	ae 53       	subi	r26, 0x3E	; 62
    20d2:	bd 4f       	sbci	r27, 0xFD	; 253
    20d4:	33 96       	adiw	r30, 0x03	; 3
    20d6:	88 e0       	ldi	r24, 0x08	; 8
    20d8:	01 90       	ld	r0, Z+
    20da:	0d 92       	st	X+, r0
    20dc:	8a 95       	dec	r24
    20de:	e1 f7       	brne	.-8      	; 0x20d8 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    20e0:	2f 5f       	subi	r18, 0xFF	; 255
    20e2:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	01 c0       	rjmp	.+2      	; 0x20ec <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    20ea:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    20ec:	eb ed       	ldi	r30, 0xDB	; 219
    20ee:	f0 e0       	ldi	r31, 0x00	; 0
    20f0:	90 81       	ld	r25, Z
    20f2:	90 68       	ori	r25, 0x80	; 128
    20f4:	90 83       	st	Z, r25

	return result;
    20f6:	df 91       	pop	r29
    20f8:	cf 91       	pop	r28
    20fa:	08 95       	ret

000020fc <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    20fc:	95 b1       	in	r25, 0x05	; 5
    20fe:	89 2b       	or	r24, r25
    2100:	85 b9       	out	0x05, r24	; 5
    2102:	08 95       	ret

00002104 <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    2104:	84 b1       	in	r24, 0x04	; 4
    2106:	80 6e       	ori	r24, 0xE0	; 224
    2108:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    210a:	80 ee       	ldi	r24, 0xE0	; 224
    210c:	f7 cf       	rjmp	.-18     	; 0x20fc <rgbled_turn_off>
    210e:	08 95       	ret

00002110 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2110:	95 b1       	in	r25, 0x05	; 5
    2112:	80 95       	com	r24
    2114:	98 23       	and	r25, r24
    2116:	95 b9       	out	0x05, r25	; 5
    2118:	08 95       	ret

0000211a <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    211a:	95 b1       	in	r25, 0x05	; 5
    211c:	89 27       	eor	r24, r25
    211e:	85 b9       	out	0x05, r24	; 5
    2120:	08 95       	ret

00002122 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    2122:	94 b1       	in	r25, 0x04	; 4
    2124:	97 60       	ori	r25, 0x07	; 7
    2126:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2128:	82 fb       	bst	r24, 2
    212a:	99 27       	eor	r25, r25
    212c:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    212e:	28 2f       	mov	r18, r24
    2130:	22 70       	andi	r18, 0x02	; 2
    2132:	81 70       	andi	r24, 0x01	; 1
    2134:	80 65       	ori	r24, 0x50	; 80
    2136:	82 2b       	or	r24, r18
    2138:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    213a:	8c b5       	in	r24, 0x2c	; 44
    213c:	83 7f       	andi	r24, 0xF3	; 243
    213e:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2140:	9d bd       	out	0x2d, r25	; 45
    2142:	08 95       	ret

00002144 <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    214a:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    214c:	41 15       	cp	r20, r1
    214e:	51 05       	cpc	r21, r1
    2150:	c1 f0       	breq	.+48     	; 0x2182 <spi_trancieve+0x3e>
    2152:	fb 01       	movw	r30, r22
    2154:	dc 01       	movw	r26, r24
    2156:	46 0f       	add	r20, r22
    2158:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    215a:	8f ef       	ldi	r24, 0xFF	; 255
    215c:	20 97       	sbiw	r28, 0x00	; 0
    215e:	11 f0       	breq	.+4      	; 0x2164 <spi_trancieve+0x20>
    2160:	9c 91       	ld	r25, X
    2162:	01 c0       	rjmp	.+2      	; 0x2166 <spi_trancieve+0x22>
    2164:	98 2f       	mov	r25, r24
    2166:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2168:	0d b4       	in	r0, 0x2d	; 45
    216a:	07 fe       	sbrs	r0, 7
    216c:	fd cf       	rjmp	.-6      	; 0x2168 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    216e:	61 15       	cp	r22, r1
    2170:	71 05       	cpc	r23, r1
    2172:	11 f0       	breq	.+4      	; 0x2178 <spi_trancieve+0x34>
    2174:	9e b5       	in	r25, 0x2e	; 46
    2176:	90 83       	st	Z, r25
    2178:	31 96       	adiw	r30, 0x01	; 1
    217a:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    217c:	e4 17       	cp	r30, r20
    217e:	f5 07       	cpc	r31, r21
    2180:	69 f7       	brne	.-38     	; 0x215c <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2182:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    2184:	28 9a       	sbi	0x05, 0	; 5
	}
}
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	08 95       	ret

0000218c <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    218c:	1f 92       	push	r1
    218e:	0f 92       	push	r0
    2190:	0f b6       	in	r0, 0x3f	; 63
    2192:	0f 92       	push	r0
    2194:	11 24       	eor	r1, r1
    2196:	0b b6       	in	r0, 0x3b	; 59
    2198:	0f 92       	push	r0
    219a:	2f 93       	push	r18
    219c:	3f 93       	push	r19
    219e:	4f 93       	push	r20
    21a0:	5f 93       	push	r21
    21a2:	6f 93       	push	r22
    21a4:	7f 93       	push	r23
    21a6:	8f 93       	push	r24
    21a8:	af 93       	push	r26
    21aa:	bf 93       	push	r27
    21ac:	ef 93       	push	r30
    21ae:	ff 93       	push	r31
    21b0:	af e8       	ldi	r26, 0x8F	; 143
    21b2:	b3 e0       	ldi	r27, 0x03	; 3
    21b4:	ef e6       	ldi	r30, 0x6F	; 111
    21b6:	f3 e0       	ldi	r31, 0x03	; 3
    21b8:	2f e8       	ldi	r18, 0x8F	; 143
    21ba:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    21bc:	8d 91       	ld	r24, X+
    21be:	88 23       	and	r24, r24
    21c0:	59 f0       	breq	.+22     	; 0x21d8 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    21c2:	40 81       	ld	r20, Z
    21c4:	51 81       	ldd	r21, Z+1	; 0x01
    21c6:	62 81       	ldd	r22, Z+2	; 0x02
    21c8:	73 81       	ldd	r23, Z+3	; 0x03
    21ca:	50 5e       	subi	r21, 0xE0	; 224
    21cc:	6f 4f       	sbci	r22, 0xFF	; 255
    21ce:	7f 4f       	sbci	r23, 0xFF	; 255
    21d0:	40 83       	st	Z, r20
    21d2:	51 83       	std	Z+1, r21	; 0x01
    21d4:	62 83       	std	Z+2, r22	; 0x02
    21d6:	73 83       	std	Z+3, r23	; 0x03
    21d8:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    21da:	e2 17       	cp	r30, r18
    21dc:	f3 07       	cpc	r31, r19
    21de:	71 f7       	brne	.-36     	; 0x21bc <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    21e0:	ff 91       	pop	r31
    21e2:	ef 91       	pop	r30
    21e4:	bf 91       	pop	r27
    21e6:	af 91       	pop	r26
    21e8:	8f 91       	pop	r24
    21ea:	7f 91       	pop	r23
    21ec:	6f 91       	pop	r22
    21ee:	5f 91       	pop	r21
    21f0:	4f 91       	pop	r20
    21f2:	3f 91       	pop	r19
    21f4:	2f 91       	pop	r18
    21f6:	0f 90       	pop	r0
    21f8:	0b be       	out	0x3b, r0	; 59
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	0f 90       	pop	r0
    2200:	1f 90       	pop	r1
    2202:	18 95       	reti

00002204 <__subsf3>:
    2204:	50 58       	subi	r21, 0x80	; 128

00002206 <__addsf3>:
    2206:	bb 27       	eor	r27, r27
    2208:	aa 27       	eor	r26, r26
    220a:	0e d0       	rcall	.+28     	; 0x2228 <__addsf3x>
    220c:	75 c1       	rjmp	.+746    	; 0x24f8 <__fp_round>
    220e:	66 d1       	rcall	.+716    	; 0x24dc <__fp_pscA>
    2210:	30 f0       	brcs	.+12     	; 0x221e <__addsf3+0x18>
    2212:	6b d1       	rcall	.+726    	; 0x24ea <__fp_pscB>
    2214:	20 f0       	brcs	.+8      	; 0x221e <__addsf3+0x18>
    2216:	31 f4       	brne	.+12     	; 0x2224 <__addsf3+0x1e>
    2218:	9f 3f       	cpi	r25, 0xFF	; 255
    221a:	11 f4       	brne	.+4      	; 0x2220 <__addsf3+0x1a>
    221c:	1e f4       	brtc	.+6      	; 0x2224 <__addsf3+0x1e>
    221e:	5b c1       	rjmp	.+694    	; 0x24d6 <__fp_nan>
    2220:	0e f4       	brtc	.+2      	; 0x2224 <__addsf3+0x1e>
    2222:	e0 95       	com	r30
    2224:	e7 fb       	bst	r30, 7
    2226:	51 c1       	rjmp	.+674    	; 0x24ca <__fp_inf>

00002228 <__addsf3x>:
    2228:	e9 2f       	mov	r30, r25
    222a:	77 d1       	rcall	.+750    	; 0x251a <__fp_split3>
    222c:	80 f3       	brcs	.-32     	; 0x220e <__addsf3+0x8>
    222e:	ba 17       	cp	r27, r26
    2230:	62 07       	cpc	r22, r18
    2232:	73 07       	cpc	r23, r19
    2234:	84 07       	cpc	r24, r20
    2236:	95 07       	cpc	r25, r21
    2238:	18 f0       	brcs	.+6      	; 0x2240 <__addsf3x+0x18>
    223a:	71 f4       	brne	.+28     	; 0x2258 <__addsf3x+0x30>
    223c:	9e f5       	brtc	.+102    	; 0x22a4 <__addsf3x+0x7c>
    223e:	8f c1       	rjmp	.+798    	; 0x255e <__fp_zero>
    2240:	0e f4       	brtc	.+2      	; 0x2244 <__addsf3x+0x1c>
    2242:	e0 95       	com	r30
    2244:	0b 2e       	mov	r0, r27
    2246:	ba 2f       	mov	r27, r26
    2248:	a0 2d       	mov	r26, r0
    224a:	0b 01       	movw	r0, r22
    224c:	b9 01       	movw	r22, r18
    224e:	90 01       	movw	r18, r0
    2250:	0c 01       	movw	r0, r24
    2252:	ca 01       	movw	r24, r20
    2254:	a0 01       	movw	r20, r0
    2256:	11 24       	eor	r1, r1
    2258:	ff 27       	eor	r31, r31
    225a:	59 1b       	sub	r21, r25
    225c:	99 f0       	breq	.+38     	; 0x2284 <__addsf3x+0x5c>
    225e:	59 3f       	cpi	r21, 0xF9	; 249
    2260:	50 f4       	brcc	.+20     	; 0x2276 <__addsf3x+0x4e>
    2262:	50 3e       	cpi	r21, 0xE0	; 224
    2264:	68 f1       	brcs	.+90     	; 0x22c0 <__addsf3x+0x98>
    2266:	1a 16       	cp	r1, r26
    2268:	f0 40       	sbci	r31, 0x00	; 0
    226a:	a2 2f       	mov	r26, r18
    226c:	23 2f       	mov	r18, r19
    226e:	34 2f       	mov	r19, r20
    2270:	44 27       	eor	r20, r20
    2272:	58 5f       	subi	r21, 0xF8	; 248
    2274:	f3 cf       	rjmp	.-26     	; 0x225c <__addsf3x+0x34>
    2276:	46 95       	lsr	r20
    2278:	37 95       	ror	r19
    227a:	27 95       	ror	r18
    227c:	a7 95       	ror	r26
    227e:	f0 40       	sbci	r31, 0x00	; 0
    2280:	53 95       	inc	r21
    2282:	c9 f7       	brne	.-14     	; 0x2276 <__addsf3x+0x4e>
    2284:	7e f4       	brtc	.+30     	; 0x22a4 <__addsf3x+0x7c>
    2286:	1f 16       	cp	r1, r31
    2288:	ba 0b       	sbc	r27, r26
    228a:	62 0b       	sbc	r22, r18
    228c:	73 0b       	sbc	r23, r19
    228e:	84 0b       	sbc	r24, r20
    2290:	ba f0       	brmi	.+46     	; 0x22c0 <__addsf3x+0x98>
    2292:	91 50       	subi	r25, 0x01	; 1
    2294:	a1 f0       	breq	.+40     	; 0x22be <__addsf3x+0x96>
    2296:	ff 0f       	add	r31, r31
    2298:	bb 1f       	adc	r27, r27
    229a:	66 1f       	adc	r22, r22
    229c:	77 1f       	adc	r23, r23
    229e:	88 1f       	adc	r24, r24
    22a0:	c2 f7       	brpl	.-16     	; 0x2292 <__addsf3x+0x6a>
    22a2:	0e c0       	rjmp	.+28     	; 0x22c0 <__addsf3x+0x98>
    22a4:	ba 0f       	add	r27, r26
    22a6:	62 1f       	adc	r22, r18
    22a8:	73 1f       	adc	r23, r19
    22aa:	84 1f       	adc	r24, r20
    22ac:	48 f4       	brcc	.+18     	; 0x22c0 <__addsf3x+0x98>
    22ae:	87 95       	ror	r24
    22b0:	77 95       	ror	r23
    22b2:	67 95       	ror	r22
    22b4:	b7 95       	ror	r27
    22b6:	f7 95       	ror	r31
    22b8:	9e 3f       	cpi	r25, 0xFE	; 254
    22ba:	08 f0       	brcs	.+2      	; 0x22be <__addsf3x+0x96>
    22bc:	b3 cf       	rjmp	.-154    	; 0x2224 <__addsf3+0x1e>
    22be:	93 95       	inc	r25
    22c0:	88 0f       	add	r24, r24
    22c2:	08 f0       	brcs	.+2      	; 0x22c6 <__addsf3x+0x9e>
    22c4:	99 27       	eor	r25, r25
    22c6:	ee 0f       	add	r30, r30
    22c8:	97 95       	ror	r25
    22ca:	87 95       	ror	r24
    22cc:	08 95       	ret

000022ce <__cmpsf2>:
    22ce:	d9 d0       	rcall	.+434    	; 0x2482 <__fp_cmp>
    22d0:	08 f4       	brcc	.+2      	; 0x22d4 <__cmpsf2+0x6>
    22d2:	81 e0       	ldi	r24, 0x01	; 1
    22d4:	08 95       	ret

000022d6 <__divsf3>:
    22d6:	0c d0       	rcall	.+24     	; 0x22f0 <__divsf3x>
    22d8:	0f c1       	rjmp	.+542    	; 0x24f8 <__fp_round>
    22da:	07 d1       	rcall	.+526    	; 0x24ea <__fp_pscB>
    22dc:	40 f0       	brcs	.+16     	; 0x22ee <__divsf3+0x18>
    22de:	fe d0       	rcall	.+508    	; 0x24dc <__fp_pscA>
    22e0:	30 f0       	brcs	.+12     	; 0x22ee <__divsf3+0x18>
    22e2:	21 f4       	brne	.+8      	; 0x22ec <__divsf3+0x16>
    22e4:	5f 3f       	cpi	r21, 0xFF	; 255
    22e6:	19 f0       	breq	.+6      	; 0x22ee <__divsf3+0x18>
    22e8:	f0 c0       	rjmp	.+480    	; 0x24ca <__fp_inf>
    22ea:	51 11       	cpse	r21, r1
    22ec:	39 c1       	rjmp	.+626    	; 0x2560 <__fp_szero>
    22ee:	f3 c0       	rjmp	.+486    	; 0x24d6 <__fp_nan>

000022f0 <__divsf3x>:
    22f0:	14 d1       	rcall	.+552    	; 0x251a <__fp_split3>
    22f2:	98 f3       	brcs	.-26     	; 0x22da <__divsf3+0x4>

000022f4 <__divsf3_pse>:
    22f4:	99 23       	and	r25, r25
    22f6:	c9 f3       	breq	.-14     	; 0x22ea <__divsf3+0x14>
    22f8:	55 23       	and	r21, r21
    22fa:	b1 f3       	breq	.-20     	; 0x22e8 <__divsf3+0x12>
    22fc:	95 1b       	sub	r25, r21
    22fe:	55 0b       	sbc	r21, r21
    2300:	bb 27       	eor	r27, r27
    2302:	aa 27       	eor	r26, r26
    2304:	62 17       	cp	r22, r18
    2306:	73 07       	cpc	r23, r19
    2308:	84 07       	cpc	r24, r20
    230a:	38 f0       	brcs	.+14     	; 0x231a <__divsf3_pse+0x26>
    230c:	9f 5f       	subi	r25, 0xFF	; 255
    230e:	5f 4f       	sbci	r21, 0xFF	; 255
    2310:	22 0f       	add	r18, r18
    2312:	33 1f       	adc	r19, r19
    2314:	44 1f       	adc	r20, r20
    2316:	aa 1f       	adc	r26, r26
    2318:	a9 f3       	breq	.-22     	; 0x2304 <__divsf3_pse+0x10>
    231a:	33 d0       	rcall	.+102    	; 0x2382 <__divsf3_pse+0x8e>
    231c:	0e 2e       	mov	r0, r30
    231e:	3a f0       	brmi	.+14     	; 0x232e <__divsf3_pse+0x3a>
    2320:	e0 e8       	ldi	r30, 0x80	; 128
    2322:	30 d0       	rcall	.+96     	; 0x2384 <__divsf3_pse+0x90>
    2324:	91 50       	subi	r25, 0x01	; 1
    2326:	50 40       	sbci	r21, 0x00	; 0
    2328:	e6 95       	lsr	r30
    232a:	00 1c       	adc	r0, r0
    232c:	ca f7       	brpl	.-14     	; 0x2320 <__divsf3_pse+0x2c>
    232e:	29 d0       	rcall	.+82     	; 0x2382 <__divsf3_pse+0x8e>
    2330:	fe 2f       	mov	r31, r30
    2332:	27 d0       	rcall	.+78     	; 0x2382 <__divsf3_pse+0x8e>
    2334:	66 0f       	add	r22, r22
    2336:	77 1f       	adc	r23, r23
    2338:	88 1f       	adc	r24, r24
    233a:	bb 1f       	adc	r27, r27
    233c:	26 17       	cp	r18, r22
    233e:	37 07       	cpc	r19, r23
    2340:	48 07       	cpc	r20, r24
    2342:	ab 07       	cpc	r26, r27
    2344:	b0 e8       	ldi	r27, 0x80	; 128
    2346:	09 f0       	breq	.+2      	; 0x234a <__divsf3_pse+0x56>
    2348:	bb 0b       	sbc	r27, r27
    234a:	80 2d       	mov	r24, r0
    234c:	bf 01       	movw	r22, r30
    234e:	ff 27       	eor	r31, r31
    2350:	93 58       	subi	r25, 0x83	; 131
    2352:	5f 4f       	sbci	r21, 0xFF	; 255
    2354:	2a f0       	brmi	.+10     	; 0x2360 <__divsf3_pse+0x6c>
    2356:	9e 3f       	cpi	r25, 0xFE	; 254
    2358:	51 05       	cpc	r21, r1
    235a:	68 f0       	brcs	.+26     	; 0x2376 <__divsf3_pse+0x82>
    235c:	b6 c0       	rjmp	.+364    	; 0x24ca <__fp_inf>
    235e:	00 c1       	rjmp	.+512    	; 0x2560 <__fp_szero>
    2360:	5f 3f       	cpi	r21, 0xFF	; 255
    2362:	ec f3       	brlt	.-6      	; 0x235e <__divsf3_pse+0x6a>
    2364:	98 3e       	cpi	r25, 0xE8	; 232
    2366:	dc f3       	brlt	.-10     	; 0x235e <__divsf3_pse+0x6a>
    2368:	86 95       	lsr	r24
    236a:	77 95       	ror	r23
    236c:	67 95       	ror	r22
    236e:	b7 95       	ror	r27
    2370:	f7 95       	ror	r31
    2372:	9f 5f       	subi	r25, 0xFF	; 255
    2374:	c9 f7       	brne	.-14     	; 0x2368 <__divsf3_pse+0x74>
    2376:	88 0f       	add	r24, r24
    2378:	91 1d       	adc	r25, r1
    237a:	96 95       	lsr	r25
    237c:	87 95       	ror	r24
    237e:	97 f9       	bld	r25, 7
    2380:	08 95       	ret
    2382:	e1 e0       	ldi	r30, 0x01	; 1
    2384:	66 0f       	add	r22, r22
    2386:	77 1f       	adc	r23, r23
    2388:	88 1f       	adc	r24, r24
    238a:	bb 1f       	adc	r27, r27
    238c:	62 17       	cp	r22, r18
    238e:	73 07       	cpc	r23, r19
    2390:	84 07       	cpc	r24, r20
    2392:	ba 07       	cpc	r27, r26
    2394:	20 f0       	brcs	.+8      	; 0x239e <__divsf3_pse+0xaa>
    2396:	62 1b       	sub	r22, r18
    2398:	73 0b       	sbc	r23, r19
    239a:	84 0b       	sbc	r24, r20
    239c:	ba 0b       	sbc	r27, r26
    239e:	ee 1f       	adc	r30, r30
    23a0:	88 f7       	brcc	.-30     	; 0x2384 <__divsf3_pse+0x90>
    23a2:	e0 95       	com	r30
    23a4:	08 95       	ret

000023a6 <__fixsfsi>:
    23a6:	04 d0       	rcall	.+8      	; 0x23b0 <__fixunssfsi>
    23a8:	68 94       	set
    23aa:	b1 11       	cpse	r27, r1
    23ac:	d9 c0       	rjmp	.+434    	; 0x2560 <__fp_szero>
    23ae:	08 95       	ret

000023b0 <__fixunssfsi>:
    23b0:	bc d0       	rcall	.+376    	; 0x252a <__fp_splitA>
    23b2:	88 f0       	brcs	.+34     	; 0x23d6 <__fixunssfsi+0x26>
    23b4:	9f 57       	subi	r25, 0x7F	; 127
    23b6:	90 f0       	brcs	.+36     	; 0x23dc <__fixunssfsi+0x2c>
    23b8:	b9 2f       	mov	r27, r25
    23ba:	99 27       	eor	r25, r25
    23bc:	b7 51       	subi	r27, 0x17	; 23
    23be:	a0 f0       	brcs	.+40     	; 0x23e8 <__fixunssfsi+0x38>
    23c0:	d1 f0       	breq	.+52     	; 0x23f6 <__fixunssfsi+0x46>
    23c2:	66 0f       	add	r22, r22
    23c4:	77 1f       	adc	r23, r23
    23c6:	88 1f       	adc	r24, r24
    23c8:	99 1f       	adc	r25, r25
    23ca:	1a f0       	brmi	.+6      	; 0x23d2 <__fixunssfsi+0x22>
    23cc:	ba 95       	dec	r27
    23ce:	c9 f7       	brne	.-14     	; 0x23c2 <__fixunssfsi+0x12>
    23d0:	12 c0       	rjmp	.+36     	; 0x23f6 <__fixunssfsi+0x46>
    23d2:	b1 30       	cpi	r27, 0x01	; 1
    23d4:	81 f0       	breq	.+32     	; 0x23f6 <__fixunssfsi+0x46>
    23d6:	c3 d0       	rcall	.+390    	; 0x255e <__fp_zero>
    23d8:	b1 e0       	ldi	r27, 0x01	; 1
    23da:	08 95       	ret
    23dc:	c0 c0       	rjmp	.+384    	; 0x255e <__fp_zero>
    23de:	67 2f       	mov	r22, r23
    23e0:	78 2f       	mov	r23, r24
    23e2:	88 27       	eor	r24, r24
    23e4:	b8 5f       	subi	r27, 0xF8	; 248
    23e6:	39 f0       	breq	.+14     	; 0x23f6 <__fixunssfsi+0x46>
    23e8:	b9 3f       	cpi	r27, 0xF9	; 249
    23ea:	cc f3       	brlt	.-14     	; 0x23de <__fixunssfsi+0x2e>
    23ec:	86 95       	lsr	r24
    23ee:	77 95       	ror	r23
    23f0:	67 95       	ror	r22
    23f2:	b3 95       	inc	r27
    23f4:	d9 f7       	brne	.-10     	; 0x23ec <__fixunssfsi+0x3c>
    23f6:	3e f4       	brtc	.+14     	; 0x2406 <__fixunssfsi+0x56>
    23f8:	90 95       	com	r25
    23fa:	80 95       	com	r24
    23fc:	70 95       	com	r23
    23fe:	61 95       	neg	r22
    2400:	7f 4f       	sbci	r23, 0xFF	; 255
    2402:	8f 4f       	sbci	r24, 0xFF	; 255
    2404:	9f 4f       	sbci	r25, 0xFF	; 255
    2406:	08 95       	ret

00002408 <__floatunsisf>:
    2408:	e8 94       	clt
    240a:	09 c0       	rjmp	.+18     	; 0x241e <__floatsisf+0x12>

0000240c <__floatsisf>:
    240c:	97 fb       	bst	r25, 7
    240e:	3e f4       	brtc	.+14     	; 0x241e <__floatsisf+0x12>
    2410:	90 95       	com	r25
    2412:	80 95       	com	r24
    2414:	70 95       	com	r23
    2416:	61 95       	neg	r22
    2418:	7f 4f       	sbci	r23, 0xFF	; 255
    241a:	8f 4f       	sbci	r24, 0xFF	; 255
    241c:	9f 4f       	sbci	r25, 0xFF	; 255
    241e:	99 23       	and	r25, r25
    2420:	a9 f0       	breq	.+42     	; 0x244c <__floatsisf+0x40>
    2422:	f9 2f       	mov	r31, r25
    2424:	96 e9       	ldi	r25, 0x96	; 150
    2426:	bb 27       	eor	r27, r27
    2428:	93 95       	inc	r25
    242a:	f6 95       	lsr	r31
    242c:	87 95       	ror	r24
    242e:	77 95       	ror	r23
    2430:	67 95       	ror	r22
    2432:	b7 95       	ror	r27
    2434:	f1 11       	cpse	r31, r1
    2436:	f8 cf       	rjmp	.-16     	; 0x2428 <__floatsisf+0x1c>
    2438:	fa f4       	brpl	.+62     	; 0x2478 <__floatsisf+0x6c>
    243a:	bb 0f       	add	r27, r27
    243c:	11 f4       	brne	.+4      	; 0x2442 <__floatsisf+0x36>
    243e:	60 ff       	sbrs	r22, 0
    2440:	1b c0       	rjmp	.+54     	; 0x2478 <__floatsisf+0x6c>
    2442:	6f 5f       	subi	r22, 0xFF	; 255
    2444:	7f 4f       	sbci	r23, 0xFF	; 255
    2446:	8f 4f       	sbci	r24, 0xFF	; 255
    2448:	9f 4f       	sbci	r25, 0xFF	; 255
    244a:	16 c0       	rjmp	.+44     	; 0x2478 <__floatsisf+0x6c>
    244c:	88 23       	and	r24, r24
    244e:	11 f0       	breq	.+4      	; 0x2454 <__floatsisf+0x48>
    2450:	96 e9       	ldi	r25, 0x96	; 150
    2452:	11 c0       	rjmp	.+34     	; 0x2476 <__floatsisf+0x6a>
    2454:	77 23       	and	r23, r23
    2456:	21 f0       	breq	.+8      	; 0x2460 <__floatsisf+0x54>
    2458:	9e e8       	ldi	r25, 0x8E	; 142
    245a:	87 2f       	mov	r24, r23
    245c:	76 2f       	mov	r23, r22
    245e:	05 c0       	rjmp	.+10     	; 0x246a <__floatsisf+0x5e>
    2460:	66 23       	and	r22, r22
    2462:	71 f0       	breq	.+28     	; 0x2480 <__floatsisf+0x74>
    2464:	96 e8       	ldi	r25, 0x86	; 134
    2466:	86 2f       	mov	r24, r22
    2468:	70 e0       	ldi	r23, 0x00	; 0
    246a:	60 e0       	ldi	r22, 0x00	; 0
    246c:	2a f0       	brmi	.+10     	; 0x2478 <__floatsisf+0x6c>
    246e:	9a 95       	dec	r25
    2470:	66 0f       	add	r22, r22
    2472:	77 1f       	adc	r23, r23
    2474:	88 1f       	adc	r24, r24
    2476:	da f7       	brpl	.-10     	; 0x246e <__floatsisf+0x62>
    2478:	88 0f       	add	r24, r24
    247a:	96 95       	lsr	r25
    247c:	87 95       	ror	r24
    247e:	97 f9       	bld	r25, 7
    2480:	08 95       	ret

00002482 <__fp_cmp>:
    2482:	99 0f       	add	r25, r25
    2484:	00 08       	sbc	r0, r0
    2486:	55 0f       	add	r21, r21
    2488:	aa 0b       	sbc	r26, r26
    248a:	e0 e8       	ldi	r30, 0x80	; 128
    248c:	fe ef       	ldi	r31, 0xFE	; 254
    248e:	16 16       	cp	r1, r22
    2490:	17 06       	cpc	r1, r23
    2492:	e8 07       	cpc	r30, r24
    2494:	f9 07       	cpc	r31, r25
    2496:	c0 f0       	brcs	.+48     	; 0x24c8 <__fp_cmp+0x46>
    2498:	12 16       	cp	r1, r18
    249a:	13 06       	cpc	r1, r19
    249c:	e4 07       	cpc	r30, r20
    249e:	f5 07       	cpc	r31, r21
    24a0:	98 f0       	brcs	.+38     	; 0x24c8 <__fp_cmp+0x46>
    24a2:	62 1b       	sub	r22, r18
    24a4:	73 0b       	sbc	r23, r19
    24a6:	84 0b       	sbc	r24, r20
    24a8:	95 0b       	sbc	r25, r21
    24aa:	39 f4       	brne	.+14     	; 0x24ba <__fp_cmp+0x38>
    24ac:	0a 26       	eor	r0, r26
    24ae:	61 f0       	breq	.+24     	; 0x24c8 <__fp_cmp+0x46>
    24b0:	23 2b       	or	r18, r19
    24b2:	24 2b       	or	r18, r20
    24b4:	25 2b       	or	r18, r21
    24b6:	21 f4       	brne	.+8      	; 0x24c0 <__fp_cmp+0x3e>
    24b8:	08 95       	ret
    24ba:	0a 26       	eor	r0, r26
    24bc:	09 f4       	brne	.+2      	; 0x24c0 <__fp_cmp+0x3e>
    24be:	a1 40       	sbci	r26, 0x01	; 1
    24c0:	a6 95       	lsr	r26
    24c2:	8f ef       	ldi	r24, 0xFF	; 255
    24c4:	81 1d       	adc	r24, r1
    24c6:	81 1d       	adc	r24, r1
    24c8:	08 95       	ret

000024ca <__fp_inf>:
    24ca:	97 f9       	bld	r25, 7
    24cc:	9f 67       	ori	r25, 0x7F	; 127
    24ce:	80 e8       	ldi	r24, 0x80	; 128
    24d0:	70 e0       	ldi	r23, 0x00	; 0
    24d2:	60 e0       	ldi	r22, 0x00	; 0
    24d4:	08 95       	ret

000024d6 <__fp_nan>:
    24d6:	9f ef       	ldi	r25, 0xFF	; 255
    24d8:	80 ec       	ldi	r24, 0xC0	; 192
    24da:	08 95       	ret

000024dc <__fp_pscA>:
    24dc:	00 24       	eor	r0, r0
    24de:	0a 94       	dec	r0
    24e0:	16 16       	cp	r1, r22
    24e2:	17 06       	cpc	r1, r23
    24e4:	18 06       	cpc	r1, r24
    24e6:	09 06       	cpc	r0, r25
    24e8:	08 95       	ret

000024ea <__fp_pscB>:
    24ea:	00 24       	eor	r0, r0
    24ec:	0a 94       	dec	r0
    24ee:	12 16       	cp	r1, r18
    24f0:	13 06       	cpc	r1, r19
    24f2:	14 06       	cpc	r1, r20
    24f4:	05 06       	cpc	r0, r21
    24f6:	08 95       	ret

000024f8 <__fp_round>:
    24f8:	09 2e       	mov	r0, r25
    24fa:	03 94       	inc	r0
    24fc:	00 0c       	add	r0, r0
    24fe:	11 f4       	brne	.+4      	; 0x2504 <__fp_round+0xc>
    2500:	88 23       	and	r24, r24
    2502:	52 f0       	brmi	.+20     	; 0x2518 <__fp_round+0x20>
    2504:	bb 0f       	add	r27, r27
    2506:	40 f4       	brcc	.+16     	; 0x2518 <__fp_round+0x20>
    2508:	bf 2b       	or	r27, r31
    250a:	11 f4       	brne	.+4      	; 0x2510 <__fp_round+0x18>
    250c:	60 ff       	sbrs	r22, 0
    250e:	04 c0       	rjmp	.+8      	; 0x2518 <__fp_round+0x20>
    2510:	6f 5f       	subi	r22, 0xFF	; 255
    2512:	7f 4f       	sbci	r23, 0xFF	; 255
    2514:	8f 4f       	sbci	r24, 0xFF	; 255
    2516:	9f 4f       	sbci	r25, 0xFF	; 255
    2518:	08 95       	ret

0000251a <__fp_split3>:
    251a:	57 fd       	sbrc	r21, 7
    251c:	90 58       	subi	r25, 0x80	; 128
    251e:	44 0f       	add	r20, r20
    2520:	55 1f       	adc	r21, r21
    2522:	59 f0       	breq	.+22     	; 0x253a <__fp_splitA+0x10>
    2524:	5f 3f       	cpi	r21, 0xFF	; 255
    2526:	71 f0       	breq	.+28     	; 0x2544 <__fp_splitA+0x1a>
    2528:	47 95       	ror	r20

0000252a <__fp_splitA>:
    252a:	88 0f       	add	r24, r24
    252c:	97 fb       	bst	r25, 7
    252e:	99 1f       	adc	r25, r25
    2530:	61 f0       	breq	.+24     	; 0x254a <__fp_splitA+0x20>
    2532:	9f 3f       	cpi	r25, 0xFF	; 255
    2534:	79 f0       	breq	.+30     	; 0x2554 <__fp_splitA+0x2a>
    2536:	87 95       	ror	r24
    2538:	08 95       	ret
    253a:	12 16       	cp	r1, r18
    253c:	13 06       	cpc	r1, r19
    253e:	14 06       	cpc	r1, r20
    2540:	55 1f       	adc	r21, r21
    2542:	f2 cf       	rjmp	.-28     	; 0x2528 <__fp_split3+0xe>
    2544:	46 95       	lsr	r20
    2546:	f1 df       	rcall	.-30     	; 0x252a <__fp_splitA>
    2548:	08 c0       	rjmp	.+16     	; 0x255a <__fp_splitA+0x30>
    254a:	16 16       	cp	r1, r22
    254c:	17 06       	cpc	r1, r23
    254e:	18 06       	cpc	r1, r24
    2550:	99 1f       	adc	r25, r25
    2552:	f1 cf       	rjmp	.-30     	; 0x2536 <__fp_splitA+0xc>
    2554:	86 95       	lsr	r24
    2556:	71 05       	cpc	r23, r1
    2558:	61 05       	cpc	r22, r1
    255a:	08 94       	sec
    255c:	08 95       	ret

0000255e <__fp_zero>:
    255e:	e8 94       	clt

00002560 <__fp_szero>:
    2560:	bb 27       	eor	r27, r27
    2562:	66 27       	eor	r22, r22
    2564:	77 27       	eor	r23, r23
    2566:	cb 01       	movw	r24, r22
    2568:	97 f9       	bld	r25, 7
    256a:	08 95       	ret

0000256c <__gesf2>:
    256c:	8a df       	rcall	.-236    	; 0x2482 <__fp_cmp>
    256e:	08 f4       	brcc	.+2      	; 0x2572 <__gesf2+0x6>
    2570:	8f ef       	ldi	r24, 0xFF	; 255
    2572:	08 95       	ret

00002574 <__mulsf3>:
    2574:	0b d0       	rcall	.+22     	; 0x258c <__mulsf3x>
    2576:	c0 cf       	rjmp	.-128    	; 0x24f8 <__fp_round>
    2578:	b1 df       	rcall	.-158    	; 0x24dc <__fp_pscA>
    257a:	28 f0       	brcs	.+10     	; 0x2586 <__mulsf3+0x12>
    257c:	b6 df       	rcall	.-148    	; 0x24ea <__fp_pscB>
    257e:	18 f0       	brcs	.+6      	; 0x2586 <__mulsf3+0x12>
    2580:	95 23       	and	r25, r21
    2582:	09 f0       	breq	.+2      	; 0x2586 <__mulsf3+0x12>
    2584:	a2 cf       	rjmp	.-188    	; 0x24ca <__fp_inf>
    2586:	a7 cf       	rjmp	.-178    	; 0x24d6 <__fp_nan>
    2588:	11 24       	eor	r1, r1
    258a:	ea cf       	rjmp	.-44     	; 0x2560 <__fp_szero>

0000258c <__mulsf3x>:
    258c:	c6 df       	rcall	.-116    	; 0x251a <__fp_split3>
    258e:	a0 f3       	brcs	.-24     	; 0x2578 <__mulsf3+0x4>

00002590 <__mulsf3_pse>:
    2590:	95 9f       	mul	r25, r21
    2592:	d1 f3       	breq	.-12     	; 0x2588 <__mulsf3+0x14>
    2594:	95 0f       	add	r25, r21
    2596:	50 e0       	ldi	r21, 0x00	; 0
    2598:	55 1f       	adc	r21, r21
    259a:	62 9f       	mul	r22, r18
    259c:	f0 01       	movw	r30, r0
    259e:	72 9f       	mul	r23, r18
    25a0:	bb 27       	eor	r27, r27
    25a2:	f0 0d       	add	r31, r0
    25a4:	b1 1d       	adc	r27, r1
    25a6:	63 9f       	mul	r22, r19
    25a8:	aa 27       	eor	r26, r26
    25aa:	f0 0d       	add	r31, r0
    25ac:	b1 1d       	adc	r27, r1
    25ae:	aa 1f       	adc	r26, r26
    25b0:	64 9f       	mul	r22, r20
    25b2:	66 27       	eor	r22, r22
    25b4:	b0 0d       	add	r27, r0
    25b6:	a1 1d       	adc	r26, r1
    25b8:	66 1f       	adc	r22, r22
    25ba:	82 9f       	mul	r24, r18
    25bc:	22 27       	eor	r18, r18
    25be:	b0 0d       	add	r27, r0
    25c0:	a1 1d       	adc	r26, r1
    25c2:	62 1f       	adc	r22, r18
    25c4:	73 9f       	mul	r23, r19
    25c6:	b0 0d       	add	r27, r0
    25c8:	a1 1d       	adc	r26, r1
    25ca:	62 1f       	adc	r22, r18
    25cc:	83 9f       	mul	r24, r19
    25ce:	a0 0d       	add	r26, r0
    25d0:	61 1d       	adc	r22, r1
    25d2:	22 1f       	adc	r18, r18
    25d4:	74 9f       	mul	r23, r20
    25d6:	33 27       	eor	r19, r19
    25d8:	a0 0d       	add	r26, r0
    25da:	61 1d       	adc	r22, r1
    25dc:	23 1f       	adc	r18, r19
    25de:	84 9f       	mul	r24, r20
    25e0:	60 0d       	add	r22, r0
    25e2:	21 1d       	adc	r18, r1
    25e4:	82 2f       	mov	r24, r18
    25e6:	76 2f       	mov	r23, r22
    25e8:	6a 2f       	mov	r22, r26
    25ea:	11 24       	eor	r1, r1
    25ec:	9f 57       	subi	r25, 0x7F	; 127
    25ee:	50 40       	sbci	r21, 0x00	; 0
    25f0:	8a f0       	brmi	.+34     	; 0x2614 <__mulsf3_pse+0x84>
    25f2:	e1 f0       	breq	.+56     	; 0x262c <__mulsf3_pse+0x9c>
    25f4:	88 23       	and	r24, r24
    25f6:	4a f0       	brmi	.+18     	; 0x260a <__mulsf3_pse+0x7a>
    25f8:	ee 0f       	add	r30, r30
    25fa:	ff 1f       	adc	r31, r31
    25fc:	bb 1f       	adc	r27, r27
    25fe:	66 1f       	adc	r22, r22
    2600:	77 1f       	adc	r23, r23
    2602:	88 1f       	adc	r24, r24
    2604:	91 50       	subi	r25, 0x01	; 1
    2606:	50 40       	sbci	r21, 0x00	; 0
    2608:	a9 f7       	brne	.-22     	; 0x25f4 <__mulsf3_pse+0x64>
    260a:	9e 3f       	cpi	r25, 0xFE	; 254
    260c:	51 05       	cpc	r21, r1
    260e:	70 f0       	brcs	.+28     	; 0x262c <__mulsf3_pse+0x9c>
    2610:	5c cf       	rjmp	.-328    	; 0x24ca <__fp_inf>
    2612:	a6 cf       	rjmp	.-180    	; 0x2560 <__fp_szero>
    2614:	5f 3f       	cpi	r21, 0xFF	; 255
    2616:	ec f3       	brlt	.-6      	; 0x2612 <__mulsf3_pse+0x82>
    2618:	98 3e       	cpi	r25, 0xE8	; 232
    261a:	dc f3       	brlt	.-10     	; 0x2612 <__mulsf3_pse+0x82>
    261c:	86 95       	lsr	r24
    261e:	77 95       	ror	r23
    2620:	67 95       	ror	r22
    2622:	b7 95       	ror	r27
    2624:	f7 95       	ror	r31
    2626:	e7 95       	ror	r30
    2628:	9f 5f       	subi	r25, 0xFF	; 255
    262a:	c1 f7       	brne	.-16     	; 0x261c <__mulsf3_pse+0x8c>
    262c:	fe 2b       	or	r31, r30
    262e:	88 0f       	add	r24, r24
    2630:	91 1d       	adc	r25, r1
    2632:	96 95       	lsr	r25
    2634:	87 95       	ror	r24
    2636:	97 f9       	bld	r25, 7
    2638:	08 95       	ret

0000263a <__tablejump2__>:
    263a:	ee 0f       	add	r30, r30
    263c:	ff 1f       	adc	r31, r31
    263e:	00 24       	eor	r0, r0
    2640:	00 1c       	adc	r0, r0
    2642:	0b be       	out	0x3b, r0	; 59
    2644:	07 90       	elpm	r0, Z+
    2646:	f6 91       	elpm	r31, Z
    2648:	e0 2d       	mov	r30, r0
    264a:	09 94       	ijmp

0000264c <atoi>:
    264c:	fc 01       	movw	r30, r24
    264e:	88 27       	eor	r24, r24
    2650:	99 27       	eor	r25, r25
    2652:	e8 94       	clt
    2654:	21 91       	ld	r18, Z+
    2656:	20 32       	cpi	r18, 0x20	; 32
    2658:	e9 f3       	breq	.-6      	; 0x2654 <atoi+0x8>
    265a:	29 30       	cpi	r18, 0x09	; 9
    265c:	10 f0       	brcs	.+4      	; 0x2662 <atoi+0x16>
    265e:	2e 30       	cpi	r18, 0x0E	; 14
    2660:	c8 f3       	brcs	.-14     	; 0x2654 <atoi+0x8>
    2662:	2b 32       	cpi	r18, 0x2B	; 43
    2664:	39 f0       	breq	.+14     	; 0x2674 <atoi+0x28>
    2666:	2d 32       	cpi	r18, 0x2D	; 45
    2668:	31 f4       	brne	.+12     	; 0x2676 <atoi+0x2a>
    266a:	68 94       	set
    266c:	03 c0       	rjmp	.+6      	; 0x2674 <atoi+0x28>
    266e:	14 d0       	rcall	.+40     	; 0x2698 <__mulhi_const_10>
    2670:	82 0f       	add	r24, r18
    2672:	91 1d       	adc	r25, r1
    2674:	21 91       	ld	r18, Z+
    2676:	20 53       	subi	r18, 0x30	; 48
    2678:	2a 30       	cpi	r18, 0x0A	; 10
    267a:	c8 f3       	brcs	.-14     	; 0x266e <atoi+0x22>
    267c:	1e f4       	brtc	.+6      	; 0x2684 <atoi+0x38>
    267e:	90 95       	com	r25
    2680:	81 95       	neg	r24
    2682:	9f 4f       	sbci	r25, 0xFF	; 255
    2684:	08 95       	ret

00002686 <strcmp>:
    2686:	fb 01       	movw	r30, r22
    2688:	dc 01       	movw	r26, r24
    268a:	8d 91       	ld	r24, X+
    268c:	01 90       	ld	r0, Z+
    268e:	80 19       	sub	r24, r0
    2690:	01 10       	cpse	r0, r1
    2692:	d9 f3       	breq	.-10     	; 0x268a <strcmp+0x4>
    2694:	99 0b       	sbc	r25, r25
    2696:	08 95       	ret

00002698 <__mulhi_const_10>:
    2698:	7a e0       	ldi	r23, 0x0A	; 10
    269a:	97 9f       	mul	r25, r23
    269c:	90 2d       	mov	r25, r0
    269e:	87 9f       	mul	r24, r23
    26a0:	80 2d       	mov	r24, r0
    26a2:	91 0d       	add	r25, r1
    26a4:	11 24       	eor	r1, r1
    26a6:	08 95       	ret

000026a8 <printf>:
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	ae 01       	movw	r20, r28
    26b2:	4b 5f       	subi	r20, 0xFB	; 251
    26b4:	5f 4f       	sbci	r21, 0xFF	; 255
    26b6:	fa 01       	movw	r30, r20
    26b8:	61 91       	ld	r22, Z+
    26ba:	71 91       	ld	r23, Z+
    26bc:	af 01       	movw	r20, r30
    26be:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    26c2:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    26c6:	38 d0       	rcall	.+112    	; 0x2738 <vfprintf>
    26c8:	df 91       	pop	r29
    26ca:	cf 91       	pop	r28
    26cc:	08 95       	ret

000026ce <putchar>:
    26ce:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    26d2:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    26d6:	43 c2       	rjmp	.+1158   	; 0x2b5e <fputc>

000026d8 <puts>:
    26d8:	0f 93       	push	r16
    26da:	1f 93       	push	r17
    26dc:	cf 93       	push	r28
    26de:	df 93       	push	r29
    26e0:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    26e4:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    26e8:	23 81       	ldd	r18, Z+3	; 0x03
    26ea:	21 ff       	sbrs	r18, 1
    26ec:	1b c0       	rjmp	.+54     	; 0x2724 <puts+0x4c>
    26ee:	8c 01       	movw	r16, r24
    26f0:	d0 e0       	ldi	r29, 0x00	; 0
    26f2:	c0 e0       	ldi	r28, 0x00	; 0
    26f4:	f8 01       	movw	r30, r16
    26f6:	81 91       	ld	r24, Z+
    26f8:	8f 01       	movw	r16, r30
    26fa:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    26fe:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    2702:	db 01       	movw	r26, r22
    2704:	18 96       	adiw	r26, 0x08	; 8
    2706:	ed 91       	ld	r30, X+
    2708:	fc 91       	ld	r31, X
    270a:	19 97       	sbiw	r26, 0x09	; 9
    270c:	88 23       	and	r24, r24
    270e:	31 f0       	breq	.+12     	; 0x271c <puts+0x44>
    2710:	09 95       	icall
    2712:	89 2b       	or	r24, r25
    2714:	79 f3       	breq	.-34     	; 0x26f4 <puts+0x1c>
    2716:	df ef       	ldi	r29, 0xFF	; 255
    2718:	cf ef       	ldi	r28, 0xFF	; 255
    271a:	ec cf       	rjmp	.-40     	; 0x26f4 <puts+0x1c>
    271c:	8a e0       	ldi	r24, 0x0A	; 10
    271e:	09 95       	icall
    2720:	89 2b       	or	r24, r25
    2722:	19 f0       	breq	.+6      	; 0x272a <puts+0x52>
    2724:	8f ef       	ldi	r24, 0xFF	; 255
    2726:	9f ef       	ldi	r25, 0xFF	; 255
    2728:	02 c0       	rjmp	.+4      	; 0x272e <puts+0x56>
    272a:	8d 2f       	mov	r24, r29
    272c:	9c 2f       	mov	r25, r28
    272e:	df 91       	pop	r29
    2730:	cf 91       	pop	r28
    2732:	1f 91       	pop	r17
    2734:	0f 91       	pop	r16
    2736:	08 95       	ret

00002738 <vfprintf>:
    2738:	2f 92       	push	r2
    273a:	3f 92       	push	r3
    273c:	4f 92       	push	r4
    273e:	5f 92       	push	r5
    2740:	6f 92       	push	r6
    2742:	7f 92       	push	r7
    2744:	8f 92       	push	r8
    2746:	9f 92       	push	r9
    2748:	af 92       	push	r10
    274a:	bf 92       	push	r11
    274c:	cf 92       	push	r12
    274e:	df 92       	push	r13
    2750:	ef 92       	push	r14
    2752:	ff 92       	push	r15
    2754:	0f 93       	push	r16
    2756:	1f 93       	push	r17
    2758:	cf 93       	push	r28
    275a:	df 93       	push	r29
    275c:	cd b7       	in	r28, 0x3d	; 61
    275e:	de b7       	in	r29, 0x3e	; 62
    2760:	2b 97       	sbiw	r28, 0x0b	; 11
    2762:	0f b6       	in	r0, 0x3f	; 63
    2764:	f8 94       	cli
    2766:	de bf       	out	0x3e, r29	; 62
    2768:	0f be       	out	0x3f, r0	; 63
    276a:	cd bf       	out	0x3d, r28	; 61
    276c:	6c 01       	movw	r12, r24
    276e:	7b 01       	movw	r14, r22
    2770:	8a 01       	movw	r16, r20
    2772:	fc 01       	movw	r30, r24
    2774:	17 82       	std	Z+7, r1	; 0x07
    2776:	16 82       	std	Z+6, r1	; 0x06
    2778:	83 81       	ldd	r24, Z+3	; 0x03
    277a:	81 ff       	sbrs	r24, 1
    277c:	bf c1       	rjmp	.+894    	; 0x2afc <vfprintf+0x3c4>
    277e:	ce 01       	movw	r24, r28
    2780:	01 96       	adiw	r24, 0x01	; 1
    2782:	3c 01       	movw	r6, r24
    2784:	f6 01       	movw	r30, r12
    2786:	93 81       	ldd	r25, Z+3	; 0x03
    2788:	f7 01       	movw	r30, r14
    278a:	93 fd       	sbrc	r25, 3
    278c:	85 91       	lpm	r24, Z+
    278e:	93 ff       	sbrs	r25, 3
    2790:	81 91       	ld	r24, Z+
    2792:	7f 01       	movw	r14, r30
    2794:	88 23       	and	r24, r24
    2796:	09 f4       	brne	.+2      	; 0x279a <vfprintf+0x62>
    2798:	ad c1       	rjmp	.+858    	; 0x2af4 <vfprintf+0x3bc>
    279a:	85 32       	cpi	r24, 0x25	; 37
    279c:	39 f4       	brne	.+14     	; 0x27ac <vfprintf+0x74>
    279e:	93 fd       	sbrc	r25, 3
    27a0:	85 91       	lpm	r24, Z+
    27a2:	93 ff       	sbrs	r25, 3
    27a4:	81 91       	ld	r24, Z+
    27a6:	7f 01       	movw	r14, r30
    27a8:	85 32       	cpi	r24, 0x25	; 37
    27aa:	21 f4       	brne	.+8      	; 0x27b4 <vfprintf+0x7c>
    27ac:	b6 01       	movw	r22, r12
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	d6 d1       	rcall	.+940    	; 0x2b5e <fputc>
    27b2:	e8 cf       	rjmp	.-48     	; 0x2784 <vfprintf+0x4c>
    27b4:	91 2c       	mov	r9, r1
    27b6:	21 2c       	mov	r2, r1
    27b8:	31 2c       	mov	r3, r1
    27ba:	ff e1       	ldi	r31, 0x1F	; 31
    27bc:	f3 15       	cp	r31, r3
    27be:	d8 f0       	brcs	.+54     	; 0x27f6 <vfprintf+0xbe>
    27c0:	8b 32       	cpi	r24, 0x2B	; 43
    27c2:	79 f0       	breq	.+30     	; 0x27e2 <vfprintf+0xaa>
    27c4:	38 f4       	brcc	.+14     	; 0x27d4 <vfprintf+0x9c>
    27c6:	80 32       	cpi	r24, 0x20	; 32
    27c8:	79 f0       	breq	.+30     	; 0x27e8 <vfprintf+0xb0>
    27ca:	83 32       	cpi	r24, 0x23	; 35
    27cc:	a1 f4       	brne	.+40     	; 0x27f6 <vfprintf+0xbe>
    27ce:	23 2d       	mov	r18, r3
    27d0:	20 61       	ori	r18, 0x10	; 16
    27d2:	1d c0       	rjmp	.+58     	; 0x280e <vfprintf+0xd6>
    27d4:	8d 32       	cpi	r24, 0x2D	; 45
    27d6:	61 f0       	breq	.+24     	; 0x27f0 <vfprintf+0xb8>
    27d8:	80 33       	cpi	r24, 0x30	; 48
    27da:	69 f4       	brne	.+26     	; 0x27f6 <vfprintf+0xbe>
    27dc:	23 2d       	mov	r18, r3
    27de:	21 60       	ori	r18, 0x01	; 1
    27e0:	16 c0       	rjmp	.+44     	; 0x280e <vfprintf+0xd6>
    27e2:	83 2d       	mov	r24, r3
    27e4:	82 60       	ori	r24, 0x02	; 2
    27e6:	38 2e       	mov	r3, r24
    27e8:	e3 2d       	mov	r30, r3
    27ea:	e4 60       	ori	r30, 0x04	; 4
    27ec:	3e 2e       	mov	r3, r30
    27ee:	2a c0       	rjmp	.+84     	; 0x2844 <vfprintf+0x10c>
    27f0:	f3 2d       	mov	r31, r3
    27f2:	f8 60       	ori	r31, 0x08	; 8
    27f4:	1d c0       	rjmp	.+58     	; 0x2830 <vfprintf+0xf8>
    27f6:	37 fc       	sbrc	r3, 7
    27f8:	2d c0       	rjmp	.+90     	; 0x2854 <vfprintf+0x11c>
    27fa:	20 ed       	ldi	r18, 0xD0	; 208
    27fc:	28 0f       	add	r18, r24
    27fe:	2a 30       	cpi	r18, 0x0A	; 10
    2800:	40 f0       	brcs	.+16     	; 0x2812 <vfprintf+0xda>
    2802:	8e 32       	cpi	r24, 0x2E	; 46
    2804:	b9 f4       	brne	.+46     	; 0x2834 <vfprintf+0xfc>
    2806:	36 fc       	sbrc	r3, 6
    2808:	75 c1       	rjmp	.+746    	; 0x2af4 <vfprintf+0x3bc>
    280a:	23 2d       	mov	r18, r3
    280c:	20 64       	ori	r18, 0x40	; 64
    280e:	32 2e       	mov	r3, r18
    2810:	19 c0       	rjmp	.+50     	; 0x2844 <vfprintf+0x10c>
    2812:	36 fe       	sbrs	r3, 6
    2814:	06 c0       	rjmp	.+12     	; 0x2822 <vfprintf+0xea>
    2816:	8a e0       	ldi	r24, 0x0A	; 10
    2818:	98 9e       	mul	r9, r24
    281a:	20 0d       	add	r18, r0
    281c:	11 24       	eor	r1, r1
    281e:	92 2e       	mov	r9, r18
    2820:	11 c0       	rjmp	.+34     	; 0x2844 <vfprintf+0x10c>
    2822:	ea e0       	ldi	r30, 0x0A	; 10
    2824:	2e 9e       	mul	r2, r30
    2826:	20 0d       	add	r18, r0
    2828:	11 24       	eor	r1, r1
    282a:	22 2e       	mov	r2, r18
    282c:	f3 2d       	mov	r31, r3
    282e:	f0 62       	ori	r31, 0x20	; 32
    2830:	3f 2e       	mov	r3, r31
    2832:	08 c0       	rjmp	.+16     	; 0x2844 <vfprintf+0x10c>
    2834:	8c 36       	cpi	r24, 0x6C	; 108
    2836:	21 f4       	brne	.+8      	; 0x2840 <vfprintf+0x108>
    2838:	83 2d       	mov	r24, r3
    283a:	80 68       	ori	r24, 0x80	; 128
    283c:	38 2e       	mov	r3, r24
    283e:	02 c0       	rjmp	.+4      	; 0x2844 <vfprintf+0x10c>
    2840:	88 36       	cpi	r24, 0x68	; 104
    2842:	41 f4       	brne	.+16     	; 0x2854 <vfprintf+0x11c>
    2844:	f7 01       	movw	r30, r14
    2846:	93 fd       	sbrc	r25, 3
    2848:	85 91       	lpm	r24, Z+
    284a:	93 ff       	sbrs	r25, 3
    284c:	81 91       	ld	r24, Z+
    284e:	7f 01       	movw	r14, r30
    2850:	81 11       	cpse	r24, r1
    2852:	b3 cf       	rjmp	.-154    	; 0x27ba <vfprintf+0x82>
    2854:	98 2f       	mov	r25, r24
    2856:	9f 7d       	andi	r25, 0xDF	; 223
    2858:	95 54       	subi	r25, 0x45	; 69
    285a:	93 30       	cpi	r25, 0x03	; 3
    285c:	28 f4       	brcc	.+10     	; 0x2868 <vfprintf+0x130>
    285e:	0c 5f       	subi	r16, 0xFC	; 252
    2860:	1f 4f       	sbci	r17, 0xFF	; 255
    2862:	9f e3       	ldi	r25, 0x3F	; 63
    2864:	99 83       	std	Y+1, r25	; 0x01
    2866:	0d c0       	rjmp	.+26     	; 0x2882 <vfprintf+0x14a>
    2868:	83 36       	cpi	r24, 0x63	; 99
    286a:	31 f0       	breq	.+12     	; 0x2878 <vfprintf+0x140>
    286c:	83 37       	cpi	r24, 0x73	; 115
    286e:	71 f0       	breq	.+28     	; 0x288c <vfprintf+0x154>
    2870:	83 35       	cpi	r24, 0x53	; 83
    2872:	09 f0       	breq	.+2      	; 0x2876 <vfprintf+0x13e>
    2874:	55 c0       	rjmp	.+170    	; 0x2920 <vfprintf+0x1e8>
    2876:	20 c0       	rjmp	.+64     	; 0x28b8 <vfprintf+0x180>
    2878:	f8 01       	movw	r30, r16
    287a:	80 81       	ld	r24, Z
    287c:	89 83       	std	Y+1, r24	; 0x01
    287e:	0e 5f       	subi	r16, 0xFE	; 254
    2880:	1f 4f       	sbci	r17, 0xFF	; 255
    2882:	88 24       	eor	r8, r8
    2884:	83 94       	inc	r8
    2886:	91 2c       	mov	r9, r1
    2888:	53 01       	movw	r10, r6
    288a:	12 c0       	rjmp	.+36     	; 0x28b0 <vfprintf+0x178>
    288c:	28 01       	movw	r4, r16
    288e:	f2 e0       	ldi	r31, 0x02	; 2
    2890:	4f 0e       	add	r4, r31
    2892:	51 1c       	adc	r5, r1
    2894:	f8 01       	movw	r30, r16
    2896:	a0 80       	ld	r10, Z
    2898:	b1 80       	ldd	r11, Z+1	; 0x01
    289a:	36 fe       	sbrs	r3, 6
    289c:	03 c0       	rjmp	.+6      	; 0x28a4 <vfprintf+0x16c>
    289e:	69 2d       	mov	r22, r9
    28a0:	70 e0       	ldi	r23, 0x00	; 0
    28a2:	02 c0       	rjmp	.+4      	; 0x28a8 <vfprintf+0x170>
    28a4:	6f ef       	ldi	r22, 0xFF	; 255
    28a6:	7f ef       	ldi	r23, 0xFF	; 255
    28a8:	c5 01       	movw	r24, r10
    28aa:	4e d1       	rcall	.+668    	; 0x2b48 <strnlen>
    28ac:	4c 01       	movw	r8, r24
    28ae:	82 01       	movw	r16, r4
    28b0:	f3 2d       	mov	r31, r3
    28b2:	ff 77       	andi	r31, 0x7F	; 127
    28b4:	3f 2e       	mov	r3, r31
    28b6:	15 c0       	rjmp	.+42     	; 0x28e2 <vfprintf+0x1aa>
    28b8:	28 01       	movw	r4, r16
    28ba:	22 e0       	ldi	r18, 0x02	; 2
    28bc:	42 0e       	add	r4, r18
    28be:	51 1c       	adc	r5, r1
    28c0:	f8 01       	movw	r30, r16
    28c2:	a0 80       	ld	r10, Z
    28c4:	b1 80       	ldd	r11, Z+1	; 0x01
    28c6:	36 fe       	sbrs	r3, 6
    28c8:	03 c0       	rjmp	.+6      	; 0x28d0 <vfprintf+0x198>
    28ca:	69 2d       	mov	r22, r9
    28cc:	70 e0       	ldi	r23, 0x00	; 0
    28ce:	02 c0       	rjmp	.+4      	; 0x28d4 <vfprintf+0x19c>
    28d0:	6f ef       	ldi	r22, 0xFF	; 255
    28d2:	7f ef       	ldi	r23, 0xFF	; 255
    28d4:	c5 01       	movw	r24, r10
    28d6:	2d d1       	rcall	.+602    	; 0x2b32 <strnlen_P>
    28d8:	4c 01       	movw	r8, r24
    28da:	f3 2d       	mov	r31, r3
    28dc:	f0 68       	ori	r31, 0x80	; 128
    28de:	3f 2e       	mov	r3, r31
    28e0:	82 01       	movw	r16, r4
    28e2:	33 fc       	sbrc	r3, 3
    28e4:	19 c0       	rjmp	.+50     	; 0x2918 <vfprintf+0x1e0>
    28e6:	82 2d       	mov	r24, r2
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	88 16       	cp	r8, r24
    28ec:	99 06       	cpc	r9, r25
    28ee:	a0 f4       	brcc	.+40     	; 0x2918 <vfprintf+0x1e0>
    28f0:	b6 01       	movw	r22, r12
    28f2:	80 e2       	ldi	r24, 0x20	; 32
    28f4:	90 e0       	ldi	r25, 0x00	; 0
    28f6:	33 d1       	rcall	.+614    	; 0x2b5e <fputc>
    28f8:	2a 94       	dec	r2
    28fa:	f5 cf       	rjmp	.-22     	; 0x28e6 <vfprintf+0x1ae>
    28fc:	f5 01       	movw	r30, r10
    28fe:	37 fc       	sbrc	r3, 7
    2900:	85 91       	lpm	r24, Z+
    2902:	37 fe       	sbrs	r3, 7
    2904:	81 91       	ld	r24, Z+
    2906:	5f 01       	movw	r10, r30
    2908:	b6 01       	movw	r22, r12
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	28 d1       	rcall	.+592    	; 0x2b5e <fputc>
    290e:	21 10       	cpse	r2, r1
    2910:	2a 94       	dec	r2
    2912:	21 e0       	ldi	r18, 0x01	; 1
    2914:	82 1a       	sub	r8, r18
    2916:	91 08       	sbc	r9, r1
    2918:	81 14       	cp	r8, r1
    291a:	91 04       	cpc	r9, r1
    291c:	79 f7       	brne	.-34     	; 0x28fc <vfprintf+0x1c4>
    291e:	e1 c0       	rjmp	.+450    	; 0x2ae2 <vfprintf+0x3aa>
    2920:	84 36       	cpi	r24, 0x64	; 100
    2922:	11 f0       	breq	.+4      	; 0x2928 <vfprintf+0x1f0>
    2924:	89 36       	cpi	r24, 0x69	; 105
    2926:	39 f5       	brne	.+78     	; 0x2976 <vfprintf+0x23e>
    2928:	f8 01       	movw	r30, r16
    292a:	37 fe       	sbrs	r3, 7
    292c:	07 c0       	rjmp	.+14     	; 0x293c <vfprintf+0x204>
    292e:	60 81       	ld	r22, Z
    2930:	71 81       	ldd	r23, Z+1	; 0x01
    2932:	82 81       	ldd	r24, Z+2	; 0x02
    2934:	93 81       	ldd	r25, Z+3	; 0x03
    2936:	0c 5f       	subi	r16, 0xFC	; 252
    2938:	1f 4f       	sbci	r17, 0xFF	; 255
    293a:	08 c0       	rjmp	.+16     	; 0x294c <vfprintf+0x214>
    293c:	60 81       	ld	r22, Z
    293e:	71 81       	ldd	r23, Z+1	; 0x01
    2940:	07 2e       	mov	r0, r23
    2942:	00 0c       	add	r0, r0
    2944:	88 0b       	sbc	r24, r24
    2946:	99 0b       	sbc	r25, r25
    2948:	0e 5f       	subi	r16, 0xFE	; 254
    294a:	1f 4f       	sbci	r17, 0xFF	; 255
    294c:	f3 2d       	mov	r31, r3
    294e:	ff 76       	andi	r31, 0x6F	; 111
    2950:	3f 2e       	mov	r3, r31
    2952:	97 ff       	sbrs	r25, 7
    2954:	09 c0       	rjmp	.+18     	; 0x2968 <vfprintf+0x230>
    2956:	90 95       	com	r25
    2958:	80 95       	com	r24
    295a:	70 95       	com	r23
    295c:	61 95       	neg	r22
    295e:	7f 4f       	sbci	r23, 0xFF	; 255
    2960:	8f 4f       	sbci	r24, 0xFF	; 255
    2962:	9f 4f       	sbci	r25, 0xFF	; 255
    2964:	f0 68       	ori	r31, 0x80	; 128
    2966:	3f 2e       	mov	r3, r31
    2968:	2a e0       	ldi	r18, 0x0A	; 10
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	a3 01       	movw	r20, r6
    296e:	33 d1       	rcall	.+614    	; 0x2bd6 <__ultoa_invert>
    2970:	88 2e       	mov	r8, r24
    2972:	86 18       	sub	r8, r6
    2974:	44 c0       	rjmp	.+136    	; 0x29fe <vfprintf+0x2c6>
    2976:	85 37       	cpi	r24, 0x75	; 117
    2978:	31 f4       	brne	.+12     	; 0x2986 <vfprintf+0x24e>
    297a:	23 2d       	mov	r18, r3
    297c:	2f 7e       	andi	r18, 0xEF	; 239
    297e:	b2 2e       	mov	r11, r18
    2980:	2a e0       	ldi	r18, 0x0A	; 10
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	25 c0       	rjmp	.+74     	; 0x29d0 <vfprintf+0x298>
    2986:	93 2d       	mov	r25, r3
    2988:	99 7f       	andi	r25, 0xF9	; 249
    298a:	b9 2e       	mov	r11, r25
    298c:	8f 36       	cpi	r24, 0x6F	; 111
    298e:	c1 f0       	breq	.+48     	; 0x29c0 <vfprintf+0x288>
    2990:	18 f4       	brcc	.+6      	; 0x2998 <vfprintf+0x260>
    2992:	88 35       	cpi	r24, 0x58	; 88
    2994:	79 f0       	breq	.+30     	; 0x29b4 <vfprintf+0x27c>
    2996:	ae c0       	rjmp	.+348    	; 0x2af4 <vfprintf+0x3bc>
    2998:	80 37       	cpi	r24, 0x70	; 112
    299a:	19 f0       	breq	.+6      	; 0x29a2 <vfprintf+0x26a>
    299c:	88 37       	cpi	r24, 0x78	; 120
    299e:	21 f0       	breq	.+8      	; 0x29a8 <vfprintf+0x270>
    29a0:	a9 c0       	rjmp	.+338    	; 0x2af4 <vfprintf+0x3bc>
    29a2:	e9 2f       	mov	r30, r25
    29a4:	e0 61       	ori	r30, 0x10	; 16
    29a6:	be 2e       	mov	r11, r30
    29a8:	b4 fe       	sbrs	r11, 4
    29aa:	0d c0       	rjmp	.+26     	; 0x29c6 <vfprintf+0x28e>
    29ac:	fb 2d       	mov	r31, r11
    29ae:	f4 60       	ori	r31, 0x04	; 4
    29b0:	bf 2e       	mov	r11, r31
    29b2:	09 c0       	rjmp	.+18     	; 0x29c6 <vfprintf+0x28e>
    29b4:	34 fe       	sbrs	r3, 4
    29b6:	0a c0       	rjmp	.+20     	; 0x29cc <vfprintf+0x294>
    29b8:	29 2f       	mov	r18, r25
    29ba:	26 60       	ori	r18, 0x06	; 6
    29bc:	b2 2e       	mov	r11, r18
    29be:	06 c0       	rjmp	.+12     	; 0x29cc <vfprintf+0x294>
    29c0:	28 e0       	ldi	r18, 0x08	; 8
    29c2:	30 e0       	ldi	r19, 0x00	; 0
    29c4:	05 c0       	rjmp	.+10     	; 0x29d0 <vfprintf+0x298>
    29c6:	20 e1       	ldi	r18, 0x10	; 16
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	02 c0       	rjmp	.+4      	; 0x29d0 <vfprintf+0x298>
    29cc:	20 e1       	ldi	r18, 0x10	; 16
    29ce:	32 e0       	ldi	r19, 0x02	; 2
    29d0:	f8 01       	movw	r30, r16
    29d2:	b7 fe       	sbrs	r11, 7
    29d4:	07 c0       	rjmp	.+14     	; 0x29e4 <vfprintf+0x2ac>
    29d6:	60 81       	ld	r22, Z
    29d8:	71 81       	ldd	r23, Z+1	; 0x01
    29da:	82 81       	ldd	r24, Z+2	; 0x02
    29dc:	93 81       	ldd	r25, Z+3	; 0x03
    29de:	0c 5f       	subi	r16, 0xFC	; 252
    29e0:	1f 4f       	sbci	r17, 0xFF	; 255
    29e2:	06 c0       	rjmp	.+12     	; 0x29f0 <vfprintf+0x2b8>
    29e4:	60 81       	ld	r22, Z
    29e6:	71 81       	ldd	r23, Z+1	; 0x01
    29e8:	80 e0       	ldi	r24, 0x00	; 0
    29ea:	90 e0       	ldi	r25, 0x00	; 0
    29ec:	0e 5f       	subi	r16, 0xFE	; 254
    29ee:	1f 4f       	sbci	r17, 0xFF	; 255
    29f0:	a3 01       	movw	r20, r6
    29f2:	f1 d0       	rcall	.+482    	; 0x2bd6 <__ultoa_invert>
    29f4:	88 2e       	mov	r8, r24
    29f6:	86 18       	sub	r8, r6
    29f8:	fb 2d       	mov	r31, r11
    29fa:	ff 77       	andi	r31, 0x7F	; 127
    29fc:	3f 2e       	mov	r3, r31
    29fe:	36 fe       	sbrs	r3, 6
    2a00:	0d c0       	rjmp	.+26     	; 0x2a1c <vfprintf+0x2e4>
    2a02:	23 2d       	mov	r18, r3
    2a04:	2e 7f       	andi	r18, 0xFE	; 254
    2a06:	a2 2e       	mov	r10, r18
    2a08:	89 14       	cp	r8, r9
    2a0a:	58 f4       	brcc	.+22     	; 0x2a22 <vfprintf+0x2ea>
    2a0c:	34 fe       	sbrs	r3, 4
    2a0e:	0b c0       	rjmp	.+22     	; 0x2a26 <vfprintf+0x2ee>
    2a10:	32 fc       	sbrc	r3, 2
    2a12:	09 c0       	rjmp	.+18     	; 0x2a26 <vfprintf+0x2ee>
    2a14:	83 2d       	mov	r24, r3
    2a16:	8e 7e       	andi	r24, 0xEE	; 238
    2a18:	a8 2e       	mov	r10, r24
    2a1a:	05 c0       	rjmp	.+10     	; 0x2a26 <vfprintf+0x2ee>
    2a1c:	b8 2c       	mov	r11, r8
    2a1e:	a3 2c       	mov	r10, r3
    2a20:	03 c0       	rjmp	.+6      	; 0x2a28 <vfprintf+0x2f0>
    2a22:	b8 2c       	mov	r11, r8
    2a24:	01 c0       	rjmp	.+2      	; 0x2a28 <vfprintf+0x2f0>
    2a26:	b9 2c       	mov	r11, r9
    2a28:	a4 fe       	sbrs	r10, 4
    2a2a:	0f c0       	rjmp	.+30     	; 0x2a4a <vfprintf+0x312>
    2a2c:	fe 01       	movw	r30, r28
    2a2e:	e8 0d       	add	r30, r8
    2a30:	f1 1d       	adc	r31, r1
    2a32:	80 81       	ld	r24, Z
    2a34:	80 33       	cpi	r24, 0x30	; 48
    2a36:	21 f4       	brne	.+8      	; 0x2a40 <vfprintf+0x308>
    2a38:	9a 2d       	mov	r25, r10
    2a3a:	99 7e       	andi	r25, 0xE9	; 233
    2a3c:	a9 2e       	mov	r10, r25
    2a3e:	09 c0       	rjmp	.+18     	; 0x2a52 <vfprintf+0x31a>
    2a40:	a2 fe       	sbrs	r10, 2
    2a42:	06 c0       	rjmp	.+12     	; 0x2a50 <vfprintf+0x318>
    2a44:	b3 94       	inc	r11
    2a46:	b3 94       	inc	r11
    2a48:	04 c0       	rjmp	.+8      	; 0x2a52 <vfprintf+0x31a>
    2a4a:	8a 2d       	mov	r24, r10
    2a4c:	86 78       	andi	r24, 0x86	; 134
    2a4e:	09 f0       	breq	.+2      	; 0x2a52 <vfprintf+0x31a>
    2a50:	b3 94       	inc	r11
    2a52:	a3 fc       	sbrc	r10, 3
    2a54:	10 c0       	rjmp	.+32     	; 0x2a76 <vfprintf+0x33e>
    2a56:	a0 fe       	sbrs	r10, 0
    2a58:	06 c0       	rjmp	.+12     	; 0x2a66 <vfprintf+0x32e>
    2a5a:	b2 14       	cp	r11, r2
    2a5c:	80 f4       	brcc	.+32     	; 0x2a7e <vfprintf+0x346>
    2a5e:	28 0c       	add	r2, r8
    2a60:	92 2c       	mov	r9, r2
    2a62:	9b 18       	sub	r9, r11
    2a64:	0d c0       	rjmp	.+26     	; 0x2a80 <vfprintf+0x348>
    2a66:	b2 14       	cp	r11, r2
    2a68:	58 f4       	brcc	.+22     	; 0x2a80 <vfprintf+0x348>
    2a6a:	b6 01       	movw	r22, r12
    2a6c:	80 e2       	ldi	r24, 0x20	; 32
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	76 d0       	rcall	.+236    	; 0x2b5e <fputc>
    2a72:	b3 94       	inc	r11
    2a74:	f8 cf       	rjmp	.-16     	; 0x2a66 <vfprintf+0x32e>
    2a76:	b2 14       	cp	r11, r2
    2a78:	18 f4       	brcc	.+6      	; 0x2a80 <vfprintf+0x348>
    2a7a:	2b 18       	sub	r2, r11
    2a7c:	02 c0       	rjmp	.+4      	; 0x2a82 <vfprintf+0x34a>
    2a7e:	98 2c       	mov	r9, r8
    2a80:	21 2c       	mov	r2, r1
    2a82:	a4 fe       	sbrs	r10, 4
    2a84:	0f c0       	rjmp	.+30     	; 0x2aa4 <vfprintf+0x36c>
    2a86:	b6 01       	movw	r22, r12
    2a88:	80 e3       	ldi	r24, 0x30	; 48
    2a8a:	90 e0       	ldi	r25, 0x00	; 0
    2a8c:	68 d0       	rcall	.+208    	; 0x2b5e <fputc>
    2a8e:	a2 fe       	sbrs	r10, 2
    2a90:	16 c0       	rjmp	.+44     	; 0x2abe <vfprintf+0x386>
    2a92:	a1 fc       	sbrc	r10, 1
    2a94:	03 c0       	rjmp	.+6      	; 0x2a9c <vfprintf+0x364>
    2a96:	88 e7       	ldi	r24, 0x78	; 120
    2a98:	90 e0       	ldi	r25, 0x00	; 0
    2a9a:	02 c0       	rjmp	.+4      	; 0x2aa0 <vfprintf+0x368>
    2a9c:	88 e5       	ldi	r24, 0x58	; 88
    2a9e:	90 e0       	ldi	r25, 0x00	; 0
    2aa0:	b6 01       	movw	r22, r12
    2aa2:	0c c0       	rjmp	.+24     	; 0x2abc <vfprintf+0x384>
    2aa4:	8a 2d       	mov	r24, r10
    2aa6:	86 78       	andi	r24, 0x86	; 134
    2aa8:	51 f0       	breq	.+20     	; 0x2abe <vfprintf+0x386>
    2aaa:	a1 fe       	sbrs	r10, 1
    2aac:	02 c0       	rjmp	.+4      	; 0x2ab2 <vfprintf+0x37a>
    2aae:	8b e2       	ldi	r24, 0x2B	; 43
    2ab0:	01 c0       	rjmp	.+2      	; 0x2ab4 <vfprintf+0x37c>
    2ab2:	80 e2       	ldi	r24, 0x20	; 32
    2ab4:	a7 fc       	sbrc	r10, 7
    2ab6:	8d e2       	ldi	r24, 0x2D	; 45
    2ab8:	b6 01       	movw	r22, r12
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	50 d0       	rcall	.+160    	; 0x2b5e <fputc>
    2abe:	89 14       	cp	r8, r9
    2ac0:	30 f4       	brcc	.+12     	; 0x2ace <vfprintf+0x396>
    2ac2:	b6 01       	movw	r22, r12
    2ac4:	80 e3       	ldi	r24, 0x30	; 48
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	4a d0       	rcall	.+148    	; 0x2b5e <fputc>
    2aca:	9a 94       	dec	r9
    2acc:	f8 cf       	rjmp	.-16     	; 0x2abe <vfprintf+0x386>
    2ace:	8a 94       	dec	r8
    2ad0:	f3 01       	movw	r30, r6
    2ad2:	e8 0d       	add	r30, r8
    2ad4:	f1 1d       	adc	r31, r1
    2ad6:	80 81       	ld	r24, Z
    2ad8:	b6 01       	movw	r22, r12
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	40 d0       	rcall	.+128    	; 0x2b5e <fputc>
    2ade:	81 10       	cpse	r8, r1
    2ae0:	f6 cf       	rjmp	.-20     	; 0x2ace <vfprintf+0x396>
    2ae2:	22 20       	and	r2, r2
    2ae4:	09 f4       	brne	.+2      	; 0x2ae8 <vfprintf+0x3b0>
    2ae6:	4e ce       	rjmp	.-868    	; 0x2784 <vfprintf+0x4c>
    2ae8:	b6 01       	movw	r22, r12
    2aea:	80 e2       	ldi	r24, 0x20	; 32
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	37 d0       	rcall	.+110    	; 0x2b5e <fputc>
    2af0:	2a 94       	dec	r2
    2af2:	f7 cf       	rjmp	.-18     	; 0x2ae2 <vfprintf+0x3aa>
    2af4:	f6 01       	movw	r30, r12
    2af6:	86 81       	ldd	r24, Z+6	; 0x06
    2af8:	97 81       	ldd	r25, Z+7	; 0x07
    2afa:	02 c0       	rjmp	.+4      	; 0x2b00 <vfprintf+0x3c8>
    2afc:	8f ef       	ldi	r24, 0xFF	; 255
    2afe:	9f ef       	ldi	r25, 0xFF	; 255
    2b00:	2b 96       	adiw	r28, 0x0b	; 11
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	0f be       	out	0x3f, r0	; 63
    2b0a:	cd bf       	out	0x3d, r28	; 61
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	1f 91       	pop	r17
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	df 90       	pop	r13
    2b1a:	cf 90       	pop	r12
    2b1c:	bf 90       	pop	r11
    2b1e:	af 90       	pop	r10
    2b20:	9f 90       	pop	r9
    2b22:	8f 90       	pop	r8
    2b24:	7f 90       	pop	r7
    2b26:	6f 90       	pop	r6
    2b28:	5f 90       	pop	r5
    2b2a:	4f 90       	pop	r4
    2b2c:	3f 90       	pop	r3
    2b2e:	2f 90       	pop	r2
    2b30:	08 95       	ret

00002b32 <strnlen_P>:
    2b32:	fc 01       	movw	r30, r24
    2b34:	05 90       	lpm	r0, Z+
    2b36:	61 50       	subi	r22, 0x01	; 1
    2b38:	70 40       	sbci	r23, 0x00	; 0
    2b3a:	01 10       	cpse	r0, r1
    2b3c:	d8 f7       	brcc	.-10     	; 0x2b34 <strnlen_P+0x2>
    2b3e:	80 95       	com	r24
    2b40:	90 95       	com	r25
    2b42:	8e 0f       	add	r24, r30
    2b44:	9f 1f       	adc	r25, r31
    2b46:	08 95       	ret

00002b48 <strnlen>:
    2b48:	fc 01       	movw	r30, r24
    2b4a:	61 50       	subi	r22, 0x01	; 1
    2b4c:	70 40       	sbci	r23, 0x00	; 0
    2b4e:	01 90       	ld	r0, Z+
    2b50:	01 10       	cpse	r0, r1
    2b52:	d8 f7       	brcc	.-10     	; 0x2b4a <strnlen+0x2>
    2b54:	80 95       	com	r24
    2b56:	90 95       	com	r25
    2b58:	8e 0f       	add	r24, r30
    2b5a:	9f 1f       	adc	r25, r31
    2b5c:	08 95       	ret

00002b5e <fputc>:
    2b5e:	0f 93       	push	r16
    2b60:	1f 93       	push	r17
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	fb 01       	movw	r30, r22
    2b68:	23 81       	ldd	r18, Z+3	; 0x03
    2b6a:	21 fd       	sbrc	r18, 1
    2b6c:	03 c0       	rjmp	.+6      	; 0x2b74 <fputc+0x16>
    2b6e:	8f ef       	ldi	r24, 0xFF	; 255
    2b70:	9f ef       	ldi	r25, 0xFF	; 255
    2b72:	2c c0       	rjmp	.+88     	; 0x2bcc <fputc+0x6e>
    2b74:	22 ff       	sbrs	r18, 2
    2b76:	16 c0       	rjmp	.+44     	; 0x2ba4 <fputc+0x46>
    2b78:	46 81       	ldd	r20, Z+6	; 0x06
    2b7a:	57 81       	ldd	r21, Z+7	; 0x07
    2b7c:	24 81       	ldd	r18, Z+4	; 0x04
    2b7e:	35 81       	ldd	r19, Z+5	; 0x05
    2b80:	42 17       	cp	r20, r18
    2b82:	53 07       	cpc	r21, r19
    2b84:	44 f4       	brge	.+16     	; 0x2b96 <fputc+0x38>
    2b86:	a0 81       	ld	r26, Z
    2b88:	b1 81       	ldd	r27, Z+1	; 0x01
    2b8a:	9d 01       	movw	r18, r26
    2b8c:	2f 5f       	subi	r18, 0xFF	; 255
    2b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b90:	31 83       	std	Z+1, r19	; 0x01
    2b92:	20 83       	st	Z, r18
    2b94:	8c 93       	st	X, r24
    2b96:	26 81       	ldd	r18, Z+6	; 0x06
    2b98:	37 81       	ldd	r19, Z+7	; 0x07
    2b9a:	2f 5f       	subi	r18, 0xFF	; 255
    2b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9e:	37 83       	std	Z+7, r19	; 0x07
    2ba0:	26 83       	std	Z+6, r18	; 0x06
    2ba2:	14 c0       	rjmp	.+40     	; 0x2bcc <fputc+0x6e>
    2ba4:	8b 01       	movw	r16, r22
    2ba6:	ec 01       	movw	r28, r24
    2ba8:	fb 01       	movw	r30, r22
    2baa:	00 84       	ldd	r0, Z+8	; 0x08
    2bac:	f1 85       	ldd	r31, Z+9	; 0x09
    2bae:	e0 2d       	mov	r30, r0
    2bb0:	09 95       	icall
    2bb2:	89 2b       	or	r24, r25
    2bb4:	e1 f6       	brne	.-72     	; 0x2b6e <fputc+0x10>
    2bb6:	d8 01       	movw	r26, r16
    2bb8:	16 96       	adiw	r26, 0x06	; 6
    2bba:	8d 91       	ld	r24, X+
    2bbc:	9c 91       	ld	r25, X
    2bbe:	17 97       	sbiw	r26, 0x07	; 7
    2bc0:	01 96       	adiw	r24, 0x01	; 1
    2bc2:	17 96       	adiw	r26, 0x07	; 7
    2bc4:	9c 93       	st	X, r25
    2bc6:	8e 93       	st	-X, r24
    2bc8:	16 97       	sbiw	r26, 0x06	; 6
    2bca:	ce 01       	movw	r24, r28
    2bcc:	df 91       	pop	r29
    2bce:	cf 91       	pop	r28
    2bd0:	1f 91       	pop	r17
    2bd2:	0f 91       	pop	r16
    2bd4:	08 95       	ret

00002bd6 <__ultoa_invert>:
    2bd6:	fa 01       	movw	r30, r20
    2bd8:	aa 27       	eor	r26, r26
    2bda:	28 30       	cpi	r18, 0x08	; 8
    2bdc:	51 f1       	breq	.+84     	; 0x2c32 <__ultoa_invert+0x5c>
    2bde:	20 31       	cpi	r18, 0x10	; 16
    2be0:	81 f1       	breq	.+96     	; 0x2c42 <__ultoa_invert+0x6c>
    2be2:	e8 94       	clt
    2be4:	6f 93       	push	r22
    2be6:	6e 7f       	andi	r22, 0xFE	; 254
    2be8:	6e 5f       	subi	r22, 0xFE	; 254
    2bea:	7f 4f       	sbci	r23, 0xFF	; 255
    2bec:	8f 4f       	sbci	r24, 0xFF	; 255
    2bee:	9f 4f       	sbci	r25, 0xFF	; 255
    2bf0:	af 4f       	sbci	r26, 0xFF	; 255
    2bf2:	b1 e0       	ldi	r27, 0x01	; 1
    2bf4:	3e d0       	rcall	.+124    	; 0x2c72 <__ultoa_invert+0x9c>
    2bf6:	b4 e0       	ldi	r27, 0x04	; 4
    2bf8:	3c d0       	rcall	.+120    	; 0x2c72 <__ultoa_invert+0x9c>
    2bfa:	67 0f       	add	r22, r23
    2bfc:	78 1f       	adc	r23, r24
    2bfe:	89 1f       	adc	r24, r25
    2c00:	9a 1f       	adc	r25, r26
    2c02:	a1 1d       	adc	r26, r1
    2c04:	68 0f       	add	r22, r24
    2c06:	79 1f       	adc	r23, r25
    2c08:	8a 1f       	adc	r24, r26
    2c0a:	91 1d       	adc	r25, r1
    2c0c:	a1 1d       	adc	r26, r1
    2c0e:	6a 0f       	add	r22, r26
    2c10:	71 1d       	adc	r23, r1
    2c12:	81 1d       	adc	r24, r1
    2c14:	91 1d       	adc	r25, r1
    2c16:	a1 1d       	adc	r26, r1
    2c18:	20 d0       	rcall	.+64     	; 0x2c5a <__ultoa_invert+0x84>
    2c1a:	09 f4       	brne	.+2      	; 0x2c1e <__ultoa_invert+0x48>
    2c1c:	68 94       	set
    2c1e:	3f 91       	pop	r19
    2c20:	2a e0       	ldi	r18, 0x0A	; 10
    2c22:	26 9f       	mul	r18, r22
    2c24:	11 24       	eor	r1, r1
    2c26:	30 19       	sub	r19, r0
    2c28:	30 5d       	subi	r19, 0xD0	; 208
    2c2a:	31 93       	st	Z+, r19
    2c2c:	de f6       	brtc	.-74     	; 0x2be4 <__ultoa_invert+0xe>
    2c2e:	cf 01       	movw	r24, r30
    2c30:	08 95       	ret
    2c32:	46 2f       	mov	r20, r22
    2c34:	47 70       	andi	r20, 0x07	; 7
    2c36:	40 5d       	subi	r20, 0xD0	; 208
    2c38:	41 93       	st	Z+, r20
    2c3a:	b3 e0       	ldi	r27, 0x03	; 3
    2c3c:	0f d0       	rcall	.+30     	; 0x2c5c <__ultoa_invert+0x86>
    2c3e:	c9 f7       	brne	.-14     	; 0x2c32 <__ultoa_invert+0x5c>
    2c40:	f6 cf       	rjmp	.-20     	; 0x2c2e <__ultoa_invert+0x58>
    2c42:	46 2f       	mov	r20, r22
    2c44:	4f 70       	andi	r20, 0x0F	; 15
    2c46:	40 5d       	subi	r20, 0xD0	; 208
    2c48:	4a 33       	cpi	r20, 0x3A	; 58
    2c4a:	18 f0       	brcs	.+6      	; 0x2c52 <__ultoa_invert+0x7c>
    2c4c:	49 5d       	subi	r20, 0xD9	; 217
    2c4e:	31 fd       	sbrc	r19, 1
    2c50:	40 52       	subi	r20, 0x20	; 32
    2c52:	41 93       	st	Z+, r20
    2c54:	02 d0       	rcall	.+4      	; 0x2c5a <__ultoa_invert+0x84>
    2c56:	a9 f7       	brne	.-22     	; 0x2c42 <__ultoa_invert+0x6c>
    2c58:	ea cf       	rjmp	.-44     	; 0x2c2e <__ultoa_invert+0x58>
    2c5a:	b4 e0       	ldi	r27, 0x04	; 4
    2c5c:	a6 95       	lsr	r26
    2c5e:	97 95       	ror	r25
    2c60:	87 95       	ror	r24
    2c62:	77 95       	ror	r23
    2c64:	67 95       	ror	r22
    2c66:	ba 95       	dec	r27
    2c68:	c9 f7       	brne	.-14     	; 0x2c5c <__ultoa_invert+0x86>
    2c6a:	00 97       	sbiw	r24, 0x00	; 0
    2c6c:	61 05       	cpc	r22, r1
    2c6e:	71 05       	cpc	r23, r1
    2c70:	08 95       	ret
    2c72:	9b 01       	movw	r18, r22
    2c74:	ac 01       	movw	r20, r24
    2c76:	0a 2e       	mov	r0, r26
    2c78:	06 94       	lsr	r0
    2c7a:	57 95       	ror	r21
    2c7c:	47 95       	ror	r20
    2c7e:	37 95       	ror	r19
    2c80:	27 95       	ror	r18
    2c82:	ba 95       	dec	r27
    2c84:	c9 f7       	brne	.-14     	; 0x2c78 <__ultoa_invert+0xa2>
    2c86:	62 0f       	add	r22, r18
    2c88:	73 1f       	adc	r23, r19
    2c8a:	84 1f       	adc	r24, r20
    2c8c:	95 1f       	adc	r25, r21
    2c8e:	a0 1d       	adc	r26, r0
    2c90:	08 95       	ret

00002c92 <eeprom_read_word>:
    2c92:	a8 e1       	ldi	r26, 0x18	; 24
    2c94:	b0 e0       	ldi	r27, 0x00	; 0
    2c96:	42 e0       	ldi	r20, 0x02	; 2
    2c98:	50 e0       	ldi	r21, 0x00	; 0
    2c9a:	05 c0       	rjmp	.+10     	; 0x2ca6 <eeprom_read_blraw>

00002c9c <eeprom_write_word>:
    2c9c:	12 d0       	rcall	.+36     	; 0x2cc2 <eeprom_write_byte>
    2c9e:	27 2f       	mov	r18, r23
    2ca0:	11 c0       	rjmp	.+34     	; 0x2cc4 <eeprom_write_r18>

00002ca2 <eeprom_read_block>:
    2ca2:	dc 01       	movw	r26, r24
    2ca4:	cb 01       	movw	r24, r22

00002ca6 <eeprom_read_blraw>:
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	f9 99       	sbic	0x1f, 1	; 31
    2caa:	fe cf       	rjmp	.-4      	; 0x2ca8 <eeprom_read_blraw+0x2>
    2cac:	06 c0       	rjmp	.+12     	; 0x2cba <eeprom_read_blraw+0x14>
    2cae:	f2 bd       	out	0x22, r31	; 34
    2cb0:	e1 bd       	out	0x21, r30	; 33
    2cb2:	f8 9a       	sbi	0x1f, 0	; 31
    2cb4:	31 96       	adiw	r30, 0x01	; 1
    2cb6:	00 b4       	in	r0, 0x20	; 32
    2cb8:	0d 92       	st	X+, r0
    2cba:	41 50       	subi	r20, 0x01	; 1
    2cbc:	50 40       	sbci	r21, 0x00	; 0
    2cbe:	b8 f7       	brcc	.-18     	; 0x2cae <eeprom_read_blraw+0x8>
    2cc0:	08 95       	ret

00002cc2 <eeprom_write_byte>:
    2cc2:	26 2f       	mov	r18, r22

00002cc4 <eeprom_write_r18>:
    2cc4:	f9 99       	sbic	0x1f, 1	; 31
    2cc6:	fe cf       	rjmp	.-4      	; 0x2cc4 <eeprom_write_r18>
    2cc8:	92 bd       	out	0x22, r25	; 34
    2cca:	81 bd       	out	0x21, r24	; 33
    2ccc:	20 bd       	out	0x20, r18	; 32
    2cce:	0f b6       	in	r0, 0x3f	; 63
    2cd0:	f8 94       	cli
    2cd2:	fa 9a       	sbi	0x1f, 2	; 31
    2cd4:	f9 9a       	sbi	0x1f, 1	; 31
    2cd6:	0f be       	out	0x3f, r0	; 63
    2cd8:	01 96       	adiw	r24, 0x01	; 1
    2cda:	08 95       	ret

00002cdc <_exit>:
    2cdc:	f8 94       	cli

00002cde <__stop_program>:
    2cde:	ff cf       	rjmp	.-2      	; 0x2cde <__stop_program>
