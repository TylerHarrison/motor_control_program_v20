
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002dde  00002e72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dde  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f52  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f52  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fe0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00003020  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007172  00000000  00000000  000035d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001dec  00000000  00000000  0000a742  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003374  00000000  00000000  0000c52e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000109c  00000000  00000000  0000f8a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a07  00000000  00000000  00010940  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000469f  00000000  00000000  00012347  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  000169e6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 56 0d 	jmp	0x1aac	; 0x1aac <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 c5 0c 	jmp	0x198a	; 0x198a <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 06 0c 	jmp	0x180c	; 0x180c <__vector_16>
      44:	0c 94 45 11 	jmp	0x228a	; 0x228a <__vector_17>
      48:	0c 94 f6 0e 	jmp	0x1dec	; 0x1dec <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 f2 0a 	jmp	0x15e4	; 0x15e4 <__vector_21>
      58:	0c 94 d4 0a 	jmp	0x15a8	; 0x15a8 <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 2b 0b 	jmp	0x1656	; 0x1656 <__vector_32>
      84:	0c 94 0d 0b 	jmp	0x161a	; 0x161a <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	c8 0e       	add	r12, r24
      96:	cd 0e       	add	r12, r29
      98:	d3 0e       	add	r13, r19
      9a:	d9 0e       	add	r13, r25
      9c:	df 0e       	add	r13, r31
      9e:	e4 0e       	add	r14, r20
      a0:	ea 0e       	add	r14, r26
      a2:	f0 0e       	add	r15, r16

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	ee ed       	ldi	r30, 0xDE	; 222
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 6d 0b 	call	0x16da	; 0x16da <main>
      de:	0c 94 ed 16 	jmp	0x2dda	; 0x2dda <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	11 f0       	breq	.+4      	; 0x214 <actuator_pwm+0x8>
     210:	75 9a       	sbi	0x0e, 5	; 14
     212:	08 95       	ret
     214:	75 98       	cbi	0x0e, 5	; 14
     216:	08 95       	ret

00000218 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     218:	4f 92       	push	r4
     21a:	5f 92       	push	r5
     21c:	6f 92       	push	r6
     21e:	7f 92       	push	r7
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	ec 01       	movw	r28, r24
     238:	96 2e       	mov	r9, r22
     23a:	c6 01       	movw	r24, r12
     23c:	b5 01       	movw	r22, r10
			3) actuator_duty_cycle
			4) gear_status
*/

	float kp = 3.8; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     23e:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     242:	87 01       	movw	r16, r14
     244:	06 1b       	sub	r16, r22
     246:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     248:	b8 01       	movw	r22, r16
     24a:	01 2e       	mov	r0, r17
     24c:	00 0c       	add	r0, r0
     24e:	88 0b       	sbc	r24, r24
     250:	99 0b       	sbc	r25, r25
     252:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
     256:	2b 01       	movw	r4, r22
     258:	3c 01       	movw	r6, r24
     25a:	23 e3       	ldi	r18, 0x33	; 51
     25c:	33 e3       	ldi	r19, 0x33	; 51
     25e:	43 e7       	ldi	r20, 0x73	; 115
     260:	50 e4       	ldi	r21, 0x40	; 64
     262:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	45 e8       	ldi	r20, 0x85	; 133
     26c:	52 e4       	ldi	r21, 0x42	; 66
     26e:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     272:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     276:	6b 01       	movw	r12, r22
     278:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 ea       	ldi	r20, 0xA0	; 160
     280:	50 e4       	ldi	r21, 0x40	; 64
     282:	c3 01       	movw	r24, r6
     284:	b2 01       	movw	r22, r4
     286:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__cmpsf2>
     28a:	88 23       	and	r24, r24
     28c:	c4 f5       	brge	.+112    	; 0x2fe <actuator_set_position+0xe6>
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	40 ea       	ldi	r20, 0xA0	; 160
     294:	50 ec       	ldi	r21, 0xC0	; 192
     296:	c3 01       	movw	r24, r6
     298:	b2 01       	movw	r22, r4
     29a:	0e 94 35 13 	call	0x266a	; 0x266a <__gesf2>
     29e:	18 16       	cp	r1, r24
     2a0:	74 f5       	brge	.+92     	; 0x2fe <actuator_set_position+0xe6>
     2a2:	30 c0       	rjmp	.+96     	; 0x304 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2a4:	8c 81       	ldd	r24, Y+4	; 0x04
     2a6:	9d 81       	ldd	r25, Y+5	; 0x05
     2a8:	00 97       	sbiw	r24, 0x00	; 0
     2aa:	29 f0       	breq	.+10     	; 0x2b6 <actuator_set_position+0x9e>
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	89 f4       	brne	.+34     	; 0x2d2 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2b0:	1b 82       	std	Y+3, r1	; 0x03
     2b2:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2b4:	0e c0       	rjmp	.+28     	; 0x2d2 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2b6:	10 16       	cp	r1, r16
     2b8:	11 06       	cpc	r1, r17
     2ba:	2c f4       	brge	.+10     	; 0x2c6 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2c6:	11 23       	and	r17, r17
     2c8:	24 f4       	brge	.+8      	; 0x2d2 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2ca:	82 e0       	ldi	r24, 0x02	; 2
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	9b 83       	std	Y+3, r25	; 0x03
     2d0:	8a 83       	std	Y+2, r24	; 0x02
     2d2:	c6 01       	movw	r24, r12
     2d4:	83 38       	cpi	r24, 0x83	; 131
     2d6:	91 05       	cpc	r25, r1
     2d8:	14 f0       	brlt	.+4      	; 0x2de <actuator_set_position+0xc6>
     2da:	82 e8       	ldi	r24, 0x82	; 130
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	6c 01       	movw	r12, r24
     2e0:	99 23       	and	r25, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <actuator_set_position+0xd0>
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2e8:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2ec:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2f0:	db 86       	std	Y+11, r13	; 0x0b
     2f2:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2f4:	4e 82       	std	Y+6, r4	; 0x06
     2f6:	5f 82       	std	Y+7, r5	; 0x07
     2f8:	68 86       	std	Y+8, r6	; 0x08
     2fa:	79 86       	std	Y+9, r7	; 0x09
}
     2fc:	0c c0       	rjmp	.+24     	; 0x316 <actuator_set_position+0xfe>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		//new_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2fe:	1d 82       	std	Y+5, r1	; 0x05
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	d0 cf       	rjmp	.-96     	; 0x2a4 <actuator_set_position+0x8c>
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9d 83       	std	Y+5, r25	; 0x05
     30a:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     30c:	89 2d       	mov	r24, r9
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	99 83       	std	Y+1, r25	; 0x01
     312:	88 83       	st	Y, r24
     314:	c7 cf       	rjmp	.-114    	; 0x2a4 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	7f 90       	pop	r7
     32e:	6f 90       	pop	r6
     330:	5f 90       	pop	r5
     332:	4f 90       	pop	r4
     334:	08 95       	ret

00000336 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     336:	af 92       	push	r10
     338:	bf 92       	push	r11
     33a:	cf 92       	push	r12
     33c:	df 92       	push	r13
     33e:	ef 92       	push	r14
     340:	ff 92       	push	r15
     342:	0f 93       	push	r16
     344:	1f 93       	push	r17
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     34c:	8b a1       	ldd	r24, Y+35	; 0x23
     34e:	9c a1       	ldd	r25, Y+36	; 0x24
     350:	89 2b       	or	r24, r25
     352:	61 f1       	breq	.+88     	; 0x3ac <actuator_p_controller+0x76>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     354:	8b ad       	ldd	r24, Y+59	; 0x3b
     356:	81 30       	cpi	r24, 0x01	; 1
     358:	39 f0       	breq	.+14     	; 0x368 <actuator_p_controller+0x32>
     35a:	18 f0       	brcs	.+6      	; 0x362 <actuator_p_controller+0x2c>
     35c:	82 30       	cpi	r24, 0x02	; 2
     35e:	39 f0       	breq	.+14     	; 0x36e <actuator_p_controller+0x38>
     360:	09 c0       	rjmp	.+18     	; 0x374 <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     362:	ec a8       	ldd	r14, Y+52	; 0x34
     364:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     366:	08 c0       	rjmp	.+16     	; 0x378 <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     368:	ee a8       	ldd	r14, Y+54	; 0x36
     36a:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     36c:	05 c0       	rjmp	.+10     	; 0x378 <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     36e:	e8 ac       	ldd	r14, Y+56	; 0x38
     370:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     372:	02 c0       	rjmp	.+4      	; 0x378 <actuator_p_controller+0x42>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     374:	e1 2c       	mov	r14, r1
     376:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     378:	ab a4       	ldd	r10, Y+43	; 0x2b
     37a:	bc a4       	ldd	r11, Y+44	; 0x2c
     37c:	cd a4       	ldd	r12, Y+45	; 0x2d
     37e:	de a4       	ldd	r13, Y+46	; 0x2e
     380:	0f a5       	ldd	r16, Y+47	; 0x2f
     382:	2f a1       	ldd	r18, Y+39	; 0x27
     384:	38 a5       	ldd	r19, Y+40	; 0x28
     386:	49 a5       	ldd	r20, Y+41	; 0x29
     388:	5a a5       	ldd	r21, Y+42	; 0x2a
     38a:	6b ad       	ldd	r22, Y+59	; 0x3b
     38c:	10 e0       	ldi	r17, 0x00	; 0
     38e:	80 ee       	ldi	r24, 0xE0	; 224
     390:	91 e0       	ldi	r25, 0x01	; 1
     392:	42 df       	rcall	.-380    	; 0x218 <actuator_set_position>
		
		if (ActuatorComValues.actuator_in_position)
     394:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <__data_end+0x4>
     398:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <__data_end+0x5>
     39c:	89 2b       	or	r24, r25
     39e:	b1 f0       	breq	.+44     	; 0x3cc <actuator_p_controller+0x96>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     3a0:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     3a4:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     3a8:	8a af       	std	Y+58, r24	; 0x3a
     3aa:	10 c0       	rjmp	.+32     	; 0x3cc <actuator_p_controller+0x96>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     3ac:	ea a8       	ldd	r14, Y+50	; 0x32
     3ae:	fb a8       	ldd	r15, Y+51	; 0x33
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     3b0:	ab a4       	ldd	r10, Y+43	; 0x2b
     3b2:	bc a4       	ldd	r11, Y+44	; 0x2c
     3b4:	cd a4       	ldd	r12, Y+45	; 0x2d
     3b6:	de a4       	ldd	r13, Y+46	; 0x2e
     3b8:	0f a5       	ldd	r16, Y+47	; 0x2f
     3ba:	2f a1       	ldd	r18, Y+39	; 0x27
     3bc:	38 a5       	ldd	r19, Y+40	; 0x28
     3be:	49 a5       	ldd	r20, Y+41	; 0x29
     3c0:	5a a5       	ldd	r21, Y+42	; 0x2a
     3c2:	6b ad       	ldd	r22, Y+59	; 0x3b
     3c4:	10 e0       	ldi	r17, 0x00	; 0
     3c6:	80 ee       	ldi	r24, 0xE0	; 224
     3c8:	91 e0       	ldi	r25, 0x01	; 1
     3ca:	26 df       	rcall	.-436    	; 0x218 <actuator_set_position>

	}
}
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	08 95       	ret

000003e2 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3e2:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3e6:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3ea:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3ee:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3f2:	08 95       	ret

000003f4 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3f4:	68 2f       	mov	r22, r24
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
     400:	20 e0       	ldi	r18, 0x00	; 0
     402:	30 e0       	ldi	r19, 0x00	; 0
     404:	48 e4       	ldi	r20, 0x48	; 72
     406:	52 e4       	ldi	r21, 0x42	; 66
     408:	0e 94 81 11 	call	0x2302	; 0x2302 <__subsf3>
     40c:	27 ed       	ldi	r18, 0xD7	; 215
     40e:	33 ea       	ldi	r19, 0xA3	; 163
     410:	48 e8       	ldi	r20, 0x88	; 136
     412:	51 e4       	ldi	r21, 0x41	; 65
     414:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
     418:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     41c:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     420:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     424:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     428:	08 95       	ret

0000042a <controller>:
}

void controller(volatile ModuleValues_t *vals){
     42a:	8f 92       	push	r8
     42c:	9f 92       	push	r9
     42e:	af 92       	push	r10
     430:	bf 92       	push	r11
     432:	cf 92       	push	r12
     434:	df 92       	push	r13
     436:	ef 92       	push	r14
     438:	ff 92       	push	r15
     43a:	0f 93       	push	r16
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     444:	8e 8d       	ldd	r24, Y+30	; 0x1e
     446:	82 30       	cpi	r24, 0x02	; 2
     448:	21 f4       	brne	.+8      	; 0x452 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     44a:	68 8d       	ldd	r22, Y+24	; 0x18
     44c:	16 2f       	mov	r17, r22
     44e:	11 95       	neg	r17
     450:	01 c0       	rjmp	.+2      	; 0x454 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     452:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     454:	8e 8d       	ldd	r24, Y+30	; 0x1e
     456:	81 30       	cpi	r24, 0x01	; 1
     458:	09 f4       	brne	.+2      	; 0x45c <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     45a:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     45c:	89 a1       	ldd	r24, Y+33	; 0x21
     45e:	81 11       	cpse	r24, r1
     460:	7b c0       	rjmp	.+246    	; 0x558 <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     462:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     466:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     46a:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     46e:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     472:	20 e0       	ldi	r18, 0x00	; 0
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	4e eb       	ldi	r20, 0xBE	; 190
     478:	52 e4       	ldi	r21, 0x42	; 66
     47a:	c7 01       	movw	r24, r14
     47c:	b6 01       	movw	r22, r12
     47e:	0e 94 35 13 	call	0x266a	; 0x266a <__gesf2>
     482:	88 23       	and	r24, r24
     484:	54 f4       	brge	.+20     	; 0x49a <controller+0x70>
     486:	20 e0       	ldi	r18, 0x00	; 0
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	48 e4       	ldi	r20, 0x48	; 72
     48c:	52 e4       	ldi	r21, 0x42	; 66
     48e:	c7 01       	movw	r24, r14
     490:	b6 01       	movw	r22, r12
     492:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__cmpsf2>
     496:	18 16       	cp	r1, r24
     498:	6c f0       	brlt	.+26     	; 0x4b4 <controller+0x8a>
		{
			b_saturation = 1 ;
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4a0:	61 2f       	mov	r22, r17
     4a2:	11 0f       	add	r17, r17
     4a4:	77 0b       	sbc	r23, r23
     4a6:	88 0b       	sbc	r24, r24
     4a8:	99 0b       	sbc	r25, r25
     4aa:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
     4ae:	6b 01       	movw	r12, r22
     4b0:	7c 01       	movw	r14, r24
     4b2:	25 c0       	rjmp	.+74     	; 0x4fe <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     4b4:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4b8:	61 2f       	mov	r22, r17
     4ba:	11 0f       	add	r17, r17
     4bc:	77 0b       	sbc	r23, r23
     4be:	88 0b       	sbc	r24, r24
     4c0:	99 0b       	sbc	r25, r25
     4c2:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
     4c6:	6b 01       	movw	r12, r22
     4c8:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4ca:	2a e0       	ldi	r18, 0x0A	; 10
     4cc:	37 ed       	ldi	r19, 0xD7	; 215
     4ce:	43 ea       	ldi	r20, 0xA3	; 163
     4d0:	5b e3       	ldi	r21, 0x3B	; 59
     4d2:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     4d6:	9b 01       	movw	r18, r22
     4d8:	ac 01       	movw	r20, r24
     4da:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4de:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4e2:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4e6:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4ea:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     4ee:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4f2:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4f6:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     4fa:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     4fe:	27 ed       	ldi	r18, 0xD7	; 215
     500:	33 ea       	ldi	r19, 0xA3	; 163
     502:	48 e8       	ldi	r20, 0x88	; 136
     504:	51 e4       	ldi	r21, 0x41	; 65
     506:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     50a:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     50e:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     512:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     516:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     51a:	4b 01       	movw	r8, r22
     51c:	5c 01       	movw	r10, r24
     51e:	27 e8       	ldi	r18, 0x87	; 135
     520:	3f eb       	ldi	r19, 0xBF	; 191
     522:	46 e2       	ldi	r20, 0x26	; 38
     524:	5e e3       	ldi	r21, 0x3E	; 62
     526:	c7 01       	movw	r24, r14
     528:	b6 01       	movw	r22, r12
     52a:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     52e:	9b 01       	movw	r18, r22
     530:	ac 01       	movw	r20, r24
     532:	c5 01       	movw	r24, r10
     534:	b4 01       	movw	r22, r8
     536:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	48 e4       	ldi	r20, 0x48	; 72
     540:	52 e4       	ldi	r21, 0x42	; 66
     542:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     546:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     54a:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     54e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     552:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     556:	11 c0       	rjmp	.+34     	; 0x57a <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     558:	89 a1       	ldd	r24, Y+33	; 0x21
     55a:	81 30       	cpi	r24, 0x01	; 1
     55c:	71 f4       	brne	.+28     	; 0x57a <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     55e:	69 8d       	ldd	r22, Y+25	; 0x19
     560:	70 e0       	ldi	r23, 0x00	; 0
     562:	80 e0       	ldi	r24, 0x00	; 0
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     56a:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     56e:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     572:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     576:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     57a:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     57e:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     582:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     586:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     58a:	20 e0       	ldi	r18, 0x00	; 0
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	4e eb       	ldi	r20, 0xBE	; 190
     590:	52 e4       	ldi	r21, 0x42	; 66
     592:	c7 01       	movw	r24, r14
     594:	b6 01       	movw	r22, r12
     596:	0e 94 35 13 	call	0x266a	; 0x266a <__gesf2>
     59a:	18 16       	cp	r1, r24
     59c:	6c f4       	brge	.+26     	; 0x5b8 <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     59e:	80 e0       	ldi	r24, 0x00	; 0
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	ae eb       	ldi	r26, 0xBE	; 190
     5a4:	b2 e4       	ldi	r27, 0x42	; 66
     5a6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5aa:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5ae:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5b2:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     5b6:	16 c0       	rjmp	.+44     	; 0x5e4 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	48 e4       	ldi	r20, 0x48	; 72
     5be:	52 e4       	ldi	r21, 0x42	; 66
     5c0:	c7 01       	movw	r24, r14
     5c2:	b6 01       	movw	r22, r12
     5c4:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__cmpsf2>
     5c8:	88 23       	and	r24, r24
     5ca:	64 f4       	brge	.+24     	; 0x5e4 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	a8 e4       	ldi	r26, 0x48	; 72
     5d2:	b2 e4       	ldi	r27, 0x42	; 66
     5d4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5d8:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5dc:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5e0:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5e4:	06 e9       	ldi	r16, 0x96	; 150
     5e6:	10 e0       	ldi	r17, 0x00	; 0
     5e8:	f8 01       	movw	r30, r16
     5ea:	e0 80       	ld	r14, Z
     5ec:	f1 80       	ldd	r15, Z+1	; 0x01
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	48 ec       	ldi	r20, 0xC8	; 200
     5f4:	52 e4       	ldi	r21, 0x42	; 66
     5f6:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5fa:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5fe:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     602:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     606:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
     60a:	4b 01       	movw	r8, r22
     60c:	5c 01       	movw	r10, r24
     60e:	b7 01       	movw	r22, r14
     610:	80 e0       	ldi	r24, 0x00	; 0
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     618:	9b 01       	movw	r18, r22
     61a:	ac 01       	movw	r20, r24
     61c:	c5 01       	movw	r24, r10
     61e:	b4 01       	movw	r22, r8
     620:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     624:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     628:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     62c:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     630:	f8 01       	movw	r30, r16
     632:	60 81       	ld	r22, Z
     634:	71 81       	ldd	r23, Z+1	; 0x01
     636:	00 81       	ld	r16, Z
     638:	11 81       	ldd	r17, Z+1	; 0x01
     63a:	80 e0       	ldi	r24, 0x00	; 0
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     642:	6b 01       	movw	r12, r22
     644:	7c 01       	movw	r14, r24
     646:	20 e0       	ldi	r18, 0x00	; 0
     648:	30 e0       	ldi	r19, 0x00	; 0
     64a:	48 ec       	ldi	r20, 0xC8	; 200
     64c:	52 e4       	ldi	r21, 0x42	; 66
     64e:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     652:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     656:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     65a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     65e:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
     662:	4b 01       	movw	r8, r22
     664:	5c 01       	movw	r10, r24
     666:	b8 01       	movw	r22, r16
     668:	80 e0       	ldi	r24, 0x00	; 0
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     670:	9b 01       	movw	r18, r22
     672:	ac 01       	movw	r20, r24
     674:	c5 01       	movw	r24, r10
     676:	b4 01       	movw	r22, r8
     678:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     67c:	9b 01       	movw	r18, r22
     67e:	ac 01       	movw	r20, r24
     680:	c7 01       	movw	r24, r14
     682:	b6 01       	movw	r22, r12
     684:	0e 94 81 11 	call	0x2302	; 0x2302 <__subsf3>
     688:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     68c:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     690:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     694:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     698:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     69c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     6a0:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     6a4:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
     6a8:	69 8f       	std	Y+25, r22	; 0x19

}
     6aa:	df 91       	pop	r29
     6ac:	cf 91       	pop	r28
     6ae:	1f 91       	pop	r17
     6b0:	0f 91       	pop	r16
     6b2:	ff 90       	pop	r15
     6b4:	ef 90       	pop	r14
     6b6:	df 90       	pop	r13
     6b8:	cf 90       	pop	r12
     6ba:	bf 90       	pop	r11
     6bc:	af 90       	pop	r10
     6be:	9f 90       	pop	r9
     6c0:	8f 90       	pop	r8
     6c2:	08 95       	ret

000006c4 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6c4:	53 9a       	sbi	0x0a, 3	; 10
     6c6:	08 95       	ret

000006c8 <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6c8:	81 30       	cpi	r24, 0x01	; 1
     6ca:	11 f4       	brne	.+4      	; 0x6d0 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6cc:	5b 9a       	sbi	0x0b, 3	; 11
     6ce:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6d0:	5b 98       	cbi	0x0b, 3	; 11
     6d2:	08 95       	ret

000006d4 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6da:	6a ef       	ldi	r22, 0xFA	; 250
     6dc:	71 e0       	ldi	r23, 0x01	; 1
     6de:	80 e0       	ldi	r24, 0x00	; 0
     6e0:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6e4:	21 e0       	ldi	r18, 0x01	; 1
     6e6:	43 e0       	ldi	r20, 0x03	; 3
     6e8:	50 e0       	ldi	r21, 0x00	; 0
     6ea:	67 ef       	ldi	r22, 0xF7	; 247
     6ec:	71 e0       	ldi	r23, 0x01	; 1
     6ee:	8a ef       	ldi	r24, 0xFA	; 250
     6f0:	91 e0       	ldi	r25, 0x01	; 1
     6f2:	0e 94 21 11 	call	0x2242	; 0x2242 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6f6:	e7 ef       	ldi	r30, 0xF7	; 247
     6f8:	f1 e0       	ldi	r31, 0x01	; 1
     6fa:	61 81       	ldd	r22, Z+1	; 0x01
     6fc:	6f 71       	andi	r22, 0x1F	; 31
     6fe:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	76 2f       	mov	r23, r22
     704:	66 27       	eor	r22, r22
     706:	82 81       	ldd	r24, Z+2	; 0x02
     708:	68 2b       	or	r22, r24
     70a:	80 e0       	ldi	r24, 0x00	; 0
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	49 e8       	ldi	r20, 0x89	; 137
     718:	52 e4       	ldi	r21, 0x42	; 66
     71a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
     71e:	20 e0       	ldi	r18, 0x00	; 0
     720:	30 e0       	ldi	r19, 0x00	; 0
     722:	40 e2       	ldi	r20, 0x20	; 32
     724:	51 e4       	ldi	r21, 0x41	; 65
     726:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     72a:	20 e0       	ldi	r18, 0x00	; 0
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	48 e8       	ldi	r20, 0x88	; 136
     730:	51 e4       	ldi	r21, 0x41	; 65
     732:	0e 94 81 11 	call	0x2302	; 0x2302 <__subsf3>
     736:	20 e0       	ldi	r18, 0x00	; 0
     738:	30 e0       	ldi	r19, 0x00	; 0
     73a:	a9 01       	movw	r20, r18
     73c:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     740:	68 83       	st	Y, r22
     742:	79 83       	std	Y+1, r23	; 0x01
     744:	8a 83       	std	Y+2, r24	; 0x02
     746:	9b 83       	std	Y+3, r25	; 0x03
}
     748:	df 91       	pop	r29
     74a:	cf 91       	pop	r28
     74c:	08 95       	ret

0000074e <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     754:	6a ef       	ldi	r22, 0xFA	; 250
     756:	71 e0       	ldi	r23, 0x01	; 1
     758:	81 e0       	ldi	r24, 0x01	; 1
     75a:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     75e:	21 e0       	ldi	r18, 0x01	; 1
     760:	43 e0       	ldi	r20, 0x03	; 3
     762:	50 e0       	ldi	r21, 0x00	; 0
     764:	67 ef       	ldi	r22, 0xF7	; 247
     766:	71 e0       	ldi	r23, 0x01	; 1
     768:	8a ef       	ldi	r24, 0xFA	; 250
     76a:	91 e0       	ldi	r25, 0x01	; 1
     76c:	0e 94 21 11 	call	0x2242	; 0x2242 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     770:	e7 ef       	ldi	r30, 0xF7	; 247
     772:	f1 e0       	ldi	r31, 0x01	; 1
     774:	61 81       	ldd	r22, Z+1	; 0x01
     776:	6f 71       	andi	r22, 0x1F	; 31
     778:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     77a:	70 e0       	ldi	r23, 0x00	; 0
     77c:	76 2f       	mov	r23, r22
     77e:	66 27       	eor	r22, r22
     780:	82 81       	ldd	r24, Z+2	; 0x02
     782:	68 2b       	or	r22, r24
     784:	41 e0       	ldi	r20, 0x01	; 1
     786:	ce 01       	movw	r24, r28
     788:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <handle_current_sensor>
}
     78c:	df 91       	pop	r29
     78e:	cf 91       	pop	r28
     790:	08 95       	ret

00000792 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     798:	6a ef       	ldi	r22, 0xFA	; 250
     79a:	71 e0       	ldi	r23, 0x01	; 1
     79c:	84 e0       	ldi	r24, 0x04	; 4
     79e:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7a2:	21 e0       	ldi	r18, 0x01	; 1
     7a4:	43 e0       	ldi	r20, 0x03	; 3
     7a6:	50 e0       	ldi	r21, 0x00	; 0
     7a8:	67 ef       	ldi	r22, 0xF7	; 247
     7aa:	71 e0       	ldi	r23, 0x01	; 1
     7ac:	8a ef       	ldi	r24, 0xFA	; 250
     7ae:	91 e0       	ldi	r25, 0x01	; 1
     7b0:	0e 94 21 11 	call	0x2242	; 0x2242 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7b4:	e7 ef       	ldi	r30, 0xF7	; 247
     7b6:	f1 e0       	ldi	r31, 0x01	; 1
     7b8:	61 81       	ldd	r22, Z+1	; 0x01
     7ba:	6f 71       	andi	r22, 0x1F	; 31
     7bc:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7be:	70 e0       	ldi	r23, 0x00	; 0
     7c0:	76 2f       	mov	r23, r22
     7c2:	66 27       	eor	r22, r22
     7c4:	82 81       	ldd	r24, Z+2	; 0x02
     7c6:	68 2b       	or	r22, r24
     7c8:	ce 01       	movw	r24, r28
     7ca:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <handle_temp_sensor>
}
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	08 95       	ret

000007d4 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	cf 93       	push	r28
     7da:	df 93       	push	r29
     7dc:	00 d0       	rcall	.+0      	; 0x7de <SPI_handler_6+0xa>
     7de:	00 d0       	rcall	.+0      	; 0x7e0 <SPI_handler_6+0xc>
     7e0:	cd b7       	in	r28, 0x3d	; 61
     7e2:	de b7       	in	r29, 0x3e	; 62
     7e4:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7e6:	6a ef       	ldi	r22, 0xFA	; 250
     7e8:	71 e0       	ldi	r23, 0x01	; 1
     7ea:	86 e0       	ldi	r24, 0x06	; 6
     7ec:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7f0:	21 e0       	ldi	r18, 0x01	; 1
     7f2:	43 e0       	ldi	r20, 0x03	; 3
     7f4:	50 e0       	ldi	r21, 0x00	; 0
     7f6:	67 ef       	ldi	r22, 0xF7	; 247
     7f8:	71 e0       	ldi	r23, 0x01	; 1
     7fa:	8a ef       	ldi	r24, 0xFA	; 250
     7fc:	91 e0       	ldi	r25, 0x01	; 1
     7fe:	0e 94 21 11 	call	0x2242	; 0x2242 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     802:	e7 ef       	ldi	r30, 0xF7	; 247
     804:	f1 e0       	ldi	r31, 0x01	; 1
     806:	61 81       	ldd	r22, Z+1	; 0x01
     808:	6f 71       	andi	r22, 0x1F	; 31
     80a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     80c:	70 e0       	ldi	r23, 0x00	; 0
     80e:	76 2f       	mov	r23, r22
     810:	66 27       	eor	r22, r22
     812:	82 81       	ldd	r24, Z+2	; 0x02
     814:	68 2b       	or	r22, r24
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     81e:	20 e0       	ldi	r18, 0x00	; 0
     820:	30 e0       	ldi	r19, 0x00	; 0
     822:	40 ea       	ldi	r20, 0xA0	; 160
     824:	50 e4       	ldi	r21, 0x40	; 64
     826:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     82a:	20 e0       	ldi	r18, 0x00	; 0
     82c:	30 e0       	ldi	r19, 0x00	; 0
     82e:	40 e8       	ldi	r20, 0x80	; 128
     830:	59 e3       	ldi	r21, 0x39	; 57
     832:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     836:	69 83       	std	Y+1, r22	; 0x01
     838:	7a 83       	std	Y+2, r23	; 0x02
     83a:	8b 83       	std	Y+3, r24	; 0x03
     83c:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     83e:	69 81       	ldd	r22, Y+1	; 0x01
     840:	7a 81       	ldd	r23, Y+2	; 0x02
     842:	8b 81       	ldd	r24, Y+3	; 0x03
     844:	9c 81       	ldd	r25, Y+4	; 0x04
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	48 ec       	ldi	r20, 0xC8	; 200
     84c:	52 e4       	ldi	r21, 0x42	; 66
     84e:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     852:	20 e0       	ldi	r18, 0x00	; 0
     854:	30 e0       	ldi	r19, 0x00	; 0
     856:	48 ec       	ldi	r20, 0xC8	; 200
     858:	51 e4       	ldi	r21, 0x41	; 65
     85a:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
     85e:	f8 01       	movw	r30, r16
     860:	60 83       	st	Z, r22
     862:	71 83       	std	Z+1, r23	; 0x01
     864:	82 83       	std	Z+2, r24	; 0x02
     866:	93 83       	std	Z+3, r25	; 0x03
}
     868:	0f 90       	pop	r0
     86a:	0f 90       	pop	r0
     86c:	0f 90       	pop	r0
     86e:	0f 90       	pop	r0
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	08 95       	ret

0000087a <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     880:	6a ef       	ldi	r22, 0xFA	; 250
     882:	71 e0       	ldi	r23, 0x01	; 1
     884:	87 e0       	ldi	r24, 0x07	; 7
     886:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     88a:	21 e0       	ldi	r18, 0x01	; 1
     88c:	43 e0       	ldi	r20, 0x03	; 3
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	67 ef       	ldi	r22, 0xF7	; 247
     892:	71 e0       	ldi	r23, 0x01	; 1
     894:	8a ef       	ldi	r24, 0xFA	; 250
     896:	91 e0       	ldi	r25, 0x01	; 1
     898:	0e 94 21 11 	call	0x2242	; 0x2242 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     89c:	e7 ef       	ldi	r30, 0xF7	; 247
     89e:	f1 e0       	ldi	r31, 0x01	; 1
     8a0:	61 81       	ldd	r22, Z+1	; 0x01
     8a2:	6f 71       	andi	r22, 0x1F	; 31
     8a4:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     8a6:	70 e0       	ldi	r23, 0x00	; 0
     8a8:	76 2f       	mov	r23, r22
     8aa:	66 27       	eor	r22, r22
     8ac:	82 81       	ldd	r24, Z+2	; 0x02
     8ae:	68 2b       	or	r22, r24
     8b0:	40 e0       	ldi	r20, 0x00	; 0
     8b2:	ce 01       	movw	r24, r28
     8b4:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <handle_current_sensor>
}
     8b8:	df 91       	pop	r29
     8ba:	cf 91       	pop	r28
     8bc:	08 95       	ret

000008be <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	8c 01       	movw	r16, r24
     8c8:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8ca:	cb 01       	movw	r24, r22
     8cc:	0e 94 3c 10 	call	0x2078	; 0x2078 <can_read_message_if_new>
     8d0:	88 23       	and	r24, r24
     8d2:	09 f4       	brne	.+2      	; 0x8d6 <handle_can+0x18>
     8d4:	46 c0       	rjmp	.+140    	; 0x962 <handle_can+0xa4>
     8d6:	f8 01       	movw	r30, r16
     8d8:	86 8d       	ldd	r24, Z+30	; 0x1e
     8da:	84 30       	cpi	r24, 0x04	; 4
     8dc:	09 f4       	brne	.+2      	; 0x8e0 <handle_can+0x22>
     8de:	41 c0       	rjmp	.+130    	; 0x962 <handle_can+0xa4>
		switch (rx->id){
     8e0:	88 81       	ld	r24, Y
     8e2:	99 81       	ldd	r25, Y+1	; 0x01
     8e4:	80 32       	cpi	r24, 0x20	; 32
     8e6:	f1 e0       	ldi	r31, 0x01	; 1
     8e8:	9f 07       	cpc	r25, r31
     8ea:	91 f1       	breq	.+100    	; 0x950 <handle_can+0x92>
     8ec:	80 33       	cpi	r24, 0x30	; 48
     8ee:	92 40       	sbci	r25, 0x02	; 2
     8f0:	c1 f5       	brne	.+112    	; 0x962 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	f8 01       	movw	r30, r16
     8f6:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     8f8:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     8fa:	82 e3       	ldi	r24, 0x32	; 50
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	93 8f       	std	Z+27, r25	; 0x1b
     900:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     902:	8e 81       	ldd	r24, Y+6	; 0x06
     904:	89 30       	cpi	r24, 0x09	; 9
     906:	40 f0       	brcs	.+16     	; 0x918 <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     908:	86 95       	lsr	r24
     90a:	86 95       	lsr	r24
     90c:	86 95       	lsr	r24
     90e:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     910:	8e e1       	ldi	r24, 0x1E	; 30
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	95 8f       	std	Z+29, r25	; 0x1d
     916:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     918:	8f 81       	ldd	r24, Y+7	; 0x07
     91a:	89 30       	cpi	r24, 0x09	; 9
     91c:	88 f0       	brcs	.+34     	; 0x940 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     91e:	8d 81       	ldd	r24, Y+5	; 0x05
     920:	9d ec       	ldi	r25, 0xCD	; 205
     922:	89 9f       	mul	r24, r25
     924:	81 2d       	mov	r24, r1
     926:	11 24       	eor	r1, r1
     928:	86 95       	lsr	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	f8 01       	movw	r30, r16
     930:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     932:	8e e1       	ldi	r24, 0x1E	; 30
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	95 8f       	std	Z+29, r25	; 0x1d
     938:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     93a:	8f 81       	ldd	r24, Y+7	; 0x07
     93c:	89 30       	cpi	r24, 0x09	; 9
     93e:	10 f4       	brcc	.+4      	; 0x944 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     940:	f8 01       	movw	r30, r16
     942:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     944:	8e 81       	ldd	r24, Y+6	; 0x06
     946:	89 30       	cpi	r24, 0x09	; 9
     948:	60 f4       	brcc	.+24     	; 0x962 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     94a:	f8 01       	movw	r30, r16
     94c:	17 8a       	std	Z+23, r1	; 0x17
     94e:	09 c0       	rjmp	.+18     	; 0x962 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	f8 01       	movw	r30, r16
     954:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	9c 81       	ldd	r25, Y+4	; 0x04
     95a:	96 8b       	std	Z+22, r25	; 0x16
     95c:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     95e:	8d 81       	ldd	r24, Y+5	; 0x05
     960:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	08 95       	ret

0000096c <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     96c:	0f 93       	push	r16
     96e:	1f 93       	push	r17
     970:	cf 93       	push	r28
     972:	df 93       	push	r29
     974:	cd b7       	in	r28, 0x3d	; 61
     976:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     978:	08 eb       	ldi	r16, 0xB8	; 184
     97a:	13 e0       	ldi	r17, 0x03	; 3
     97c:	80 e5       	ldi	r24, 0x50	; 80
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	f8 01       	movw	r30, r16
     982:	91 83       	std	Z+1, r25	; 0x01
     984:	80 83       	st	Z, r24
	txFrame.length = 8;
     986:	88 e0       	ldi	r24, 0x08	; 8
     988:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     98a:	8d a1       	ldd	r24, Y+37	; 0x25
     98c:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     98e:	69 85       	ldd	r22, Y+9	; 0x09
     990:	7a 85       	ldd	r23, Y+10	; 0x0a
     992:	8b 85       	ldd	r24, Y+11	; 0x0b
     994:	9c 85       	ldd	r25, Y+12	; 0x0c
     996:	20 e0       	ldi	r18, 0x00	; 0
     998:	30 e0       	ldi	r19, 0x00	; 0
     99a:	40 e2       	ldi	r20, 0x20	; 32
     99c:	51 e4       	ldi	r21, 0x41	; 65
     99e:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     9a2:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     9a6:	f8 01       	movw	r30, r16
     9a8:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     9aa:	69 89       	ldd	r22, Y+17	; 0x11
     9ac:	7a 89       	ldd	r23, Y+18	; 0x12
     9ae:	8b 89       	ldd	r24, Y+19	; 0x13
     9b0:	9c 89       	ldd	r25, Y+20	; 0x14
     9b2:	20 e0       	ldi	r18, 0x00	; 0
     9b4:	30 e0       	ldi	r19, 0x00	; 0
     9b6:	40 e2       	ldi	r20, 0x20	; 32
     9b8:	51 e4       	ldi	r21, 0x41	; 65
     9ba:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     9be:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
     9c2:	f8 01       	movw	r30, r16
     9c4:	76 83       	std	Z+6, r23	; 0x06
     9c6:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9c8:	6d 89       	ldd	r22, Y+21	; 0x15
     9ca:	7e 89       	ldd	r23, Y+22	; 0x16
     9cc:	8f 89       	ldd	r24, Y+23	; 0x17
     9ce:	98 8d       	ldd	r25, Y+24	; 0x18
     9d0:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     9d4:	07 2e       	mov	r0, r23
     9d6:	00 0c       	add	r0, r0
     9d8:	88 0b       	sbc	r24, r24
     9da:	99 0b       	sbc	r25, r25
     9dc:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
     9e0:	20 e0       	ldi	r18, 0x00	; 0
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	48 ec       	ldi	r20, 0xC8	; 200
     9e6:	52 e4       	ldi	r21, 0x42	; 66
     9e8:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
     9ec:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     9f0:	9b 01       	movw	r18, r22
     9f2:	77 23       	and	r23, r23
     9f4:	24 f4       	brge	.+8      	; 0x9fe <handle_motor_status_can_msg+0x92>
     9f6:	22 27       	eor	r18, r18
     9f8:	33 27       	eor	r19, r19
     9fa:	26 1b       	sub	r18, r22
     9fc:	37 0b       	sbc	r19, r23
     9fe:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     a02:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     a06:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a08:	7b 8d       	ldd	r23, Y+27	; 0x1b
     a0a:	08 eb       	ldi	r16, 0xB8	; 184
     a0c:	13 e0       	ldi	r17, 0x03	; 3
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
     a16:	26 e6       	ldi	r18, 0x66	; 102
     a18:	36 e6       	ldi	r19, 0x66	; 102
     a1a:	46 e6       	ldi	r20, 0x66	; 102
     a1c:	50 e4       	ldi	r21, 0x40	; 64
     a1e:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     a22:	20 e0       	ldi	r18, 0x00	; 0
     a24:	30 e0       	ldi	r19, 0x00	; 0
     a26:	40 e0       	ldi	r20, 0x00	; 0
     a28:	5f e3       	ldi	r21, 0x3F	; 63
     a2a:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
     a2e:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
     a32:	f8 01       	movw	r30, r16
     a34:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a36:	89 8d       	ldd	r24, Y+25	; 0x19
     a38:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a3a:	c8 01       	movw	r24, r16
     a3c:	0e 94 7f 10 	call	0x20fe	; 0x20fe <can_send_message>
}
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	1f 91       	pop	r17
     a46:	0f 91       	pop	r16
     a48:	08 95       	ret

00000a4a <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a4a:	cf 93       	push	r28
     a4c:	df 93       	push	r29
     a4e:	cd b7       	in	r28, 0x3d	; 61
     a50:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a52:	ed ea       	ldi	r30, 0xAD	; 173
     a54:	f3 e0       	ldi	r31, 0x03	; 3
     a56:	81 e5       	ldi	r24, 0x51	; 81
     a58:	92 e0       	ldi	r25, 0x02	; 2
     a5a:	91 83       	std	Z+1, r25	; 0x01
     a5c:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a62:	21 96       	adiw	r28, 0x01	; 1
     a64:	8f ad       	ldd	r24, Y+63	; 0x3f
     a66:	21 97       	sbiw	r28, 0x01	; 1
     a68:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a6a:	cf 01       	movw	r24, r30
     a6c:	0e 94 7f 10 	call	0x20fe	; 0x20fe <can_send_message>
}
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	08 95       	ret

00000a76 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a76:	af 92       	push	r10
     a78:	bf 92       	push	r11
     a7a:	cf 92       	push	r12
     a7c:	df 92       	push	r13
     a7e:	ef 92       	push	r14
     a80:	ff 92       	push	r15
     a82:	0f 93       	push	r16
     a84:	1f 93       	push	r17
     a86:	cf 93       	push	r28
     a88:	df 93       	push	r29
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
     a8e:	66 97       	sbiw	r28, 0x16	; 22
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	f8 94       	cli
     a94:	de bf       	out	0x3e, r29	; 62
     a96:	0f be       	out	0x3f, r0	; 63
     a98:	cd bf       	out	0x3d, r28	; 61
     a9a:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     a9c:	fe 01       	movw	r30, r28
     a9e:	31 96       	adiw	r30, 0x01	; 1
     aa0:	96 e1       	ldi	r25, 0x16	; 22
     aa2:	df 01       	movw	r26, r30
     aa4:	1d 92       	st	X+, r1
     aa6:	9a 95       	dec	r25
     aa8:	e9 f7       	brne	.-6      	; 0xaa4 <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     aaa:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     aae:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     ab2:	92 1b       	sub	r25, r18
     ab4:	9f 71       	andi	r25, 0x1F	; 31
     ab6:	09 f4       	brne	.+2      	; 0xaba <receive_uart+0x44>
     ab8:	4e c1       	rjmp	.+668    	; 0xd56 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     aba:	f6 01       	movw	r30, r12
     abc:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     abe:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     ac0:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     ac2:	66 e1       	ldi	r22, 0x16	; 22
     ac4:	ce 01       	movw	r24, r28
     ac6:	01 96       	adiw	r24, 0x01	; 1
     ac8:	08 d5       	rcall	.+2576   	; 0x14da <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     aca:	ce 01       	movw	r24, r28
     acc:	01 96       	adiw	r24, 0x01	; 1
     ace:	0e 94 a5 13 	call	0x274a	; 0x274a <atoi>
     ad2:	5c 01       	movw	r10, r24
     ad4:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ad6:	d6 01       	movw	r26, r12
     ad8:	8d 91       	ld	r24, X+
     ada:	9c 91       	ld	r25, X
     adc:	89 2b       	or	r24, r25
     ade:	71 f4       	brne	.+28     	; 0xafc <receive_uart+0x86>
     ae0:	6f e4       	ldi	r22, 0x4F	; 79
     ae2:	71 e0       	ldi	r23, 0x01	; 1
     ae4:	ce 01       	movw	r24, r28
     ae6:	01 96       	adiw	r24, 0x01	; 1
     ae8:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     aec:	89 2b       	or	r24, r25
     aee:	31 f4       	brne	.+12     	; 0xafc <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     af0:	f6 01       	movw	r30, r12
     af2:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     af4:	81 e0       	ldi	r24, 0x01	; 1
     af6:	90 e0       	ldi	r25, 0x00	; 0
     af8:	91 83       	std	Z+1, r25	; 0x01
     afa:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     afc:	d6 01       	movw	r26, r12
     afe:	8d 91       	ld	r24, X+
     b00:	9c 91       	ld	r25, X
     b02:	89 2b       	or	r24, r25
     b04:	71 f0       	breq	.+28     	; 0xb22 <receive_uart+0xac>
     b06:	61 e6       	ldi	r22, 0x61	; 97
     b08:	71 e0       	ldi	r23, 0x01	; 1
     b0a:	ce 01       	movw	r24, r28
     b0c:	01 96       	adiw	r24, 0x01	; 1
     b0e:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     b12:	89 2b       	or	r24, r25
     b14:	31 f4       	brne	.+12     	; 0xb22 <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     b16:	f6 01       	movw	r30, r12
     b18:	11 82       	std	Z+1, r1	; 0x01
     b1a:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     b1c:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b1e:	15 8e       	std	Z+29, r1	; 0x1d
     b20:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b22:	62 e7       	ldi	r22, 0x72	; 114
     b24:	71 e0       	ldi	r23, 0x01	; 1
     b26:	ce 01       	movw	r24, r28
     b28:	01 96       	adiw	r24, 0x01	; 1
     b2a:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     b2e:	89 2b       	or	r24, r25
     b30:	11 f5       	brne	.+68     	; 0xb76 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b32:	d6 01       	movw	r26, r12
     b34:	94 96       	adiw	r26, 0x24	; 36
     b36:	1c 92       	st	X, r1
     b38:	1e 92       	st	-X, r1
     b3a:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b3c:	da 96       	adiw	r26, 0x3a	; 58
     b3e:	8c 91       	ld	r24, X
     b40:	81 30       	cpi	r24, 0x01	; 1
     b42:	51 f0       	breq	.+20     	; 0xb58 <receive_uart+0xe2>
     b44:	18 f0       	brcs	.+6      	; 0xb4c <receive_uart+0xd6>
     b46:	82 30       	cpi	r24, 0x02	; 2
     b48:	89 f0       	breq	.+34     	; 0xb6c <receive_uart+0xf6>
     b4a:	15 c0       	rjmp	.+42     	; 0xb76 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b4c:	f6 01       	movw	r30, r12
     b4e:	84 a9       	ldd	r24, Z+52	; 0x34
     b50:	95 a9       	ldd	r25, Z+53	; 0x35
     b52:	93 ab       	std	Z+51, r25	; 0x33
     b54:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b56:	0f c0       	rjmp	.+30     	; 0xb76 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b58:	d6 01       	movw	r26, r12
     b5a:	d6 96       	adiw	r26, 0x36	; 54
     b5c:	8d 91       	ld	r24, X+
     b5e:	9c 91       	ld	r25, X
     b60:	d7 97       	sbiw	r26, 0x37	; 55
     b62:	d3 96       	adiw	r26, 0x33	; 51
     b64:	9c 93       	st	X, r25
     b66:	8e 93       	st	-X, r24
     b68:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b6a:	05 c0       	rjmp	.+10     	; 0xb76 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b6c:	f6 01       	movw	r30, r12
     b6e:	80 ad       	ldd	r24, Z+56	; 0x38
     b70:	91 ad       	ldd	r25, Z+57	; 0x39
     b72:	93 ab       	std	Z+51, r25	; 0x33
     b74:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b76:	65 e8       	ldi	r22, 0x85	; 133
     b78:	71 e0       	ldi	r23, 0x01	; 1
     b7a:	ce 01       	movw	r24, r28
     b7c:	01 96       	adiw	r24, 0x01	; 1
     b7e:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     b82:	89 2b       	or	r24, r25
     b84:	39 f4       	brne	.+14     	; 0xb94 <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	90 e0       	ldi	r25, 0x00	; 0
     b8a:	d6 01       	movw	r26, r12
     b8c:	94 96       	adiw	r26, 0x24	; 36
     b8e:	9c 93       	st	X, r25
     b90:	8e 93       	st	-X, r24
     b92:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b94:	f6 01       	movw	r30, r12
     b96:	80 81       	ld	r24, Z
     b98:	91 81       	ldd	r25, Z+1	; 0x01
     b9a:	89 2b       	or	r24, r25
     b9c:	39 f0       	breq	.+14     	; 0xbac <receive_uart+0x136>
     b9e:	c5 01       	movw	r24, r10
     ba0:	0b 97       	sbiw	r24, 0x0b	; 11
     ba2:	0a 97       	sbiw	r24, 0x0a	; 10
     ba4:	18 f4       	brcc	.+6      	; 0xbac <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     ba6:	86 ef       	ldi	r24, 0xF6	; 246
     ba8:	8a 0d       	add	r24, r10
     baa:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     bac:	d6 01       	movw	r26, r12
     bae:	8d 91       	ld	r24, X+
     bb0:	9c 91       	ld	r25, X
     bb2:	11 97       	sbiw	r26, 0x01	; 1
     bb4:	89 2b       	or	r24, r25
     bb6:	39 f0       	breq	.+14     	; 0xbc6 <receive_uart+0x150>
     bb8:	0a 30       	cpi	r16, 0x0A	; 10
     bba:	11 05       	cpc	r17, r1
     bbc:	20 f4       	brcc	.+8      	; 0xbc6 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     bbe:	8a e0       	ldi	r24, 0x0A	; 10
     bc0:	8a 19       	sub	r24, r10
     bc2:	58 96       	adiw	r26, 0x18	; 24
     bc4:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     bc6:	f6 01       	movw	r30, r12
     bc8:	80 81       	ld	r24, Z
     bca:	91 81       	ldd	r25, Z+1	; 0x01
     bcc:	89 2b       	or	r24, r25
     bce:	31 f0       	breq	.+12     	; 0xbdc <receive_uart+0x166>
     bd0:	01 2b       	or	r16, r17
     bd2:	21 f4       	brne	.+8      	; 0xbdc <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bd4:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bd6:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bd8:	82 e3       	ldi	r24, 0x32	; 50
     bda:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bdc:	d6 01       	movw	r26, r12
     bde:	93 96       	adiw	r26, 0x23	; 35
     be0:	8d 91       	ld	r24, X+
     be2:	9c 91       	ld	r25, X
     be4:	94 97       	sbiw	r26, 0x24	; 36
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	51 f4       	brne	.+20     	; 0xbfe <receive_uart+0x188>
     bea:	67 e9       	ldi	r22, 0x97	; 151
     bec:	71 e0       	ldi	r23, 0x01	; 1
     bee:	ce 01       	movw	r24, r28
     bf0:	01 96       	adiw	r24, 0x01	; 1
     bf2:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     bf6:	89 2b       	or	r24, r25
     bf8:	11 f4       	brne	.+4      	; 0xbfe <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     bfa:	f6 01       	movw	r30, r12
     bfc:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     bfe:	d6 01       	movw	r26, r12
     c00:	93 96       	adiw	r26, 0x23	; 35
     c02:	8d 91       	ld	r24, X+
     c04:	9c 91       	ld	r25, X
     c06:	94 97       	sbiw	r26, 0x24	; 36
     c08:	01 97       	sbiw	r24, 0x01	; 1
     c0a:	59 f4       	brne	.+22     	; 0xc22 <receive_uart+0x1ac>
     c0c:	69 e9       	ldi	r22, 0x99	; 153
     c0e:	71 e0       	ldi	r23, 0x01	; 1
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     c18:	89 2b       	or	r24, r25
     c1a:	19 f4       	brne	.+6      	; 0xc22 <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     c1c:	81 e0       	ldi	r24, 0x01	; 1
     c1e:	f6 01       	movw	r30, r12
     c20:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c22:	d6 01       	movw	r26, r12
     c24:	93 96       	adiw	r26, 0x23	; 35
     c26:	8d 91       	ld	r24, X+
     c28:	9c 91       	ld	r25, X
     c2a:	94 97       	sbiw	r26, 0x24	; 36
     c2c:	01 97       	sbiw	r24, 0x01	; 1
     c2e:	59 f4       	brne	.+22     	; 0xc46 <receive_uart+0x1d0>
     c30:	65 eb       	ldi	r22, 0xB5	; 181
     c32:	71 e0       	ldi	r23, 0x01	; 1
     c34:	ce 01       	movw	r24, r28
     c36:	01 96       	adiw	r24, 0x01	; 1
     c38:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     c3c:	89 2b       	or	r24, r25
     c3e:	19 f4       	brne	.+6      	; 0xc46 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c40:	82 e0       	ldi	r24, 0x02	; 2
     c42:	f6 01       	movw	r30, r12
     c44:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c46:	d6 01       	movw	r26, r12
     c48:	93 96       	adiw	r26, 0x23	; 35
     c4a:	8d 91       	ld	r24, X+
     c4c:	9c 91       	ld	r25, X
     c4e:	94 97       	sbiw	r26, 0x24	; 36
     c50:	89 2b       	or	r24, r25
     c52:	59 f4       	brne	.+22     	; 0xc6a <receive_uart+0x1f4>
     c54:	6b e9       	ldi	r22, 0x9B	; 155
     c56:	71 e0       	ldi	r23, 0x01	; 1
     c58:	ce 01       	movw	r24, r28
     c5a:	01 96       	adiw	r24, 0x01	; 1
     c5c:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     c60:	89 2b       	or	r24, r25
     c62:	19 f4       	brne	.+6      	; 0xc6a <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	d1 da       	rcall	.-2654   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c6a:	f6 01       	movw	r30, r12
     c6c:	83 a1       	ldd	r24, Z+35	; 0x23
     c6e:	94 a1       	ldd	r25, Z+36	; 0x24
     c70:	89 2b       	or	r24, r25
     c72:	59 f4       	brne	.+22     	; 0xc8a <receive_uart+0x214>
     c74:	63 ea       	ldi	r22, 0xA3	; 163
     c76:	71 e0       	ldi	r23, 0x01	; 1
     c78:	ce 01       	movw	r24, r28
     c7a:	01 96       	adiw	r24, 0x01	; 1
     c7c:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     c80:	89 2b       	or	r24, r25
     c82:	19 f4       	brne	.+6      	; 0xc8a <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	c1 da       	rcall	.-2686   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c8a:	d6 01       	movw	r26, r12
     c8c:	93 96       	adiw	r26, 0x23	; 35
     c8e:	8d 91       	ld	r24, X+
     c90:	9c 91       	ld	r25, X
     c92:	94 97       	sbiw	r26, 0x24	; 36
     c94:	89 2b       	or	r24, r25
     c96:	a9 f4       	brne	.+42     	; 0xcc2 <receive_uart+0x24c>
     c98:	69 ea       	ldi	r22, 0xA9	; 169
     c9a:	71 e0       	ldi	r23, 0x01	; 1
     c9c:	ce 01       	movw	r24, r28
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     ca4:	89 2b       	or	r24, r25
     ca6:	69 f4       	brne	.+26     	; 0xcc2 <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     ca8:	f6 01       	movw	r30, r12
     caa:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cac:	e0 ac       	ldd	r14, Z+56	; 0x38
     cae:	f1 ac       	ldd	r15, Z+57	; 0x39
     cb0:	06 a9       	ldd	r16, Z+54	; 0x36
     cb2:	17 a9       	ldd	r17, Z+55	; 0x37
     cb4:	24 a9       	ldd	r18, Z+52	; 0x34
     cb6:	35 a9       	ldd	r19, Z+53	; 0x35
     cb8:	42 a9       	ldd	r20, Z+50	; 0x32
     cba:	53 a9       	ldd	r21, Z+51	; 0x33
     cbc:	62 ad       	ldd	r22, Z+58	; 0x3a
     cbe:	83 ad       	ldd	r24, Z+59	; 0x3b
     cc0:	72 da       	rcall	.-2844   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     cc2:	d6 01       	movw	r26, r12
     cc4:	93 96       	adiw	r26, 0x23	; 35
     cc6:	8d 91       	ld	r24, X+
     cc8:	9c 91       	ld	r25, X
     cca:	94 97       	sbiw	r26, 0x24	; 36
     ccc:	89 2b       	or	r24, r25
     cce:	b1 f4       	brne	.+44     	; 0xcfc <receive_uart+0x286>
     cd0:	67 eb       	ldi	r22, 0xB7	; 183
     cd2:	71 e0       	ldi	r23, 0x01	; 1
     cd4:	ce 01       	movw	r24, r28
     cd6:	01 96       	adiw	r24, 0x01	; 1
     cd8:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     cdc:	89 2b       	or	r24, r25
     cde:	71 f4       	brne	.+28     	; 0xcfc <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	f6 01       	movw	r30, r12
     ce4:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     ce6:	e0 ac       	ldd	r14, Z+56	; 0x38
     ce8:	f1 ac       	ldd	r15, Z+57	; 0x39
     cea:	06 a9       	ldd	r16, Z+54	; 0x36
     cec:	17 a9       	ldd	r17, Z+55	; 0x37
     cee:	24 a9       	ldd	r18, Z+52	; 0x34
     cf0:	35 a9       	ldd	r19, Z+53	; 0x35
     cf2:	42 a9       	ldd	r20, Z+50	; 0x32
     cf4:	53 a9       	ldd	r21, Z+51	; 0x33
     cf6:	62 ad       	ldd	r22, Z+58	; 0x3a
     cf8:	83 ad       	ldd	r24, Z+59	; 0x3b
     cfa:	55 da       	rcall	.-2902   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cfc:	d6 01       	movw	r26, r12
     cfe:	93 96       	adiw	r26, 0x23	; 35
     d00:	8d 91       	ld	r24, X+
     d02:	9c 91       	ld	r25, X
     d04:	94 97       	sbiw	r26, 0x24	; 36
     d06:	89 2b       	or	r24, r25
     d08:	b1 f4       	brne	.+44     	; 0xd36 <receive_uart+0x2c0>
     d0a:	67 ec       	ldi	r22, 0xC7	; 199
     d0c:	71 e0       	ldi	r23, 0x01	; 1
     d0e:	ce 01       	movw	r24, r28
     d10:	01 96       	adiw	r24, 0x01	; 1
     d12:	0e 94 c2 13 	call	0x2784	; 0x2784 <strcmp>
     d16:	89 2b       	or	r24, r25
     d18:	71 f4       	brne	.+28     	; 0xd36 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     d1a:	82 e0       	ldi	r24, 0x02	; 2
     d1c:	f6 01       	movw	r30, r12
     d1e:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d20:	e0 ac       	ldd	r14, Z+56	; 0x38
     d22:	f1 ac       	ldd	r15, Z+57	; 0x39
     d24:	06 a9       	ldd	r16, Z+54	; 0x36
     d26:	17 a9       	ldd	r17, Z+55	; 0x37
     d28:	24 a9       	ldd	r18, Z+52	; 0x34
     d2a:	35 a9       	ldd	r19, Z+53	; 0x35
     d2c:	42 a9       	ldd	r20, Z+50	; 0x32
     d2e:	53 a9       	ldd	r21, Z+51	; 0x33
     d30:	62 ad       	ldd	r22, Z+58	; 0x3a
     d32:	83 ad       	ldd	r24, Z+59	; 0x3b
     d34:	38 da       	rcall	.-2960   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d36:	d6 01       	movw	r26, r12
     d38:	93 96       	adiw	r26, 0x23	; 35
     d3a:	8d 91       	ld	r24, X+
     d3c:	9c 91       	ld	r25, X
     d3e:	94 97       	sbiw	r26, 0x24	; 36
     d40:	89 2b       	or	r24, r25
     d42:	41 f4       	brne	.+16     	; 0xd54 <receive_uart+0x2de>
     d44:	c5 01       	movw	r24, r10
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	87 3e       	cpi	r24, 0xE7	; 231
     d4a:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d4c:	18 f4       	brcc	.+6      	; 0xd54 <receive_uart+0x2de>
     d4e:	f6 01       	movw	r30, r12
     d50:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d52:	a2 aa       	std	Z+50, r10	; 0x32
     d54:	78 d3       	rcall	.+1776   	; 0x1446 <uart0_flush>
	}
}
     d56:	66 96       	adiw	r28, 0x16	; 22
     d58:	0f b6       	in	r0, 0x3f	; 63
     d5a:	f8 94       	cli
     d5c:	de bf       	out	0x3e, r29	; 62
     d5e:	0f be       	out	0x3f, r0	; 63
     d60:	cd bf       	out	0x3d, r28	; 61
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	1f 91       	pop	r17
     d68:	0f 91       	pop	r16
     d6a:	ff 90       	pop	r15
     d6c:	ef 90       	pop	r14
     d6e:	df 90       	pop	r13
     d70:	cf 90       	pop	r12
     d72:	bf 90       	pop	r11
     d74:	af 90       	pop	r10
     d76:	08 95       	ret

00000d78 <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d78:	ef 92       	push	r14
     d7a:	ff 92       	push	r15
     d7c:	0f 93       	push	r16
     d7e:	1f 93       	push	r17
     d80:	cf 93       	push	r28
     d82:	df 93       	push	r29
     d84:	cd b7       	in	r28, 0x3d	; 61
     d86:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d88:	88 ed       	ldi	r24, 0xD8	; 216
     d8a:	91 e0       	ldi	r25, 0x01	; 1
     d8c:	0e 94 eb 13 	call	0x27d6	; 0x27d6 <puts>
	printf("%i", (int16_t)vals.actuator_in_position);
     d90:	8e a5       	ldd	r24, Y+46	; 0x2e
     d92:	9f a5       	ldd	r25, Y+47	; 0x2f
     d94:	9f 93       	push	r25
     d96:	8f 93       	push	r24
     d98:	0f 2e       	mov	r0, r31
     d9a:	fa ed       	ldi	r31, 0xDA	; 218
     d9c:	ef 2e       	mov	r14, r31
     d9e:	f1 e0       	ldi	r31, 0x01	; 1
     da0:	ff 2e       	mov	r15, r31
     da2:	f0 2d       	mov	r31, r0
     da4:	ff 92       	push	r15
     da6:	ef 92       	push	r14
     da8:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     dac:	8c e2       	ldi	r24, 0x2C	; 44
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u", vals.gear_required);
     db4:	25 96       	adiw	r28, 0x05	; 5
     db6:	8f ad       	ldd	r24, Y+63	; 0x3f
     db8:	25 97       	sbiw	r28, 0x05	; 5
     dba:	1f 92       	push	r1
     dbc:	8f 93       	push	r24
     dbe:	0d ed       	ldi	r16, 0xDD	; 221
     dc0:	11 e0       	ldi	r17, 0x01	; 1
     dc2:	1f 93       	push	r17
     dc4:	0f 93       	push	r16
     dc6:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     dca:	8c e2       	ldi	r24, 0x2C	; 44
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.gear_status);
     dd2:	24 96       	adiw	r28, 0x04	; 4
     dd4:	8f ad       	ldd	r24, Y+63	; 0x3f
     dd6:	24 97       	sbiw	r28, 0x04	; 4
     dd8:	1f 92       	push	r1
     dda:	8f 93       	push	r24
     ddc:	1f 93       	push	r17
     dde:	0f 93       	push	r16
     de0:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     de4:	8c e2       	ldi	r24, 0x2C	; 44
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u", vals.motor_status);
     dec:	8f a1       	ldd	r24, Y+39	; 0x27
     dee:	1f 92       	push	r1
     df0:	8f 93       	push	r24
     df2:	1f 93       	push	r17
     df4:	0f 93       	push	r16
     df6:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     dfa:	8c e2       	ldi	r24, 0x2C	; 44
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.message_mode);
     e02:	88 a5       	ldd	r24, Y+40	; 0x28
     e04:	1f 92       	push	r1
     e06:	8f 93       	push	r24
     e08:	1f 93       	push	r17
     e0a:	0f 93       	push	r16
     e0c:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     e10:	8c e2       	ldi	r24, 0x2C	; 44
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.u8_duty_cycle);
     e18:	8a a1       	ldd	r24, Y+34	; 0x22
     e1a:	1f 92       	push	r1
     e1c:	8f 93       	push	r24
     e1e:	1f 93       	push	r17
     e20:	0f 93       	push	r16
     e22:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     e26:	8c e2       	ldi	r24, 0x2C	; 44
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e2e:	6b 89       	ldd	r22, Y+19	; 0x13
     e30:	7c 89       	ldd	r23, Y+20	; 0x14
     e32:	8d 89       	ldd	r24, Y+21	; 0x15
     e34:	9e 89       	ldd	r25, Y+22	; 0x16
     e36:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     e3a:	7f 93       	push	r23
     e3c:	6f 93       	push	r22
     e3e:	ff 92       	push	r15
     e40:	ef 92       	push	r14
     e42:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     e46:	8c e2       	ldi	r24, 0x2C	; 44
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e4e:	6c a9       	ldd	r22, Y+52	; 0x34
     e50:	7d a9       	ldd	r23, Y+53	; 0x35
     e52:	8e a9       	ldd	r24, Y+54	; 0x36
     e54:	9f a9       	ldd	r25, Y+55	; 0x37
     e56:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     e5a:	7f 93       	push	r23
     e5c:	6f 93       	push	r22
     e5e:	ff 92       	push	r15
     e60:	ef 92       	push	r14
     e62:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     e66:	0f b6       	in	r0, 0x3f	; 63
     e68:	f8 94       	cli
     e6a:	de bf       	out	0x3e, r29	; 62
     e6c:	0f be       	out	0x3f, r0	; 63
     e6e:	cd bf       	out	0x3d, r28	; 61
     e70:	8c e2       	ldi	r24, 0x2C	; 44
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e78:	89 85       	ldd	r24, Y+9	; 0x09
     e7a:	9a 85       	ldd	r25, Y+10	; 0x0a
     e7c:	9f 93       	push	r25
     e7e:	8f 93       	push	r24
     e80:	ff 92       	push	r15
     e82:	ef 92       	push	r14
     e84:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     e88:	8c e2       	ldi	r24, 0x2C	; 44
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%i",vals.clutch_enabled);
     e90:	8c a5       	ldd	r24, Y+44	; 0x2c
     e92:	9d a5       	ldd	r25, Y+45	; 0x2d
     e94:	9f 93       	push	r25
     e96:	8f 93       	push	r24
     e98:	ff 92       	push	r15
     e9a:	ef 92       	push	r14
     e9c:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     ea0:	8c e2       	ldi	r24, 0x2C	; 44
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.position_neutral);
     ea8:	8d ad       	ldd	r24, Y+61	; 0x3d
     eaa:	9e ad       	ldd	r25, Y+62	; 0x3e
     eac:	9f 93       	push	r25
     eae:	8f 93       	push	r24
     eb0:	1f 93       	push	r17
     eb2:	0f 93       	push	r16
     eb4:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     eb8:	8c e2       	ldi	r24, 0x2C	; 44
     eba:	90 e0       	ldi	r25, 0x00	; 0
     ebc:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.position_gear_1);
     ec0:	21 96       	adiw	r28, 0x01	; 1
     ec2:	8e ad       	ldd	r24, Y+62	; 0x3e
     ec4:	9f ad       	ldd	r25, Y+63	; 0x3f
     ec6:	21 97       	sbiw	r28, 0x01	; 1
     ec8:	9f 93       	push	r25
     eca:	8f 93       	push	r24
     ecc:	1f 93       	push	r17
     ece:	0f 93       	push	r16
     ed0:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     ed4:	8c e2       	ldi	r24, 0x2C	; 44
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%u",vals.position_gear_2);	
     edc:	23 96       	adiw	r28, 0x03	; 3
     ede:	8e ad       	ldd	r24, Y+62	; 0x3e
     ee0:	9f ad       	ldd	r25, Y+63	; 0x3f
     ee2:	23 97       	sbiw	r28, 0x03	; 3
     ee4:	9f 93       	push	r25
     ee6:	8f 93       	push	r24
     ee8:	1f 93       	push	r17
     eea:	0f 93       	push	r16
     eec:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     ef0:	8c e2       	ldi	r24, 0x2C	; 44
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     ef8:	88 ad       	ldd	r24, Y+56	; 0x38
     efa:	1f 92       	push	r1
     efc:	8f 93       	push	r24
     efe:	ff 92       	push	r15
     f00:	ef 92       	push	r14
     f02:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	printf(",");
     f06:	8c e2       	ldi	r24, 0x2C	; 44
     f08:	90 e0       	ldi	r25, 0x00	; 0
     f0a:	0e 94 e6 13 	call	0x27cc	; 0x27cc <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     f0e:	68 a9       	ldd	r22, Y+48	; 0x30
     f10:	79 a9       	ldd	r23, Y+49	; 0x31
     f12:	8a a9       	ldd	r24, Y+50	; 0x32
     f14:	9b a9       	ldd	r25, Y+51	; 0x33
     f16:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
     f1a:	7f 93       	push	r23
     f1c:	6f 93       	push	r22
     f1e:	ff 92       	push	r15
     f20:	ef 92       	push	r14
     f22:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <printf>
	
}
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	0f be       	out	0x3f, r0	; 63
     f2e:	cd bf       	out	0x3d, r28	; 61
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	1f 91       	pop	r17
     f36:	0f 91       	pop	r16
     f38:	ff 90       	pop	r15
     f3a:	ef 90       	pop	r14
     f3c:	08 95       	ret

00000f3e <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	cd b7       	in	r28, 0x3d	; 61
     f44:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f46:	8b a1       	ldd	r24, Y+35	; 0x23
     f48:	82 30       	cpi	r24, 0x02	; 2
     f4a:	91 f1       	breq	.+100    	; 0xfb0 <manage_LEDs+0x72>
     f4c:	28 f4       	brcc	.+10     	; 0xf58 <manage_LEDs+0x1a>
     f4e:	88 23       	and	r24, r24
     f50:	49 f0       	breq	.+18     	; 0xf64 <manage_LEDs+0x26>
     f52:	81 30       	cpi	r24, 0x01	; 1
     f54:	19 f1       	breq	.+70     	; 0xf9c <manage_LEDs+0x5e>
     f56:	49 c0       	rjmp	.+146    	; 0xfea <manage_LEDs+0xac>
     f58:	84 30       	cpi	r24, 0x04	; 4
     f5a:	f1 f1       	breq	.+124    	; 0xfd8 <manage_LEDs+0x9a>
     f5c:	98 f1       	brcs	.+102    	; 0xfc4 <manage_LEDs+0x86>
     f5e:	85 30       	cpi	r24, 0x05	; 5
     f60:	99 f0       	breq	.+38     	; 0xf88 <manage_LEDs+0x4a>
     f62:	43 c0       	rjmp	.+134    	; 0xfea <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f64:	80 e4       	ldi	r24, 0x40	; 64
     f66:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f6a:	80 e8       	ldi	r24, 0x80	; 128
     f6c:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f70:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f72:	98 a1       	ldd	r25, Y+32	; 0x20
     f74:	89 2b       	or	r24, r25
     f76:	21 f4       	brne	.+8      	; 0xf80 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f78:	80 e2       	ldi	r24, 0x20	; 32
     f7a:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
     f7e:	35 c0       	rjmp	.+106    	; 0xfea <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f80:	80 e2       	ldi	r24, 0x20	; 32
     f82:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
     f86:	31 c0       	rjmp	.+98     	; 0xfea <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f88:	80 e2       	ldi	r24, 0x20	; 32
     f8a:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f8e:	80 e4       	ldi	r24, 0x40	; 64
     f90:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     f94:	80 e8       	ldi	r24, 0x80	; 128
     f96:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
		break ;
     f9a:	27 c0       	rjmp	.+78     	; 0xfea <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     f9c:	80 e2       	ldi	r24, 0x20	; 32
     f9e:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fa2:	80 e8       	ldi	r24, 0x80	; 128
     fa4:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fa8:	80 e4       	ldi	r24, 0x40	; 64
     faa:	0e 94 0c 11 	call	0x2218	; 0x2218 <rgbled_toggle>
		break;
     fae:	1d c0       	rjmp	.+58     	; 0xfea <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     fb0:	80 e8       	ldi	r24, 0x80	; 128
     fb2:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fb6:	80 e4       	ldi	r24, 0x40	; 64
     fb8:	0e 94 0c 11 	call	0x2218	; 0x2218 <rgbled_toggle>
			rgbled_toggle(LED_RED);
     fbc:	80 e2       	ldi	r24, 0x20	; 32
     fbe:	0e 94 0c 11 	call	0x2218	; 0x2218 <rgbled_toggle>
		break;
     fc2:	13 c0       	rjmp	.+38     	; 0xfea <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     fc4:	80 e2       	ldi	r24, 0x20	; 32
     fc6:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fd0:	80 e4       	ldi	r24, 0x40	; 64
     fd2:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
		break;
     fd6:	09 c0       	rjmp	.+18     	; 0xfea <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     fd8:	80 e4       	ldi	r24, 0x40	; 64
     fda:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fde:	80 e8       	ldi	r24, 0x80	; 128
     fe0:	0e 94 fd 10 	call	0x21fa	; 0x21fa <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     fe4:	80 e2       	ldi	r24, 0x20	; 32
     fe6:	0e 94 07 11 	call	0x220e	; 0x220e <rgbled_turn_on>
		break;
	}
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	08 95       	ret

00000ff0 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     ff0:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     ff2:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     ff4:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     ff6:	e9 e6       	ldi	r30, 0x69	; 105
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	80 81       	ld	r24, Z
     ffc:	84 60       	ori	r24, 0x04	; 4
     ffe:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
    1000:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
    1002:	e9 9a       	sbi	0x1d, 1	; 29
    1004:	08 95       	ret

00001006 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
    1006:	0f 93       	push	r16
    1008:	1f 93       	push	r17
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
	
	if (*u16_counter > 70)
    100e:	fb 01       	movw	r30, r22
    1010:	20 81       	ld	r18, Z
    1012:	31 81       	ldd	r19, Z+1	; 0x01
    1014:	27 34       	cpi	r18, 0x47	; 71
    1016:	31 05       	cpc	r19, r1
    1018:	b8 f0       	brcs	.+46     	; 0x1048 <handle_speed_sensor+0x42>
    101a:	eb 01       	movw	r28, r22
    101c:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    101e:	60 81       	ld	r22, Z
    1020:	71 81       	ldd	r23, Z+1	; 0x01
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
    102a:	9b 01       	movw	r18, r22
    102c:	ac 01       	movw	r20, r24
    102e:	60 e0       	ldi	r22, 0x00	; 0
    1030:	76 e7       	ldi	r23, 0x76	; 118
    1032:	88 e8       	ldi	r24, 0x88	; 136
    1034:	96 e4       	ldi	r25, 0x46	; 70
    1036:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
    103a:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
    103e:	f8 01       	movw	r30, r16
    1040:	71 83       	std	Z+1, r23	; 0x01
    1042:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    1044:	19 82       	std	Y+1, r1	; 0x01
    1046:	18 82       	st	Y, r1
	}	
}
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	1f 91       	pop	r17
    104e:	0f 91       	pop	r16
    1050:	08 95       	ret

00001052 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    1052:	cf 92       	push	r12
    1054:	df 92       	push	r13
    1056:	ef 92       	push	r14
    1058:	ff 92       	push	r15
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	1f 92       	push	r1
    1060:	cd b7       	in	r28, 0x3d	; 61
    1062:	de b7       	in	r29, 0x3e	; 62
    1064:	89 83       	std	Y+1, r24	; 0x01
    1066:	69 01       	movw	r12, r18
    1068:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    106a:	61 30       	cpi	r22, 0x01	; 1
    106c:	19 f5       	brne	.+70     	; 0x10b4 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    106e:	69 81       	ldd	r22, Y+1	; 0x01
    1070:	70 e0       	ldi	r23, 0x00	; 0
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
    107a:	22 e1       	ldi	r18, 0x12	; 18
    107c:	35 e8       	ldi	r19, 0x85	; 133
    107e:	41 e6       	ldi	r20, 0x61	; 97
    1080:	5e e3       	ldi	r21, 0x3E	; 62
    1082:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    1086:	a7 01       	movw	r20, r14
    1088:	96 01       	movw	r18, r12
    108a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
    108e:	20 e0       	ldi	r18, 0x00	; 0
    1090:	30 e0       	ldi	r19, 0x00	; 0
    1092:	48 ec       	ldi	r20, 0xC8	; 200
    1094:	52 e4       	ldi	r21, 0x42	; 66
    1096:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    109a:	20 e0       	ldi	r18, 0x00	; 0
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	48 e4       	ldi	r20, 0x48	; 72
    10a0:	52 e4       	ldi	r21, 0x42	; 66
    10a2:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
    10a6:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
    10aa:	86 2f       	mov	r24, r22
		if (Duty == 50)
    10ac:	62 33       	cpi	r22, 0x32	; 50
    10ae:	29 f5       	brne	.+74     	; 0x10fa <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
    10b0:	84 e3       	ldi	r24, 0x34	; 52
    10b2:	23 c0       	rjmp	.+70     	; 0x10fa <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    10b4:	62 30       	cpi	r22, 0x02	; 2
    10b6:	01 f5       	brne	.+64     	; 0x10f8 <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    10b8:	69 81       	ldd	r22, Y+1	; 0x01
    10ba:	70 e0       	ldi	r23, 0x00	; 0
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	90 e0       	ldi	r25, 0x00	; 0
    10c0:	0e 94 85 12 	call	0x250a	; 0x250a <__floatsisf>
    10c4:	23 ee       	ldi	r18, 0xE3	; 227
    10c6:	3e ee       	ldi	r19, 0xEE	; 238
    10c8:	4b e3       	ldi	r20, 0x3B	; 59
    10ca:	5e e3       	ldi	r21, 0x3E	; 62
    10cc:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    10d0:	a7 01       	movw	r20, r14
    10d2:	96 01       	movw	r18, r12
    10d4:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__divsf3>
    10d8:	20 e0       	ldi	r18, 0x00	; 0
    10da:	30 e0       	ldi	r19, 0x00	; 0
    10dc:	48 ec       	ldi	r20, 0xC8	; 200
    10de:	52 e4       	ldi	r21, 0x42	; 66
    10e0:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    10e4:	20 e0       	ldi	r18, 0x00	; 0
    10e6:	30 e0       	ldi	r19, 0x00	; 0
    10e8:	48 e4       	ldi	r20, 0x48	; 72
    10ea:	52 e4       	ldi	r21, 0x42	; 66
    10ec:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3>
    10f0:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fixunssfsi>
    10f4:	86 2f       	mov	r24, r22
    10f6:	01 c0       	rjmp	.+2      	; 0x10fa <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    10f8:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    10fa:	0f 90       	pop	r0
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	ff 90       	pop	r15
    1102:	ef 90       	pop	r14
    1104:	df 90       	pop	r13
    1106:	cf 90       	pop	r12
    1108:	08 95       	ret

0000110a <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    110a:	cf 93       	push	r28
    110c:	df 93       	push	r29
    110e:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    1110:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1112:	81 11       	cpse	r24, r1
    1114:	08 c0       	rjmp	.+16     	; 0x1126 <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    1116:	82 e3       	ldi	r24, 0x32	; 50
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	9b 8f       	std	Y+27, r25	; 0x1b
    111c:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    111e:	8e e1       	ldi	r24, 0x1E	; 30
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	9d 8f       	std	Y+29, r25	; 0x1d
    1124:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1126:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    112a:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    112e:	00 97       	sbiw	r24, 0x00	; 0
    1130:	31 f0       	breq	.+12     	; 0x113e <state_handler+0x34>
	{
		fault_timeout -- ;
    1132:	01 97       	sbiw	r24, 0x01	; 1
    1134:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    1138:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    113c:	05 c0       	rjmp	.+10     	; 0x1148 <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    113e:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1142:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1144:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    1148:	8e 8d       	ldd	r24, Y+30	; 0x1e
    114a:	82 30       	cpi	r24, 0x02	; 2
    114c:	09 f4       	brne	.+2      	; 0x1150 <state_handler+0x46>
    114e:	b7 c0       	rjmp	.+366    	; 0x12be <state_handler+0x1b4>
    1150:	30 f4       	brcc	.+12     	; 0x115e <state_handler+0x54>
    1152:	88 23       	and	r24, r24
    1154:	61 f0       	breq	.+24     	; 0x116e <state_handler+0x64>
    1156:	81 30       	cpi	r24, 0x01	; 1
    1158:	09 f4       	brne	.+2      	; 0x115c <state_handler+0x52>
    115a:	8f c0       	rjmp	.+286    	; 0x127a <state_handler+0x170>
    115c:	e1 c0       	rjmp	.+450    	; 0x1320 <state_handler+0x216>
    115e:	84 30       	cpi	r24, 0x04	; 4
    1160:	09 f4       	brne	.+2      	; 0x1164 <state_handler+0x5a>
    1162:	cf c0       	rjmp	.+414    	; 0x1302 <state_handler+0x1f8>
    1164:	a0 f0       	brcs	.+40     	; 0x118e <state_handler+0x84>
    1166:	85 30       	cpi	r24, 0x05	; 5
    1168:	09 f4       	brne	.+2      	; 0x116c <state_handler+0x62>
    116a:	51 c0       	rjmp	.+162    	; 0x120e <state_handler+0x104>
    116c:	d9 c0       	rjmp	.+434    	; 0x1320 <state_handler+0x216>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    116e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1170:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1172:	89 2b       	or	r24, r25
    1174:	11 f0       	breq	.+4      	; 0x117a <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    1176:	83 e0       	ldi	r24, 0x03	; 3
    1178:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    117a:	80 e0       	ldi	r24, 0x00	; 0
    117c:	a5 da       	rcall	.-2742   	; 0x6c8 <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    117e:	18 a2       	std	Y+32, r1	; 0x20
    1180:	30 d9       	rcall	.-3488   	; 0x3e2 <reset_I>
			vals->u8_brake_cmd = 0;
    1182:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    1184:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    1186:	82 e3       	ldi	r24, 0x32	; 50
    1188:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    118a:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    118c:	c9 c0       	rjmp	.+402    	; 0x1320 <state_handler+0x216>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    118e:	8a a1       	ldd	r24, Y+34	; 0x22
    1190:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    1192:	24 c0       	rjmp	.+72     	; 0x11dc <state_handler+0xd2>
    1194:	99 da       	rcall	.-2766   	; 0x6c8 <drivers>
				reset_I();
    1196:	25 d9       	rcall	.-3510   	; 0x3e2 <reset_I>
    1198:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    119a:	89 8f       	std	Y+25, r24	; 0x19
    119c:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    119e:	88 23       	and	r24, r24
    11a0:	69 f0       	breq	.+26     	; 0x11bc <state_handler+0xb2>
    11a2:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    11a6:	4c 85       	ldd	r20, Y+12	; 0x0c
    11a8:	5d 85       	ldd	r21, Y+13	; 0x0d
    11aa:	8b 89       	ldd	r24, Y+19	; 0x13
    11ac:	9c 89       	ldd	r25, Y+20	; 0x14
    11ae:	62 e0       	ldi	r22, 0x02	; 2
    11b0:	50 df       	rcall	.-352    	; 0x1052 <compute_synch_duty>
    11b2:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11b4:	89 8d       	ldd	r24, Y+25	; 0x19
    11b6:	1e d9       	rcall	.-3524   	; 0x3f4 <set_I>
    11b8:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    11ba:	8e 8f       	std	Y+30, r24	; 0x1e
    11bc:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11be:	88 23       	and	r24, r24
    11c0:	69 f0       	breq	.+26     	; 0x11dc <state_handler+0xd2>
    11c2:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11c4:	3b 85       	ldd	r19, Y+11	; 0x0b
    11c6:	4c 85       	ldd	r20, Y+12	; 0x0c
    11c8:	5d 85       	ldd	r21, Y+13	; 0x0d
    11ca:	8b 89       	ldd	r24, Y+19	; 0x13
    11cc:	9c 89       	ldd	r25, Y+20	; 0x14
    11ce:	62 e0       	ldi	r22, 0x02	; 2
    11d0:	40 df       	rcall	.-384    	; 0x1052 <compute_synch_duty>
    11d2:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11d4:	89 8d       	ldd	r24, Y+25	; 0x19
    11d6:	0e d9       	rcall	.-3556   	; 0x3f4 <set_I>
    11d8:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    11da:	8e 8f       	std	Y+30, r24	; 0x1e
    11dc:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    11de:	81 30       	cpi	r24, 0x01	; 1
    11e0:	09 f0       	breq	.+2      	; 0x11e4 <state_handler+0xda>
    11e2:	9e c0       	rjmp	.+316    	; 0x1320 <state_handler+0x216>
    11e4:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    11e6:	81 11       	cpse	r24, r1
    11e8:	03 c0       	rjmp	.+6      	; 0x11f0 <state_handler+0xe6>
    11ea:	88 8d       	ldd	r24, Y+24	; 0x18
    11ec:	88 23       	and	r24, r24
    11ee:	41 f0       	breq	.+16     	; 0x1200 <state_handler+0xf6>
    11f0:	8a ad       	ldd	r24, Y+58	; 0x3a
    11f2:	81 11       	cpse	r24, r1
    11f4:	05 c0       	rjmp	.+10     	; 0x1200 <state_handler+0xf6>
				{
					vals->motor_status = ENGAGE;
    11f6:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    11f8:	8e 8f       	std	Y+30, r24	; 0x1e
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    1200:	80 e0       	ldi	r24, 0x00	; 0
    1202:	62 da       	rcall	.-2876   	; 0x6c8 <drivers>
				vals->gear_required = NEUTRAL ;
    1204:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    1206:	ed d8       	rcall	.-3622   	; 0x3e2 <reset_I>
    1208:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    120a:	89 8f       	std	Y+25, r24	; 0x19
    120c:	89 c0       	rjmp	.+274    	; 0x1320 <state_handler+0x216>
    120e:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    1210:	8b af       	std	Y+59, r24	; 0x3b
    1212:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    1216:	88 23       	and	r24, r24
    1218:	69 f0       	breq	.+26     	; 0x1234 <state_handler+0x12a>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    121a:	2a 85       	ldd	r18, Y+10	; 0x0a
    121c:	3b 85       	ldd	r19, Y+11	; 0x0b
    121e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1220:	5d 85       	ldd	r21, Y+13	; 0x0d
    1222:	6b ad       	ldd	r22, Y+59	; 0x3b
    1224:	8b 89       	ldd	r24, Y+19	; 0x13
    1226:	9c 89       	ldd	r25, Y+20	; 0x14
    1228:	14 df       	rcall	.-472    	; 0x1052 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    122a:	89 8f       	std	Y+25, r24	; 0x19
    122c:	89 8d       	ldd	r24, Y+25	; 0x19
    122e:	e2 d8       	rcall	.-3644   	; 0x3f4 <set_I>
				starting_engage = 0;
    1230:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1234:	81 e0       	ldi	r24, 0x01	; 1
    1236:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    1238:	ce 01       	movw	r24, r28
    123a:	f7 d8       	rcall	.-3602   	; 0x42a <controller>
    123c:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    123e:	44 da       	rcall	.-2936   	; 0x6c8 <drivers>
    1240:	88 8d       	ldd	r24, Y+24	; 0x18
    1242:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1244:	29 f0       	breq	.+10     	; 0x1250 <state_handler+0x146>
    1246:	8a ad       	ldd	r24, Y+58	; 0x3a
    1248:	81 30       	cpi	r24, 0x01	; 1
    124a:	11 f4       	brne	.+4      	; 0x1250 <state_handler+0x146>
    124c:	82 e0       	ldi	r24, 0x02	; 2
    124e:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    1250:	8f 89       	ldd	r24, Y+23	; 0x17
    1252:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1254:	21 f0       	breq	.+8      	; 0x125e <state_handler+0x154>
    1256:	8a ad       	ldd	r24, Y+58	; 0x3a
    1258:	81 30       	cpi	r24, 0x01	; 1
    125a:	09 f4       	brne	.+2      	; 0x125e <state_handler+0x154>
    125c:	8e 8f       	std	Y+30, r24	; 0x1e
    125e:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    1260:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1262:	5e c0       	rjmp	.+188    	; 0x1320 <state_handler+0x216>
    1264:	88 8d       	ldd	r24, Y+24	; 0x18
    1266:	81 11       	cpse	r24, r1
    1268:	5b c0       	rjmp	.+182    	; 0x1320 <state_handler+0x216>
    126a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    126c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    126e:	89 2b       	or	r24, r25
    1270:	09 f0       	breq	.+2      	; 0x1274 <state_handler+0x16a>
    1272:	56 c0       	rjmp	.+172    	; 0x1320 <state_handler+0x216>
			{
				vals->motor_status = IDLE;
    1274:	83 e0       	ldi	r24, 0x03	; 3
    1276:	8e 8f       	std	Y+30, r24	; 0x1e
    1278:	53 c0       	rjmp	.+166    	; 0x1320 <state_handler+0x216>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    127a:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    127c:	ce 01       	movw	r24, r28
    127e:	d5 d8       	rcall	.-3670   	; 0x42a <controller>
    1280:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1282:	22 da       	rcall	.-3004   	; 0x6c8 <drivers>
    1284:	8f 89       	ldd	r24, Y+23	; 0x17
    1286:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1288:	06 c0       	rjmp	.+12     	; 0x1296 <state_handler+0x18c>
    128a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    128c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    128e:	89 2b       	or	r24, r25
    1290:	11 f4       	brne	.+4      	; 0x1296 <state_handler+0x18c>
    1292:	83 e0       	ldi	r24, 0x03	; 3
    1294:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1296:	8a a1       	ldd	r24, Y+34	; 0x22
    1298:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    129a:	41 f4       	brne	.+16     	; 0x12ac <state_handler+0x1a2>
    129c:	8a ad       	ldd	r24, Y+58	; 0x3a
    129e:	81 11       	cpse	r24, r1
    12a0:	05 c0       	rjmp	.+10     	; 0x12ac <state_handler+0x1a2>
    12a2:	85 e0       	ldi	r24, 0x05	; 5
    12a4:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12a6:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    12a8:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    12ac:	88 8d       	ldd	r24, Y+24	; 0x18
    12ae:	88 23       	and	r24, r24
    12b0:	b9 f1       	breq	.+110    	; 0x1320 <state_handler+0x216>
    12b2:	8f 89       	ldd	r24, Y+23	; 0x17
    12b4:	81 11       	cpse	r24, r1
    12b6:	34 c0       	rjmp	.+104    	; 0x1320 <state_handler+0x216>
			{
				vals->motor_status = BRAKE;
    12b8:	82 e0       	ldi	r24, 0x02	; 2
    12ba:	8e 8f       	std	Y+30, r24	; 0x1e
    12bc:	31 c0       	rjmp	.+98     	; 0x1320 <state_handler+0x216>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12be:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12c0:	ce 01       	movw	r24, r28
    12c2:	b3 d8       	rcall	.-3738   	; 0x42a <controller>
    12c4:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12c6:	00 da       	rcall	.-3072   	; 0x6c8 <drivers>
    12c8:	88 8d       	ldd	r24, Y+24	; 0x18
    12ca:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12cc:	06 c0       	rjmp	.+12     	; 0x12da <state_handler+0x1d0>
    12ce:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12d0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12d2:	89 2b       	or	r24, r25
    12d4:	11 f4       	brne	.+4      	; 0x12da <state_handler+0x1d0>
    12d6:	83 e0       	ldi	r24, 0x03	; 3
    12d8:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12da:	8a a1       	ldd	r24, Y+34	; 0x22
    12dc:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12de:	41 f4       	brne	.+16     	; 0x12f0 <state_handler+0x1e6>
    12e0:	8a ad       	ldd	r24, Y+58	; 0x3a
    12e2:	81 11       	cpse	r24, r1
    12e4:	05 c0       	rjmp	.+10     	; 0x12f0 <state_handler+0x1e6>
    12e6:	85 e0       	ldi	r24, 0x05	; 5
    12e8:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    12f0:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    12f2:	81 11       	cpse	r24, r1
    12f4:	15 c0       	rjmp	.+42     	; 0x1320 <state_handler+0x216>
    12f6:	8f 89       	ldd	r24, Y+23	; 0x17
    12f8:	88 23       	and	r24, r24
    12fa:	91 f0       	breq	.+36     	; 0x1320 <state_handler+0x216>
			{
				vals->motor_status = ACCEL;
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	8e 8f       	std	Y+30, r24	; 0x1e
    1300:	0f c0       	rjmp	.+30     	; 0x1320 <state_handler+0x216>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1302:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1306:	81 11       	cpse	r24, r1
    1308:	02 c0       	rjmp	.+4      	; 0x130e <state_handler+0x204>
			{
				vals->motor_status = IDLE;
    130a:	83 e0       	ldi	r24, 0x03	; 3
    130c:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	db d9       	rcall	.-3146   	; 0x6c8 <drivers>
    1312:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    1314:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    1316:	65 d8       	rcall	.-3894   	; 0x3e2 <reset_I>
			reset_I(); //reset integrator
    1318:	18 8e       	std	Y+24, r1	; 0x18
    131a:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    131c:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    131e:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    1320:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1322:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1324:	49 f0       	breq	.+18     	; 0x1338 <state_handler+0x22e>
    1326:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1328:	81 30       	cpi	r24, 0x01	; 1
    132a:	31 f0       	breq	.+12     	; 0x1338 <state_handler+0x22e>
    132c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    132e:	82 30       	cpi	r24, 0x02	; 2
    1330:	19 f0       	breq	.+6      	; 0x1338 <state_handler+0x22e>
    1332:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1334:	85 30       	cpi	r24, 0x05	; 5
    1336:	29 f4       	brne	.+10     	; 0x1342 <state_handler+0x238>
    1338:	8a 8d       	ldd	r24, Y+26	; 0x1a
    133a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    133c:	89 2b       	or	r24, r25
    133e:	09 f4       	brne	.+2      	; 0x1342 <state_handler+0x238>
    1340:	1e 8e       	std	Y+30, r1	; 0x1e
    1342:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1344:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1346:	08 95       	ret

00001348 <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    1348:	cf 93       	push	r28
    134a:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    134c:	8e b1       	in	r24, 0x0e	; 14
    134e:	87 7c       	andi	r24, 0xC7	; 199
    1350:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1352:	8d b1       	in	r24, 0x0d	; 13
    1354:	88 63       	ori	r24, 0x38	; 56
    1356:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    1358:	a1 e9       	ldi	r26, 0x91	; 145
    135a:	b0 e0       	ldi	r27, 0x00	; 0
    135c:	8c 91       	ld	r24, X
    135e:	80 61       	ori	r24, 0x10	; 16
    1360:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    1362:	8c 91       	ld	r24, X
    1364:	87 7f       	andi	r24, 0xF7	; 247
    1366:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    1368:	e0 e9       	ldi	r30, 0x90	; 144
    136a:	f0 e0       	ldi	r31, 0x00	; 0
    136c:	80 81       	ld	r24, Z
    136e:	82 60       	ori	r24, 0x02	; 2
    1370:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    1372:	80 81       	ld	r24, Z
    1374:	8e 7f       	andi	r24, 0xFE	; 254
    1376:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    1378:	80 81       	ld	r24, Z
    137a:	80 68       	ori	r24, 0x80	; 128
    137c:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    137e:	80 81       	ld	r24, Z
    1380:	8f 7b       	andi	r24, 0xBF	; 191
    1382:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    1384:	80 81       	ld	r24, Z
    1386:	80 62       	ori	r24, 0x20	; 32
    1388:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    138a:	80 81       	ld	r24, Z
    138c:	8f 7e       	andi	r24, 0xEF	; 239
    138e:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    1390:	80 81       	ld	r24, Z
    1392:	88 60       	ori	r24, 0x08	; 8
    1394:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    1396:	80 81       	ld	r24, Z
    1398:	8b 7f       	andi	r24, 0xFB	; 251
    139a:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    139c:	8c 91       	ld	r24, X
    139e:	81 60       	ori	r24, 0x01	; 1
    13a0:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    13a2:	8c 91       	ld	r24, X
    13a4:	89 7f       	andi	r24, 0xF9	; 249
    13a6:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    13a8:	c6 e9       	ldi	r28, 0x96	; 150
    13aa:	d0 e0       	ldi	r29, 0x00	; 0
    13ac:	85 e8       	ldi	r24, 0x85	; 133
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	99 83       	std	Y+1, r25	; 0x01
    13b2:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    13b4:	68 81       	ld	r22, Y
    13b6:	79 81       	ldd	r23, Y+1	; 0x01
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
    13c0:	20 e0       	ldi	r18, 0x00	; 0
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	40 e0       	ldi	r20, 0x00	; 0
    13c6:	5f e3       	ldi	r21, 0x3F	; 63
    13c8:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    13cc:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
    13d0:	e8 e9       	ldi	r30, 0x98	; 152
    13d2:	f0 e0       	ldi	r31, 0x00	; 0
    13d4:	71 83       	std	Z+1, r23	; 0x01
    13d6:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    13d8:	88 81       	ld	r24, Y
    13da:	99 81       	ldd	r25, Y+1	; 0x01
    13dc:	20 81       	ld	r18, Z
    13de:	31 81       	ldd	r19, Z+1	; 0x01
    13e0:	82 1b       	sub	r24, r18
    13e2:	93 0b       	sbc	r25, r19
    13e4:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    13e8:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    13ec:	68 81       	ld	r22, Y
    13ee:	79 81       	ldd	r23, Y+1	; 0x01
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	0e 94 83 12 	call	0x2506	; 0x2506 <__floatunsisf>
    13f8:	20 e0       	ldi	r18, 0x00	; 0
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	40 e0       	ldi	r20, 0x00	; 0
    13fe:	5f e3       	ldi	r21, 0x3F	; 63
    1400:	0e 94 39 13 	call	0x2672	; 0x2672 <__mulsf3>
    1404:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__fixsfsi>
    1408:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    140c:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	08 95       	ret

00001416 <uart0_putc>:
    1416:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    141a:	9f 5f       	subi	r25, 0xFF	; 255
    141c:	9f 71       	andi	r25, 0x1F	; 31
    141e:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1422:	92 17       	cp	r25, r18
    1424:	e1 f3       	breq	.-8      	; 0x141e <uart0_putc+0x8>
    1426:	e9 2f       	mov	r30, r25
    1428:	f0 e0       	ldi	r31, 0x00	; 0
    142a:	e5 5d       	subi	r30, 0xD5	; 213
    142c:	fb 4f       	sbci	r31, 0xFB	; 251
    142e:	80 83       	st	Z, r24
    1430:	2f b7       	in	r18, 0x3f	; 63
    1432:	f8 94       	cli
    1434:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    1438:	e1 ec       	ldi	r30, 0xC1	; 193
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	80 81       	ld	r24, Z
    143e:	80 62       	ori	r24, 0x20	; 32
    1440:	80 83       	st	Z, r24
    1442:	2f bf       	out	0x3f, r18	; 63
    1444:	08 95       	ret

00001446 <uart0_flush>:
    1446:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    144a:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    144e:	98 13       	cpse	r25, r24
    1450:	fa cf       	rjmp	.-12     	; 0x1446 <uart0_flush>
    1452:	08 95       	ret

00001454 <uart1_putc>:
    1454:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    1458:	9f 5f       	subi	r25, 0xFF	; 255
    145a:	9f 71       	andi	r25, 0x1F	; 31
    145c:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    1460:	92 17       	cp	r25, r18
    1462:	e1 f3       	breq	.-8      	; 0x145c <uart1_putc+0x8>
    1464:	e9 2f       	mov	r30, r25
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	ea 51       	subi	r30, 0x1A	; 26
    146a:	fc 4f       	sbci	r31, 0xFC	; 252
    146c:	80 83       	st	Z, r24
    146e:	2f b7       	in	r18, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    1476:	e9 ec       	ldi	r30, 0xC9	; 201
    1478:	f0 e0       	ldi	r31, 0x00	; 0
    147a:	80 81       	ld	r24, Z
    147c:	80 62       	ori	r24, 0x20	; 32
    147e:	80 83       	st	Z, r24
    1480:	2f bf       	out	0x3f, r18	; 63
    1482:	08 95       	ret

00001484 <uart_putchar>:
    1484:	cf 93       	push	r28
    1486:	c8 2f       	mov	r28, r24
    1488:	fb 01       	movw	r30, r22
    148a:	84 85       	ldd	r24, Z+12	; 0x0c
    148c:	95 85       	ldd	r25, Z+13	; 0x0d
    148e:	01 97       	sbiw	r24, 0x01	; 1
    1490:	39 f0       	breq	.+14     	; 0x14a0 <uart_putchar+0x1c>
    1492:	ca 30       	cpi	r28, 0x0A	; 10
    1494:	11 f4       	brne	.+4      	; 0x149a <uart_putchar+0x16>
    1496:	8d e0       	ldi	r24, 0x0D	; 13
    1498:	be df       	rcall	.-132    	; 0x1416 <uart0_putc>
    149a:	8c 2f       	mov	r24, r28
    149c:	bc df       	rcall	.-136    	; 0x1416 <uart0_putc>
    149e:	06 c0       	rjmp	.+12     	; 0x14ac <uart_putchar+0x28>
    14a0:	ca 30       	cpi	r28, 0x0A	; 10
    14a2:	11 f4       	brne	.+4      	; 0x14a8 <uart_putchar+0x24>
    14a4:	8d e0       	ldi	r24, 0x0D	; 13
    14a6:	d6 df       	rcall	.-84     	; 0x1454 <uart1_putc>
    14a8:	8c 2f       	mov	r24, r28
    14aa:	d4 df       	rcall	.-88     	; 0x1454 <uart1_putc>
    14ac:	80 e0       	ldi	r24, 0x00	; 0
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	cf 91       	pop	r28
    14b2:	08 95       	ret

000014b4 <uart0_getc>:
    14b4:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    14b8:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    14bc:	89 17       	cp	r24, r25
    14be:	59 f0       	breq	.+22     	; 0x14d6 <uart0_getc+0x22>
    14c0:	8f 5f       	subi	r24, 0xFF	; 255
    14c2:	98 2f       	mov	r25, r24
    14c4:	9f 71       	andi	r25, 0x1F	; 31
    14c6:	e9 2f       	mov	r30, r25
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	ed 53       	subi	r30, 0x3D	; 61
    14cc:	fc 4f       	sbci	r31, 0xFC	; 252
    14ce:	80 81       	ld	r24, Z
    14d0:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    14d4:	08 95       	ret
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	08 95       	ret

000014da <uart0_getln>:
    14da:	0f 93       	push	r16
    14dc:	1f 93       	push	r17
    14de:	cf 93       	push	r28
    14e0:	df 93       	push	r29
    14e2:	ec 01       	movw	r28, r24
    14e4:	61 30       	cpi	r22, 0x01	; 1
    14e6:	b1 f0       	breq	.+44     	; 0x1514 <uart0_getln+0x3a>
    14e8:	62 50       	subi	r22, 0x02	; 2
    14ea:	06 2f       	mov	r16, r22
    14ec:	10 e0       	ldi	r17, 0x00	; 0
    14ee:	0f 5f       	subi	r16, 0xFF	; 255
    14f0:	1f 4f       	sbci	r17, 0xFF	; 255
    14f2:	08 0f       	add	r16, r24
    14f4:	19 1f       	adc	r17, r25
    14f6:	de df       	rcall	.-68     	; 0x14b4 <uart0_getc>
    14f8:	88 83       	st	Y, r24
    14fa:	88 23       	and	r24, r24
    14fc:	e1 f3       	breq	.-8      	; 0x14f6 <uart0_getln+0x1c>
    14fe:	8d 30       	cpi	r24, 0x0D	; 13
    1500:	21 f4       	brne	.+8      	; 0x150a <uart0_getln+0x30>
    1502:	d8 df       	rcall	.-80     	; 0x14b4 <uart0_getc>
    1504:	88 23       	and	r24, r24
    1506:	e9 f3       	breq	.-6      	; 0x1502 <uart0_getln+0x28>
    1508:	05 c0       	rjmp	.+10     	; 0x1514 <uart0_getln+0x3a>
    150a:	21 96       	adiw	r28, 0x01	; 1
    150c:	c0 17       	cp	r28, r16
    150e:	d1 07       	cpc	r29, r17
    1510:	91 f7       	brne	.-28     	; 0x14f6 <uart0_getln+0x1c>
    1512:	e8 01       	movw	r28, r16
    1514:	18 82       	st	Y, r1
    1516:	df 91       	pop	r29
    1518:	cf 91       	pop	r28
    151a:	1f 91       	pop	r17
    151c:	0f 91       	pop	r16
    151e:	08 95       	ret

00001520 <uart0_getData>:
    1520:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1524:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    1528:	89 17       	cp	r24, r25
    152a:	61 f0       	breq	.+24     	; 0x1544 <uart0_getData+0x24>
    152c:	8f 5f       	subi	r24, 0xFF	; 255
    152e:	8f 71       	andi	r24, 0x1F	; 31
    1530:	e8 2f       	mov	r30, r24
    1532:	f0 e0       	ldi	r31, 0x00	; 0
    1534:	ed 53       	subi	r30, 0x3D	; 61
    1536:	fc 4f       	sbci	r31, 0xFC	; 252
    1538:	90 81       	ld	r25, Z
    153a:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    153e:	89 2f       	mov	r24, r25
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	08 95       	ret
    1544:	8f ef       	ldi	r24, 0xFF	; 255
    1546:	9f ef       	ldi	r25, 0xFF	; 255
    1548:	08 95       	ret

0000154a <uart1_getData>:
    154a:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    154e:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1552:	89 17       	cp	r24, r25
    1554:	61 f0       	breq	.+24     	; 0x156e <uart1_getData+0x24>
    1556:	8f 5f       	subi	r24, 0xFF	; 255
    1558:	8f 71       	andi	r24, 0x1F	; 31
    155a:	e8 2f       	mov	r30, r24
    155c:	f0 e0       	ldi	r31, 0x00	; 0
    155e:	e9 5f       	subi	r30, 0xF9	; 249
    1560:	fb 4f       	sbci	r31, 0xFB	; 251
    1562:	90 81       	ld	r25, Z
    1564:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    1568:	89 2f       	mov	r24, r25
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	08 95       	ret
    156e:	8f ef       	ldi	r24, 0xFF	; 255
    1570:	9f ef       	ldi	r25, 0xFF	; 255
    1572:	08 95       	ret

00001574 <uart_getchar>:
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	fc 01       	movw	r30, r24
    157a:	84 85       	ldd	r24, Z+12	; 0x0c
    157c:	95 85       	ldd	r25, Z+13	; 0x0d
    157e:	01 97       	sbiw	r24, 0x01	; 1
    1580:	41 f0       	breq	.+16     	; 0x1592 <uart_getchar+0x1e>
    1582:	ce df       	rcall	.-100    	; 0x1520 <uart0_getData>
    1584:	ec 01       	movw	r28, r24
    1586:	99 23       	and	r25, r25
    1588:	e4 f3       	brlt	.-8      	; 0x1582 <uart_getchar+0xe>
    158a:	45 df       	rcall	.-374    	; 0x1416 <uart0_putc>
    158c:	ce 01       	movw	r24, r28
    158e:	99 27       	eor	r25, r25
    1590:	07 c0       	rjmp	.+14     	; 0x15a0 <uart_getchar+0x2c>
    1592:	db df       	rcall	.-74     	; 0x154a <uart1_getData>
    1594:	ec 01       	movw	r28, r24
    1596:	99 23       	and	r25, r25
    1598:	e4 f3       	brlt	.-8      	; 0x1592 <uart_getchar+0x1e>
    159a:	5c df       	rcall	.-328    	; 0x1454 <uart1_putc>
    159c:	ce 01       	movw	r24, r28
    159e:	99 27       	eor	r25, r25
    15a0:	99 27       	eor	r25, r25
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	08 95       	ret

000015a8 <__vector_22>:
    15a8:	0f 93       	push	r16
    15aa:	0f b7       	in	r16, 0x3f	; 63
    15ac:	ef 93       	push	r30
    15ae:	ff 93       	push	r31
    15b0:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    15b4:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    15b8:	e3 95       	inc	r30
    15ba:	ef 71       	andi	r30, 0x1F	; 31
    15bc:	ef 13       	cpse	r30, r31
    15be:	05 c0       	rjmp	.+10     	; 0x15ca <USART0_TX_CONTINUE>
    15c0:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15c4:	ff 7d       	andi	r31, 0xDF	; 223
    15c6:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015ca <USART0_TX_CONTINUE>:
    15ca:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    15ce:	f0 e0       	ldi	r31, 0x00	; 0
    15d0:	e5 5d       	subi	r30, 0xD5	; 213
    15d2:	fb 4f       	sbci	r31, 0xFB	; 251
    15d4:	e0 81       	ld	r30, Z
    15d6:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

000015da <USART0_TX_EXIT>:
    15da:	ff 91       	pop	r31
    15dc:	ef 91       	pop	r30
    15de:	0f bf       	out	0x3f, r16	; 63
    15e0:	0f 91       	pop	r16
    15e2:	18 95       	reti

000015e4 <__vector_21>:
    15e4:	0f 93       	push	r16
    15e6:	0f b7       	in	r16, 0x3f	; 63
    15e8:	9f 93       	push	r25
    15ea:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    15ee:	ef 93       	push	r30
    15f0:	ff 93       	push	r31
    15f2:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    15f6:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    15fa:	e3 95       	inc	r30
    15fc:	ef 71       	andi	r30, 0x1F	; 31
    15fe:	fe 17       	cp	r31, r30
    1600:	31 f0       	breq	.+12     	; 0x160e <USART0_RX_EXIT>
    1602:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    1606:	f0 e0       	ldi	r31, 0x00	; 0
    1608:	ed 53       	subi	r30, 0x3D	; 61
    160a:	fc 4f       	sbci	r31, 0xFC	; 252
    160c:	90 83       	st	Z, r25

0000160e <USART0_RX_EXIT>:
    160e:	ff 91       	pop	r31
    1610:	ef 91       	pop	r30
    1612:	9f 91       	pop	r25
    1614:	0f bf       	out	0x3f, r16	; 63
    1616:	0f 91       	pop	r16
    1618:	18 95       	reti

0000161a <__vector_33>:
    161a:	0f 93       	push	r16
    161c:	0f b7       	in	r16, 0x3f	; 63
    161e:	ef 93       	push	r30
    1620:	ff 93       	push	r31
    1622:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1626:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    162a:	e3 95       	inc	r30
    162c:	ef 71       	andi	r30, 0x1F	; 31
    162e:	ef 13       	cpse	r30, r31
    1630:	05 c0       	rjmp	.+10     	; 0x163c <USART1_TX_CONTINUE>
    1632:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1636:	ff 7d       	andi	r31, 0xDF	; 223
    1638:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

0000163c <USART1_TX_CONTINUE>:
    163c:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    1640:	f0 e0       	ldi	r31, 0x00	; 0
    1642:	ea 51       	subi	r30, 0x1A	; 26
    1644:	fc 4f       	sbci	r31, 0xFC	; 252
    1646:	e0 81       	ld	r30, Z
    1648:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

0000164c <USART1_TX_EXIT>:
    164c:	ff 91       	pop	r31
    164e:	ef 91       	pop	r30
    1650:	0f bf       	out	0x3f, r16	; 63
    1652:	0f 91       	pop	r16
    1654:	18 95       	reti

00001656 <__vector_32>:
    1656:	0f 93       	push	r16
    1658:	0f b7       	in	r16, 0x3f	; 63
    165a:	9f 93       	push	r25
    165c:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1660:	ef 93       	push	r30
    1662:	ff 93       	push	r31
    1664:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    1668:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    166c:	e3 95       	inc	r30
    166e:	ef 71       	andi	r30, 0x1F	; 31
    1670:	fe 17       	cp	r31, r30
    1672:	31 f0       	breq	.+12     	; 0x1680 <USART1_RX_EXIT>
    1674:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    1678:	f0 e0       	ldi	r31, 0x00	; 0
    167a:	e9 5f       	subi	r30, 0xF9	; 249
    167c:	fb 4f       	sbci	r31, 0xFB	; 251
    167e:	90 83       	st	Z, r25

00001680 <USART1_RX_EXIT>:
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	9f 91       	pop	r25
    1686:	0f bf       	out	0x3f, r16	; 63
    1688:	0f 91       	pop	r16
    168a:	18 95       	reti

0000168c <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    168c:	e1 e8       	ldi	r30, 0x81	; 129
    168e:	f0 e0       	ldi	r31, 0x00	; 0
    1690:	80 81       	ld	r24, Z
    1692:	83 60       	ori	r24, 0x03	; 3
    1694:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    1696:	80 81       	ld	r24, Z
    1698:	88 60       	ori	r24, 0x08	; 8
    169a:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    169c:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    16a0:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    16a4:	ef e6       	ldi	r30, 0x6F	; 111
    16a6:	f0 e0       	ldi	r31, 0x00	; 0
    16a8:	80 81       	ld	r24, Z
    16aa:	82 60       	ori	r24, 0x02	; 2
    16ac:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    16ae:	8d e7       	ldi	r24, 0x7D	; 125
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16b6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16ba:	08 95       	ret

000016bc <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    16bc:	84 b5       	in	r24, 0x24	; 36
    16be:	85 60       	ori	r24, 0x05	; 5
    16c0:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16c2:	84 b5       	in	r24, 0x24	; 36
    16c4:	88 60       	ori	r24, 0x08	; 8
    16c6:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16c8:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16ca:	ee e6       	ldi	r30, 0x6E	; 110
    16cc:	f0 e0       	ldi	r31, 0x00	; 0
    16ce:	80 81       	ld	r24, Z
    16d0:	82 60       	ori	r24, 0x02	; 2
    16d2:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    16d4:	87 e2       	ldi	r24, 0x27	; 39
    16d6:	87 bd       	out	0x27, r24	; 39
    16d8:	08 95       	ret

000016da <main>:
};


int main(void)	
{
	cli();
    16da:	f8 94       	cli
	rgbled_init();
    16dc:	92 d5       	rcall	.+2852   	; 0x2202 <rgbled_init>
	DWC_init();
    16de:	11 d2       	rcall	.+1058   	; 0x1b02 <DWC_init>
	pwm_init();
    16e0:	33 de       	rcall	.-922    	; 0x1348 <pwm_init>
    16e2:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    16e4:	70 e0       	ldi	r23, 0x00	; 0
    16e6:	80 e0       	ldi	r24, 0x00	; 0
    16e8:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    16ea:	71 d4       	rcall	.+2274   	; 0x1fce <can_init>
	timer0_init_ts();
    16ec:	cf df       	rcall	.-98     	; 0x168c <timer1_init_ts>
    16ee:	e6 df       	rcall	.-52     	; 0x16bc <timer0_init_ts>
	speed_init();
    16f0:	7f dc       	rcall	.-1794   	; 0xff0 <speed_init>
    16f2:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    16f4:	95 d5       	rcall	.+2858   	; 0x2220 <spi_init>
    16f6:	82 e1       	ldi	r24, 0x12	; 18
    16f8:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    16fa:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    16fe:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    1702:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1706:	88 e9       	ldi	r24, 0x98	; 152
    1708:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    170c:	eb e4       	ldi	r30, 0x4B	; 75
    170e:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    1710:	84 e0       	ldi	r24, 0x04	; 4
    1712:	91 e0       	ldi	r25, 0x01	; 1
    1714:	93 83       	std	Z+3, r25	; 0x03
    1716:	82 83       	std	Z+2, r24	; 0x02
    1718:	91 83       	std	Z+1, r25	; 0x01
    171a:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    171c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <drivers_init>
	drivers_init();
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	0e 94 64 03 	call	0x6c8	; 0x6c8 <drivers>
	drivers(0);
    1726:	78 94       	sei
	sei();
    1728:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    172a:	67 e9       	ldi	r22, 0x97	; 151
    172c:	73 e0       	ldi	r23, 0x03	; 3
    172e:	82 e1       	ldi	r24, 0x12	; 18
    1730:	91 e0       	ldi	r25, 0x01	; 1
    1732:	c5 d8       	rcall	.-3702   	; 0x8be <handle_can>
    1734:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1736:	91 e0       	ldi	r25, 0x01	; 1
    1738:	9e d9       	rcall	.-3268   	; 0xa76 <receive_uart>
    173a:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    173e:	88 23       	and	r24, r24
    1740:	09 f4       	brne	.+2      	; 0x1744 <main+0x6a>
    1742:	41 c0       	rjmp	.+130    	; 0x17c6 <main+0xec>
    1744:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1748:	88 23       	and	r24, r24
    174a:	f1 f0       	breq	.+60     	; 0x1788 <main+0xae>
    174c:	8d b7       	in	r24, 0x3d	; 61
    174e:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    1750:	cd 97       	sbiw	r24, 0x3d	; 61
    1752:	0f b6       	in	r0, 0x3f	; 63
    1754:	f8 94       	cli
    1756:	9e bf       	out	0x3e, r25	; 62
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	8d bf       	out	0x3d, r24	; 61
    175c:	ad b7       	in	r26, 0x3d	; 61
    175e:	be b7       	in	r27, 0x3e	; 62
    1760:	11 96       	adiw	r26, 0x01	; 1
    1762:	8d e3       	ldi	r24, 0x3D	; 61
    1764:	e2 e1       	ldi	r30, 0x12	; 18
    1766:	f1 e0       	ldi	r31, 0x01	; 1
    1768:	01 90       	ld	r0, Z+
    176a:	0d 92       	st	X+, r0
    176c:	8a 95       	dec	r24
    176e:	e1 f7       	brne	.-8      	; 0x1768 <main+0x8e>
    1770:	fd d8       	rcall	.-3590   	; 0x96c <handle_motor_status_can_msg>
    1772:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    1776:	8d b7       	in	r24, 0x3d	; 61
    1778:	9e b7       	in	r25, 0x3e	; 62
    177a:	cd 96       	adiw	r24, 0x3d	; 61
    177c:	0f b6       	in	r0, 0x3f	; 63
    177e:	f8 94       	cli
    1780:	9e bf       	out	0x3e, r25	; 62
    1782:	0f be       	out	0x3f, r0	; 63
    1784:	8d bf       	out	0x3d, r24	; 61
    1786:	1d c0       	rjmp	.+58     	; 0x17c2 <main+0xe8>
    1788:	8d b7       	in	r24, 0x3d	; 61
    178a:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    178c:	cd 97       	sbiw	r24, 0x3d	; 61
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	9e bf       	out	0x3e, r25	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	8d bf       	out	0x3d, r24	; 61
    1798:	ad b7       	in	r26, 0x3d	; 61
    179a:	be b7       	in	r27, 0x3e	; 62
    179c:	11 96       	adiw	r26, 0x01	; 1
    179e:	8d e3       	ldi	r24, 0x3D	; 61
    17a0:	e2 e1       	ldi	r30, 0x12	; 18
    17a2:	f1 e0       	ldi	r31, 0x01	; 1
    17a4:	01 90       	ld	r0, Z+
    17a6:	0d 92       	st	X+, r0
    17a8:	8a 95       	dec	r24
    17aa:	e1 f7       	brne	.-8      	; 0x17a4 <main+0xca>
    17ac:	4e d9       	rcall	.-3428   	; 0xa4a <handle_clutch_cmd_can_msg>
    17ae:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    17b2:	8d b7       	in	r24, 0x3d	; 61
    17b4:	9e b7       	in	r25, 0x3e	; 62
    17b6:	cd 96       	adiw	r24, 0x3d	; 61
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	f8 94       	cli
    17bc:	9e bf       	out	0x3e, r25	; 62
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	8d bf       	out	0x3d, r24	; 61
    17c2:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17c6:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17ca:	88 23       	and	r24, r24
    17cc:	09 f4       	brne	.+2      	; 0x17d0 <main+0xf6>
    17ce:	ad cf       	rjmp	.-166    	; 0x172a <main+0x50>
    17d0:	8d b7       	in	r24, 0x3d	; 61
    17d2:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    17d4:	cd 97       	sbiw	r24, 0x3d	; 61
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	9e bf       	out	0x3e, r25	; 62
    17dc:	0f be       	out	0x3f, r0	; 63
    17de:	8d bf       	out	0x3d, r24	; 61
    17e0:	ad b7       	in	r26, 0x3d	; 61
    17e2:	be b7       	in	r27, 0x3e	; 62
    17e4:	11 96       	adiw	r26, 0x01	; 1
    17e6:	8d e3       	ldi	r24, 0x3D	; 61
    17e8:	e2 e1       	ldi	r30, 0x12	; 18
    17ea:	f1 e0       	ldi	r31, 0x01	; 1
    17ec:	01 90       	ld	r0, Z+
    17ee:	0d 92       	st	X+, r0
    17f0:	8a 95       	dec	r24
    17f2:	e1 f7       	brne	.-8      	; 0x17ec <main+0x112>
    17f4:	c1 da       	rcall	.-2686   	; 0xd78 <send_uart>
    17f6:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    17fa:	8d b7       	in	r24, 0x3d	; 61
    17fc:	9e b7       	in	r25, 0x3e	; 62
    17fe:	cd 96       	adiw	r24, 0x3d	; 61
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	9e bf       	out	0x3e, r25	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	8d bf       	out	0x3d, r24	; 61
    180a:	8f cf       	rjmp	.-226    	; 0x172a <main+0x50>

0000180c <__vector_16>:
    180c:	1f 92       	push	r1
    180e:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    1810:	0f b6       	in	r0, 0x3f	; 63
    1812:	0f 92       	push	r0
    1814:	11 24       	eor	r1, r1
    1816:	0b b6       	in	r0, 0x3b	; 59
    1818:	0f 92       	push	r0
    181a:	ef 92       	push	r14
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	2f 93       	push	r18
    1822:	3f 93       	push	r19
    1824:	4f 93       	push	r20
    1826:	5f 93       	push	r21
    1828:	6f 93       	push	r22
    182a:	7f 93       	push	r23
    182c:	8f 93       	push	r24
    182e:	9f 93       	push	r25
    1830:	af 93       	push	r26
    1832:	bf 93       	push	r27
    1834:	ef 93       	push	r30
    1836:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1838:	82 e1       	ldi	r24, 0x12	; 18
    183a:	91 e0       	ldi	r25, 0x01	; 1
    183c:	63 d1       	rcall	.+710    	; 0x1b04 <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    183e:	82 e1       	ldi	r24, 0x12	; 18
    1840:	91 e0       	ldi	r25, 0x01	; 1
    1842:	63 dc       	rcall	.-1850   	; 0x110a <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    1844:	82 e1       	ldi	r24, 0x12	; 18
    1846:	91 e0       	ldi	r25, 0x01	; 1
    1848:	0e 94 9b 01 	call	0x336	; 0x336 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    184c:	82 e1       	ldi	r24, 0x12	; 18
    184e:	91 e0       	ldi	r25, 0x01	; 1
    1850:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    1854:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1858:	87 30       	cpi	r24, 0x07	; 7
    185a:	09 f0       	breq	.+2      	; 0x185e <__vector_16+0x52>
    185c:	51 c0       	rjmp	.+162    	; 0x1900 <__vector_16+0xf4>
	{
		b_send_can = 1;
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    1864:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1868:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    186c:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    1870:	89 2b       	or	r24, r25
    1872:	b1 f0       	breq	.+44     	; 0x18a0 <__vector_16+0x94>
    1874:	e2 e1       	ldi	r30, 0x12	; 18
    1876:	f1 e0       	ldi	r31, 0x01	; 1
    1878:	97 8d       	ldd	r25, Z+31	; 0x1f
    187a:	27 8d       	ldd	r18, Z+31	; 0x1f
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	91 30       	cpi	r25, 0x01	; 1
    1880:	09 f0       	breq	.+2      	; 0x1884 <__vector_16+0x78>
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	81 11       	cpse	r24, r1
    1886:	05 c0       	rjmp	.+10     	; 0x1892 <__vector_16+0x86>
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	21 11       	cpse	r18, r1
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	88 23       	and	r24, r24
    1890:	39 f0       	breq	.+14     	; 0x18a0 <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    1892:	e2 e1       	ldi	r30, 0x12	; 18
    1894:	f1 e0       	ldi	r31, 0x01	; 1
    1896:	82 8d       	ldd	r24, Z+26	; 0x1a
    1898:	93 8d       	ldd	r25, Z+27	; 0x1b
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	93 8f       	std	Z+27, r25	; 0x1b
    189e:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    18a0:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    18a4:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    18a8:	89 2b       	or	r24, r25
    18aa:	b1 f0       	breq	.+44     	; 0x18d8 <__vector_16+0xcc>
    18ac:	e2 e1       	ldi	r30, 0x12	; 18
    18ae:	f1 e0       	ldi	r31, 0x01	; 1
    18b0:	97 8d       	ldd	r25, Z+31	; 0x1f
    18b2:	27 8d       	ldd	r18, Z+31	; 0x1f
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	91 30       	cpi	r25, 0x01	; 1
    18b8:	09 f0       	breq	.+2      	; 0x18bc <__vector_16+0xb0>
    18ba:	80 e0       	ldi	r24, 0x00	; 0
    18bc:	81 11       	cpse	r24, r1
    18be:	05 c0       	rjmp	.+10     	; 0x18ca <__vector_16+0xbe>
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	21 11       	cpse	r18, r1
    18c4:	80 e0       	ldi	r24, 0x00	; 0
    18c6:	88 23       	and	r24, r24
    18c8:	39 f0       	breq	.+14     	; 0x18d8 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18ca:	e2 e1       	ldi	r30, 0x12	; 18
    18cc:	f1 e0       	ldi	r31, 0x01	; 1
    18ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    18d0:	95 8d       	ldd	r25, Z+29	; 0x1d
    18d2:	01 97       	sbiw	r24, 0x01	; 1
    18d4:	95 8f       	std	Z+29, r25	; 0x1d
    18d6:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    18d8:	e2 e1       	ldi	r30, 0x12	; 18
    18da:	f1 e0       	ldi	r31, 0x01	; 1
    18dc:	02 85       	ldd	r16, Z+10	; 0x0a
    18de:	13 85       	ldd	r17, Z+11	; 0x0b
    18e0:	24 85       	ldd	r18, Z+12	; 0x0c
    18e2:	35 85       	ldd	r19, Z+13	; 0x0d
    18e4:	46 81       	ldd	r20, Z+6	; 0x06
    18e6:	57 81       	ldd	r21, Z+7	; 0x07
    18e8:	60 85       	ldd	r22, Z+8	; 0x08
    18ea:	71 85       	ldd	r23, Z+9	; 0x09
    18ec:	0f 2e       	mov	r0, r31
    18ee:	f9 e2       	ldi	r31, 0x29	; 41
    18f0:	ef 2e       	mov	r14, r31
    18f2:	f0 2d       	mov	r31, r0
    18f4:	80 e2       	ldi	r24, 0x20	; 32
    18f6:	91 e0       	ldi	r25, 0x01	; 1
    18f8:	e6 d1       	rcall	.+972    	; 0x1cc6 <handle_joulemeter>
		systic_counter_fast = 0;
    18fa:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    18fe:	03 c0       	rjmp	.+6      	; 0x1906 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    1900:	8f 5f       	subi	r24, 0xFF	; 255
    1902:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1906:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    190a:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    190e:	84 36       	cpi	r24, 0x64	; 100
    1910:	91 05       	cpc	r25, r1
    1912:	01 f5       	brne	.+64     	; 0x1954 <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    1914:	8d b7       	in	r24, 0x3d	; 61
    1916:	9e b7       	in	r25, 0x3e	; 62
    1918:	cd 97       	sbiw	r24, 0x3d	; 61
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	9e bf       	out	0x3e, r25	; 62
    1920:	0f be       	out	0x3f, r0	; 63
    1922:	8d bf       	out	0x3d, r24	; 61
    1924:	ad b7       	in	r26, 0x3d	; 61
    1926:	be b7       	in	r27, 0x3e	; 62
    1928:	11 96       	adiw	r26, 0x01	; 1
    192a:	8d e3       	ldi	r24, 0x3D	; 61
    192c:	e2 e1       	ldi	r30, 0x12	; 18
    192e:	f1 e0       	ldi	r31, 0x01	; 1
    1930:	01 90       	ld	r0, Z+
    1932:	0d 92       	st	X+, r0
    1934:	8a 95       	dec	r24
    1936:	e1 f7       	brne	.-8      	; 0x1930 <__vector_16+0x124>
    1938:	02 db       	rcall	.-2556   	; 0xf3e <manage_LEDs>
		systic_counter_slow = 0;
    193a:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    193e:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    1942:	8d b7       	in	r24, 0x3d	; 61
    1944:	9e b7       	in	r25, 0x3e	; 62
    1946:	cd 96       	adiw	r24, 0x3d	; 61
    1948:	0f b6       	in	r0, 0x3f	; 63
    194a:	f8 94       	cli
    194c:	9e bf       	out	0x3e, r25	; 62
    194e:	0f be       	out	0x3f, r0	; 63
    1950:	8d bf       	out	0x3d, r24	; 61
    1952:	05 c0       	rjmp	.+10     	; 0x195e <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    1954:	01 96       	adiw	r24, 0x01	; 1
    1956:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    195a:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    195e:	ff 91       	pop	r31
    1960:	ef 91       	pop	r30
    1962:	bf 91       	pop	r27
    1964:	af 91       	pop	r26
    1966:	9f 91       	pop	r25
    1968:	8f 91       	pop	r24
    196a:	7f 91       	pop	r23
    196c:	6f 91       	pop	r22
    196e:	5f 91       	pop	r21
    1970:	4f 91       	pop	r20
    1972:	3f 91       	pop	r19
    1974:	2f 91       	pop	r18
    1976:	1f 91       	pop	r17
    1978:	0f 91       	pop	r16
    197a:	ef 90       	pop	r14
    197c:	0f 90       	pop	r0
    197e:	0b be       	out	0x3b, r0	; 59
    1980:	0f 90       	pop	r0
    1982:	0f be       	out	0x3f, r0	; 63
    1984:	0f 90       	pop	r0
    1986:	1f 90       	pop	r1
    1988:	18 95       	reti

0000198a <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    198a:	1f 92       	push	r1
    198c:	0f 92       	push	r0
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	0f 92       	push	r0
    1992:	11 24       	eor	r1, r1
    1994:	0b b6       	in	r0, 0x3b	; 59
    1996:	0f 92       	push	r0
    1998:	2f 93       	push	r18
    199a:	3f 93       	push	r19
    199c:	4f 93       	push	r20
    199e:	5f 93       	push	r21
    19a0:	6f 93       	push	r22
    19a2:	7f 93       	push	r23
    19a4:	8f 93       	push	r24
    19a6:	9f 93       	push	r25
    19a8:	af 93       	push	r26
    19aa:	bf 93       	push	r27
    19ac:	ef 93       	push	r30
    19ae:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    19b0:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19b4:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19b8:	80 3d       	cpi	r24, 0xD0	; 208
    19ba:	97 40       	sbci	r25, 0x07	; 7
    19bc:	50 f4       	brcc	.+20     	; 0x19d2 <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19be:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19c2:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19c6:	01 96       	adiw	r24, 0x01	; 1
    19c8:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19cc:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19d0:	08 c0       	rjmp	.+16     	; 0x19e2 <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19d2:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    19d6:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    19da:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    19de:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    19e2:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19e6:	87 30       	cpi	r24, 0x07	; 7
    19e8:	41 f4       	brne	.+16     	; 0x19fa <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    19ea:	84 e1       	ldi	r24, 0x14	; 20
    19ec:	91 e0       	ldi	r25, 0x01	; 1
    19ee:	0e 94 3d 04 	call	0x87a	; 0x87a <SPI_handler_7>
		u8_SPI_count = 0 ;
    19f2:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    19f6:	80 e0       	ldi	r24, 0x00	; 0
    19f8:	13 c0       	rjmp	.+38     	; 0x1a20 <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    19fa:	86 30       	cpi	r24, 0x06	; 6
    19fc:	49 f4       	brne	.+18     	; 0x1a10 <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    19fe:	8d e3       	ldi	r24, 0x3D	; 61
    1a00:	91 e0       	ldi	r25, 0x01	; 1
    1a02:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPI_handler_6>
		u8_SPI_count ++ ;
    1a06:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a0a:	8f 5f       	subi	r24, 0xFF	; 255
    1a0c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1a10:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a14:	85 30       	cpi	r24, 0x05	; 5
    1a16:	21 f4       	brne	.+8      	; 0x1a20 <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1a18:	86 e0       	ldi	r24, 0x06	; 6
    1a1a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a1e:	13 c0       	rjmp	.+38     	; 0x1a46 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a20:	84 30       	cpi	r24, 0x04	; 4
    1a22:	49 f4       	brne	.+18     	; 0x1a36 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a24:	84 e2       	ldi	r24, 0x24	; 36
    1a26:	91 e0       	ldi	r25, 0x01	; 1
    1a28:	0e 94 c9 03 	call	0x792	; 0x792 <SPI_handler_4>
		u8_SPI_count ++ ;
    1a2c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a30:	8f 5f       	subi	r24, 0xFF	; 255
    1a32:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a36:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a3a:	83 30       	cpi	r24, 0x03	; 3
    1a3c:	21 f4       	brne	.+8      	; 0x1a46 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a3e:	84 e0       	ldi	r24, 0x04	; 4
    1a40:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a44:	13 c0       	rjmp	.+38     	; 0x1a6c <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a46:	82 30       	cpi	r24, 0x02	; 2
    1a48:	21 f4       	brne	.+8      	; 0x1a52 <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a4a:	83 e0       	ldi	r24, 0x03	; 3
    1a4c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a50:	1a c0       	rjmp	.+52     	; 0x1a86 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a52:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a56:	81 30       	cpi	r24, 0x01	; 1
    1a58:	49 f4       	brne	.+18     	; 0x1a6c <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a5a:	88 e1       	ldi	r24, 0x18	; 24
    1a5c:	91 e0       	ldi	r25, 0x01	; 1
    1a5e:	0e 94 a7 03 	call	0x74e	; 0x74e <SPI_handler_1>
		u8_SPI_count ++ ;
    1a62:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a66:	8f 5f       	subi	r24, 0xFF	; 255
    1a68:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a6c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a70:	81 11       	cpse	r24, r1
    1a72:	09 c0       	rjmp	.+18     	; 0x1a86 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1a74:	8c e1       	ldi	r24, 0x1C	; 28
    1a76:	91 e0       	ldi	r25, 0x01	; 1
    1a78:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <SPI_handler_0>
		u8_SPI_count ++ ;
    1a7c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a80:	8f 5f       	subi	r24, 0xFF	; 255
    1a82:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1a86:	ff 91       	pop	r31
    1a88:	ef 91       	pop	r30
    1a8a:	bf 91       	pop	r27
    1a8c:	af 91       	pop	r26
    1a8e:	9f 91       	pop	r25
    1a90:	8f 91       	pop	r24
    1a92:	7f 91       	pop	r23
    1a94:	6f 91       	pop	r22
    1a96:	5f 91       	pop	r21
    1a98:	4f 91       	pop	r20
    1a9a:	3f 91       	pop	r19
    1a9c:	2f 91       	pop	r18
    1a9e:	0f 90       	pop	r0
    1aa0:	0b be       	out	0x3b, r0	; 59
    1aa2:	0f 90       	pop	r0
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	0f 90       	pop	r0
    1aa8:	1f 90       	pop	r1
    1aaa:	18 95       	reti

00001aac <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1aac:	1f 92       	push	r1
    1aae:	0f 92       	push	r0
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	0f 92       	push	r0
    1ab4:	11 24       	eor	r1, r1
    1ab6:	0b b6       	in	r0, 0x3b	; 59
    1ab8:	0f 92       	push	r0
    1aba:	2f 93       	push	r18
    1abc:	3f 93       	push	r19
    1abe:	4f 93       	push	r20
    1ac0:	5f 93       	push	r21
    1ac2:	6f 93       	push	r22
    1ac4:	7f 93       	push	r23
    1ac6:	8f 93       	push	r24
    1ac8:	9f 93       	push	r25
    1aca:	af 93       	push	r26
    1acc:	bf 93       	push	r27
    1ace:	ef 93       	push	r30
    1ad0:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1ad2:	60 e0       	ldi	r22, 0x00	; 0
    1ad4:	72 e0       	ldi	r23, 0x02	; 2
    1ad6:	85 e2       	ldi	r24, 0x25	; 37
    1ad8:	91 e0       	ldi	r25, 0x01	; 1
    1ada:	95 da       	rcall	.-2774   	; 0x1006 <handle_speed_sensor>
}
    1adc:	ff 91       	pop	r31
    1ade:	ef 91       	pop	r30
    1ae0:	bf 91       	pop	r27
    1ae2:	af 91       	pop	r26
    1ae4:	9f 91       	pop	r25
    1ae6:	8f 91       	pop	r24
    1ae8:	7f 91       	pop	r23
    1aea:	6f 91       	pop	r22
    1aec:	5f 91       	pop	r21
    1aee:	4f 91       	pop	r20
    1af0:	3f 91       	pop	r19
    1af2:	2f 91       	pop	r18
    1af4:	0f 90       	pop	r0
    1af6:	0b be       	out	0x3b, r0	; 59
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	0f 90       	pop	r0
    1afe:	1f 90       	pop	r1
    1b00:	18 95       	reti

00001b02 <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1b02:	08 95       	ret

00001b04 <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1b04:	7a 99       	sbic	0x0f, 2	; 15
    1b06:	03 c0       	rjmp	.+6      	; 0x1b0e <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1b08:	fc 01       	movw	r30, r24
    1b0a:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1b0c:	10 8e       	std	Z+24, r1	; 0x18
    1b0e:	08 95       	ret

00001b10 <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1b10:	8f 92       	push	r8
    1b12:	9f 92       	push	r9
    1b14:	af 92       	push	r10
    1b16:	bf 92       	push	r11
    1b18:	cf 92       	push	r12
    1b1a:	df 92       	push	r13
    1b1c:	ef 92       	push	r14
    1b1e:	ff 92       	push	r15
    1b20:	0f 93       	push	r16
    1b22:	1f 93       	push	r17
    1b24:	cf 93       	push	r28
    1b26:	df 93       	push	r29
    1b28:	00 d0       	rcall	.+0      	; 0x1b2a <handle_current_sensor+0x1a>
    1b2a:	00 d0       	rcall	.+0      	; 0x1b2c <handle_current_sensor+0x1c>
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
    1b30:	8c 01       	movw	r16, r24
    1b32:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	e6 d4       	rcall	.+2508   	; 0x2506 <__floatunsisf>
    1b3a:	20 e0       	ldi	r18, 0x00	; 0
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	40 ea       	ldi	r20, 0xA0	; 160
    1b40:	50 e4       	ldi	r21, 0x40	; 64
    1b42:	97 d5       	rcall	.+2862   	; 0x2672 <__mulsf3>
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	40 e8       	ldi	r20, 0x80	; 128
    1b4a:	59 e3       	ldi	r21, 0x39	; 57
    1b4c:	92 d5       	rcall	.+2852   	; 0x2672 <__mulsf3>
    1b4e:	20 e0       	ldi	r18, 0x00	; 0
    1b50:	30 e0       	ldi	r19, 0x00	; 0
    1b52:	40 e0       	ldi	r20, 0x00	; 0
    1b54:	51 e4       	ldi	r21, 0x41	; 65
    1b56:	8d d5       	rcall	.+2842   	; 0x2672 <__mulsf3>
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	40 ea       	ldi	r20, 0xA0	; 160
    1b5e:	51 e4       	ldi	r21, 0x41	; 65
    1b60:	d0 d3       	rcall	.+1952   	; 0x2302 <__subsf3>
    1b62:	69 83       	std	Y+1, r22	; 0x01
    1b64:	7a 83       	std	Y+2, r23	; 0x02
    1b66:	8b 83       	std	Y+3, r24	; 0x03
    1b68:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b6a:	ff 20       	and	r15, r15
    1b6c:	49 f0       	breq	.+18     	; 0x1b80 <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	9a 81       	ldd	r25, Y+2	; 0x02
    1b72:	ab 81       	ldd	r26, Y+3	; 0x03
    1b74:	bc 81       	ldd	r27, Y+4	; 0x04
    1b76:	89 83       	std	Y+1, r24	; 0x01
    1b78:	9a 83       	std	Y+2, r25	; 0x02
    1b7a:	ab 83       	std	Y+3, r26	; 0x03
    1b7c:	bc 83       	std	Y+4, r27	; 0x04
    1b7e:	08 c0       	rjmp	.+16     	; 0x1b90 <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b80:	89 81       	ldd	r24, Y+1	; 0x01
    1b82:	9a 81       	ldd	r25, Y+2	; 0x02
    1b84:	ab 81       	ldd	r26, Y+3	; 0x03
    1b86:	bc 81       	ldd	r27, Y+4	; 0x04
    1b88:	89 83       	std	Y+1, r24	; 0x01
    1b8a:	9a 83       	std	Y+2, r25	; 0x02
    1b8c:	ab 83       	std	Y+3, r26	; 0x03
    1b8e:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1b90:	f8 01       	movw	r30, r16
    1b92:	60 81       	ld	r22, Z
    1b94:	71 81       	ldd	r23, Z+1	; 0x01
    1b96:	82 81       	ldd	r24, Z+2	; 0x02
    1b98:	93 81       	ldd	r25, Z+3	; 0x03
    1b9a:	89 80       	ldd	r8, Y+1	; 0x01
    1b9c:	9a 80       	ldd	r9, Y+2	; 0x02
    1b9e:	ab 80       	ldd	r10, Y+3	; 0x03
    1ba0:	bc 80       	ldd	r11, Y+4	; 0x04
    1ba2:	26 e6       	ldi	r18, 0x66	; 102
    1ba4:	36 e6       	ldi	r19, 0x66	; 102
    1ba6:	46 e6       	ldi	r20, 0x66	; 102
    1ba8:	5f e3       	ldi	r21, 0x3F	; 63
    1baa:	63 d5       	rcall	.+2758   	; 0x2672 <__mulsf3>
    1bac:	6b 01       	movw	r12, r22
    1bae:	7c 01       	movw	r14, r24
    1bb0:	2d ec       	ldi	r18, 0xCD	; 205
    1bb2:	3c ec       	ldi	r19, 0xCC	; 204
    1bb4:	4c ec       	ldi	r20, 0xCC	; 204
    1bb6:	5d e3       	ldi	r21, 0x3D	; 61
    1bb8:	c5 01       	movw	r24, r10
    1bba:	b4 01       	movw	r22, r8
    1bbc:	5a d5       	rcall	.+2740   	; 0x2672 <__mulsf3>
    1bbe:	9b 01       	movw	r18, r22
    1bc0:	ac 01       	movw	r20, r24
    1bc2:	c7 01       	movw	r24, r14
    1bc4:	b6 01       	movw	r22, r12
    1bc6:	9e d3       	rcall	.+1852   	; 0x2304 <__addsf3>
    1bc8:	f8 01       	movw	r30, r16
    1bca:	60 83       	st	Z, r22
    1bcc:	71 83       	std	Z+1, r23	; 0x01
    1bce:	82 83       	std	Z+2, r24	; 0x02
    1bd0:	93 83       	std	Z+3, r25	; 0x03
}
    1bd2:	0f 90       	pop	r0
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	0f 90       	pop	r0
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	1f 91       	pop	r17
    1be0:	0f 91       	pop	r16
    1be2:	ff 90       	pop	r15
    1be4:	ef 90       	pop	r14
    1be6:	df 90       	pop	r13
    1be8:	cf 90       	pop	r12
    1bea:	bf 90       	pop	r11
    1bec:	af 90       	pop	r10
    1bee:	9f 90       	pop	r9
    1bf0:	8f 90       	pop	r8
    1bf2:	08 95       	ret

00001bf4 <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1bf4:	cf 92       	push	r12
    1bf6:	df 92       	push	r13
    1bf8:	ef 92       	push	r14
    1bfa:	ff 92       	push	r15
    1bfc:	cf 93       	push	r28
    1bfe:	df 93       	push	r29
    1c00:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1c02:	80 e0       	ldi	r24, 0x00	; 0
    1c04:	90 e0       	ldi	r25, 0x00	; 0
    1c06:	7f d4       	rcall	.+2302   	; 0x2506 <__floatunsisf>
    1c08:	20 e0       	ldi	r18, 0x00	; 0
    1c0a:	30 e0       	ldi	r19, 0x00	; 0
    1c0c:	40 ea       	ldi	r20, 0xA0	; 160
    1c0e:	50 e4       	ldi	r21, 0x40	; 64
    1c10:	30 d5       	rcall	.+2656   	; 0x2672 <__mulsf3>
    1c12:	20 e0       	ldi	r18, 0x00	; 0
    1c14:	30 e0       	ldi	r19, 0x00	; 0
    1c16:	40 e8       	ldi	r20, 0x80	; 128
    1c18:	59 e3       	ldi	r21, 0x39	; 57
    1c1a:	2b d5       	rcall	.+2646   	; 0x2672 <__mulsf3>
    1c1c:	6b 01       	movw	r12, r22
    1c1e:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c20:	2d ec       	ldi	r18, 0xCD	; 205
    1c22:	3c ec       	ldi	r19, 0xCC	; 204
    1c24:	4c e6       	ldi	r20, 0x6C	; 108
    1c26:	50 e4       	ldi	r21, 0x40	; 64
    1c28:	d1 d3       	rcall	.+1954   	; 0x23cc <__cmpsf2>
    1c2a:	18 16       	cp	r1, r24
    1c2c:	74 f0       	brlt	.+28     	; 0x1c4a <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c2e:	20 e0       	ldi	r18, 0x00	; 0
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	40 ea       	ldi	r20, 0xA0	; 160
    1c34:	51 e4       	ldi	r21, 0x41	; 65
    1c36:	c7 01       	movw	r24, r14
    1c38:	b6 01       	movw	r22, r12
    1c3a:	1b d5       	rcall	.+2614   	; 0x2672 <__mulsf3>
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	40 eb       	ldi	r20, 0xB0	; 176
    1c42:	51 e4       	ldi	r21, 0x41	; 65
    1c44:	5e d3       	rcall	.+1724   	; 0x2302 <__subsf3>
    1c46:	33 d4       	rcall	.+2150   	; 0x24ae <__fixunssfsi>
    1c48:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c4a:	26 e6       	ldi	r18, 0x66	; 102
    1c4c:	36 e6       	ldi	r19, 0x66	; 102
    1c4e:	46 e9       	ldi	r20, 0x96	; 150
    1c50:	50 e4       	ldi	r21, 0x40	; 64
    1c52:	c7 01       	movw	r24, r14
    1c54:	b6 01       	movw	r22, r12
    1c56:	ba d3       	rcall	.+1908   	; 0x23cc <__cmpsf2>
    1c58:	18 16       	cp	r1, r24
    1c5a:	bc f0       	brlt	.+46     	; 0x1c8a <handle_temp_sensor+0x96>
    1c5c:	2d ec       	ldi	r18, 0xCD	; 205
    1c5e:	3c ec       	ldi	r19, 0xCC	; 204
    1c60:	4c e6       	ldi	r20, 0x6C	; 108
    1c62:	50 e4       	ldi	r21, 0x40	; 64
    1c64:	c7 01       	movw	r24, r14
    1c66:	b6 01       	movw	r22, r12
    1c68:	00 d5       	rcall	.+2560   	; 0x266a <__gesf2>
    1c6a:	18 16       	cp	r1, r24
    1c6c:	74 f4       	brge	.+28     	; 0x1c8a <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c6e:	20 e0       	ldi	r18, 0x00	; 0
    1c70:	30 e0       	ldi	r19, 0x00	; 0
    1c72:	4e e5       	ldi	r20, 0x5E	; 94
    1c74:	52 e4       	ldi	r21, 0x42	; 66
    1c76:	c7 01       	movw	r24, r14
    1c78:	b6 01       	movw	r22, r12
    1c7a:	fb d4       	rcall	.+2550   	; 0x2672 <__mulsf3>
    1c7c:	20 e0       	ldi	r18, 0x00	; 0
    1c7e:	30 e8       	ldi	r19, 0x80	; 128
    1c80:	4b e1       	ldi	r20, 0x1B	; 27
    1c82:	53 e4       	ldi	r21, 0x43	; 67
    1c84:	3e d3       	rcall	.+1660   	; 0x2302 <__subsf3>
    1c86:	13 d4       	rcall	.+2086   	; 0x24ae <__fixunssfsi>
    1c88:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c8a:	26 e6       	ldi	r18, 0x66	; 102
    1c8c:	36 e6       	ldi	r19, 0x66	; 102
    1c8e:	46 e9       	ldi	r20, 0x96	; 150
    1c90:	50 e4       	ldi	r21, 0x40	; 64
    1c92:	c7 01       	movw	r24, r14
    1c94:	b6 01       	movw	r22, r12
    1c96:	e9 d4       	rcall	.+2514   	; 0x266a <__gesf2>
    1c98:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1c9a:	74 f4       	brge	.+28     	; 0x1cb8 <handle_temp_sensor+0xc4>
    1c9c:	20 e0       	ldi	r18, 0x00	; 0
    1c9e:	30 e0       	ldi	r19, 0x00	; 0
    1ca0:	48 e4       	ldi	r20, 0x48	; 72
    1ca2:	53 e4       	ldi	r21, 0x43	; 67
    1ca4:	c7 01       	movw	r24, r14
    1ca6:	b6 01       	movw	r22, r12
    1ca8:	e4 d4       	rcall	.+2504   	; 0x2672 <__mulsf3>
    1caa:	20 e0       	ldi	r18, 0x00	; 0
    1cac:	30 e0       	ldi	r19, 0x00	; 0
    1cae:	42 e5       	ldi	r20, 0x52	; 82
    1cb0:	54 e4       	ldi	r21, 0x44	; 68
    1cb2:	27 d3       	rcall	.+1614   	; 0x2302 <__subsf3>
    1cb4:	fc d3       	rcall	.+2040   	; 0x24ae <__fixunssfsi>
    1cb6:	68 83       	st	Y, r22
    1cb8:	df 91       	pop	r29
    1cba:	cf 91       	pop	r28
	}
}
    1cbc:	ff 90       	pop	r15
    1cbe:	ef 90       	pop	r14
    1cc0:	df 90       	pop	r13
    1cc2:	cf 90       	pop	r12
    1cc4:	08 95       	ret

00001cc6 <handle_joulemeter>:
    1cc6:	4f 92       	push	r4
    1cc8:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cca:	6f 92       	push	r6
    1ccc:	7f 92       	push	r7
    1cce:	8f 92       	push	r8
    1cd0:	9f 92       	push	r9
    1cd2:	af 92       	push	r10
    1cd4:	bf 92       	push	r11
    1cd6:	cf 92       	push	r12
    1cd8:	df 92       	push	r13
    1cda:	ef 92       	push	r14
    1cdc:	0f 93       	push	r16
    1cde:	1f 93       	push	r17
    1ce0:	cf 93       	push	r28
    1ce2:	df 93       	push	r29
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	28 97       	sbiw	r28, 0x08	; 8
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	de bf       	out	0x3e, r29	; 62
    1cf0:	0f be       	out	0x3f, r0	; 63
    1cf2:	cd bf       	out	0x3d, r28	; 61
    1cf4:	6c 01       	movw	r12, r24
    1cf6:	49 83       	std	Y+1, r20	; 0x01
    1cf8:	5a 83       	std	Y+2, r21	; 0x02
    1cfa:	6b 83       	std	Y+3, r22	; 0x03
    1cfc:	7c 83       	std	Y+4, r23	; 0x04
    1cfe:	0d 83       	std	Y+5, r16	; 0x05
    1d00:	1e 83       	std	Y+6, r17	; 0x06
    1d02:	2f 83       	std	Y+7, r18	; 0x07
    1d04:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1d06:	6d 81       	ldd	r22, Y+5	; 0x05
    1d08:	7e 81       	ldd	r23, Y+6	; 0x06
    1d0a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d0c:	98 85       	ldd	r25, Y+8	; 0x08
    1d0e:	29 81       	ldd	r18, Y+1	; 0x01
    1d10:	3a 81       	ldd	r19, Y+2	; 0x02
    1d12:	4b 81       	ldd	r20, Y+3	; 0x03
    1d14:	5c 81       	ldd	r21, Y+4	; 0x04
    1d16:	f6 01       	movw	r30, r12
    1d18:	80 80       	ld	r8, Z
    1d1a:	91 80       	ldd	r9, Z+1	; 0x01
    1d1c:	a2 80       	ldd	r10, Z+2	; 0x02
    1d1e:	b3 80       	ldd	r11, Z+3	; 0x03
    1d20:	a8 d4       	rcall	.+2384   	; 0x2672 <__mulsf3>
    1d22:	2b 01       	movw	r4, r22
    1d24:	3c 01       	movw	r6, r24
    1d26:	6e 2d       	mov	r22, r14
    1d28:	70 e0       	ldi	r23, 0x00	; 0
    1d2a:	80 e0       	ldi	r24, 0x00	; 0
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	eb d3       	rcall	.+2006   	; 0x2506 <__floatunsisf>
    1d30:	9b 01       	movw	r18, r22
    1d32:	ac 01       	movw	r20, r24
    1d34:	c3 01       	movw	r24, r6
    1d36:	b2 01       	movw	r22, r4
    1d38:	9c d4       	rcall	.+2360   	; 0x2672 <__mulsf3>
    1d3a:	20 e0       	ldi	r18, 0x00	; 0
    1d3c:	30 e0       	ldi	r19, 0x00	; 0
    1d3e:	4a e7       	ldi	r20, 0x7A	; 122
    1d40:	54 e4       	ldi	r21, 0x44	; 68
    1d42:	48 d3       	rcall	.+1680   	; 0x23d4 <__divsf3>
    1d44:	a5 01       	movw	r20, r10
    1d46:	94 01       	movw	r18, r8
    1d48:	dd d2       	rcall	.+1466   	; 0x2304 <__addsf3>
    1d4a:	f6 01       	movw	r30, r12
    1d4c:	60 83       	st	Z, r22
    1d4e:	71 83       	std	Z+1, r23	; 0x01
    1d50:	82 83       	std	Z+2, r24	; 0x02
    1d52:	93 83       	std	Z+3, r25	; 0x03
}
    1d54:	28 96       	adiw	r28, 0x08	; 8
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	de bf       	out	0x3e, r29	; 62
    1d5c:	0f be       	out	0x3f, r0	; 63
    1d5e:	cd bf       	out	0x3d, r28	; 61
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	ef 90       	pop	r14
    1d6a:	df 90       	pop	r13
    1d6c:	cf 90       	pop	r12
    1d6e:	bf 90       	pop	r11
    1d70:	af 90       	pop	r10
    1d72:	9f 90       	pop	r9
    1d74:	8f 90       	pop	r8
    1d76:	7f 90       	pop	r7
    1d78:	6f 90       	pop	r6
    1d7a:	5f 90       	pop	r5
    1d7c:	4f 90       	pop	r4
    1d7e:	08 95       	ret

00001d80 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	88 30       	cpi	r24, 0x08	; 8
    1d84:	91 05       	cpc	r25, r1
    1d86:	88 f5       	brcc	.+98     	; 0x1dea <Set_ADC_Channel_ext+0x6a>
    1d88:	fc 01       	movw	r30, r24
    1d8a:	e6 5b       	subi	r30, 0xB6	; 182
    1d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d8e:	d4 c4       	rjmp	.+2472   	; 0x2738 <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d90:	86 e0       	ldi	r24, 0x06	; 6
    1d92:	fb 01       	movw	r30, r22
    1d94:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1d96:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d98:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d9a:	86 e0       	ldi	r24, 0x06	; 6
    1d9c:	fb 01       	movw	r30, r22
    1d9e:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1da0:	80 e4       	ldi	r24, 0x40	; 64
    1da2:	81 83       	std	Z+1, r24	; 0x01
		break;
    1da4:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1da6:	86 e0       	ldi	r24, 0x06	; 6
    1da8:	fb 01       	movw	r30, r22
    1daa:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1dac:	80 e8       	ldi	r24, 0x80	; 128
    1dae:	81 83       	std	Z+1, r24	; 0x01
		break;
    1db0:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1db2:	86 e0       	ldi	r24, 0x06	; 6
    1db4:	fb 01       	movw	r30, r22
    1db6:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1db8:	80 ec       	ldi	r24, 0xC0	; 192
    1dba:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dbc:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dbe:	87 e0       	ldi	r24, 0x07	; 7
    1dc0:	fb 01       	movw	r30, r22
    1dc2:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1dc4:	11 82       	std	Z+1, r1	; 0x01
		break;
    1dc6:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dc8:	87 e0       	ldi	r24, 0x07	; 7
    1dca:	fb 01       	movw	r30, r22
    1dcc:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1dce:	80 e4       	ldi	r24, 0x40	; 64
    1dd0:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dd2:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dd4:	87 e0       	ldi	r24, 0x07	; 7
    1dd6:	fb 01       	movw	r30, r22
    1dd8:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1dda:	80 e8       	ldi	r24, 0x80	; 128
    1ddc:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dde:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1de0:	87 e0       	ldi	r24, 0x07	; 7
    1de2:	fb 01       	movw	r30, r22
    1de4:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1de6:	80 ec       	ldi	r24, 0xC0	; 192
    1de8:	81 83       	std	Z+1, r24	; 0x01
    1dea:	08 95       	ret

00001dec <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1dec:	1f 92       	push	r1
    1dee:	0f 92       	push	r0
    1df0:	0f b6       	in	r0, 0x3f	; 63
    1df2:	0f 92       	push	r0
    1df4:	11 24       	eor	r1, r1
    1df6:	0b b6       	in	r0, 0x3b	; 59
    1df8:	0f 92       	push	r0
    1dfa:	2f 93       	push	r18
    1dfc:	3f 93       	push	r19
    1dfe:	4f 93       	push	r20
    1e00:	5f 93       	push	r21
    1e02:	6f 93       	push	r22
    1e04:	8f 93       	push	r24
    1e06:	9f 93       	push	r25
    1e08:	af 93       	push	r26
    1e0a:	bf 93       	push	r27
    1e0c:	ef 93       	push	r30
    1e0e:	ff 93       	push	r31
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	1f 92       	push	r1
    1e16:	cd b7       	in	r28, 0x3d	; 61
    1e18:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1e1a:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e1e:	80 ff       	sbrs	r24, 0
    1e20:	47 c0       	rjmp	.+142    	; 0x1eb0 <__vector_18+0xc4>
    1e22:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e26:	90 ff       	sbrs	r25, 0
    1e28:	43 c0       	rjmp	.+134    	; 0x1eb0 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e2a:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e2e:	ee ee       	ldi	r30, 0xEE	; 238
    1e30:	f0 e0       	ldi	r31, 0x00	; 0
    1e32:	80 81       	ld	r24, Z
    1e34:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e36:	80 81       	ld	r24, Z
    1e38:	8f 7b       	andi	r24, 0xBF	; 191
    1e3a:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e3c:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e40:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e44:	98 17       	cp	r25, r24
    1e46:	89 f1       	breq	.+98     	; 0x1eaa <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e48:	8f 70       	andi	r24, 0x0F	; 15
    1e4a:	2b e0       	ldi	r18, 0x0B	; 11
    1e4c:	82 9f       	mul	r24, r18
    1e4e:	c0 01       	movw	r24, r0
    1e50:	11 24       	eor	r1, r1
    1e52:	fc 01       	movw	r30, r24
    1e54:	e1 54       	subi	r30, 0x41	; 65
    1e56:	fd 4f       	sbci	r31, 0xFD	; 253
    1e58:	20 81       	ld	r18, Z
    1e5a:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e5e:	20 81       	ld	r18, Z
    1e60:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e64:	21 81       	ldd	r18, Z+1	; 0x01
    1e66:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e6a:	23 81       	ldd	r18, Z+3	; 0x03
    1e6c:	aa ef       	ldi	r26, 0xFA	; 250
    1e6e:	b0 e0       	ldi	r27, 0x00	; 0
    1e70:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e72:	24 81       	ldd	r18, Z+4	; 0x04
    1e74:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1e76:	25 81       	ldd	r18, Z+5	; 0x05
    1e78:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e7a:	26 81       	ldd	r18, Z+6	; 0x06
    1e7c:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e7e:	27 81       	ldd	r18, Z+7	; 0x07
    1e80:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e82:	20 85       	ldd	r18, Z+8	; 0x08
    1e84:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e86:	21 85       	ldd	r18, Z+9	; 0x09
    1e88:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e8a:	22 85       	ldd	r18, Z+10	; 0x0a
    1e8c:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1e8e:	fc 01       	movw	r30, r24
    1e90:	ef 53       	subi	r30, 0x3F	; 63
    1e92:	fd 4f       	sbci	r31, 0xFD	; 253
    1e94:	80 81       	ld	r24, Z
    1e96:	8f 70       	andi	r24, 0x0F	; 15
    1e98:	80 64       	ori	r24, 0x40	; 64
    1e9a:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1e9e:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1ea2:	8f 5f       	subi	r24, 0xFF	; 255
    1ea4:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1ea8:	7d c0       	rjmp	.+250    	; 0x1fa4 <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1eaa:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1eae:	7a c0       	rjmp	.+244    	; 0x1fa4 <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1eb0:	81 ff       	sbrs	r24, 1
    1eb2:	78 c0       	rjmp	.+240    	; 0x1fa4 <__vector_18+0x1b8>
    1eb4:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1eb8:	81 ff       	sbrs	r24, 1
    1eba:	74 c0       	rjmp	.+232    	; 0x1fa4 <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1ebc:	80 e1       	ldi	r24, 0x10	; 16
    1ebe:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1ec2:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ec6:	28 2f       	mov	r18, r24
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1ece:	29 1b       	sub	r18, r25
    1ed0:	31 09       	sbc	r19, r1
    1ed2:	2f 77       	andi	r18, 0x7F	; 127
    1ed4:	33 27       	eor	r19, r19
    1ed6:	20 31       	cpi	r18, 0x10	; 16
    1ed8:	31 05       	cpc	r19, r1
    1eda:	0c f0       	brlt	.+2      	; 0x1ede <__vector_18+0xf2>
    1edc:	58 c0       	rjmp	.+176    	; 0x1f8e <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1ede:	e8 2f       	mov	r30, r24
    1ee0:	ef 70       	andi	r30, 0x0F	; 15
    1ee2:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1ee6:	2e 2f       	mov	r18, r30
    1ee8:	30 e0       	ldi	r19, 0x00	; 0
    1eea:	4b e0       	ldi	r20, 0x0B	; 11
    1eec:	e4 9f       	mul	r30, r20
    1eee:	f0 01       	movw	r30, r0
    1ef0:	11 24       	eor	r1, r1
    1ef2:	e1 5f       	subi	r30, 0xF1	; 241
    1ef4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ef6:	9f 70       	andi	r25, 0x0F	; 15
    1ef8:	42 81       	ldd	r20, Z+2	; 0x02
    1efa:	40 7f       	andi	r20, 0xF0	; 240
    1efc:	94 2b       	or	r25, r20
    1efe:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1f00:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1f04:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f08:	40 7e       	andi	r20, 0xE0	; 224
    1f0a:	97 70       	andi	r25, 0x07	; 7
    1f0c:	94 2b       	or	r25, r20
    1f0e:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1f10:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1f14:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1f16:	aa ef       	ldi	r26, 0xFA	; 250
    1f18:	b0 e0       	ldi	r27, 0x00	; 0
    1f1a:	9c 91       	ld	r25, X
    1f1c:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f1e:	9c 91       	ld	r25, X
    1f20:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f22:	9c 91       	ld	r25, X
    1f24:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f26:	9c 91       	ld	r25, X
    1f28:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f2a:	9c 91       	ld	r25, X
    1f2c:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f2e:	9c 91       	ld	r25, X
    1f30:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f32:	9c 91       	ld	r25, X
    1f34:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f36:	9c 91       	ld	r25, X
    1f38:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f3a:	8f 5f       	subi	r24, 0xFF	; 255
    1f3c:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f40:	40 81       	ld	r20, Z
    1f42:	42 95       	swap	r20
    1f44:	46 95       	lsr	r20
    1f46:	47 70       	andi	r20, 0x07	; 7
    1f48:	51 81       	ldd	r21, Z+1	; 0x01
    1f4a:	65 2f       	mov	r22, r21
    1f4c:	66 0f       	add	r22, r22
    1f4e:	66 0f       	add	r22, r22
    1f50:	66 0f       	add	r22, r22
    1f52:	86 2f       	mov	r24, r22
    1f54:	84 2b       	or	r24, r20
    1f56:	95 2f       	mov	r25, r21
    1f58:	92 95       	swap	r25
    1f5a:	96 95       	lsr	r25
    1f5c:	97 70       	andi	r25, 0x07	; 7
    1f5e:	89 2b       	or	r24, r25
    1f60:	b1 f4       	brne	.+44     	; 0x1f8e <__vector_18+0x1a2>
    1f62:	8b e0       	ldi	r24, 0x0B	; 11
    1f64:	82 9f       	mul	r24, r18
    1f66:	f0 01       	movw	r30, r0
    1f68:	83 9f       	mul	r24, r19
    1f6a:	f0 0d       	add	r31, r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	e1 5f       	subi	r30, 0xF1	; 241
    1f70:	fd 4f       	sbci	r31, 0xFD	; 253
    1f72:	83 81       	ldd	r24, Z+3	; 0x03
    1f74:	83 30       	cpi	r24, 0x03	; 3
    1f76:	59 f4       	brne	.+22     	; 0x1f8e <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1f78:	98 e0       	ldi	r25, 0x08	; 8
    1f7a:	88 e1       	ldi	r24, 0x18	; 24
    1f7c:	0f b6       	in	r0, 0x3f	; 63
    1f7e:	f8 94       	cli
    1f80:	a8 95       	wdr
    1f82:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f86:	0f be       	out	0x3f, r0	; 63
    1f88:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f8c:	ff cf       	rjmp	.-2      	; 0x1f8c <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1f8e:	ee ee       	ldi	r30, 0xEE	; 238
    1f90:	f0 e0       	ldi	r31, 0x00	; 0
    1f92:	80 81       	ld	r24, Z
    1f94:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1f96:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1f98:	80 81       	ld	r24, Z
    1f9a:	8f 7d       	andi	r24, 0xDF	; 223
    1f9c:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1f9e:	80 e8       	ldi	r24, 0x80	; 128
    1fa0:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1fa4:	0f 90       	pop	r0
    1fa6:	df 91       	pop	r29
    1fa8:	cf 91       	pop	r28
    1faa:	ff 91       	pop	r31
    1fac:	ef 91       	pop	r30
    1fae:	bf 91       	pop	r27
    1fb0:	af 91       	pop	r26
    1fb2:	9f 91       	pop	r25
    1fb4:	8f 91       	pop	r24
    1fb6:	6f 91       	pop	r22
    1fb8:	5f 91       	pop	r21
    1fba:	4f 91       	pop	r20
    1fbc:	3f 91       	pop	r19
    1fbe:	2f 91       	pop	r18
    1fc0:	0f 90       	pop	r0
    1fc2:	0b be       	out	0x3b, r0	; 59
    1fc4:	0f 90       	pop	r0
    1fc6:	0f be       	out	0x3f, r0	; 63
    1fc8:	0f 90       	pop	r0
    1fca:	1f 90       	pop	r1
    1fcc:	18 95       	reti

00001fce <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1fd2:	e8 ed       	ldi	r30, 0xD8	; 216
    1fd4:	f0 e0       	ldi	r31, 0x00	; 0
    1fd6:	21 e0       	ldi	r18, 0x01	; 1
    1fd8:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1fda:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1fde:	2c e0       	ldi	r18, 0x0C	; 12
    1fe0:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1fe4:	27 e3       	ldi	r18, 0x37	; 55
    1fe6:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1fea:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1fee:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1ff2:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1ff6:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1ffa:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1ffe:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    2002:	cd ee       	ldi	r28, 0xED	; 237
    2004:	d0 e0       	ldi	r29, 0x00	; 0
    2006:	18 82       	st	Y, r1
	CANSTMOB = 0;
    2008:	ae ee       	ldi	r26, 0xEE	; 238
    200a:	b0 e0       	ldi	r27, 0x00	; 0
    200c:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    200e:	20 e1       	ldi	r18, 0x10	; 16
    2010:	28 83       	st	Y, r18
	CANSTMOB = 0;
    2012:	1c 92       	st	X, r1
	CANIDM4 = 0;
    2014:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    2018:	28 2f       	mov	r18, r24
    201a:	22 95       	swap	r18
    201c:	22 0f       	add	r18, r18
    201e:	20 7e       	andi	r18, 0xE0	; 224
    2020:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    2024:	96 95       	lsr	r25
    2026:	87 95       	ror	r24
    2028:	96 95       	lsr	r25
    202a:	87 95       	ror	r24
    202c:	96 95       	lsr	r25
    202e:	87 95       	ror	r24
    2030:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    2034:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    2038:	86 2f       	mov	r24, r22
    203a:	82 95       	swap	r24
    203c:	88 0f       	add	r24, r24
    203e:	80 7e       	andi	r24, 0xE0	; 224
    2040:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    2044:	76 95       	lsr	r23
    2046:	67 95       	ror	r22
    2048:	76 95       	lsr	r23
    204a:	67 95       	ror	r22
    204c:	76 95       	lsr	r23
    204e:	67 95       	ror	r22
    2050:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    2054:	80 e8       	ldi	r24, 0x80	; 128
    2056:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    205a:	83 e0       	ldi	r24, 0x03	; 3
    205c:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    2060:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    2064:	80 eb       	ldi	r24, 0xB0	; 176
    2066:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    206a:	82 e0       	ldi	r24, 0x02	; 2
    206c:	80 83       	st	Z, r24

	reset = 0;
    206e:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    2072:	df 91       	pop	r29
    2074:	cf 91       	pop	r28
    2076:	08 95       	ret

00002078 <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    2078:	cf 93       	push	r28
    207a:	df 93       	push	r29
    207c:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    207e:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    2082:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    2086:	24 17       	cp	r18, r20
    2088:	89 f1       	breq	.+98     	; 0x20ec <can_read_message_if_new+0x74>
    208a:	a4 2f       	mov	r26, r20
    208c:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    208e:	8b e0       	ldi	r24, 0x0B	; 11
    2090:	a8 9f       	mul	r26, r24
    2092:	b0 01       	movw	r22, r0
    2094:	11 24       	eor	r1, r1
    2096:	fb 01       	movw	r30, r22
    2098:	e1 5f       	subi	r30, 0xF1	; 241
    209a:	fd 4f       	sbci	r31, 0xFD	; 253
    209c:	20 81       	ld	r18, Z
    209e:	22 95       	swap	r18
    20a0:	26 95       	lsr	r18
    20a2:	27 70       	andi	r18, 0x07	; 7
    20a4:	31 81       	ldd	r19, Z+1	; 0x01
    20a6:	53 2f       	mov	r21, r19
    20a8:	55 0f       	add	r21, r21
    20aa:	55 0f       	add	r21, r21
    20ac:	55 0f       	add	r21, r21
    20ae:	25 2b       	or	r18, r21
    20b0:	32 95       	swap	r19
    20b2:	36 95       	lsr	r19
    20b4:	37 70       	andi	r19, 0x07	; 7
    20b6:	28 83       	st	Y, r18
    20b8:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    20ba:	fb 01       	movw	r30, r22
    20bc:	ef 5e       	subi	r30, 0xEF	; 239
    20be:	fd 4f       	sbci	r31, 0xFD	; 253
    20c0:	20 81       	ld	r18, Z
    20c2:	2f 70       	andi	r18, 0x0F	; 15
    20c4:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20c6:	22 23       	and	r18, r18
    20c8:	99 f0       	breq	.+38     	; 0x20f0 <can_read_message_if_new+0x78>
    20ca:	db 01       	movw	r26, r22
    20cc:	ae 5e       	subi	r26, 0xEE	; 238
    20ce:	bd 4f       	sbci	r27, 0xFD	; 253
    20d0:	fe 01       	movw	r30, r28
    20d2:	33 96       	adiw	r30, 0x03	; 3
    20d4:	30 e0       	ldi	r19, 0x00	; 0
    20d6:	2d 5f       	subi	r18, 0xFD	; 253
    20d8:	3f 4f       	sbci	r19, 0xFF	; 255
    20da:	ce 01       	movw	r24, r28
    20dc:	82 0f       	add	r24, r18
    20de:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    20e0:	2d 91       	ld	r18, X+
    20e2:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    20e4:	e8 17       	cp	r30, r24
    20e6:	f9 07       	cpc	r31, r25
    20e8:	d9 f7       	brne	.-10     	; 0x20e0 <can_read_message_if_new+0x68>
    20ea:	02 c0       	rjmp	.+4      	; 0x20f0 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	04 c0       	rjmp	.+8      	; 0x20f8 <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    20f0:	4f 5f       	subi	r20, 0xFF	; 255
    20f2:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    20f6:	81 e0       	ldi	r24, 0x01	; 1
}
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	08 95       	ret

000020fe <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
    2102:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    2104:	ab ed       	ldi	r26, 0xDB	; 219
    2106:	b0 e0       	ldi	r27, 0x00	; 0
    2108:	8c 91       	ld	r24, X
    210a:	8f 77       	andi	r24, 0x7F	; 127
    210c:	8c 93       	st	X, r24

	if (!tx_busy) {
    210e:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    2112:	81 11       	cpse	r24, r1
    2114:	27 c0       	rjmp	.+78     	; 0x2164 <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2116:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    211a:	80 81       	ld	r24, Z
    211c:	82 95       	swap	r24
    211e:	88 0f       	add	r24, r24
    2120:	80 7e       	andi	r24, 0xE0	; 224
    2122:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2126:	80 81       	ld	r24, Z
    2128:	91 81       	ldd	r25, Z+1	; 0x01
    212a:	96 95       	lsr	r25
    212c:	87 95       	ror	r24
    212e:	96 95       	lsr	r25
    2130:	87 95       	ror	r24
    2132:	96 95       	lsr	r25
    2134:	87 95       	ror	r24
    2136:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    213a:	df 01       	movw	r26, r30
    213c:	13 96       	adiw	r26, 0x03	; 3
    213e:	9f 01       	movw	r18, r30
    2140:	25 5f       	subi	r18, 0xF5	; 245
    2142:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    2144:	ca ef       	ldi	r28, 0xFA	; 250
    2146:	d0 e0       	ldi	r29, 0x00	; 0
    2148:	9d 91       	ld	r25, X+
    214a:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    214c:	a2 17       	cp	r26, r18
    214e:	b3 07       	cpc	r27, r19
    2150:	d9 f7       	brne	.-10     	; 0x2148 <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    2152:	81 e0       	ldi	r24, 0x01	; 1
    2154:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    2158:	82 81       	ldd	r24, Z+2	; 0x02
    215a:	80 64       	ori	r24, 0x40	; 64
    215c:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    2160:	81 e0       	ldi	r24, 0x01	; 1
    2162:	43 c0       	rjmp	.+134    	; 0x21ea <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    2164:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    2168:	82 2f       	mov	r24, r18
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    2170:	83 1b       	sub	r24, r19
    2172:	91 09       	sbc	r25, r1
    2174:	8f 77       	andi	r24, 0x7F	; 127
    2176:	99 27       	eor	r25, r25
    2178:	40 97       	sbiw	r24, 0x10	; 16
    217a:	b1 f1       	breq	.+108    	; 0x21e8 <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    217c:	a2 2f       	mov	r26, r18
    217e:	af 70       	andi	r26, 0x0F	; 15
    2180:	8b e0       	ldi	r24, 0x0B	; 11
    2182:	a8 9f       	mul	r26, r24
    2184:	d0 01       	movw	r26, r0
    2186:	11 24       	eor	r1, r1
    2188:	ed 01       	movw	r28, r26
    218a:	c1 54       	subi	r28, 0x41	; 65
    218c:	dd 4f       	sbci	r29, 0xFD	; 253
    218e:	80 81       	ld	r24, Z
    2190:	98 2f       	mov	r25, r24
    2192:	92 95       	swap	r25
    2194:	99 0f       	add	r25, r25
    2196:	90 7e       	andi	r25, 0xE0	; 224
    2198:	88 81       	ld	r24, Y
    219a:	8f 71       	andi	r24, 0x1F	; 31
    219c:	89 2b       	or	r24, r25
    219e:	88 83       	st	Y, r24
    21a0:	80 81       	ld	r24, Z
    21a2:	98 2f       	mov	r25, r24
    21a4:	96 95       	lsr	r25
    21a6:	96 95       	lsr	r25
    21a8:	96 95       	lsr	r25
    21aa:	89 81       	ldd	r24, Y+1	; 0x01
    21ac:	80 7e       	andi	r24, 0xE0	; 224
    21ae:	89 2b       	or	r24, r25
    21b0:	89 83       	std	Y+1, r24	; 0x01
    21b2:	91 81       	ldd	r25, Z+1	; 0x01
    21b4:	92 95       	swap	r25
    21b6:	99 0f       	add	r25, r25
    21b8:	90 7e       	andi	r25, 0xE0	; 224
    21ba:	8f 71       	andi	r24, 0x1F	; 31
    21bc:	89 2b       	or	r24, r25
    21be:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21c0:	82 81       	ldd	r24, Z+2	; 0x02
    21c2:	98 2f       	mov	r25, r24
    21c4:	9f 70       	andi	r25, 0x0F	; 15
    21c6:	8a 81       	ldd	r24, Y+2	; 0x02
    21c8:	80 7f       	andi	r24, 0xF0	; 240
    21ca:	89 2b       	or	r24, r25
    21cc:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21ce:	ae 53       	subi	r26, 0x3E	; 62
    21d0:	bd 4f       	sbci	r27, 0xFD	; 253
    21d2:	33 96       	adiw	r30, 0x03	; 3
    21d4:	88 e0       	ldi	r24, 0x08	; 8
    21d6:	01 90       	ld	r0, Z+
    21d8:	0d 92       	st	X+, r0
    21da:	8a 95       	dec	r24
    21dc:	e1 f7       	brne	.-8      	; 0x21d6 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    21de:	2f 5f       	subi	r18, 0xFF	; 255
    21e0:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	01 c0       	rjmp	.+2      	; 0x21ea <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    21e8:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    21ea:	eb ed       	ldi	r30, 0xDB	; 219
    21ec:	f0 e0       	ldi	r31, 0x00	; 0
    21ee:	90 81       	ld	r25, Z
    21f0:	90 68       	ori	r25, 0x80	; 128
    21f2:	90 83       	st	Z, r25

	return result;
    21f4:	df 91       	pop	r29
    21f6:	cf 91       	pop	r28
    21f8:	08 95       	ret

000021fa <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    21fa:	95 b1       	in	r25, 0x05	; 5
    21fc:	89 2b       	or	r24, r25
    21fe:	85 b9       	out	0x05, r24	; 5
    2200:	08 95       	ret

00002202 <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    2202:	84 b1       	in	r24, 0x04	; 4
    2204:	80 6e       	ori	r24, 0xE0	; 224
    2206:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    2208:	80 ee       	ldi	r24, 0xE0	; 224
    220a:	f7 cf       	rjmp	.-18     	; 0x21fa <rgbled_turn_off>
    220c:	08 95       	ret

0000220e <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    220e:	95 b1       	in	r25, 0x05	; 5
    2210:	80 95       	com	r24
    2212:	98 23       	and	r25, r24
    2214:	95 b9       	out	0x05, r25	; 5
    2216:	08 95       	ret

00002218 <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    2218:	95 b1       	in	r25, 0x05	; 5
    221a:	89 27       	eor	r24, r25
    221c:	85 b9       	out	0x05, r24	; 5
    221e:	08 95       	ret

00002220 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    2220:	94 b1       	in	r25, 0x04	; 4
    2222:	97 60       	ori	r25, 0x07	; 7
    2224:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2226:	82 fb       	bst	r24, 2
    2228:	99 27       	eor	r25, r25
    222a:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    222c:	28 2f       	mov	r18, r24
    222e:	22 70       	andi	r18, 0x02	; 2
    2230:	81 70       	andi	r24, 0x01	; 1
    2232:	80 65       	ori	r24, 0x50	; 80
    2234:	82 2b       	or	r24, r18
    2236:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    2238:	8c b5       	in	r24, 0x2c	; 44
    223a:	83 7f       	andi	r24, 0xF3	; 243
    223c:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    223e:	9d bd       	out	0x2d, r25	; 45
    2240:	08 95       	ret

00002242 <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    2242:	cf 93       	push	r28
    2244:	df 93       	push	r29
    2246:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    2248:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    224a:	41 15       	cp	r20, r1
    224c:	51 05       	cpc	r21, r1
    224e:	c1 f0       	breq	.+48     	; 0x2280 <spi_trancieve+0x3e>
    2250:	fb 01       	movw	r30, r22
    2252:	dc 01       	movw	r26, r24
    2254:	46 0f       	add	r20, r22
    2256:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    2258:	8f ef       	ldi	r24, 0xFF	; 255
    225a:	20 97       	sbiw	r28, 0x00	; 0
    225c:	11 f0       	breq	.+4      	; 0x2262 <spi_trancieve+0x20>
    225e:	9c 91       	ld	r25, X
    2260:	01 c0       	rjmp	.+2      	; 0x2264 <spi_trancieve+0x22>
    2262:	98 2f       	mov	r25, r24
    2264:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2266:	0d b4       	in	r0, 0x2d	; 45
    2268:	07 fe       	sbrs	r0, 7
    226a:	fd cf       	rjmp	.-6      	; 0x2266 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    226c:	61 15       	cp	r22, r1
    226e:	71 05       	cpc	r23, r1
    2270:	11 f0       	breq	.+4      	; 0x2276 <spi_trancieve+0x34>
    2272:	9e b5       	in	r25, 0x2e	; 46
    2274:	90 83       	st	Z, r25
    2276:	31 96       	adiw	r30, 0x01	; 1
    2278:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    227a:	e4 17       	cp	r30, r20
    227c:	f5 07       	cpc	r31, r21
    227e:	69 f7       	brne	.-38     	; 0x225a <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2280:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    2282:	28 9a       	sbi	0x05, 0	; 5
	}
}
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	08 95       	ret

0000228a <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    228a:	1f 92       	push	r1
    228c:	0f 92       	push	r0
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	0f 92       	push	r0
    2292:	11 24       	eor	r1, r1
    2294:	0b b6       	in	r0, 0x3b	; 59
    2296:	0f 92       	push	r0
    2298:	2f 93       	push	r18
    229a:	3f 93       	push	r19
    229c:	4f 93       	push	r20
    229e:	5f 93       	push	r21
    22a0:	6f 93       	push	r22
    22a2:	7f 93       	push	r23
    22a4:	8f 93       	push	r24
    22a6:	af 93       	push	r26
    22a8:	bf 93       	push	r27
    22aa:	ef 93       	push	r30
    22ac:	ff 93       	push	r31
    22ae:	af e8       	ldi	r26, 0x8F	; 143
    22b0:	b3 e0       	ldi	r27, 0x03	; 3
    22b2:	ef e6       	ldi	r30, 0x6F	; 111
    22b4:	f3 e0       	ldi	r31, 0x03	; 3
    22b6:	2f e8       	ldi	r18, 0x8F	; 143
    22b8:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    22ba:	8d 91       	ld	r24, X+
    22bc:	88 23       	and	r24, r24
    22be:	59 f0       	breq	.+22     	; 0x22d6 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22c0:	40 81       	ld	r20, Z
    22c2:	51 81       	ldd	r21, Z+1	; 0x01
    22c4:	62 81       	ldd	r22, Z+2	; 0x02
    22c6:	73 81       	ldd	r23, Z+3	; 0x03
    22c8:	50 5e       	subi	r21, 0xE0	; 224
    22ca:	6f 4f       	sbci	r22, 0xFF	; 255
    22cc:	7f 4f       	sbci	r23, 0xFF	; 255
    22ce:	40 83       	st	Z, r20
    22d0:	51 83       	std	Z+1, r21	; 0x01
    22d2:	62 83       	std	Z+2, r22	; 0x02
    22d4:	73 83       	std	Z+3, r23	; 0x03
    22d6:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    22d8:	e2 17       	cp	r30, r18
    22da:	f3 07       	cpc	r31, r19
    22dc:	71 f7       	brne	.-36     	; 0x22ba <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    22de:	ff 91       	pop	r31
    22e0:	ef 91       	pop	r30
    22e2:	bf 91       	pop	r27
    22e4:	af 91       	pop	r26
    22e6:	8f 91       	pop	r24
    22e8:	7f 91       	pop	r23
    22ea:	6f 91       	pop	r22
    22ec:	5f 91       	pop	r21
    22ee:	4f 91       	pop	r20
    22f0:	3f 91       	pop	r19
    22f2:	2f 91       	pop	r18
    22f4:	0f 90       	pop	r0
    22f6:	0b be       	out	0x3b, r0	; 59
    22f8:	0f 90       	pop	r0
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	0f 90       	pop	r0
    22fe:	1f 90       	pop	r1
    2300:	18 95       	reti

00002302 <__subsf3>:
    2302:	50 58       	subi	r21, 0x80	; 128

00002304 <__addsf3>:
    2304:	bb 27       	eor	r27, r27
    2306:	aa 27       	eor	r26, r26
    2308:	0e d0       	rcall	.+28     	; 0x2326 <__addsf3x>
    230a:	75 c1       	rjmp	.+746    	; 0x25f6 <__fp_round>
    230c:	66 d1       	rcall	.+716    	; 0x25da <__fp_pscA>
    230e:	30 f0       	brcs	.+12     	; 0x231c <__addsf3+0x18>
    2310:	6b d1       	rcall	.+726    	; 0x25e8 <__fp_pscB>
    2312:	20 f0       	brcs	.+8      	; 0x231c <__addsf3+0x18>
    2314:	31 f4       	brne	.+12     	; 0x2322 <__addsf3+0x1e>
    2316:	9f 3f       	cpi	r25, 0xFF	; 255
    2318:	11 f4       	brne	.+4      	; 0x231e <__addsf3+0x1a>
    231a:	1e f4       	brtc	.+6      	; 0x2322 <__addsf3+0x1e>
    231c:	5b c1       	rjmp	.+694    	; 0x25d4 <__fp_nan>
    231e:	0e f4       	brtc	.+2      	; 0x2322 <__addsf3+0x1e>
    2320:	e0 95       	com	r30
    2322:	e7 fb       	bst	r30, 7
    2324:	51 c1       	rjmp	.+674    	; 0x25c8 <__fp_inf>

00002326 <__addsf3x>:
    2326:	e9 2f       	mov	r30, r25
    2328:	77 d1       	rcall	.+750    	; 0x2618 <__fp_split3>
    232a:	80 f3       	brcs	.-32     	; 0x230c <__addsf3+0x8>
    232c:	ba 17       	cp	r27, r26
    232e:	62 07       	cpc	r22, r18
    2330:	73 07       	cpc	r23, r19
    2332:	84 07       	cpc	r24, r20
    2334:	95 07       	cpc	r25, r21
    2336:	18 f0       	brcs	.+6      	; 0x233e <__addsf3x+0x18>
    2338:	71 f4       	brne	.+28     	; 0x2356 <__addsf3x+0x30>
    233a:	9e f5       	brtc	.+102    	; 0x23a2 <__addsf3x+0x7c>
    233c:	8f c1       	rjmp	.+798    	; 0x265c <__fp_zero>
    233e:	0e f4       	brtc	.+2      	; 0x2342 <__addsf3x+0x1c>
    2340:	e0 95       	com	r30
    2342:	0b 2e       	mov	r0, r27
    2344:	ba 2f       	mov	r27, r26
    2346:	a0 2d       	mov	r26, r0
    2348:	0b 01       	movw	r0, r22
    234a:	b9 01       	movw	r22, r18
    234c:	90 01       	movw	r18, r0
    234e:	0c 01       	movw	r0, r24
    2350:	ca 01       	movw	r24, r20
    2352:	a0 01       	movw	r20, r0
    2354:	11 24       	eor	r1, r1
    2356:	ff 27       	eor	r31, r31
    2358:	59 1b       	sub	r21, r25
    235a:	99 f0       	breq	.+38     	; 0x2382 <__addsf3x+0x5c>
    235c:	59 3f       	cpi	r21, 0xF9	; 249
    235e:	50 f4       	brcc	.+20     	; 0x2374 <__addsf3x+0x4e>
    2360:	50 3e       	cpi	r21, 0xE0	; 224
    2362:	68 f1       	brcs	.+90     	; 0x23be <__addsf3x+0x98>
    2364:	1a 16       	cp	r1, r26
    2366:	f0 40       	sbci	r31, 0x00	; 0
    2368:	a2 2f       	mov	r26, r18
    236a:	23 2f       	mov	r18, r19
    236c:	34 2f       	mov	r19, r20
    236e:	44 27       	eor	r20, r20
    2370:	58 5f       	subi	r21, 0xF8	; 248
    2372:	f3 cf       	rjmp	.-26     	; 0x235a <__addsf3x+0x34>
    2374:	46 95       	lsr	r20
    2376:	37 95       	ror	r19
    2378:	27 95       	ror	r18
    237a:	a7 95       	ror	r26
    237c:	f0 40       	sbci	r31, 0x00	; 0
    237e:	53 95       	inc	r21
    2380:	c9 f7       	brne	.-14     	; 0x2374 <__addsf3x+0x4e>
    2382:	7e f4       	brtc	.+30     	; 0x23a2 <__addsf3x+0x7c>
    2384:	1f 16       	cp	r1, r31
    2386:	ba 0b       	sbc	r27, r26
    2388:	62 0b       	sbc	r22, r18
    238a:	73 0b       	sbc	r23, r19
    238c:	84 0b       	sbc	r24, r20
    238e:	ba f0       	brmi	.+46     	; 0x23be <__addsf3x+0x98>
    2390:	91 50       	subi	r25, 0x01	; 1
    2392:	a1 f0       	breq	.+40     	; 0x23bc <__addsf3x+0x96>
    2394:	ff 0f       	add	r31, r31
    2396:	bb 1f       	adc	r27, r27
    2398:	66 1f       	adc	r22, r22
    239a:	77 1f       	adc	r23, r23
    239c:	88 1f       	adc	r24, r24
    239e:	c2 f7       	brpl	.-16     	; 0x2390 <__addsf3x+0x6a>
    23a0:	0e c0       	rjmp	.+28     	; 0x23be <__addsf3x+0x98>
    23a2:	ba 0f       	add	r27, r26
    23a4:	62 1f       	adc	r22, r18
    23a6:	73 1f       	adc	r23, r19
    23a8:	84 1f       	adc	r24, r20
    23aa:	48 f4       	brcc	.+18     	; 0x23be <__addsf3x+0x98>
    23ac:	87 95       	ror	r24
    23ae:	77 95       	ror	r23
    23b0:	67 95       	ror	r22
    23b2:	b7 95       	ror	r27
    23b4:	f7 95       	ror	r31
    23b6:	9e 3f       	cpi	r25, 0xFE	; 254
    23b8:	08 f0       	brcs	.+2      	; 0x23bc <__addsf3x+0x96>
    23ba:	b3 cf       	rjmp	.-154    	; 0x2322 <__addsf3+0x1e>
    23bc:	93 95       	inc	r25
    23be:	88 0f       	add	r24, r24
    23c0:	08 f0       	brcs	.+2      	; 0x23c4 <__addsf3x+0x9e>
    23c2:	99 27       	eor	r25, r25
    23c4:	ee 0f       	add	r30, r30
    23c6:	97 95       	ror	r25
    23c8:	87 95       	ror	r24
    23ca:	08 95       	ret

000023cc <__cmpsf2>:
    23cc:	d9 d0       	rcall	.+434    	; 0x2580 <__fp_cmp>
    23ce:	08 f4       	brcc	.+2      	; 0x23d2 <__cmpsf2+0x6>
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	08 95       	ret

000023d4 <__divsf3>:
    23d4:	0c d0       	rcall	.+24     	; 0x23ee <__divsf3x>
    23d6:	0f c1       	rjmp	.+542    	; 0x25f6 <__fp_round>
    23d8:	07 d1       	rcall	.+526    	; 0x25e8 <__fp_pscB>
    23da:	40 f0       	brcs	.+16     	; 0x23ec <__divsf3+0x18>
    23dc:	fe d0       	rcall	.+508    	; 0x25da <__fp_pscA>
    23de:	30 f0       	brcs	.+12     	; 0x23ec <__divsf3+0x18>
    23e0:	21 f4       	brne	.+8      	; 0x23ea <__divsf3+0x16>
    23e2:	5f 3f       	cpi	r21, 0xFF	; 255
    23e4:	19 f0       	breq	.+6      	; 0x23ec <__divsf3+0x18>
    23e6:	f0 c0       	rjmp	.+480    	; 0x25c8 <__fp_inf>
    23e8:	51 11       	cpse	r21, r1
    23ea:	39 c1       	rjmp	.+626    	; 0x265e <__fp_szero>
    23ec:	f3 c0       	rjmp	.+486    	; 0x25d4 <__fp_nan>

000023ee <__divsf3x>:
    23ee:	14 d1       	rcall	.+552    	; 0x2618 <__fp_split3>
    23f0:	98 f3       	brcs	.-26     	; 0x23d8 <__divsf3+0x4>

000023f2 <__divsf3_pse>:
    23f2:	99 23       	and	r25, r25
    23f4:	c9 f3       	breq	.-14     	; 0x23e8 <__divsf3+0x14>
    23f6:	55 23       	and	r21, r21
    23f8:	b1 f3       	breq	.-20     	; 0x23e6 <__divsf3+0x12>
    23fa:	95 1b       	sub	r25, r21
    23fc:	55 0b       	sbc	r21, r21
    23fe:	bb 27       	eor	r27, r27
    2400:	aa 27       	eor	r26, r26
    2402:	62 17       	cp	r22, r18
    2404:	73 07       	cpc	r23, r19
    2406:	84 07       	cpc	r24, r20
    2408:	38 f0       	brcs	.+14     	; 0x2418 <__divsf3_pse+0x26>
    240a:	9f 5f       	subi	r25, 0xFF	; 255
    240c:	5f 4f       	sbci	r21, 0xFF	; 255
    240e:	22 0f       	add	r18, r18
    2410:	33 1f       	adc	r19, r19
    2412:	44 1f       	adc	r20, r20
    2414:	aa 1f       	adc	r26, r26
    2416:	a9 f3       	breq	.-22     	; 0x2402 <__divsf3_pse+0x10>
    2418:	33 d0       	rcall	.+102    	; 0x2480 <__divsf3_pse+0x8e>
    241a:	0e 2e       	mov	r0, r30
    241c:	3a f0       	brmi	.+14     	; 0x242c <__divsf3_pse+0x3a>
    241e:	e0 e8       	ldi	r30, 0x80	; 128
    2420:	30 d0       	rcall	.+96     	; 0x2482 <__divsf3_pse+0x90>
    2422:	91 50       	subi	r25, 0x01	; 1
    2424:	50 40       	sbci	r21, 0x00	; 0
    2426:	e6 95       	lsr	r30
    2428:	00 1c       	adc	r0, r0
    242a:	ca f7       	brpl	.-14     	; 0x241e <__divsf3_pse+0x2c>
    242c:	29 d0       	rcall	.+82     	; 0x2480 <__divsf3_pse+0x8e>
    242e:	fe 2f       	mov	r31, r30
    2430:	27 d0       	rcall	.+78     	; 0x2480 <__divsf3_pse+0x8e>
    2432:	66 0f       	add	r22, r22
    2434:	77 1f       	adc	r23, r23
    2436:	88 1f       	adc	r24, r24
    2438:	bb 1f       	adc	r27, r27
    243a:	26 17       	cp	r18, r22
    243c:	37 07       	cpc	r19, r23
    243e:	48 07       	cpc	r20, r24
    2440:	ab 07       	cpc	r26, r27
    2442:	b0 e8       	ldi	r27, 0x80	; 128
    2444:	09 f0       	breq	.+2      	; 0x2448 <__divsf3_pse+0x56>
    2446:	bb 0b       	sbc	r27, r27
    2448:	80 2d       	mov	r24, r0
    244a:	bf 01       	movw	r22, r30
    244c:	ff 27       	eor	r31, r31
    244e:	93 58       	subi	r25, 0x83	; 131
    2450:	5f 4f       	sbci	r21, 0xFF	; 255
    2452:	2a f0       	brmi	.+10     	; 0x245e <__divsf3_pse+0x6c>
    2454:	9e 3f       	cpi	r25, 0xFE	; 254
    2456:	51 05       	cpc	r21, r1
    2458:	68 f0       	brcs	.+26     	; 0x2474 <__divsf3_pse+0x82>
    245a:	b6 c0       	rjmp	.+364    	; 0x25c8 <__fp_inf>
    245c:	00 c1       	rjmp	.+512    	; 0x265e <__fp_szero>
    245e:	5f 3f       	cpi	r21, 0xFF	; 255
    2460:	ec f3       	brlt	.-6      	; 0x245c <__divsf3_pse+0x6a>
    2462:	98 3e       	cpi	r25, 0xE8	; 232
    2464:	dc f3       	brlt	.-10     	; 0x245c <__divsf3_pse+0x6a>
    2466:	86 95       	lsr	r24
    2468:	77 95       	ror	r23
    246a:	67 95       	ror	r22
    246c:	b7 95       	ror	r27
    246e:	f7 95       	ror	r31
    2470:	9f 5f       	subi	r25, 0xFF	; 255
    2472:	c9 f7       	brne	.-14     	; 0x2466 <__divsf3_pse+0x74>
    2474:	88 0f       	add	r24, r24
    2476:	91 1d       	adc	r25, r1
    2478:	96 95       	lsr	r25
    247a:	87 95       	ror	r24
    247c:	97 f9       	bld	r25, 7
    247e:	08 95       	ret
    2480:	e1 e0       	ldi	r30, 0x01	; 1
    2482:	66 0f       	add	r22, r22
    2484:	77 1f       	adc	r23, r23
    2486:	88 1f       	adc	r24, r24
    2488:	bb 1f       	adc	r27, r27
    248a:	62 17       	cp	r22, r18
    248c:	73 07       	cpc	r23, r19
    248e:	84 07       	cpc	r24, r20
    2490:	ba 07       	cpc	r27, r26
    2492:	20 f0       	brcs	.+8      	; 0x249c <__divsf3_pse+0xaa>
    2494:	62 1b       	sub	r22, r18
    2496:	73 0b       	sbc	r23, r19
    2498:	84 0b       	sbc	r24, r20
    249a:	ba 0b       	sbc	r27, r26
    249c:	ee 1f       	adc	r30, r30
    249e:	88 f7       	brcc	.-30     	; 0x2482 <__divsf3_pse+0x90>
    24a0:	e0 95       	com	r30
    24a2:	08 95       	ret

000024a4 <__fixsfsi>:
    24a4:	04 d0       	rcall	.+8      	; 0x24ae <__fixunssfsi>
    24a6:	68 94       	set
    24a8:	b1 11       	cpse	r27, r1
    24aa:	d9 c0       	rjmp	.+434    	; 0x265e <__fp_szero>
    24ac:	08 95       	ret

000024ae <__fixunssfsi>:
    24ae:	bc d0       	rcall	.+376    	; 0x2628 <__fp_splitA>
    24b0:	88 f0       	brcs	.+34     	; 0x24d4 <__fixunssfsi+0x26>
    24b2:	9f 57       	subi	r25, 0x7F	; 127
    24b4:	90 f0       	brcs	.+36     	; 0x24da <__fixunssfsi+0x2c>
    24b6:	b9 2f       	mov	r27, r25
    24b8:	99 27       	eor	r25, r25
    24ba:	b7 51       	subi	r27, 0x17	; 23
    24bc:	a0 f0       	brcs	.+40     	; 0x24e6 <__fixunssfsi+0x38>
    24be:	d1 f0       	breq	.+52     	; 0x24f4 <__fixunssfsi+0x46>
    24c0:	66 0f       	add	r22, r22
    24c2:	77 1f       	adc	r23, r23
    24c4:	88 1f       	adc	r24, r24
    24c6:	99 1f       	adc	r25, r25
    24c8:	1a f0       	brmi	.+6      	; 0x24d0 <__fixunssfsi+0x22>
    24ca:	ba 95       	dec	r27
    24cc:	c9 f7       	brne	.-14     	; 0x24c0 <__fixunssfsi+0x12>
    24ce:	12 c0       	rjmp	.+36     	; 0x24f4 <__fixunssfsi+0x46>
    24d0:	b1 30       	cpi	r27, 0x01	; 1
    24d2:	81 f0       	breq	.+32     	; 0x24f4 <__fixunssfsi+0x46>
    24d4:	c3 d0       	rcall	.+390    	; 0x265c <__fp_zero>
    24d6:	b1 e0       	ldi	r27, 0x01	; 1
    24d8:	08 95       	ret
    24da:	c0 c0       	rjmp	.+384    	; 0x265c <__fp_zero>
    24dc:	67 2f       	mov	r22, r23
    24de:	78 2f       	mov	r23, r24
    24e0:	88 27       	eor	r24, r24
    24e2:	b8 5f       	subi	r27, 0xF8	; 248
    24e4:	39 f0       	breq	.+14     	; 0x24f4 <__fixunssfsi+0x46>
    24e6:	b9 3f       	cpi	r27, 0xF9	; 249
    24e8:	cc f3       	brlt	.-14     	; 0x24dc <__fixunssfsi+0x2e>
    24ea:	86 95       	lsr	r24
    24ec:	77 95       	ror	r23
    24ee:	67 95       	ror	r22
    24f0:	b3 95       	inc	r27
    24f2:	d9 f7       	brne	.-10     	; 0x24ea <__fixunssfsi+0x3c>
    24f4:	3e f4       	brtc	.+14     	; 0x2504 <__fixunssfsi+0x56>
    24f6:	90 95       	com	r25
    24f8:	80 95       	com	r24
    24fa:	70 95       	com	r23
    24fc:	61 95       	neg	r22
    24fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2500:	8f 4f       	sbci	r24, 0xFF	; 255
    2502:	9f 4f       	sbci	r25, 0xFF	; 255
    2504:	08 95       	ret

00002506 <__floatunsisf>:
    2506:	e8 94       	clt
    2508:	09 c0       	rjmp	.+18     	; 0x251c <__floatsisf+0x12>

0000250a <__floatsisf>:
    250a:	97 fb       	bst	r25, 7
    250c:	3e f4       	brtc	.+14     	; 0x251c <__floatsisf+0x12>
    250e:	90 95       	com	r25
    2510:	80 95       	com	r24
    2512:	70 95       	com	r23
    2514:	61 95       	neg	r22
    2516:	7f 4f       	sbci	r23, 0xFF	; 255
    2518:	8f 4f       	sbci	r24, 0xFF	; 255
    251a:	9f 4f       	sbci	r25, 0xFF	; 255
    251c:	99 23       	and	r25, r25
    251e:	a9 f0       	breq	.+42     	; 0x254a <__floatsisf+0x40>
    2520:	f9 2f       	mov	r31, r25
    2522:	96 e9       	ldi	r25, 0x96	; 150
    2524:	bb 27       	eor	r27, r27
    2526:	93 95       	inc	r25
    2528:	f6 95       	lsr	r31
    252a:	87 95       	ror	r24
    252c:	77 95       	ror	r23
    252e:	67 95       	ror	r22
    2530:	b7 95       	ror	r27
    2532:	f1 11       	cpse	r31, r1
    2534:	f8 cf       	rjmp	.-16     	; 0x2526 <__floatsisf+0x1c>
    2536:	fa f4       	brpl	.+62     	; 0x2576 <__floatsisf+0x6c>
    2538:	bb 0f       	add	r27, r27
    253a:	11 f4       	brne	.+4      	; 0x2540 <__floatsisf+0x36>
    253c:	60 ff       	sbrs	r22, 0
    253e:	1b c0       	rjmp	.+54     	; 0x2576 <__floatsisf+0x6c>
    2540:	6f 5f       	subi	r22, 0xFF	; 255
    2542:	7f 4f       	sbci	r23, 0xFF	; 255
    2544:	8f 4f       	sbci	r24, 0xFF	; 255
    2546:	9f 4f       	sbci	r25, 0xFF	; 255
    2548:	16 c0       	rjmp	.+44     	; 0x2576 <__floatsisf+0x6c>
    254a:	88 23       	and	r24, r24
    254c:	11 f0       	breq	.+4      	; 0x2552 <__floatsisf+0x48>
    254e:	96 e9       	ldi	r25, 0x96	; 150
    2550:	11 c0       	rjmp	.+34     	; 0x2574 <__floatsisf+0x6a>
    2552:	77 23       	and	r23, r23
    2554:	21 f0       	breq	.+8      	; 0x255e <__floatsisf+0x54>
    2556:	9e e8       	ldi	r25, 0x8E	; 142
    2558:	87 2f       	mov	r24, r23
    255a:	76 2f       	mov	r23, r22
    255c:	05 c0       	rjmp	.+10     	; 0x2568 <__floatsisf+0x5e>
    255e:	66 23       	and	r22, r22
    2560:	71 f0       	breq	.+28     	; 0x257e <__floatsisf+0x74>
    2562:	96 e8       	ldi	r25, 0x86	; 134
    2564:	86 2f       	mov	r24, r22
    2566:	70 e0       	ldi	r23, 0x00	; 0
    2568:	60 e0       	ldi	r22, 0x00	; 0
    256a:	2a f0       	brmi	.+10     	; 0x2576 <__floatsisf+0x6c>
    256c:	9a 95       	dec	r25
    256e:	66 0f       	add	r22, r22
    2570:	77 1f       	adc	r23, r23
    2572:	88 1f       	adc	r24, r24
    2574:	da f7       	brpl	.-10     	; 0x256c <__floatsisf+0x62>
    2576:	88 0f       	add	r24, r24
    2578:	96 95       	lsr	r25
    257a:	87 95       	ror	r24
    257c:	97 f9       	bld	r25, 7
    257e:	08 95       	ret

00002580 <__fp_cmp>:
    2580:	99 0f       	add	r25, r25
    2582:	00 08       	sbc	r0, r0
    2584:	55 0f       	add	r21, r21
    2586:	aa 0b       	sbc	r26, r26
    2588:	e0 e8       	ldi	r30, 0x80	; 128
    258a:	fe ef       	ldi	r31, 0xFE	; 254
    258c:	16 16       	cp	r1, r22
    258e:	17 06       	cpc	r1, r23
    2590:	e8 07       	cpc	r30, r24
    2592:	f9 07       	cpc	r31, r25
    2594:	c0 f0       	brcs	.+48     	; 0x25c6 <__fp_cmp+0x46>
    2596:	12 16       	cp	r1, r18
    2598:	13 06       	cpc	r1, r19
    259a:	e4 07       	cpc	r30, r20
    259c:	f5 07       	cpc	r31, r21
    259e:	98 f0       	brcs	.+38     	; 0x25c6 <__fp_cmp+0x46>
    25a0:	62 1b       	sub	r22, r18
    25a2:	73 0b       	sbc	r23, r19
    25a4:	84 0b       	sbc	r24, r20
    25a6:	95 0b       	sbc	r25, r21
    25a8:	39 f4       	brne	.+14     	; 0x25b8 <__fp_cmp+0x38>
    25aa:	0a 26       	eor	r0, r26
    25ac:	61 f0       	breq	.+24     	; 0x25c6 <__fp_cmp+0x46>
    25ae:	23 2b       	or	r18, r19
    25b0:	24 2b       	or	r18, r20
    25b2:	25 2b       	or	r18, r21
    25b4:	21 f4       	brne	.+8      	; 0x25be <__fp_cmp+0x3e>
    25b6:	08 95       	ret
    25b8:	0a 26       	eor	r0, r26
    25ba:	09 f4       	brne	.+2      	; 0x25be <__fp_cmp+0x3e>
    25bc:	a1 40       	sbci	r26, 0x01	; 1
    25be:	a6 95       	lsr	r26
    25c0:	8f ef       	ldi	r24, 0xFF	; 255
    25c2:	81 1d       	adc	r24, r1
    25c4:	81 1d       	adc	r24, r1
    25c6:	08 95       	ret

000025c8 <__fp_inf>:
    25c8:	97 f9       	bld	r25, 7
    25ca:	9f 67       	ori	r25, 0x7F	; 127
    25cc:	80 e8       	ldi	r24, 0x80	; 128
    25ce:	70 e0       	ldi	r23, 0x00	; 0
    25d0:	60 e0       	ldi	r22, 0x00	; 0
    25d2:	08 95       	ret

000025d4 <__fp_nan>:
    25d4:	9f ef       	ldi	r25, 0xFF	; 255
    25d6:	80 ec       	ldi	r24, 0xC0	; 192
    25d8:	08 95       	ret

000025da <__fp_pscA>:
    25da:	00 24       	eor	r0, r0
    25dc:	0a 94       	dec	r0
    25de:	16 16       	cp	r1, r22
    25e0:	17 06       	cpc	r1, r23
    25e2:	18 06       	cpc	r1, r24
    25e4:	09 06       	cpc	r0, r25
    25e6:	08 95       	ret

000025e8 <__fp_pscB>:
    25e8:	00 24       	eor	r0, r0
    25ea:	0a 94       	dec	r0
    25ec:	12 16       	cp	r1, r18
    25ee:	13 06       	cpc	r1, r19
    25f0:	14 06       	cpc	r1, r20
    25f2:	05 06       	cpc	r0, r21
    25f4:	08 95       	ret

000025f6 <__fp_round>:
    25f6:	09 2e       	mov	r0, r25
    25f8:	03 94       	inc	r0
    25fa:	00 0c       	add	r0, r0
    25fc:	11 f4       	brne	.+4      	; 0x2602 <__fp_round+0xc>
    25fe:	88 23       	and	r24, r24
    2600:	52 f0       	brmi	.+20     	; 0x2616 <__fp_round+0x20>
    2602:	bb 0f       	add	r27, r27
    2604:	40 f4       	brcc	.+16     	; 0x2616 <__fp_round+0x20>
    2606:	bf 2b       	or	r27, r31
    2608:	11 f4       	brne	.+4      	; 0x260e <__fp_round+0x18>
    260a:	60 ff       	sbrs	r22, 0
    260c:	04 c0       	rjmp	.+8      	; 0x2616 <__fp_round+0x20>
    260e:	6f 5f       	subi	r22, 0xFF	; 255
    2610:	7f 4f       	sbci	r23, 0xFF	; 255
    2612:	8f 4f       	sbci	r24, 0xFF	; 255
    2614:	9f 4f       	sbci	r25, 0xFF	; 255
    2616:	08 95       	ret

00002618 <__fp_split3>:
    2618:	57 fd       	sbrc	r21, 7
    261a:	90 58       	subi	r25, 0x80	; 128
    261c:	44 0f       	add	r20, r20
    261e:	55 1f       	adc	r21, r21
    2620:	59 f0       	breq	.+22     	; 0x2638 <__fp_splitA+0x10>
    2622:	5f 3f       	cpi	r21, 0xFF	; 255
    2624:	71 f0       	breq	.+28     	; 0x2642 <__fp_splitA+0x1a>
    2626:	47 95       	ror	r20

00002628 <__fp_splitA>:
    2628:	88 0f       	add	r24, r24
    262a:	97 fb       	bst	r25, 7
    262c:	99 1f       	adc	r25, r25
    262e:	61 f0       	breq	.+24     	; 0x2648 <__fp_splitA+0x20>
    2630:	9f 3f       	cpi	r25, 0xFF	; 255
    2632:	79 f0       	breq	.+30     	; 0x2652 <__fp_splitA+0x2a>
    2634:	87 95       	ror	r24
    2636:	08 95       	ret
    2638:	12 16       	cp	r1, r18
    263a:	13 06       	cpc	r1, r19
    263c:	14 06       	cpc	r1, r20
    263e:	55 1f       	adc	r21, r21
    2640:	f2 cf       	rjmp	.-28     	; 0x2626 <__fp_split3+0xe>
    2642:	46 95       	lsr	r20
    2644:	f1 df       	rcall	.-30     	; 0x2628 <__fp_splitA>
    2646:	08 c0       	rjmp	.+16     	; 0x2658 <__fp_splitA+0x30>
    2648:	16 16       	cp	r1, r22
    264a:	17 06       	cpc	r1, r23
    264c:	18 06       	cpc	r1, r24
    264e:	99 1f       	adc	r25, r25
    2650:	f1 cf       	rjmp	.-30     	; 0x2634 <__fp_splitA+0xc>
    2652:	86 95       	lsr	r24
    2654:	71 05       	cpc	r23, r1
    2656:	61 05       	cpc	r22, r1
    2658:	08 94       	sec
    265a:	08 95       	ret

0000265c <__fp_zero>:
    265c:	e8 94       	clt

0000265e <__fp_szero>:
    265e:	bb 27       	eor	r27, r27
    2660:	66 27       	eor	r22, r22
    2662:	77 27       	eor	r23, r23
    2664:	cb 01       	movw	r24, r22
    2666:	97 f9       	bld	r25, 7
    2668:	08 95       	ret

0000266a <__gesf2>:
    266a:	8a df       	rcall	.-236    	; 0x2580 <__fp_cmp>
    266c:	08 f4       	brcc	.+2      	; 0x2670 <__gesf2+0x6>
    266e:	8f ef       	ldi	r24, 0xFF	; 255
    2670:	08 95       	ret

00002672 <__mulsf3>:
    2672:	0b d0       	rcall	.+22     	; 0x268a <__mulsf3x>
    2674:	c0 cf       	rjmp	.-128    	; 0x25f6 <__fp_round>
    2676:	b1 df       	rcall	.-158    	; 0x25da <__fp_pscA>
    2678:	28 f0       	brcs	.+10     	; 0x2684 <__mulsf3+0x12>
    267a:	b6 df       	rcall	.-148    	; 0x25e8 <__fp_pscB>
    267c:	18 f0       	brcs	.+6      	; 0x2684 <__mulsf3+0x12>
    267e:	95 23       	and	r25, r21
    2680:	09 f0       	breq	.+2      	; 0x2684 <__mulsf3+0x12>
    2682:	a2 cf       	rjmp	.-188    	; 0x25c8 <__fp_inf>
    2684:	a7 cf       	rjmp	.-178    	; 0x25d4 <__fp_nan>
    2686:	11 24       	eor	r1, r1
    2688:	ea cf       	rjmp	.-44     	; 0x265e <__fp_szero>

0000268a <__mulsf3x>:
    268a:	c6 df       	rcall	.-116    	; 0x2618 <__fp_split3>
    268c:	a0 f3       	brcs	.-24     	; 0x2676 <__mulsf3+0x4>

0000268e <__mulsf3_pse>:
    268e:	95 9f       	mul	r25, r21
    2690:	d1 f3       	breq	.-12     	; 0x2686 <__mulsf3+0x14>
    2692:	95 0f       	add	r25, r21
    2694:	50 e0       	ldi	r21, 0x00	; 0
    2696:	55 1f       	adc	r21, r21
    2698:	62 9f       	mul	r22, r18
    269a:	f0 01       	movw	r30, r0
    269c:	72 9f       	mul	r23, r18
    269e:	bb 27       	eor	r27, r27
    26a0:	f0 0d       	add	r31, r0
    26a2:	b1 1d       	adc	r27, r1
    26a4:	63 9f       	mul	r22, r19
    26a6:	aa 27       	eor	r26, r26
    26a8:	f0 0d       	add	r31, r0
    26aa:	b1 1d       	adc	r27, r1
    26ac:	aa 1f       	adc	r26, r26
    26ae:	64 9f       	mul	r22, r20
    26b0:	66 27       	eor	r22, r22
    26b2:	b0 0d       	add	r27, r0
    26b4:	a1 1d       	adc	r26, r1
    26b6:	66 1f       	adc	r22, r22
    26b8:	82 9f       	mul	r24, r18
    26ba:	22 27       	eor	r18, r18
    26bc:	b0 0d       	add	r27, r0
    26be:	a1 1d       	adc	r26, r1
    26c0:	62 1f       	adc	r22, r18
    26c2:	73 9f       	mul	r23, r19
    26c4:	b0 0d       	add	r27, r0
    26c6:	a1 1d       	adc	r26, r1
    26c8:	62 1f       	adc	r22, r18
    26ca:	83 9f       	mul	r24, r19
    26cc:	a0 0d       	add	r26, r0
    26ce:	61 1d       	adc	r22, r1
    26d0:	22 1f       	adc	r18, r18
    26d2:	74 9f       	mul	r23, r20
    26d4:	33 27       	eor	r19, r19
    26d6:	a0 0d       	add	r26, r0
    26d8:	61 1d       	adc	r22, r1
    26da:	23 1f       	adc	r18, r19
    26dc:	84 9f       	mul	r24, r20
    26de:	60 0d       	add	r22, r0
    26e0:	21 1d       	adc	r18, r1
    26e2:	82 2f       	mov	r24, r18
    26e4:	76 2f       	mov	r23, r22
    26e6:	6a 2f       	mov	r22, r26
    26e8:	11 24       	eor	r1, r1
    26ea:	9f 57       	subi	r25, 0x7F	; 127
    26ec:	50 40       	sbci	r21, 0x00	; 0
    26ee:	8a f0       	brmi	.+34     	; 0x2712 <__mulsf3_pse+0x84>
    26f0:	e1 f0       	breq	.+56     	; 0x272a <__mulsf3_pse+0x9c>
    26f2:	88 23       	and	r24, r24
    26f4:	4a f0       	brmi	.+18     	; 0x2708 <__mulsf3_pse+0x7a>
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	bb 1f       	adc	r27, r27
    26fc:	66 1f       	adc	r22, r22
    26fe:	77 1f       	adc	r23, r23
    2700:	88 1f       	adc	r24, r24
    2702:	91 50       	subi	r25, 0x01	; 1
    2704:	50 40       	sbci	r21, 0x00	; 0
    2706:	a9 f7       	brne	.-22     	; 0x26f2 <__mulsf3_pse+0x64>
    2708:	9e 3f       	cpi	r25, 0xFE	; 254
    270a:	51 05       	cpc	r21, r1
    270c:	70 f0       	brcs	.+28     	; 0x272a <__mulsf3_pse+0x9c>
    270e:	5c cf       	rjmp	.-328    	; 0x25c8 <__fp_inf>
    2710:	a6 cf       	rjmp	.-180    	; 0x265e <__fp_szero>
    2712:	5f 3f       	cpi	r21, 0xFF	; 255
    2714:	ec f3       	brlt	.-6      	; 0x2710 <__mulsf3_pse+0x82>
    2716:	98 3e       	cpi	r25, 0xE8	; 232
    2718:	dc f3       	brlt	.-10     	; 0x2710 <__mulsf3_pse+0x82>
    271a:	86 95       	lsr	r24
    271c:	77 95       	ror	r23
    271e:	67 95       	ror	r22
    2720:	b7 95       	ror	r27
    2722:	f7 95       	ror	r31
    2724:	e7 95       	ror	r30
    2726:	9f 5f       	subi	r25, 0xFF	; 255
    2728:	c1 f7       	brne	.-16     	; 0x271a <__mulsf3_pse+0x8c>
    272a:	fe 2b       	or	r31, r30
    272c:	88 0f       	add	r24, r24
    272e:	91 1d       	adc	r25, r1
    2730:	96 95       	lsr	r25
    2732:	87 95       	ror	r24
    2734:	97 f9       	bld	r25, 7
    2736:	08 95       	ret

00002738 <__tablejump2__>:
    2738:	ee 0f       	add	r30, r30
    273a:	ff 1f       	adc	r31, r31
    273c:	00 24       	eor	r0, r0
    273e:	00 1c       	adc	r0, r0
    2740:	0b be       	out	0x3b, r0	; 59
    2742:	07 90       	elpm	r0, Z+
    2744:	f6 91       	elpm	r31, Z
    2746:	e0 2d       	mov	r30, r0
    2748:	09 94       	ijmp

0000274a <atoi>:
    274a:	fc 01       	movw	r30, r24
    274c:	88 27       	eor	r24, r24
    274e:	99 27       	eor	r25, r25
    2750:	e8 94       	clt
    2752:	21 91       	ld	r18, Z+
    2754:	20 32       	cpi	r18, 0x20	; 32
    2756:	e9 f3       	breq	.-6      	; 0x2752 <atoi+0x8>
    2758:	29 30       	cpi	r18, 0x09	; 9
    275a:	10 f0       	brcs	.+4      	; 0x2760 <atoi+0x16>
    275c:	2e 30       	cpi	r18, 0x0E	; 14
    275e:	c8 f3       	brcs	.-14     	; 0x2752 <atoi+0x8>
    2760:	2b 32       	cpi	r18, 0x2B	; 43
    2762:	39 f0       	breq	.+14     	; 0x2772 <atoi+0x28>
    2764:	2d 32       	cpi	r18, 0x2D	; 45
    2766:	31 f4       	brne	.+12     	; 0x2774 <atoi+0x2a>
    2768:	68 94       	set
    276a:	03 c0       	rjmp	.+6      	; 0x2772 <atoi+0x28>
    276c:	14 d0       	rcall	.+40     	; 0x2796 <__mulhi_const_10>
    276e:	82 0f       	add	r24, r18
    2770:	91 1d       	adc	r25, r1
    2772:	21 91       	ld	r18, Z+
    2774:	20 53       	subi	r18, 0x30	; 48
    2776:	2a 30       	cpi	r18, 0x0A	; 10
    2778:	c8 f3       	brcs	.-14     	; 0x276c <atoi+0x22>
    277a:	1e f4       	brtc	.+6      	; 0x2782 <atoi+0x38>
    277c:	90 95       	com	r25
    277e:	81 95       	neg	r24
    2780:	9f 4f       	sbci	r25, 0xFF	; 255
    2782:	08 95       	ret

00002784 <strcmp>:
    2784:	fb 01       	movw	r30, r22
    2786:	dc 01       	movw	r26, r24
    2788:	8d 91       	ld	r24, X+
    278a:	01 90       	ld	r0, Z+
    278c:	80 19       	sub	r24, r0
    278e:	01 10       	cpse	r0, r1
    2790:	d9 f3       	breq	.-10     	; 0x2788 <strcmp+0x4>
    2792:	99 0b       	sbc	r25, r25
    2794:	08 95       	ret

00002796 <__mulhi_const_10>:
    2796:	7a e0       	ldi	r23, 0x0A	; 10
    2798:	97 9f       	mul	r25, r23
    279a:	90 2d       	mov	r25, r0
    279c:	87 9f       	mul	r24, r23
    279e:	80 2d       	mov	r24, r0
    27a0:	91 0d       	add	r25, r1
    27a2:	11 24       	eor	r1, r1
    27a4:	08 95       	ret

000027a6 <printf>:
    27a6:	cf 93       	push	r28
    27a8:	df 93       	push	r29
    27aa:	cd b7       	in	r28, 0x3d	; 61
    27ac:	de b7       	in	r29, 0x3e	; 62
    27ae:	ae 01       	movw	r20, r28
    27b0:	4b 5f       	subi	r20, 0xFB	; 251
    27b2:	5f 4f       	sbci	r21, 0xFF	; 255
    27b4:	fa 01       	movw	r30, r20
    27b6:	61 91       	ld	r22, Z+
    27b8:	71 91       	ld	r23, Z+
    27ba:	af 01       	movw	r20, r30
    27bc:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27c0:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27c4:	38 d0       	rcall	.+112    	; 0x2836 <vfprintf>
    27c6:	df 91       	pop	r29
    27c8:	cf 91       	pop	r28
    27ca:	08 95       	ret

000027cc <putchar>:
    27cc:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27d0:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27d4:	43 c2       	rjmp	.+1158   	; 0x2c5c <fputc>

000027d6 <puts>:
    27d6:	0f 93       	push	r16
    27d8:	1f 93       	push	r17
    27da:	cf 93       	push	r28
    27dc:	df 93       	push	r29
    27de:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    27e2:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    27e6:	23 81       	ldd	r18, Z+3	; 0x03
    27e8:	21 ff       	sbrs	r18, 1
    27ea:	1b c0       	rjmp	.+54     	; 0x2822 <puts+0x4c>
    27ec:	8c 01       	movw	r16, r24
    27ee:	d0 e0       	ldi	r29, 0x00	; 0
    27f0:	c0 e0       	ldi	r28, 0x00	; 0
    27f2:	f8 01       	movw	r30, r16
    27f4:	81 91       	ld	r24, Z+
    27f6:	8f 01       	movw	r16, r30
    27f8:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27fc:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    2800:	db 01       	movw	r26, r22
    2802:	18 96       	adiw	r26, 0x08	; 8
    2804:	ed 91       	ld	r30, X+
    2806:	fc 91       	ld	r31, X
    2808:	19 97       	sbiw	r26, 0x09	; 9
    280a:	88 23       	and	r24, r24
    280c:	31 f0       	breq	.+12     	; 0x281a <puts+0x44>
    280e:	09 95       	icall
    2810:	89 2b       	or	r24, r25
    2812:	79 f3       	breq	.-34     	; 0x27f2 <puts+0x1c>
    2814:	df ef       	ldi	r29, 0xFF	; 255
    2816:	cf ef       	ldi	r28, 0xFF	; 255
    2818:	ec cf       	rjmp	.-40     	; 0x27f2 <puts+0x1c>
    281a:	8a e0       	ldi	r24, 0x0A	; 10
    281c:	09 95       	icall
    281e:	89 2b       	or	r24, r25
    2820:	19 f0       	breq	.+6      	; 0x2828 <puts+0x52>
    2822:	8f ef       	ldi	r24, 0xFF	; 255
    2824:	9f ef       	ldi	r25, 0xFF	; 255
    2826:	02 c0       	rjmp	.+4      	; 0x282c <puts+0x56>
    2828:	8d 2f       	mov	r24, r29
    282a:	9c 2f       	mov	r25, r28
    282c:	df 91       	pop	r29
    282e:	cf 91       	pop	r28
    2830:	1f 91       	pop	r17
    2832:	0f 91       	pop	r16
    2834:	08 95       	ret

00002836 <vfprintf>:
    2836:	2f 92       	push	r2
    2838:	3f 92       	push	r3
    283a:	4f 92       	push	r4
    283c:	5f 92       	push	r5
    283e:	6f 92       	push	r6
    2840:	7f 92       	push	r7
    2842:	8f 92       	push	r8
    2844:	9f 92       	push	r9
    2846:	af 92       	push	r10
    2848:	bf 92       	push	r11
    284a:	cf 92       	push	r12
    284c:	df 92       	push	r13
    284e:	ef 92       	push	r14
    2850:	ff 92       	push	r15
    2852:	0f 93       	push	r16
    2854:	1f 93       	push	r17
    2856:	cf 93       	push	r28
    2858:	df 93       	push	r29
    285a:	cd b7       	in	r28, 0x3d	; 61
    285c:	de b7       	in	r29, 0x3e	; 62
    285e:	2b 97       	sbiw	r28, 0x0b	; 11
    2860:	0f b6       	in	r0, 0x3f	; 63
    2862:	f8 94       	cli
    2864:	de bf       	out	0x3e, r29	; 62
    2866:	0f be       	out	0x3f, r0	; 63
    2868:	cd bf       	out	0x3d, r28	; 61
    286a:	6c 01       	movw	r12, r24
    286c:	7b 01       	movw	r14, r22
    286e:	8a 01       	movw	r16, r20
    2870:	fc 01       	movw	r30, r24
    2872:	17 82       	std	Z+7, r1	; 0x07
    2874:	16 82       	std	Z+6, r1	; 0x06
    2876:	83 81       	ldd	r24, Z+3	; 0x03
    2878:	81 ff       	sbrs	r24, 1
    287a:	bf c1       	rjmp	.+894    	; 0x2bfa <vfprintf+0x3c4>
    287c:	ce 01       	movw	r24, r28
    287e:	01 96       	adiw	r24, 0x01	; 1
    2880:	3c 01       	movw	r6, r24
    2882:	f6 01       	movw	r30, r12
    2884:	93 81       	ldd	r25, Z+3	; 0x03
    2886:	f7 01       	movw	r30, r14
    2888:	93 fd       	sbrc	r25, 3
    288a:	85 91       	lpm	r24, Z+
    288c:	93 ff       	sbrs	r25, 3
    288e:	81 91       	ld	r24, Z+
    2890:	7f 01       	movw	r14, r30
    2892:	88 23       	and	r24, r24
    2894:	09 f4       	brne	.+2      	; 0x2898 <vfprintf+0x62>
    2896:	ad c1       	rjmp	.+858    	; 0x2bf2 <vfprintf+0x3bc>
    2898:	85 32       	cpi	r24, 0x25	; 37
    289a:	39 f4       	brne	.+14     	; 0x28aa <vfprintf+0x74>
    289c:	93 fd       	sbrc	r25, 3
    289e:	85 91       	lpm	r24, Z+
    28a0:	93 ff       	sbrs	r25, 3
    28a2:	81 91       	ld	r24, Z+
    28a4:	7f 01       	movw	r14, r30
    28a6:	85 32       	cpi	r24, 0x25	; 37
    28a8:	21 f4       	brne	.+8      	; 0x28b2 <vfprintf+0x7c>
    28aa:	b6 01       	movw	r22, r12
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	d6 d1       	rcall	.+940    	; 0x2c5c <fputc>
    28b0:	e8 cf       	rjmp	.-48     	; 0x2882 <vfprintf+0x4c>
    28b2:	91 2c       	mov	r9, r1
    28b4:	21 2c       	mov	r2, r1
    28b6:	31 2c       	mov	r3, r1
    28b8:	ff e1       	ldi	r31, 0x1F	; 31
    28ba:	f3 15       	cp	r31, r3
    28bc:	d8 f0       	brcs	.+54     	; 0x28f4 <vfprintf+0xbe>
    28be:	8b 32       	cpi	r24, 0x2B	; 43
    28c0:	79 f0       	breq	.+30     	; 0x28e0 <vfprintf+0xaa>
    28c2:	38 f4       	brcc	.+14     	; 0x28d2 <vfprintf+0x9c>
    28c4:	80 32       	cpi	r24, 0x20	; 32
    28c6:	79 f0       	breq	.+30     	; 0x28e6 <vfprintf+0xb0>
    28c8:	83 32       	cpi	r24, 0x23	; 35
    28ca:	a1 f4       	brne	.+40     	; 0x28f4 <vfprintf+0xbe>
    28cc:	23 2d       	mov	r18, r3
    28ce:	20 61       	ori	r18, 0x10	; 16
    28d0:	1d c0       	rjmp	.+58     	; 0x290c <vfprintf+0xd6>
    28d2:	8d 32       	cpi	r24, 0x2D	; 45
    28d4:	61 f0       	breq	.+24     	; 0x28ee <vfprintf+0xb8>
    28d6:	80 33       	cpi	r24, 0x30	; 48
    28d8:	69 f4       	brne	.+26     	; 0x28f4 <vfprintf+0xbe>
    28da:	23 2d       	mov	r18, r3
    28dc:	21 60       	ori	r18, 0x01	; 1
    28de:	16 c0       	rjmp	.+44     	; 0x290c <vfprintf+0xd6>
    28e0:	83 2d       	mov	r24, r3
    28e2:	82 60       	ori	r24, 0x02	; 2
    28e4:	38 2e       	mov	r3, r24
    28e6:	e3 2d       	mov	r30, r3
    28e8:	e4 60       	ori	r30, 0x04	; 4
    28ea:	3e 2e       	mov	r3, r30
    28ec:	2a c0       	rjmp	.+84     	; 0x2942 <vfprintf+0x10c>
    28ee:	f3 2d       	mov	r31, r3
    28f0:	f8 60       	ori	r31, 0x08	; 8
    28f2:	1d c0       	rjmp	.+58     	; 0x292e <vfprintf+0xf8>
    28f4:	37 fc       	sbrc	r3, 7
    28f6:	2d c0       	rjmp	.+90     	; 0x2952 <vfprintf+0x11c>
    28f8:	20 ed       	ldi	r18, 0xD0	; 208
    28fa:	28 0f       	add	r18, r24
    28fc:	2a 30       	cpi	r18, 0x0A	; 10
    28fe:	40 f0       	brcs	.+16     	; 0x2910 <vfprintf+0xda>
    2900:	8e 32       	cpi	r24, 0x2E	; 46
    2902:	b9 f4       	brne	.+46     	; 0x2932 <vfprintf+0xfc>
    2904:	36 fc       	sbrc	r3, 6
    2906:	75 c1       	rjmp	.+746    	; 0x2bf2 <vfprintf+0x3bc>
    2908:	23 2d       	mov	r18, r3
    290a:	20 64       	ori	r18, 0x40	; 64
    290c:	32 2e       	mov	r3, r18
    290e:	19 c0       	rjmp	.+50     	; 0x2942 <vfprintf+0x10c>
    2910:	36 fe       	sbrs	r3, 6
    2912:	06 c0       	rjmp	.+12     	; 0x2920 <vfprintf+0xea>
    2914:	8a e0       	ldi	r24, 0x0A	; 10
    2916:	98 9e       	mul	r9, r24
    2918:	20 0d       	add	r18, r0
    291a:	11 24       	eor	r1, r1
    291c:	92 2e       	mov	r9, r18
    291e:	11 c0       	rjmp	.+34     	; 0x2942 <vfprintf+0x10c>
    2920:	ea e0       	ldi	r30, 0x0A	; 10
    2922:	2e 9e       	mul	r2, r30
    2924:	20 0d       	add	r18, r0
    2926:	11 24       	eor	r1, r1
    2928:	22 2e       	mov	r2, r18
    292a:	f3 2d       	mov	r31, r3
    292c:	f0 62       	ori	r31, 0x20	; 32
    292e:	3f 2e       	mov	r3, r31
    2930:	08 c0       	rjmp	.+16     	; 0x2942 <vfprintf+0x10c>
    2932:	8c 36       	cpi	r24, 0x6C	; 108
    2934:	21 f4       	brne	.+8      	; 0x293e <vfprintf+0x108>
    2936:	83 2d       	mov	r24, r3
    2938:	80 68       	ori	r24, 0x80	; 128
    293a:	38 2e       	mov	r3, r24
    293c:	02 c0       	rjmp	.+4      	; 0x2942 <vfprintf+0x10c>
    293e:	88 36       	cpi	r24, 0x68	; 104
    2940:	41 f4       	brne	.+16     	; 0x2952 <vfprintf+0x11c>
    2942:	f7 01       	movw	r30, r14
    2944:	93 fd       	sbrc	r25, 3
    2946:	85 91       	lpm	r24, Z+
    2948:	93 ff       	sbrs	r25, 3
    294a:	81 91       	ld	r24, Z+
    294c:	7f 01       	movw	r14, r30
    294e:	81 11       	cpse	r24, r1
    2950:	b3 cf       	rjmp	.-154    	; 0x28b8 <vfprintf+0x82>
    2952:	98 2f       	mov	r25, r24
    2954:	9f 7d       	andi	r25, 0xDF	; 223
    2956:	95 54       	subi	r25, 0x45	; 69
    2958:	93 30       	cpi	r25, 0x03	; 3
    295a:	28 f4       	brcc	.+10     	; 0x2966 <vfprintf+0x130>
    295c:	0c 5f       	subi	r16, 0xFC	; 252
    295e:	1f 4f       	sbci	r17, 0xFF	; 255
    2960:	9f e3       	ldi	r25, 0x3F	; 63
    2962:	99 83       	std	Y+1, r25	; 0x01
    2964:	0d c0       	rjmp	.+26     	; 0x2980 <vfprintf+0x14a>
    2966:	83 36       	cpi	r24, 0x63	; 99
    2968:	31 f0       	breq	.+12     	; 0x2976 <vfprintf+0x140>
    296a:	83 37       	cpi	r24, 0x73	; 115
    296c:	71 f0       	breq	.+28     	; 0x298a <vfprintf+0x154>
    296e:	83 35       	cpi	r24, 0x53	; 83
    2970:	09 f0       	breq	.+2      	; 0x2974 <vfprintf+0x13e>
    2972:	55 c0       	rjmp	.+170    	; 0x2a1e <vfprintf+0x1e8>
    2974:	20 c0       	rjmp	.+64     	; 0x29b6 <vfprintf+0x180>
    2976:	f8 01       	movw	r30, r16
    2978:	80 81       	ld	r24, Z
    297a:	89 83       	std	Y+1, r24	; 0x01
    297c:	0e 5f       	subi	r16, 0xFE	; 254
    297e:	1f 4f       	sbci	r17, 0xFF	; 255
    2980:	88 24       	eor	r8, r8
    2982:	83 94       	inc	r8
    2984:	91 2c       	mov	r9, r1
    2986:	53 01       	movw	r10, r6
    2988:	12 c0       	rjmp	.+36     	; 0x29ae <vfprintf+0x178>
    298a:	28 01       	movw	r4, r16
    298c:	f2 e0       	ldi	r31, 0x02	; 2
    298e:	4f 0e       	add	r4, r31
    2990:	51 1c       	adc	r5, r1
    2992:	f8 01       	movw	r30, r16
    2994:	a0 80       	ld	r10, Z
    2996:	b1 80       	ldd	r11, Z+1	; 0x01
    2998:	36 fe       	sbrs	r3, 6
    299a:	03 c0       	rjmp	.+6      	; 0x29a2 <vfprintf+0x16c>
    299c:	69 2d       	mov	r22, r9
    299e:	70 e0       	ldi	r23, 0x00	; 0
    29a0:	02 c0       	rjmp	.+4      	; 0x29a6 <vfprintf+0x170>
    29a2:	6f ef       	ldi	r22, 0xFF	; 255
    29a4:	7f ef       	ldi	r23, 0xFF	; 255
    29a6:	c5 01       	movw	r24, r10
    29a8:	4e d1       	rcall	.+668    	; 0x2c46 <strnlen>
    29aa:	4c 01       	movw	r8, r24
    29ac:	82 01       	movw	r16, r4
    29ae:	f3 2d       	mov	r31, r3
    29b0:	ff 77       	andi	r31, 0x7F	; 127
    29b2:	3f 2e       	mov	r3, r31
    29b4:	15 c0       	rjmp	.+42     	; 0x29e0 <vfprintf+0x1aa>
    29b6:	28 01       	movw	r4, r16
    29b8:	22 e0       	ldi	r18, 0x02	; 2
    29ba:	42 0e       	add	r4, r18
    29bc:	51 1c       	adc	r5, r1
    29be:	f8 01       	movw	r30, r16
    29c0:	a0 80       	ld	r10, Z
    29c2:	b1 80       	ldd	r11, Z+1	; 0x01
    29c4:	36 fe       	sbrs	r3, 6
    29c6:	03 c0       	rjmp	.+6      	; 0x29ce <vfprintf+0x198>
    29c8:	69 2d       	mov	r22, r9
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	02 c0       	rjmp	.+4      	; 0x29d2 <vfprintf+0x19c>
    29ce:	6f ef       	ldi	r22, 0xFF	; 255
    29d0:	7f ef       	ldi	r23, 0xFF	; 255
    29d2:	c5 01       	movw	r24, r10
    29d4:	2d d1       	rcall	.+602    	; 0x2c30 <strnlen_P>
    29d6:	4c 01       	movw	r8, r24
    29d8:	f3 2d       	mov	r31, r3
    29da:	f0 68       	ori	r31, 0x80	; 128
    29dc:	3f 2e       	mov	r3, r31
    29de:	82 01       	movw	r16, r4
    29e0:	33 fc       	sbrc	r3, 3
    29e2:	19 c0       	rjmp	.+50     	; 0x2a16 <vfprintf+0x1e0>
    29e4:	82 2d       	mov	r24, r2
    29e6:	90 e0       	ldi	r25, 0x00	; 0
    29e8:	88 16       	cp	r8, r24
    29ea:	99 06       	cpc	r9, r25
    29ec:	a0 f4       	brcc	.+40     	; 0x2a16 <vfprintf+0x1e0>
    29ee:	b6 01       	movw	r22, r12
    29f0:	80 e2       	ldi	r24, 0x20	; 32
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	33 d1       	rcall	.+614    	; 0x2c5c <fputc>
    29f6:	2a 94       	dec	r2
    29f8:	f5 cf       	rjmp	.-22     	; 0x29e4 <vfprintf+0x1ae>
    29fa:	f5 01       	movw	r30, r10
    29fc:	37 fc       	sbrc	r3, 7
    29fe:	85 91       	lpm	r24, Z+
    2a00:	37 fe       	sbrs	r3, 7
    2a02:	81 91       	ld	r24, Z+
    2a04:	5f 01       	movw	r10, r30
    2a06:	b6 01       	movw	r22, r12
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	28 d1       	rcall	.+592    	; 0x2c5c <fputc>
    2a0c:	21 10       	cpse	r2, r1
    2a0e:	2a 94       	dec	r2
    2a10:	21 e0       	ldi	r18, 0x01	; 1
    2a12:	82 1a       	sub	r8, r18
    2a14:	91 08       	sbc	r9, r1
    2a16:	81 14       	cp	r8, r1
    2a18:	91 04       	cpc	r9, r1
    2a1a:	79 f7       	brne	.-34     	; 0x29fa <vfprintf+0x1c4>
    2a1c:	e1 c0       	rjmp	.+450    	; 0x2be0 <vfprintf+0x3aa>
    2a1e:	84 36       	cpi	r24, 0x64	; 100
    2a20:	11 f0       	breq	.+4      	; 0x2a26 <vfprintf+0x1f0>
    2a22:	89 36       	cpi	r24, 0x69	; 105
    2a24:	39 f5       	brne	.+78     	; 0x2a74 <vfprintf+0x23e>
    2a26:	f8 01       	movw	r30, r16
    2a28:	37 fe       	sbrs	r3, 7
    2a2a:	07 c0       	rjmp	.+14     	; 0x2a3a <vfprintf+0x204>
    2a2c:	60 81       	ld	r22, Z
    2a2e:	71 81       	ldd	r23, Z+1	; 0x01
    2a30:	82 81       	ldd	r24, Z+2	; 0x02
    2a32:	93 81       	ldd	r25, Z+3	; 0x03
    2a34:	0c 5f       	subi	r16, 0xFC	; 252
    2a36:	1f 4f       	sbci	r17, 0xFF	; 255
    2a38:	08 c0       	rjmp	.+16     	; 0x2a4a <vfprintf+0x214>
    2a3a:	60 81       	ld	r22, Z
    2a3c:	71 81       	ldd	r23, Z+1	; 0x01
    2a3e:	07 2e       	mov	r0, r23
    2a40:	00 0c       	add	r0, r0
    2a42:	88 0b       	sbc	r24, r24
    2a44:	99 0b       	sbc	r25, r25
    2a46:	0e 5f       	subi	r16, 0xFE	; 254
    2a48:	1f 4f       	sbci	r17, 0xFF	; 255
    2a4a:	f3 2d       	mov	r31, r3
    2a4c:	ff 76       	andi	r31, 0x6F	; 111
    2a4e:	3f 2e       	mov	r3, r31
    2a50:	97 ff       	sbrs	r25, 7
    2a52:	09 c0       	rjmp	.+18     	; 0x2a66 <vfprintf+0x230>
    2a54:	90 95       	com	r25
    2a56:	80 95       	com	r24
    2a58:	70 95       	com	r23
    2a5a:	61 95       	neg	r22
    2a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5e:	8f 4f       	sbci	r24, 0xFF	; 255
    2a60:	9f 4f       	sbci	r25, 0xFF	; 255
    2a62:	f0 68       	ori	r31, 0x80	; 128
    2a64:	3f 2e       	mov	r3, r31
    2a66:	2a e0       	ldi	r18, 0x0A	; 10
    2a68:	30 e0       	ldi	r19, 0x00	; 0
    2a6a:	a3 01       	movw	r20, r6
    2a6c:	33 d1       	rcall	.+614    	; 0x2cd4 <__ultoa_invert>
    2a6e:	88 2e       	mov	r8, r24
    2a70:	86 18       	sub	r8, r6
    2a72:	44 c0       	rjmp	.+136    	; 0x2afc <vfprintf+0x2c6>
    2a74:	85 37       	cpi	r24, 0x75	; 117
    2a76:	31 f4       	brne	.+12     	; 0x2a84 <vfprintf+0x24e>
    2a78:	23 2d       	mov	r18, r3
    2a7a:	2f 7e       	andi	r18, 0xEF	; 239
    2a7c:	b2 2e       	mov	r11, r18
    2a7e:	2a e0       	ldi	r18, 0x0A	; 10
    2a80:	30 e0       	ldi	r19, 0x00	; 0
    2a82:	25 c0       	rjmp	.+74     	; 0x2ace <vfprintf+0x298>
    2a84:	93 2d       	mov	r25, r3
    2a86:	99 7f       	andi	r25, 0xF9	; 249
    2a88:	b9 2e       	mov	r11, r25
    2a8a:	8f 36       	cpi	r24, 0x6F	; 111
    2a8c:	c1 f0       	breq	.+48     	; 0x2abe <vfprintf+0x288>
    2a8e:	18 f4       	brcc	.+6      	; 0x2a96 <vfprintf+0x260>
    2a90:	88 35       	cpi	r24, 0x58	; 88
    2a92:	79 f0       	breq	.+30     	; 0x2ab2 <vfprintf+0x27c>
    2a94:	ae c0       	rjmp	.+348    	; 0x2bf2 <vfprintf+0x3bc>
    2a96:	80 37       	cpi	r24, 0x70	; 112
    2a98:	19 f0       	breq	.+6      	; 0x2aa0 <vfprintf+0x26a>
    2a9a:	88 37       	cpi	r24, 0x78	; 120
    2a9c:	21 f0       	breq	.+8      	; 0x2aa6 <vfprintf+0x270>
    2a9e:	a9 c0       	rjmp	.+338    	; 0x2bf2 <vfprintf+0x3bc>
    2aa0:	e9 2f       	mov	r30, r25
    2aa2:	e0 61       	ori	r30, 0x10	; 16
    2aa4:	be 2e       	mov	r11, r30
    2aa6:	b4 fe       	sbrs	r11, 4
    2aa8:	0d c0       	rjmp	.+26     	; 0x2ac4 <vfprintf+0x28e>
    2aaa:	fb 2d       	mov	r31, r11
    2aac:	f4 60       	ori	r31, 0x04	; 4
    2aae:	bf 2e       	mov	r11, r31
    2ab0:	09 c0       	rjmp	.+18     	; 0x2ac4 <vfprintf+0x28e>
    2ab2:	34 fe       	sbrs	r3, 4
    2ab4:	0a c0       	rjmp	.+20     	; 0x2aca <vfprintf+0x294>
    2ab6:	29 2f       	mov	r18, r25
    2ab8:	26 60       	ori	r18, 0x06	; 6
    2aba:	b2 2e       	mov	r11, r18
    2abc:	06 c0       	rjmp	.+12     	; 0x2aca <vfprintf+0x294>
    2abe:	28 e0       	ldi	r18, 0x08	; 8
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	05 c0       	rjmp	.+10     	; 0x2ace <vfprintf+0x298>
    2ac4:	20 e1       	ldi	r18, 0x10	; 16
    2ac6:	30 e0       	ldi	r19, 0x00	; 0
    2ac8:	02 c0       	rjmp	.+4      	; 0x2ace <vfprintf+0x298>
    2aca:	20 e1       	ldi	r18, 0x10	; 16
    2acc:	32 e0       	ldi	r19, 0x02	; 2
    2ace:	f8 01       	movw	r30, r16
    2ad0:	b7 fe       	sbrs	r11, 7
    2ad2:	07 c0       	rjmp	.+14     	; 0x2ae2 <vfprintf+0x2ac>
    2ad4:	60 81       	ld	r22, Z
    2ad6:	71 81       	ldd	r23, Z+1	; 0x01
    2ad8:	82 81       	ldd	r24, Z+2	; 0x02
    2ada:	93 81       	ldd	r25, Z+3	; 0x03
    2adc:	0c 5f       	subi	r16, 0xFC	; 252
    2ade:	1f 4f       	sbci	r17, 0xFF	; 255
    2ae0:	06 c0       	rjmp	.+12     	; 0x2aee <vfprintf+0x2b8>
    2ae2:	60 81       	ld	r22, Z
    2ae4:	71 81       	ldd	r23, Z+1	; 0x01
    2ae6:	80 e0       	ldi	r24, 0x00	; 0
    2ae8:	90 e0       	ldi	r25, 0x00	; 0
    2aea:	0e 5f       	subi	r16, 0xFE	; 254
    2aec:	1f 4f       	sbci	r17, 0xFF	; 255
    2aee:	a3 01       	movw	r20, r6
    2af0:	f1 d0       	rcall	.+482    	; 0x2cd4 <__ultoa_invert>
    2af2:	88 2e       	mov	r8, r24
    2af4:	86 18       	sub	r8, r6
    2af6:	fb 2d       	mov	r31, r11
    2af8:	ff 77       	andi	r31, 0x7F	; 127
    2afa:	3f 2e       	mov	r3, r31
    2afc:	36 fe       	sbrs	r3, 6
    2afe:	0d c0       	rjmp	.+26     	; 0x2b1a <vfprintf+0x2e4>
    2b00:	23 2d       	mov	r18, r3
    2b02:	2e 7f       	andi	r18, 0xFE	; 254
    2b04:	a2 2e       	mov	r10, r18
    2b06:	89 14       	cp	r8, r9
    2b08:	58 f4       	brcc	.+22     	; 0x2b20 <vfprintf+0x2ea>
    2b0a:	34 fe       	sbrs	r3, 4
    2b0c:	0b c0       	rjmp	.+22     	; 0x2b24 <vfprintf+0x2ee>
    2b0e:	32 fc       	sbrc	r3, 2
    2b10:	09 c0       	rjmp	.+18     	; 0x2b24 <vfprintf+0x2ee>
    2b12:	83 2d       	mov	r24, r3
    2b14:	8e 7e       	andi	r24, 0xEE	; 238
    2b16:	a8 2e       	mov	r10, r24
    2b18:	05 c0       	rjmp	.+10     	; 0x2b24 <vfprintf+0x2ee>
    2b1a:	b8 2c       	mov	r11, r8
    2b1c:	a3 2c       	mov	r10, r3
    2b1e:	03 c0       	rjmp	.+6      	; 0x2b26 <vfprintf+0x2f0>
    2b20:	b8 2c       	mov	r11, r8
    2b22:	01 c0       	rjmp	.+2      	; 0x2b26 <vfprintf+0x2f0>
    2b24:	b9 2c       	mov	r11, r9
    2b26:	a4 fe       	sbrs	r10, 4
    2b28:	0f c0       	rjmp	.+30     	; 0x2b48 <vfprintf+0x312>
    2b2a:	fe 01       	movw	r30, r28
    2b2c:	e8 0d       	add	r30, r8
    2b2e:	f1 1d       	adc	r31, r1
    2b30:	80 81       	ld	r24, Z
    2b32:	80 33       	cpi	r24, 0x30	; 48
    2b34:	21 f4       	brne	.+8      	; 0x2b3e <vfprintf+0x308>
    2b36:	9a 2d       	mov	r25, r10
    2b38:	99 7e       	andi	r25, 0xE9	; 233
    2b3a:	a9 2e       	mov	r10, r25
    2b3c:	09 c0       	rjmp	.+18     	; 0x2b50 <vfprintf+0x31a>
    2b3e:	a2 fe       	sbrs	r10, 2
    2b40:	06 c0       	rjmp	.+12     	; 0x2b4e <vfprintf+0x318>
    2b42:	b3 94       	inc	r11
    2b44:	b3 94       	inc	r11
    2b46:	04 c0       	rjmp	.+8      	; 0x2b50 <vfprintf+0x31a>
    2b48:	8a 2d       	mov	r24, r10
    2b4a:	86 78       	andi	r24, 0x86	; 134
    2b4c:	09 f0       	breq	.+2      	; 0x2b50 <vfprintf+0x31a>
    2b4e:	b3 94       	inc	r11
    2b50:	a3 fc       	sbrc	r10, 3
    2b52:	10 c0       	rjmp	.+32     	; 0x2b74 <vfprintf+0x33e>
    2b54:	a0 fe       	sbrs	r10, 0
    2b56:	06 c0       	rjmp	.+12     	; 0x2b64 <vfprintf+0x32e>
    2b58:	b2 14       	cp	r11, r2
    2b5a:	80 f4       	brcc	.+32     	; 0x2b7c <vfprintf+0x346>
    2b5c:	28 0c       	add	r2, r8
    2b5e:	92 2c       	mov	r9, r2
    2b60:	9b 18       	sub	r9, r11
    2b62:	0d c0       	rjmp	.+26     	; 0x2b7e <vfprintf+0x348>
    2b64:	b2 14       	cp	r11, r2
    2b66:	58 f4       	brcc	.+22     	; 0x2b7e <vfprintf+0x348>
    2b68:	b6 01       	movw	r22, r12
    2b6a:	80 e2       	ldi	r24, 0x20	; 32
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	76 d0       	rcall	.+236    	; 0x2c5c <fputc>
    2b70:	b3 94       	inc	r11
    2b72:	f8 cf       	rjmp	.-16     	; 0x2b64 <vfprintf+0x32e>
    2b74:	b2 14       	cp	r11, r2
    2b76:	18 f4       	brcc	.+6      	; 0x2b7e <vfprintf+0x348>
    2b78:	2b 18       	sub	r2, r11
    2b7a:	02 c0       	rjmp	.+4      	; 0x2b80 <vfprintf+0x34a>
    2b7c:	98 2c       	mov	r9, r8
    2b7e:	21 2c       	mov	r2, r1
    2b80:	a4 fe       	sbrs	r10, 4
    2b82:	0f c0       	rjmp	.+30     	; 0x2ba2 <vfprintf+0x36c>
    2b84:	b6 01       	movw	r22, r12
    2b86:	80 e3       	ldi	r24, 0x30	; 48
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	68 d0       	rcall	.+208    	; 0x2c5c <fputc>
    2b8c:	a2 fe       	sbrs	r10, 2
    2b8e:	16 c0       	rjmp	.+44     	; 0x2bbc <vfprintf+0x386>
    2b90:	a1 fc       	sbrc	r10, 1
    2b92:	03 c0       	rjmp	.+6      	; 0x2b9a <vfprintf+0x364>
    2b94:	88 e7       	ldi	r24, 0x78	; 120
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	02 c0       	rjmp	.+4      	; 0x2b9e <vfprintf+0x368>
    2b9a:	88 e5       	ldi	r24, 0x58	; 88
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	b6 01       	movw	r22, r12
    2ba0:	0c c0       	rjmp	.+24     	; 0x2bba <vfprintf+0x384>
    2ba2:	8a 2d       	mov	r24, r10
    2ba4:	86 78       	andi	r24, 0x86	; 134
    2ba6:	51 f0       	breq	.+20     	; 0x2bbc <vfprintf+0x386>
    2ba8:	a1 fe       	sbrs	r10, 1
    2baa:	02 c0       	rjmp	.+4      	; 0x2bb0 <vfprintf+0x37a>
    2bac:	8b e2       	ldi	r24, 0x2B	; 43
    2bae:	01 c0       	rjmp	.+2      	; 0x2bb2 <vfprintf+0x37c>
    2bb0:	80 e2       	ldi	r24, 0x20	; 32
    2bb2:	a7 fc       	sbrc	r10, 7
    2bb4:	8d e2       	ldi	r24, 0x2D	; 45
    2bb6:	b6 01       	movw	r22, r12
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	50 d0       	rcall	.+160    	; 0x2c5c <fputc>
    2bbc:	89 14       	cp	r8, r9
    2bbe:	30 f4       	brcc	.+12     	; 0x2bcc <vfprintf+0x396>
    2bc0:	b6 01       	movw	r22, r12
    2bc2:	80 e3       	ldi	r24, 0x30	; 48
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	4a d0       	rcall	.+148    	; 0x2c5c <fputc>
    2bc8:	9a 94       	dec	r9
    2bca:	f8 cf       	rjmp	.-16     	; 0x2bbc <vfprintf+0x386>
    2bcc:	8a 94       	dec	r8
    2bce:	f3 01       	movw	r30, r6
    2bd0:	e8 0d       	add	r30, r8
    2bd2:	f1 1d       	adc	r31, r1
    2bd4:	80 81       	ld	r24, Z
    2bd6:	b6 01       	movw	r22, r12
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	40 d0       	rcall	.+128    	; 0x2c5c <fputc>
    2bdc:	81 10       	cpse	r8, r1
    2bde:	f6 cf       	rjmp	.-20     	; 0x2bcc <vfprintf+0x396>
    2be0:	22 20       	and	r2, r2
    2be2:	09 f4       	brne	.+2      	; 0x2be6 <vfprintf+0x3b0>
    2be4:	4e ce       	rjmp	.-868    	; 0x2882 <vfprintf+0x4c>
    2be6:	b6 01       	movw	r22, r12
    2be8:	80 e2       	ldi	r24, 0x20	; 32
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	37 d0       	rcall	.+110    	; 0x2c5c <fputc>
    2bee:	2a 94       	dec	r2
    2bf0:	f7 cf       	rjmp	.-18     	; 0x2be0 <vfprintf+0x3aa>
    2bf2:	f6 01       	movw	r30, r12
    2bf4:	86 81       	ldd	r24, Z+6	; 0x06
    2bf6:	97 81       	ldd	r25, Z+7	; 0x07
    2bf8:	02 c0       	rjmp	.+4      	; 0x2bfe <vfprintf+0x3c8>
    2bfa:	8f ef       	ldi	r24, 0xFF	; 255
    2bfc:	9f ef       	ldi	r25, 0xFF	; 255
    2bfe:	2b 96       	adiw	r28, 0x0b	; 11
    2c00:	0f b6       	in	r0, 0x3f	; 63
    2c02:	f8 94       	cli
    2c04:	de bf       	out	0x3e, r29	; 62
    2c06:	0f be       	out	0x3f, r0	; 63
    2c08:	cd bf       	out	0x3d, r28	; 61
    2c0a:	df 91       	pop	r29
    2c0c:	cf 91       	pop	r28
    2c0e:	1f 91       	pop	r17
    2c10:	0f 91       	pop	r16
    2c12:	ff 90       	pop	r15
    2c14:	ef 90       	pop	r14
    2c16:	df 90       	pop	r13
    2c18:	cf 90       	pop	r12
    2c1a:	bf 90       	pop	r11
    2c1c:	af 90       	pop	r10
    2c1e:	9f 90       	pop	r9
    2c20:	8f 90       	pop	r8
    2c22:	7f 90       	pop	r7
    2c24:	6f 90       	pop	r6
    2c26:	5f 90       	pop	r5
    2c28:	4f 90       	pop	r4
    2c2a:	3f 90       	pop	r3
    2c2c:	2f 90       	pop	r2
    2c2e:	08 95       	ret

00002c30 <strnlen_P>:
    2c30:	fc 01       	movw	r30, r24
    2c32:	05 90       	lpm	r0, Z+
    2c34:	61 50       	subi	r22, 0x01	; 1
    2c36:	70 40       	sbci	r23, 0x00	; 0
    2c38:	01 10       	cpse	r0, r1
    2c3a:	d8 f7       	brcc	.-10     	; 0x2c32 <strnlen_P+0x2>
    2c3c:	80 95       	com	r24
    2c3e:	90 95       	com	r25
    2c40:	8e 0f       	add	r24, r30
    2c42:	9f 1f       	adc	r25, r31
    2c44:	08 95       	ret

00002c46 <strnlen>:
    2c46:	fc 01       	movw	r30, r24
    2c48:	61 50       	subi	r22, 0x01	; 1
    2c4a:	70 40       	sbci	r23, 0x00	; 0
    2c4c:	01 90       	ld	r0, Z+
    2c4e:	01 10       	cpse	r0, r1
    2c50:	d8 f7       	brcc	.-10     	; 0x2c48 <strnlen+0x2>
    2c52:	80 95       	com	r24
    2c54:	90 95       	com	r25
    2c56:	8e 0f       	add	r24, r30
    2c58:	9f 1f       	adc	r25, r31
    2c5a:	08 95       	ret

00002c5c <fputc>:
    2c5c:	0f 93       	push	r16
    2c5e:	1f 93       	push	r17
    2c60:	cf 93       	push	r28
    2c62:	df 93       	push	r29
    2c64:	fb 01       	movw	r30, r22
    2c66:	23 81       	ldd	r18, Z+3	; 0x03
    2c68:	21 fd       	sbrc	r18, 1
    2c6a:	03 c0       	rjmp	.+6      	; 0x2c72 <fputc+0x16>
    2c6c:	8f ef       	ldi	r24, 0xFF	; 255
    2c6e:	9f ef       	ldi	r25, 0xFF	; 255
    2c70:	2c c0       	rjmp	.+88     	; 0x2cca <fputc+0x6e>
    2c72:	22 ff       	sbrs	r18, 2
    2c74:	16 c0       	rjmp	.+44     	; 0x2ca2 <fputc+0x46>
    2c76:	46 81       	ldd	r20, Z+6	; 0x06
    2c78:	57 81       	ldd	r21, Z+7	; 0x07
    2c7a:	24 81       	ldd	r18, Z+4	; 0x04
    2c7c:	35 81       	ldd	r19, Z+5	; 0x05
    2c7e:	42 17       	cp	r20, r18
    2c80:	53 07       	cpc	r21, r19
    2c82:	44 f4       	brge	.+16     	; 0x2c94 <fputc+0x38>
    2c84:	a0 81       	ld	r26, Z
    2c86:	b1 81       	ldd	r27, Z+1	; 0x01
    2c88:	9d 01       	movw	r18, r26
    2c8a:	2f 5f       	subi	r18, 0xFF	; 255
    2c8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c8e:	31 83       	std	Z+1, r19	; 0x01
    2c90:	20 83       	st	Z, r18
    2c92:	8c 93       	st	X, r24
    2c94:	26 81       	ldd	r18, Z+6	; 0x06
    2c96:	37 81       	ldd	r19, Z+7	; 0x07
    2c98:	2f 5f       	subi	r18, 0xFF	; 255
    2c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c9c:	37 83       	std	Z+7, r19	; 0x07
    2c9e:	26 83       	std	Z+6, r18	; 0x06
    2ca0:	14 c0       	rjmp	.+40     	; 0x2cca <fputc+0x6e>
    2ca2:	8b 01       	movw	r16, r22
    2ca4:	ec 01       	movw	r28, r24
    2ca6:	fb 01       	movw	r30, r22
    2ca8:	00 84       	ldd	r0, Z+8	; 0x08
    2caa:	f1 85       	ldd	r31, Z+9	; 0x09
    2cac:	e0 2d       	mov	r30, r0
    2cae:	09 95       	icall
    2cb0:	89 2b       	or	r24, r25
    2cb2:	e1 f6       	brne	.-72     	; 0x2c6c <fputc+0x10>
    2cb4:	d8 01       	movw	r26, r16
    2cb6:	16 96       	adiw	r26, 0x06	; 6
    2cb8:	8d 91       	ld	r24, X+
    2cba:	9c 91       	ld	r25, X
    2cbc:	17 97       	sbiw	r26, 0x07	; 7
    2cbe:	01 96       	adiw	r24, 0x01	; 1
    2cc0:	17 96       	adiw	r26, 0x07	; 7
    2cc2:	9c 93       	st	X, r25
    2cc4:	8e 93       	st	-X, r24
    2cc6:	16 97       	sbiw	r26, 0x06	; 6
    2cc8:	ce 01       	movw	r24, r28
    2cca:	df 91       	pop	r29
    2ccc:	cf 91       	pop	r28
    2cce:	1f 91       	pop	r17
    2cd0:	0f 91       	pop	r16
    2cd2:	08 95       	ret

00002cd4 <__ultoa_invert>:
    2cd4:	fa 01       	movw	r30, r20
    2cd6:	aa 27       	eor	r26, r26
    2cd8:	28 30       	cpi	r18, 0x08	; 8
    2cda:	51 f1       	breq	.+84     	; 0x2d30 <__ultoa_invert+0x5c>
    2cdc:	20 31       	cpi	r18, 0x10	; 16
    2cde:	81 f1       	breq	.+96     	; 0x2d40 <__ultoa_invert+0x6c>
    2ce0:	e8 94       	clt
    2ce2:	6f 93       	push	r22
    2ce4:	6e 7f       	andi	r22, 0xFE	; 254
    2ce6:	6e 5f       	subi	r22, 0xFE	; 254
    2ce8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cea:	8f 4f       	sbci	r24, 0xFF	; 255
    2cec:	9f 4f       	sbci	r25, 0xFF	; 255
    2cee:	af 4f       	sbci	r26, 0xFF	; 255
    2cf0:	b1 e0       	ldi	r27, 0x01	; 1
    2cf2:	3e d0       	rcall	.+124    	; 0x2d70 <__ultoa_invert+0x9c>
    2cf4:	b4 e0       	ldi	r27, 0x04	; 4
    2cf6:	3c d0       	rcall	.+120    	; 0x2d70 <__ultoa_invert+0x9c>
    2cf8:	67 0f       	add	r22, r23
    2cfa:	78 1f       	adc	r23, r24
    2cfc:	89 1f       	adc	r24, r25
    2cfe:	9a 1f       	adc	r25, r26
    2d00:	a1 1d       	adc	r26, r1
    2d02:	68 0f       	add	r22, r24
    2d04:	79 1f       	adc	r23, r25
    2d06:	8a 1f       	adc	r24, r26
    2d08:	91 1d       	adc	r25, r1
    2d0a:	a1 1d       	adc	r26, r1
    2d0c:	6a 0f       	add	r22, r26
    2d0e:	71 1d       	adc	r23, r1
    2d10:	81 1d       	adc	r24, r1
    2d12:	91 1d       	adc	r25, r1
    2d14:	a1 1d       	adc	r26, r1
    2d16:	20 d0       	rcall	.+64     	; 0x2d58 <__ultoa_invert+0x84>
    2d18:	09 f4       	brne	.+2      	; 0x2d1c <__ultoa_invert+0x48>
    2d1a:	68 94       	set
    2d1c:	3f 91       	pop	r19
    2d1e:	2a e0       	ldi	r18, 0x0A	; 10
    2d20:	26 9f       	mul	r18, r22
    2d22:	11 24       	eor	r1, r1
    2d24:	30 19       	sub	r19, r0
    2d26:	30 5d       	subi	r19, 0xD0	; 208
    2d28:	31 93       	st	Z+, r19
    2d2a:	de f6       	brtc	.-74     	; 0x2ce2 <__ultoa_invert+0xe>
    2d2c:	cf 01       	movw	r24, r30
    2d2e:	08 95       	ret
    2d30:	46 2f       	mov	r20, r22
    2d32:	47 70       	andi	r20, 0x07	; 7
    2d34:	40 5d       	subi	r20, 0xD0	; 208
    2d36:	41 93       	st	Z+, r20
    2d38:	b3 e0       	ldi	r27, 0x03	; 3
    2d3a:	0f d0       	rcall	.+30     	; 0x2d5a <__ultoa_invert+0x86>
    2d3c:	c9 f7       	brne	.-14     	; 0x2d30 <__ultoa_invert+0x5c>
    2d3e:	f6 cf       	rjmp	.-20     	; 0x2d2c <__ultoa_invert+0x58>
    2d40:	46 2f       	mov	r20, r22
    2d42:	4f 70       	andi	r20, 0x0F	; 15
    2d44:	40 5d       	subi	r20, 0xD0	; 208
    2d46:	4a 33       	cpi	r20, 0x3A	; 58
    2d48:	18 f0       	brcs	.+6      	; 0x2d50 <__ultoa_invert+0x7c>
    2d4a:	49 5d       	subi	r20, 0xD9	; 217
    2d4c:	31 fd       	sbrc	r19, 1
    2d4e:	40 52       	subi	r20, 0x20	; 32
    2d50:	41 93       	st	Z+, r20
    2d52:	02 d0       	rcall	.+4      	; 0x2d58 <__ultoa_invert+0x84>
    2d54:	a9 f7       	brne	.-22     	; 0x2d40 <__ultoa_invert+0x6c>
    2d56:	ea cf       	rjmp	.-44     	; 0x2d2c <__ultoa_invert+0x58>
    2d58:	b4 e0       	ldi	r27, 0x04	; 4
    2d5a:	a6 95       	lsr	r26
    2d5c:	97 95       	ror	r25
    2d5e:	87 95       	ror	r24
    2d60:	77 95       	ror	r23
    2d62:	67 95       	ror	r22
    2d64:	ba 95       	dec	r27
    2d66:	c9 f7       	brne	.-14     	; 0x2d5a <__ultoa_invert+0x86>
    2d68:	00 97       	sbiw	r24, 0x00	; 0
    2d6a:	61 05       	cpc	r22, r1
    2d6c:	71 05       	cpc	r23, r1
    2d6e:	08 95       	ret
    2d70:	9b 01       	movw	r18, r22
    2d72:	ac 01       	movw	r20, r24
    2d74:	0a 2e       	mov	r0, r26
    2d76:	06 94       	lsr	r0
    2d78:	57 95       	ror	r21
    2d7a:	47 95       	ror	r20
    2d7c:	37 95       	ror	r19
    2d7e:	27 95       	ror	r18
    2d80:	ba 95       	dec	r27
    2d82:	c9 f7       	brne	.-14     	; 0x2d76 <__ultoa_invert+0xa2>
    2d84:	62 0f       	add	r22, r18
    2d86:	73 1f       	adc	r23, r19
    2d88:	84 1f       	adc	r24, r20
    2d8a:	95 1f       	adc	r25, r21
    2d8c:	a0 1d       	adc	r26, r0
    2d8e:	08 95       	ret

00002d90 <eeprom_read_word>:
    2d90:	a8 e1       	ldi	r26, 0x18	; 24
    2d92:	b0 e0       	ldi	r27, 0x00	; 0
    2d94:	42 e0       	ldi	r20, 0x02	; 2
    2d96:	50 e0       	ldi	r21, 0x00	; 0
    2d98:	05 c0       	rjmp	.+10     	; 0x2da4 <eeprom_read_blraw>

00002d9a <eeprom_write_word>:
    2d9a:	12 d0       	rcall	.+36     	; 0x2dc0 <eeprom_write_byte>
    2d9c:	27 2f       	mov	r18, r23
    2d9e:	11 c0       	rjmp	.+34     	; 0x2dc2 <eeprom_write_r18>

00002da0 <eeprom_read_block>:
    2da0:	dc 01       	movw	r26, r24
    2da2:	cb 01       	movw	r24, r22

00002da4 <eeprom_read_blraw>:
    2da4:	fc 01       	movw	r30, r24
    2da6:	f9 99       	sbic	0x1f, 1	; 31
    2da8:	fe cf       	rjmp	.-4      	; 0x2da6 <eeprom_read_blraw+0x2>
    2daa:	06 c0       	rjmp	.+12     	; 0x2db8 <eeprom_read_blraw+0x14>
    2dac:	f2 bd       	out	0x22, r31	; 34
    2dae:	e1 bd       	out	0x21, r30	; 33
    2db0:	f8 9a       	sbi	0x1f, 0	; 31
    2db2:	31 96       	adiw	r30, 0x01	; 1
    2db4:	00 b4       	in	r0, 0x20	; 32
    2db6:	0d 92       	st	X+, r0
    2db8:	41 50       	subi	r20, 0x01	; 1
    2dba:	50 40       	sbci	r21, 0x00	; 0
    2dbc:	b8 f7       	brcc	.-18     	; 0x2dac <eeprom_read_blraw+0x8>
    2dbe:	08 95       	ret

00002dc0 <eeprom_write_byte>:
    2dc0:	26 2f       	mov	r18, r22

00002dc2 <eeprom_write_r18>:
    2dc2:	f9 99       	sbic	0x1f, 1	; 31
    2dc4:	fe cf       	rjmp	.-4      	; 0x2dc2 <eeprom_write_r18>
    2dc6:	92 bd       	out	0x22, r25	; 34
    2dc8:	81 bd       	out	0x21, r24	; 33
    2dca:	20 bd       	out	0x20, r18	; 32
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	fa 9a       	sbi	0x1f, 2	; 31
    2dd2:	f9 9a       	sbi	0x1f, 1	; 31
    2dd4:	0f be       	out	0x3f, r0	; 63
    2dd6:	01 96       	adiw	r24, 0x01	; 1
    2dd8:	08 95       	ret

00002dda <_exit>:
    2dda:	f8 94       	cli

00002ddc <__stop_program>:
    2ddc:	ff cf       	rjmp	.-2      	; 0x2ddc <__stop_program>
