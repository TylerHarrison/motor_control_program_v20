
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002de6  00002e7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002de6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f5a  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fe8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00003028  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007172  00000000  00000000  000035d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001dec  00000000  00000000  0000a74a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000337a  00000000  00000000  0000c536  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000109c  00000000  00000000  0000f8b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a07  00000000  00000000  0001094c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000469f  00000000  00000000  00012353  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  000169f2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 5a 0d 	jmp	0x1ab4	; 0x1ab4 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 c9 0c 	jmp	0x1992	; 0x1992 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 0a 0c 	jmp	0x1814	; 0x1814 <__vector_16>
      44:	0c 94 49 11 	jmp	0x2292	; 0x2292 <__vector_17>
      48:	0c 94 fa 0e 	jmp	0x1df4	; 0x1df4 <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 f6 0a 	jmp	0x15ec	; 0x15ec <__vector_21>
      58:	0c 94 d8 0a 	jmp	0x15b0	; 0x15b0 <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 2f 0b 	jmp	0x165e	; 0x165e <__vector_32>
      84:	0c 94 11 0b 	jmp	0x1622	; 0x1622 <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	cc 0e       	add	r12, r28
      96:	d1 0e       	add	r13, r17
      98:	d7 0e       	add	r13, r23
      9a:	dd 0e       	add	r13, r29
      9c:	e3 0e       	add	r14, r19
      9e:	e8 0e       	add	r14, r24
      a0:	ee 0e       	add	r14, r30
      a2:	f4 0e       	add	r15, r20

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e6 ee       	ldi	r30, 0xE6	; 230
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <main>
      de:	0c 94 f1 16 	jmp	0x2de2	; 0x2de2 <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	11 f0       	breq	.+4      	; 0x214 <actuator_pwm+0x8>
     210:	75 9a       	sbi	0x0e, 5	; 14
     212:	08 95       	ret
     214:	75 98       	cbi	0x0e, 5	; 14
     216:	08 95       	ret

00000218 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     218:	4f 92       	push	r4
     21a:	5f 92       	push	r5
     21c:	6f 92       	push	r6
     21e:	7f 92       	push	r7
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	ec 01       	movw	r28, r24
     238:	96 2e       	mov	r9, r22
     23a:	c6 01       	movw	r24, r12
     23c:	b5 01       	movw	r22, r10
			2) Position_ERROR
			3) actuator_duty_cycle
			4) gear_status
*/
	float kp = 5; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value 
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     23e:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     242:	87 01       	movw	r16, r14
     244:	06 1b       	sub	r16, r22
     246:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     248:	b8 01       	movw	r22, r16
     24a:	01 2e       	mov	r0, r17
     24c:	00 0c       	add	r0, r0
     24e:	88 0b       	sbc	r24, r24
     250:	99 0b       	sbc	r25, r25
     252:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
     256:	2b 01       	movw	r4, r22
     258:	3c 01       	movw	r6, r24
     25a:	20 e0       	ldi	r18, 0x00	; 0
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	40 ea       	ldi	r20, 0xA0	; 160
     260:	50 e4       	ldi	r21, 0x40	; 64
     262:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	45 e8       	ldi	r20, 0x85	; 133
     26c:	52 e4       	ldi	r21, 0x42	; 66
     26e:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     272:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     276:	6b 01       	movw	r12, r22
     278:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 ea       	ldi	r20, 0xA0	; 160
     280:	50 e4       	ldi	r21, 0x40	; 64
     282:	c3 01       	movw	r24, r6
     284:	b2 01       	movw	r22, r4
     286:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__cmpsf2>
     28a:	88 23       	and	r24, r24
     28c:	c4 f5       	brge	.+112    	; 0x2fe <actuator_set_position+0xe6>
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	40 ea       	ldi	r20, 0xA0	; 160
     294:	50 ec       	ldi	r21, 0xC0	; 192
     296:	c3 01       	movw	r24, r6
     298:	b2 01       	movw	r22, r4
     29a:	0e 94 39 13 	call	0x2672	; 0x2672 <__gesf2>
     29e:	18 16       	cp	r1, r24
     2a0:	74 f5       	brge	.+92     	; 0x2fe <actuator_set_position+0xe6>
     2a2:	30 c0       	rjmp	.+96     	; 0x304 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2a4:	8c 81       	ldd	r24, Y+4	; 0x04
     2a6:	9d 81       	ldd	r25, Y+5	; 0x05
     2a8:	00 97       	sbiw	r24, 0x00	; 0
     2aa:	29 f0       	breq	.+10     	; 0x2b6 <actuator_set_position+0x9e>
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	89 f4       	brne	.+34     	; 0x2d2 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2b0:	1b 82       	std	Y+3, r1	; 0x03
     2b2:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2b4:	0e c0       	rjmp	.+28     	; 0x2d2 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2b6:	10 16       	cp	r1, r16
     2b8:	11 06       	cpc	r1, r17
     2ba:	2c f4       	brge	.+10     	; 0x2c6 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	06 c0       	rjmp	.+12     	; 0x2d2 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2c6:	11 23       	and	r17, r17
     2c8:	24 f4       	brge	.+8      	; 0x2d2 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2ca:	82 e0       	ldi	r24, 0x02	; 2
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	9b 83       	std	Y+3, r25	; 0x03
     2d0:	8a 83       	std	Y+2, r24	; 0x02
     2d2:	c6 01       	movw	r24, r12
     2d4:	83 38       	cpi	r24, 0x83	; 131
     2d6:	91 05       	cpc	r25, r1
     2d8:	14 f0       	brlt	.+4      	; 0x2de <actuator_set_position+0xc6>
     2da:	82 e8       	ldi	r24, 0x82	; 130
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	6c 01       	movw	r12, r24
     2e0:	99 23       	and	r25, r25
     2e2:	14 f4       	brge	.+4      	; 0x2e8 <actuator_set_position+0xd0>
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2e8:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2ec:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2f0:	db 86       	std	Y+11, r13	; 0x0b
     2f2:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2f4:	4e 82       	std	Y+6, r4	; 0x06
     2f6:	5f 82       	std	Y+7, r5	; 0x07
     2f8:	68 86       	std	Y+8, r6	; 0x08
     2fa:	79 86       	std	Y+9, r7	; 0x09
	
	//if (ActuatorComValues.actuator_in_position == 0)
	//{
	//
	//}
}
     2fc:	10 c0       	rjmp	.+32     	; 0x31e <actuator_set_position+0x106>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		actuator_values->actuator_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2fe:	1d 82       	std	Y+5, r1	; 0x05
     300:	1c 82       	std	Y+4, r1	; 0x04
     302:	d0 cf       	rjmp	.-96     	; 0x2a4 <actuator_set_position+0x8c>
	
	//Is the actuator with in an acceptable error
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	9d 83       	std	Y+5, r25	; 0x05
     30a:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     30c:	89 2d       	mov	r24, r9
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	99 83       	std	Y+1, r25	; 0x01
     312:	88 83       	st	Y, r24
		actuator_values->actuator_duty_cycle = 50;
     314:	82 e3       	ldi	r24, 0x32	; 50
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	9b 87       	std	Y+11, r25	; 0x0b
     31a:	8a 87       	std	Y+10, r24	; 0x0a
     31c:	c3 cf       	rjmp	.-122    	; 0x2a4 <actuator_set_position+0x8c>
	
	//if (ActuatorComValues.actuator_in_position == 0)
	//{
	//
	//}
}
     31e:	df 91       	pop	r29
     320:	cf 91       	pop	r28
     322:	1f 91       	pop	r17
     324:	0f 91       	pop	r16
     326:	ff 90       	pop	r15
     328:	ef 90       	pop	r14
     32a:	df 90       	pop	r13
     32c:	cf 90       	pop	r12
     32e:	bf 90       	pop	r11
     330:	af 90       	pop	r10
     332:	9f 90       	pop	r9
     334:	7f 90       	pop	r7
     336:	6f 90       	pop	r6
     338:	5f 90       	pop	r5
     33a:	4f 90       	pop	r4
     33c:	08 95       	ret

0000033e <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     33e:	af 92       	push	r10
     340:	bf 92       	push	r11
     342:	cf 92       	push	r12
     344:	df 92       	push	r13
     346:	ef 92       	push	r14
     348:	ff 92       	push	r15
     34a:	0f 93       	push	r16
     34c:	1f 93       	push	r17
     34e:	cf 93       	push	r28
     350:	df 93       	push	r29
     352:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     354:	8b a1       	ldd	r24, Y+35	; 0x23
     356:	9c a1       	ldd	r25, Y+36	; 0x24
     358:	89 2b       	or	r24, r25
     35a:	61 f1       	breq	.+88     	; 0x3b4 <actuator_p_controller+0x76>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     35c:	8b ad       	ldd	r24, Y+59	; 0x3b
     35e:	81 30       	cpi	r24, 0x01	; 1
     360:	39 f0       	breq	.+14     	; 0x370 <actuator_p_controller+0x32>
     362:	18 f0       	brcs	.+6      	; 0x36a <actuator_p_controller+0x2c>
     364:	82 30       	cpi	r24, 0x02	; 2
     366:	39 f0       	breq	.+14     	; 0x376 <actuator_p_controller+0x38>
     368:	09 c0       	rjmp	.+18     	; 0x37c <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     36a:	ec a8       	ldd	r14, Y+52	; 0x34
     36c:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     36e:	08 c0       	rjmp	.+16     	; 0x380 <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     370:	ee a8       	ldd	r14, Y+54	; 0x36
     372:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     374:	05 c0       	rjmp	.+10     	; 0x380 <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     376:	e8 ac       	ldd	r14, Y+56	; 0x38
     378:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     37a:	02 c0       	rjmp	.+4      	; 0x380 <actuator_p_controller+0x42>
	//}
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     37c:	e1 2c       	mov	r14, r1
     37e:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     380:	ab a4       	ldd	r10, Y+43	; 0x2b
     382:	bc a4       	ldd	r11, Y+44	; 0x2c
     384:	cd a4       	ldd	r12, Y+45	; 0x2d
     386:	de a4       	ldd	r13, Y+46	; 0x2e
     388:	0f a5       	ldd	r16, Y+47	; 0x2f
     38a:	2f a1       	ldd	r18, Y+39	; 0x27
     38c:	38 a5       	ldd	r19, Y+40	; 0x28
     38e:	49 a5       	ldd	r20, Y+41	; 0x29
     390:	5a a5       	ldd	r21, Y+42	; 0x2a
     392:	6b ad       	ldd	r22, Y+59	; 0x3b
     394:	10 e0       	ldi	r17, 0x00	; 0
     396:	80 ee       	ldi	r24, 0xE0	; 224
     398:	91 e0       	ldi	r25, 0x01	; 1
     39a:	3e df       	rcall	.-388    	; 0x218 <actuator_set_position>
		
		if (ActuatorComValues.actuator_in_position)
     39c:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <__data_end+0x4>
     3a0:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <__data_end+0x5>
     3a4:	89 2b       	or	r24, r25
     3a6:	b1 f0       	breq	.+44     	; 0x3d4 <actuator_p_controller+0x96>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     3a8:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     3ac:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     3b0:	8a af       	std	Y+58, r24	; 0x3a
     3b2:	10 c0       	rjmp	.+32     	; 0x3d4 <actuator_p_controller+0x96>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     3b4:	ea a8       	ldd	r14, Y+50	; 0x32
     3b6:	fb a8       	ldd	r15, Y+51	; 0x33
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     3b8:	ab a4       	ldd	r10, Y+43	; 0x2b
     3ba:	bc a4       	ldd	r11, Y+44	; 0x2c
     3bc:	cd a4       	ldd	r12, Y+45	; 0x2d
     3be:	de a4       	ldd	r13, Y+46	; 0x2e
     3c0:	0f a5       	ldd	r16, Y+47	; 0x2f
     3c2:	2f a1       	ldd	r18, Y+39	; 0x27
     3c4:	38 a5       	ldd	r19, Y+40	; 0x28
     3c6:	49 a5       	ldd	r20, Y+41	; 0x29
     3c8:	5a a5       	ldd	r21, Y+42	; 0x2a
     3ca:	6b ad       	ldd	r22, Y+59	; 0x3b
     3cc:	10 e0       	ldi	r17, 0x00	; 0
     3ce:	80 ee       	ldi	r24, 0xE0	; 224
     3d0:	91 e0       	ldi	r25, 0x01	; 1
     3d2:	22 df       	rcall	.-444    	; 0x218 <actuator_set_position>

	}
}
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	ff 90       	pop	r15
     3de:	ef 90       	pop	r14
     3e0:	df 90       	pop	r13
     3e2:	cf 90       	pop	r12
     3e4:	bf 90       	pop	r11
     3e6:	af 90       	pop	r10
     3e8:	08 95       	ret

000003ea <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3ea:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3ee:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3f2:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3f6:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3fa:	08 95       	ret

000003fc <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3fc:	68 2f       	mov	r22, r24
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
     408:	20 e0       	ldi	r18, 0x00	; 0
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	48 e4       	ldi	r20, 0x48	; 72
     40e:	52 e4       	ldi	r21, 0x42	; 66
     410:	0e 94 85 11 	call	0x230a	; 0x230a <__subsf3>
     414:	27 ed       	ldi	r18, 0xD7	; 215
     416:	33 ea       	ldi	r19, 0xA3	; 163
     418:	48 e8       	ldi	r20, 0x88	; 136
     41a:	51 e4       	ldi	r21, 0x41	; 65
     41c:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
     420:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     424:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     428:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     42c:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     430:	08 95       	ret

00000432 <controller>:
}

void controller(volatile ModuleValues_t *vals){
     432:	8f 92       	push	r8
     434:	9f 92       	push	r9
     436:	af 92       	push	r10
     438:	bf 92       	push	r11
     43a:	cf 92       	push	r12
     43c:	df 92       	push	r13
     43e:	ef 92       	push	r14
     440:	ff 92       	push	r15
     442:	0f 93       	push	r16
     444:	1f 93       	push	r17
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     44c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     44e:	82 30       	cpi	r24, 0x02	; 2
     450:	21 f4       	brne	.+8      	; 0x45a <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     452:	68 8d       	ldd	r22, Y+24	; 0x18
     454:	16 2f       	mov	r17, r22
     456:	11 95       	neg	r17
     458:	01 c0       	rjmp	.+2      	; 0x45c <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     45a:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     45c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     45e:	81 30       	cpi	r24, 0x01	; 1
     460:	09 f4       	brne	.+2      	; 0x464 <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     462:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     464:	89 a1       	ldd	r24, Y+33	; 0x21
     466:	81 11       	cpse	r24, r1
     468:	7b c0       	rjmp	.+246    	; 0x560 <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     46a:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     46e:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     472:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     476:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     47a:	20 e0       	ldi	r18, 0x00	; 0
     47c:	30 e0       	ldi	r19, 0x00	; 0
     47e:	4e eb       	ldi	r20, 0xBE	; 190
     480:	52 e4       	ldi	r21, 0x42	; 66
     482:	c7 01       	movw	r24, r14
     484:	b6 01       	movw	r22, r12
     486:	0e 94 39 13 	call	0x2672	; 0x2672 <__gesf2>
     48a:	88 23       	and	r24, r24
     48c:	54 f4       	brge	.+20     	; 0x4a2 <controller+0x70>
     48e:	20 e0       	ldi	r18, 0x00	; 0
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	48 e4       	ldi	r20, 0x48	; 72
     494:	52 e4       	ldi	r21, 0x42	; 66
     496:	c7 01       	movw	r24, r14
     498:	b6 01       	movw	r22, r12
     49a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__cmpsf2>
     49e:	18 16       	cp	r1, r24
     4a0:	6c f0       	brlt	.+26     	; 0x4bc <controller+0x8a>
		{
			b_saturation = 1 ;
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4a8:	61 2f       	mov	r22, r17
     4aa:	11 0f       	add	r17, r17
     4ac:	77 0b       	sbc	r23, r23
     4ae:	88 0b       	sbc	r24, r24
     4b0:	99 0b       	sbc	r25, r25
     4b2:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
     4b6:	6b 01       	movw	r12, r22
     4b8:	7c 01       	movw	r14, r24
     4ba:	25 c0       	rjmp	.+74     	; 0x506 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     4bc:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4c0:	61 2f       	mov	r22, r17
     4c2:	11 0f       	add	r17, r17
     4c4:	77 0b       	sbc	r23, r23
     4c6:	88 0b       	sbc	r24, r24
     4c8:	99 0b       	sbc	r25, r25
     4ca:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
     4ce:	6b 01       	movw	r12, r22
     4d0:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4d2:	2a e0       	ldi	r18, 0x0A	; 10
     4d4:	37 ed       	ldi	r19, 0xD7	; 215
     4d6:	43 ea       	ldi	r20, 0xA3	; 163
     4d8:	5b e3       	ldi	r21, 0x3B	; 59
     4da:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     4de:	9b 01       	movw	r18, r22
     4e0:	ac 01       	movw	r20, r24
     4e2:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4e6:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4ea:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4ee:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4f2:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     4f6:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4fa:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4fe:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     502:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     506:	27 ed       	ldi	r18, 0xD7	; 215
     508:	33 ea       	ldi	r19, 0xA3	; 163
     50a:	48 e8       	ldi	r20, 0x88	; 136
     50c:	51 e4       	ldi	r21, 0x41	; 65
     50e:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     512:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     516:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     51a:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     51e:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     522:	4b 01       	movw	r8, r22
     524:	5c 01       	movw	r10, r24
     526:	27 e8       	ldi	r18, 0x87	; 135
     528:	3f eb       	ldi	r19, 0xBF	; 191
     52a:	46 e2       	ldi	r20, 0x26	; 38
     52c:	5e e3       	ldi	r21, 0x3E	; 62
     52e:	c7 01       	movw	r24, r14
     530:	b6 01       	movw	r22, r12
     532:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     536:	9b 01       	movw	r18, r22
     538:	ac 01       	movw	r20, r24
     53a:	c5 01       	movw	r24, r10
     53c:	b4 01       	movw	r22, r8
     53e:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     542:	20 e0       	ldi	r18, 0x00	; 0
     544:	30 e0       	ldi	r19, 0x00	; 0
     546:	48 e4       	ldi	r20, 0x48	; 72
     548:	52 e4       	ldi	r21, 0x42	; 66
     54a:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     54e:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     552:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     556:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     55a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     55e:	11 c0       	rjmp	.+34     	; 0x582 <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     560:	89 a1       	ldd	r24, Y+33	; 0x21
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	71 f4       	brne	.+28     	; 0x582 <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     566:	69 8d       	ldd	r22, Y+25	; 0x19
     568:	70 e0       	ldi	r23, 0x00	; 0
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     572:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     576:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     57a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     57e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     582:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     586:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     58a:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     58e:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	4e eb       	ldi	r20, 0xBE	; 190
     598:	52 e4       	ldi	r21, 0x42	; 66
     59a:	c7 01       	movw	r24, r14
     59c:	b6 01       	movw	r22, r12
     59e:	0e 94 39 13 	call	0x2672	; 0x2672 <__gesf2>
     5a2:	18 16       	cp	r1, r24
     5a4:	6c f4       	brge	.+26     	; 0x5c0 <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     5a6:	80 e0       	ldi	r24, 0x00	; 0
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	ae eb       	ldi	r26, 0xBE	; 190
     5ac:	b2 e4       	ldi	r27, 0x42	; 66
     5ae:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5b2:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5b6:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5ba:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     5be:	16 c0       	rjmp	.+44     	; 0x5ec <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     5c0:	20 e0       	ldi	r18, 0x00	; 0
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	48 e4       	ldi	r20, 0x48	; 72
     5c6:	52 e4       	ldi	r21, 0x42	; 66
     5c8:	c7 01       	movw	r24, r14
     5ca:	b6 01       	movw	r22, r12
     5cc:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <__cmpsf2>
     5d0:	88 23       	and	r24, r24
     5d2:	64 f4       	brge	.+24     	; 0x5ec <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	a8 e4       	ldi	r26, 0x48	; 72
     5da:	b2 e4       	ldi	r27, 0x42	; 66
     5dc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5e0:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5e4:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5e8:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5ec:	06 e9       	ldi	r16, 0x96	; 150
     5ee:	10 e0       	ldi	r17, 0x00	; 0
     5f0:	f8 01       	movw	r30, r16
     5f2:	e0 80       	ld	r14, Z
     5f4:	f1 80       	ldd	r15, Z+1	; 0x01
     5f6:	20 e0       	ldi	r18, 0x00	; 0
     5f8:	30 e0       	ldi	r19, 0x00	; 0
     5fa:	48 ec       	ldi	r20, 0xC8	; 200
     5fc:	52 e4       	ldi	r21, 0x42	; 66
     5fe:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     602:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     606:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     60a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     60e:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
     612:	4b 01       	movw	r8, r22
     614:	5c 01       	movw	r10, r24
     616:	b7 01       	movw	r22, r14
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     620:	9b 01       	movw	r18, r22
     622:	ac 01       	movw	r20, r24
     624:	c5 01       	movw	r24, r10
     626:	b4 01       	movw	r22, r8
     628:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     62c:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     630:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     634:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     638:	f8 01       	movw	r30, r16
     63a:	60 81       	ld	r22, Z
     63c:	71 81       	ldd	r23, Z+1	; 0x01
     63e:	00 81       	ld	r16, Z
     640:	11 81       	ldd	r17, Z+1	; 0x01
     642:	80 e0       	ldi	r24, 0x00	; 0
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     64a:	6b 01       	movw	r12, r22
     64c:	7c 01       	movw	r14, r24
     64e:	20 e0       	ldi	r18, 0x00	; 0
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	48 ec       	ldi	r20, 0xC8	; 200
     654:	52 e4       	ldi	r21, 0x42	; 66
     656:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     65a:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     65e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     662:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     666:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
     66a:	4b 01       	movw	r8, r22
     66c:	5c 01       	movw	r10, r24
     66e:	b8 01       	movw	r22, r16
     670:	80 e0       	ldi	r24, 0x00	; 0
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     678:	9b 01       	movw	r18, r22
     67a:	ac 01       	movw	r20, r24
     67c:	c5 01       	movw	r24, r10
     67e:	b4 01       	movw	r22, r8
     680:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     684:	9b 01       	movw	r18, r22
     686:	ac 01       	movw	r20, r24
     688:	c7 01       	movw	r24, r14
     68a:	b6 01       	movw	r22, r12
     68c:	0e 94 85 11 	call	0x230a	; 0x230a <__subsf3>
     690:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     694:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     698:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     69c:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     6a0:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     6a4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     6a8:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     6ac:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
     6b0:	69 8f       	std	Y+25, r22	; 0x19

}
     6b2:	df 91       	pop	r29
     6b4:	cf 91       	pop	r28
     6b6:	1f 91       	pop	r17
     6b8:	0f 91       	pop	r16
     6ba:	ff 90       	pop	r15
     6bc:	ef 90       	pop	r14
     6be:	df 90       	pop	r13
     6c0:	cf 90       	pop	r12
     6c2:	bf 90       	pop	r11
     6c4:	af 90       	pop	r10
     6c6:	9f 90       	pop	r9
     6c8:	8f 90       	pop	r8
     6ca:	08 95       	ret

000006cc <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6cc:	53 9a       	sbi	0x0a, 3	; 10
     6ce:	08 95       	ret

000006d0 <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6d0:	81 30       	cpi	r24, 0x01	; 1
     6d2:	11 f4       	brne	.+4      	; 0x6d8 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6d4:	5b 9a       	sbi	0x0b, 3	; 11
     6d6:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6d8:	5b 98       	cbi	0x0b, 3	; 11
     6da:	08 95       	ret

000006dc <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6e2:	6a ef       	ldi	r22, 0xFA	; 250
     6e4:	71 e0       	ldi	r23, 0x01	; 1
     6e6:	80 e0       	ldi	r24, 0x00	; 0
     6e8:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6ec:	21 e0       	ldi	r18, 0x01	; 1
     6ee:	43 e0       	ldi	r20, 0x03	; 3
     6f0:	50 e0       	ldi	r21, 0x00	; 0
     6f2:	67 ef       	ldi	r22, 0xF7	; 247
     6f4:	71 e0       	ldi	r23, 0x01	; 1
     6f6:	8a ef       	ldi	r24, 0xFA	; 250
     6f8:	91 e0       	ldi	r25, 0x01	; 1
     6fa:	0e 94 25 11 	call	0x224a	; 0x224a <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6fe:	e7 ef       	ldi	r30, 0xF7	; 247
     700:	f1 e0       	ldi	r31, 0x01	; 1
     702:	61 81       	ldd	r22, Z+1	; 0x01
     704:	6f 71       	andi	r22, 0x1F	; 31
     706:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     708:	70 e0       	ldi	r23, 0x00	; 0
     70a:	76 2f       	mov	r23, r22
     70c:	66 27       	eor	r22, r22
     70e:	82 81       	ldd	r24, Z+2	; 0x02
     710:	68 2b       	or	r22, r24
     712:	80 e0       	ldi	r24, 0x00	; 0
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     71a:	20 e0       	ldi	r18, 0x00	; 0
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	49 e8       	ldi	r20, 0x89	; 137
     720:	52 e4       	ldi	r21, 0x42	; 66
     722:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
     726:	20 e0       	ldi	r18, 0x00	; 0
     728:	30 e0       	ldi	r19, 0x00	; 0
     72a:	40 e2       	ldi	r20, 0x20	; 32
     72c:	51 e4       	ldi	r21, 0x41	; 65
     72e:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	48 e8       	ldi	r20, 0x88	; 136
     738:	51 e4       	ldi	r21, 0x41	; 65
     73a:	0e 94 85 11 	call	0x230a	; 0x230a <__subsf3>
     73e:	20 e0       	ldi	r18, 0x00	; 0
     740:	30 e0       	ldi	r19, 0x00	; 0
     742:	a9 01       	movw	r20, r18
     744:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     748:	68 83       	st	Y, r22
     74a:	79 83       	std	Y+1, r23	; 0x01
     74c:	8a 83       	std	Y+2, r24	; 0x02
     74e:	9b 83       	std	Y+3, r25	; 0x03
}
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     75c:	6a ef       	ldi	r22, 0xFA	; 250
     75e:	71 e0       	ldi	r23, 0x01	; 1
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     766:	21 e0       	ldi	r18, 0x01	; 1
     768:	43 e0       	ldi	r20, 0x03	; 3
     76a:	50 e0       	ldi	r21, 0x00	; 0
     76c:	67 ef       	ldi	r22, 0xF7	; 247
     76e:	71 e0       	ldi	r23, 0x01	; 1
     770:	8a ef       	ldi	r24, 0xFA	; 250
     772:	91 e0       	ldi	r25, 0x01	; 1
     774:	0e 94 25 11 	call	0x224a	; 0x224a <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     778:	e7 ef       	ldi	r30, 0xF7	; 247
     77a:	f1 e0       	ldi	r31, 0x01	; 1
     77c:	61 81       	ldd	r22, Z+1	; 0x01
     77e:	6f 71       	andi	r22, 0x1F	; 31
     780:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     782:	70 e0       	ldi	r23, 0x00	; 0
     784:	76 2f       	mov	r23, r22
     786:	66 27       	eor	r22, r22
     788:	82 81       	ldd	r24, Z+2	; 0x02
     78a:	68 2b       	or	r22, r24
     78c:	41 e0       	ldi	r20, 0x01	; 1
     78e:	ce 01       	movw	r24, r28
     790:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <handle_current_sensor>
}
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	08 95       	ret

0000079a <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     7a0:	6a ef       	ldi	r22, 0xFA	; 250
     7a2:	71 e0       	ldi	r23, 0x01	; 1
     7a4:	84 e0       	ldi	r24, 0x04	; 4
     7a6:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7aa:	21 e0       	ldi	r18, 0x01	; 1
     7ac:	43 e0       	ldi	r20, 0x03	; 3
     7ae:	50 e0       	ldi	r21, 0x00	; 0
     7b0:	67 ef       	ldi	r22, 0xF7	; 247
     7b2:	71 e0       	ldi	r23, 0x01	; 1
     7b4:	8a ef       	ldi	r24, 0xFA	; 250
     7b6:	91 e0       	ldi	r25, 0x01	; 1
     7b8:	0e 94 25 11 	call	0x224a	; 0x224a <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7bc:	e7 ef       	ldi	r30, 0xF7	; 247
     7be:	f1 e0       	ldi	r31, 0x01	; 1
     7c0:	61 81       	ldd	r22, Z+1	; 0x01
     7c2:	6f 71       	andi	r22, 0x1F	; 31
     7c4:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7c6:	70 e0       	ldi	r23, 0x00	; 0
     7c8:	76 2f       	mov	r23, r22
     7ca:	66 27       	eor	r22, r22
     7cc:	82 81       	ldd	r24, Z+2	; 0x02
     7ce:	68 2b       	or	r22, r24
     7d0:	ce 01       	movw	r24, r28
     7d2:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <handle_temp_sensor>
}
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	08 95       	ret

000007dc <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	00 d0       	rcall	.+0      	; 0x7e6 <SPI_handler_6+0xa>
     7e6:	00 d0       	rcall	.+0      	; 0x7e8 <SPI_handler_6+0xc>
     7e8:	cd b7       	in	r28, 0x3d	; 61
     7ea:	de b7       	in	r29, 0x3e	; 62
     7ec:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7ee:	6a ef       	ldi	r22, 0xFA	; 250
     7f0:	71 e0       	ldi	r23, 0x01	; 1
     7f2:	86 e0       	ldi	r24, 0x06	; 6
     7f4:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7f8:	21 e0       	ldi	r18, 0x01	; 1
     7fa:	43 e0       	ldi	r20, 0x03	; 3
     7fc:	50 e0       	ldi	r21, 0x00	; 0
     7fe:	67 ef       	ldi	r22, 0xF7	; 247
     800:	71 e0       	ldi	r23, 0x01	; 1
     802:	8a ef       	ldi	r24, 0xFA	; 250
     804:	91 e0       	ldi	r25, 0x01	; 1
     806:	0e 94 25 11 	call	0x224a	; 0x224a <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     80a:	e7 ef       	ldi	r30, 0xF7	; 247
     80c:	f1 e0       	ldi	r31, 0x01	; 1
     80e:	61 81       	ldd	r22, Z+1	; 0x01
     810:	6f 71       	andi	r22, 0x1F	; 31
     812:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     814:	70 e0       	ldi	r23, 0x00	; 0
     816:	76 2f       	mov	r23, r22
     818:	66 27       	eor	r22, r22
     81a:	82 81       	ldd	r24, Z+2	; 0x02
     81c:	68 2b       	or	r22, r24
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	40 ea       	ldi	r20, 0xA0	; 160
     82c:	50 e4       	ldi	r21, 0x40	; 64
     82e:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     832:	20 e0       	ldi	r18, 0x00	; 0
     834:	30 e0       	ldi	r19, 0x00	; 0
     836:	40 e8       	ldi	r20, 0x80	; 128
     838:	59 e3       	ldi	r21, 0x39	; 57
     83a:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     83e:	69 83       	std	Y+1, r22	; 0x01
     840:	7a 83       	std	Y+2, r23	; 0x02
     842:	8b 83       	std	Y+3, r24	; 0x03
     844:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     846:	69 81       	ldd	r22, Y+1	; 0x01
     848:	7a 81       	ldd	r23, Y+2	; 0x02
     84a:	8b 81       	ldd	r24, Y+3	; 0x03
     84c:	9c 81       	ldd	r25, Y+4	; 0x04
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	30 e0       	ldi	r19, 0x00	; 0
     852:	48 ec       	ldi	r20, 0xC8	; 200
     854:	52 e4       	ldi	r21, 0x42	; 66
     856:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     85a:	20 e0       	ldi	r18, 0x00	; 0
     85c:	30 e0       	ldi	r19, 0x00	; 0
     85e:	48 ec       	ldi	r20, 0xC8	; 200
     860:	51 e4       	ldi	r21, 0x41	; 65
     862:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
     866:	f8 01       	movw	r30, r16
     868:	60 83       	st	Z, r22
     86a:	71 83       	std	Z+1, r23	; 0x01
     86c:	82 83       	std	Z+2, r24	; 0x02
     86e:	93 83       	std	Z+3, r25	; 0x03
}
     870:	0f 90       	pop	r0
     872:	0f 90       	pop	r0
     874:	0f 90       	pop	r0
     876:	0f 90       	pop	r0
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	1f 91       	pop	r17
     87e:	0f 91       	pop	r16
     880:	08 95       	ret

00000882 <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     882:	cf 93       	push	r28
     884:	df 93       	push	r29
     886:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     888:	6a ef       	ldi	r22, 0xFA	; 250
     88a:	71 e0       	ldi	r23, 0x01	; 1
     88c:	87 e0       	ldi	r24, 0x07	; 7
     88e:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     892:	21 e0       	ldi	r18, 0x01	; 1
     894:	43 e0       	ldi	r20, 0x03	; 3
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	67 ef       	ldi	r22, 0xF7	; 247
     89a:	71 e0       	ldi	r23, 0x01	; 1
     89c:	8a ef       	ldi	r24, 0xFA	; 250
     89e:	91 e0       	ldi	r25, 0x01	; 1
     8a0:	0e 94 25 11 	call	0x224a	; 0x224a <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     8a4:	e7 ef       	ldi	r30, 0xF7	; 247
     8a6:	f1 e0       	ldi	r31, 0x01	; 1
     8a8:	61 81       	ldd	r22, Z+1	; 0x01
     8aa:	6f 71       	andi	r22, 0x1F	; 31
     8ac:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	76 2f       	mov	r23, r22
     8b2:	66 27       	eor	r22, r22
     8b4:	82 81       	ldd	r24, Z+2	; 0x02
     8b6:	68 2b       	or	r22, r24
     8b8:	40 e0       	ldi	r20, 0x00	; 0
     8ba:	ce 01       	movw	r24, r28
     8bc:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <handle_current_sensor>
}
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	08 95       	ret

000008c6 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8c6:	0f 93       	push	r16
     8c8:	1f 93       	push	r17
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	8c 01       	movw	r16, r24
     8d0:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8d2:	cb 01       	movw	r24, r22
     8d4:	0e 94 40 10 	call	0x2080	; 0x2080 <can_read_message_if_new>
     8d8:	88 23       	and	r24, r24
     8da:	09 f4       	brne	.+2      	; 0x8de <handle_can+0x18>
     8dc:	46 c0       	rjmp	.+140    	; 0x96a <handle_can+0xa4>
     8de:	f8 01       	movw	r30, r16
     8e0:	86 8d       	ldd	r24, Z+30	; 0x1e
     8e2:	84 30       	cpi	r24, 0x04	; 4
     8e4:	09 f4       	brne	.+2      	; 0x8e8 <handle_can+0x22>
     8e6:	41 c0       	rjmp	.+130    	; 0x96a <handle_can+0xa4>
		switch (rx->id){
     8e8:	88 81       	ld	r24, Y
     8ea:	99 81       	ldd	r25, Y+1	; 0x01
     8ec:	80 32       	cpi	r24, 0x20	; 32
     8ee:	f1 e0       	ldi	r31, 0x01	; 1
     8f0:	9f 07       	cpc	r25, r31
     8f2:	91 f1       	breq	.+100    	; 0x958 <handle_can+0x92>
     8f4:	80 33       	cpi	r24, 0x30	; 48
     8f6:	92 40       	sbci	r25, 0x02	; 2
     8f8:	c1 f5       	brne	.+112    	; 0x96a <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	f8 01       	movw	r30, r16
     8fe:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     900:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     902:	82 e3       	ldi	r24, 0x32	; 50
     904:	90 e0       	ldi	r25, 0x00	; 0
     906:	93 8f       	std	Z+27, r25	; 0x1b
     908:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     90a:	8e 81       	ldd	r24, Y+6	; 0x06
     90c:	89 30       	cpi	r24, 0x09	; 9
     90e:	40 f0       	brcs	.+16     	; 0x920 <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     910:	86 95       	lsr	r24
     912:	86 95       	lsr	r24
     914:	86 95       	lsr	r24
     916:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     918:	8e e1       	ldi	r24, 0x1E	; 30
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	95 8f       	std	Z+29, r25	; 0x1d
     91e:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     920:	8f 81       	ldd	r24, Y+7	; 0x07
     922:	89 30       	cpi	r24, 0x09	; 9
     924:	88 f0       	brcs	.+34     	; 0x948 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     926:	8d 81       	ldd	r24, Y+5	; 0x05
     928:	9d ec       	ldi	r25, 0xCD	; 205
     92a:	89 9f       	mul	r24, r25
     92c:	81 2d       	mov	r24, r1
     92e:	11 24       	eor	r1, r1
     930:	86 95       	lsr	r24
     932:	86 95       	lsr	r24
     934:	86 95       	lsr	r24
     936:	f8 01       	movw	r30, r16
     938:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     93a:	8e e1       	ldi	r24, 0x1E	; 30
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	95 8f       	std	Z+29, r25	; 0x1d
     940:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     942:	8f 81       	ldd	r24, Y+7	; 0x07
     944:	89 30       	cpi	r24, 0x09	; 9
     946:	10 f4       	brcc	.+4      	; 0x94c <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     948:	f8 01       	movw	r30, r16
     94a:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     94c:	8e 81       	ldd	r24, Y+6	; 0x06
     94e:	89 30       	cpi	r24, 0x09	; 9
     950:	60 f4       	brcc	.+24     	; 0x96a <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     952:	f8 01       	movw	r30, r16
     954:	17 8a       	std	Z+23, r1	; 0x17
     956:	09 c0       	rjmp	.+18     	; 0x96a <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     958:	81 e0       	ldi	r24, 0x01	; 1
     95a:	f8 01       	movw	r30, r16
     95c:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     95e:	8b 81       	ldd	r24, Y+3	; 0x03
     960:	9c 81       	ldd	r25, Y+4	; 0x04
     962:	96 8b       	std	Z+22, r25	; 0x16
     964:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     966:	8d 81       	ldd	r24, Y+5	; 0x05
     968:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     96a:	df 91       	pop	r29
     96c:	cf 91       	pop	r28
     96e:	1f 91       	pop	r17
     970:	0f 91       	pop	r16
     972:	08 95       	ret

00000974 <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     974:	0f 93       	push	r16
     976:	1f 93       	push	r17
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     980:	08 eb       	ldi	r16, 0xB8	; 184
     982:	13 e0       	ldi	r17, 0x03	; 3
     984:	80 e5       	ldi	r24, 0x50	; 80
     986:	92 e0       	ldi	r25, 0x02	; 2
     988:	f8 01       	movw	r30, r16
     98a:	91 83       	std	Z+1, r25	; 0x01
     98c:	80 83       	st	Z, r24
	txFrame.length = 8;
     98e:	88 e0       	ldi	r24, 0x08	; 8
     990:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     992:	8d a1       	ldd	r24, Y+37	; 0x25
     994:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     996:	69 85       	ldd	r22, Y+9	; 0x09
     998:	7a 85       	ldd	r23, Y+10	; 0x0a
     99a:	8b 85       	ldd	r24, Y+11	; 0x0b
     99c:	9c 85       	ldd	r25, Y+12	; 0x0c
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	30 e0       	ldi	r19, 0x00	; 0
     9a2:	40 e2       	ldi	r20, 0x20	; 32
     9a4:	51 e4       	ldi	r21, 0x41	; 65
     9a6:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     9aa:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     9ae:	f8 01       	movw	r30, r16
     9b0:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     9b2:	69 89       	ldd	r22, Y+17	; 0x11
     9b4:	7a 89       	ldd	r23, Y+18	; 0x12
     9b6:	8b 89       	ldd	r24, Y+19	; 0x13
     9b8:	9c 89       	ldd	r25, Y+20	; 0x14
     9ba:	20 e0       	ldi	r18, 0x00	; 0
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	40 e2       	ldi	r20, 0x20	; 32
     9c0:	51 e4       	ldi	r21, 0x41	; 65
     9c2:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     9c6:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
     9ca:	f8 01       	movw	r30, r16
     9cc:	76 83       	std	Z+6, r23	; 0x06
     9ce:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9d0:	6d 89       	ldd	r22, Y+21	; 0x15
     9d2:	7e 89       	ldd	r23, Y+22	; 0x16
     9d4:	8f 89       	ldd	r24, Y+23	; 0x17
     9d6:	98 8d       	ldd	r25, Y+24	; 0x18
     9d8:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     9dc:	07 2e       	mov	r0, r23
     9de:	00 0c       	add	r0, r0
     9e0:	88 0b       	sbc	r24, r24
     9e2:	99 0b       	sbc	r25, r25
     9e4:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
     9e8:	20 e0       	ldi	r18, 0x00	; 0
     9ea:	30 e0       	ldi	r19, 0x00	; 0
     9ec:	48 ec       	ldi	r20, 0xC8	; 200
     9ee:	52 e4       	ldi	r21, 0x42	; 66
     9f0:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
     9f4:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     9f8:	9b 01       	movw	r18, r22
     9fa:	77 23       	and	r23, r23
     9fc:	24 f4       	brge	.+8      	; 0xa06 <handle_motor_status_can_msg+0x92>
     9fe:	22 27       	eor	r18, r18
     a00:	33 27       	eor	r19, r19
     a02:	26 1b       	sub	r18, r22
     a04:	37 0b       	sbc	r19, r23
     a06:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     a0a:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     a0e:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a10:	7b 8d       	ldd	r23, Y+27	; 0x1b
     a12:	08 eb       	ldi	r16, 0xB8	; 184
     a14:	13 e0       	ldi	r17, 0x03	; 3
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
     a1e:	26 e6       	ldi	r18, 0x66	; 102
     a20:	36 e6       	ldi	r19, 0x66	; 102
     a22:	46 e6       	ldi	r20, 0x66	; 102
     a24:	50 e4       	ldi	r21, 0x40	; 64
     a26:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     a2a:	20 e0       	ldi	r18, 0x00	; 0
     a2c:	30 e0       	ldi	r19, 0x00	; 0
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	5f e3       	ldi	r21, 0x3F	; 63
     a32:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
     a36:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
     a3a:	f8 01       	movw	r30, r16
     a3c:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a3e:	89 8d       	ldd	r24, Y+25	; 0x19
     a40:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a42:	c8 01       	movw	r24, r16
     a44:	0e 94 83 10 	call	0x2106	; 0x2106 <can_send_message>
}
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a52:	cf 93       	push	r28
     a54:	df 93       	push	r29
     a56:	cd b7       	in	r28, 0x3d	; 61
     a58:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a5a:	ed ea       	ldi	r30, 0xAD	; 173
     a5c:	f3 e0       	ldi	r31, 0x03	; 3
     a5e:	81 e5       	ldi	r24, 0x51	; 81
     a60:	92 e0       	ldi	r25, 0x02	; 2
     a62:	91 83       	std	Z+1, r25	; 0x01
     a64:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a6a:	21 96       	adiw	r28, 0x01	; 1
     a6c:	8f ad       	ldd	r24, Y+63	; 0x3f
     a6e:	21 97       	sbiw	r28, 0x01	; 1
     a70:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a72:	cf 01       	movw	r24, r30
     a74:	0e 94 83 10 	call	0x2106	; 0x2106 <can_send_message>
}
     a78:	df 91       	pop	r29
     a7a:	cf 91       	pop	r28
     a7c:	08 95       	ret

00000a7e <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a7e:	af 92       	push	r10
     a80:	bf 92       	push	r11
     a82:	cf 92       	push	r12
     a84:	df 92       	push	r13
     a86:	ef 92       	push	r14
     a88:	ff 92       	push	r15
     a8a:	0f 93       	push	r16
     a8c:	1f 93       	push	r17
     a8e:	cf 93       	push	r28
     a90:	df 93       	push	r29
     a92:	cd b7       	in	r28, 0x3d	; 61
     a94:	de b7       	in	r29, 0x3e	; 62
     a96:	66 97       	sbiw	r28, 0x16	; 22
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     aa4:	fe 01       	movw	r30, r28
     aa6:	31 96       	adiw	r30, 0x01	; 1
     aa8:	96 e1       	ldi	r25, 0x16	; 22
     aaa:	df 01       	movw	r26, r30
     aac:	1d 92       	st	X+, r1
     aae:	9a 95       	dec	r25
     ab0:	e9 f7       	brne	.-6      	; 0xaac <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     ab2:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     ab6:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     aba:	92 1b       	sub	r25, r18
     abc:	9f 71       	andi	r25, 0x1F	; 31
     abe:	09 f4       	brne	.+2      	; 0xac2 <receive_uart+0x44>
     ac0:	4e c1       	rjmp	.+668    	; 0xd5e <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     ac2:	f6 01       	movw	r30, r12
     ac4:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     ac6:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     ac8:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     aca:	66 e1       	ldi	r22, 0x16	; 22
     acc:	ce 01       	movw	r24, r28
     ace:	01 96       	adiw	r24, 0x01	; 1
     ad0:	08 d5       	rcall	.+2576   	; 0x14e2 <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     ad2:	ce 01       	movw	r24, r28
     ad4:	01 96       	adiw	r24, 0x01	; 1
     ad6:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
     ada:	5c 01       	movw	r10, r24
     adc:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ade:	d6 01       	movw	r26, r12
     ae0:	8d 91       	ld	r24, X+
     ae2:	9c 91       	ld	r25, X
     ae4:	89 2b       	or	r24, r25
     ae6:	71 f4       	brne	.+28     	; 0xb04 <receive_uart+0x86>
     ae8:	6f e4       	ldi	r22, 0x4F	; 79
     aea:	71 e0       	ldi	r23, 0x01	; 1
     aec:	ce 01       	movw	r24, r28
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     af4:	89 2b       	or	r24, r25
     af6:	31 f4       	brne	.+12     	; 0xb04 <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     af8:	f6 01       	movw	r30, r12
     afa:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     afc:	81 e0       	ldi	r24, 0x01	; 1
     afe:	90 e0       	ldi	r25, 0x00	; 0
     b00:	91 83       	std	Z+1, r25	; 0x01
     b02:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     b04:	d6 01       	movw	r26, r12
     b06:	8d 91       	ld	r24, X+
     b08:	9c 91       	ld	r25, X
     b0a:	89 2b       	or	r24, r25
     b0c:	71 f0       	breq	.+28     	; 0xb2a <receive_uart+0xac>
     b0e:	61 e6       	ldi	r22, 0x61	; 97
     b10:	71 e0       	ldi	r23, 0x01	; 1
     b12:	ce 01       	movw	r24, r28
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     b1a:	89 2b       	or	r24, r25
     b1c:	31 f4       	brne	.+12     	; 0xb2a <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     b1e:	f6 01       	movw	r30, r12
     b20:	11 82       	std	Z+1, r1	; 0x01
     b22:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     b24:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b26:	15 8e       	std	Z+29, r1	; 0x1d
     b28:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b2a:	62 e7       	ldi	r22, 0x72	; 114
     b2c:	71 e0       	ldi	r23, 0x01	; 1
     b2e:	ce 01       	movw	r24, r28
     b30:	01 96       	adiw	r24, 0x01	; 1
     b32:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     b36:	89 2b       	or	r24, r25
     b38:	11 f5       	brne	.+68     	; 0xb7e <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b3a:	d6 01       	movw	r26, r12
     b3c:	94 96       	adiw	r26, 0x24	; 36
     b3e:	1c 92       	st	X, r1
     b40:	1e 92       	st	-X, r1
     b42:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b44:	da 96       	adiw	r26, 0x3a	; 58
     b46:	8c 91       	ld	r24, X
     b48:	81 30       	cpi	r24, 0x01	; 1
     b4a:	51 f0       	breq	.+20     	; 0xb60 <receive_uart+0xe2>
     b4c:	18 f0       	brcs	.+6      	; 0xb54 <receive_uart+0xd6>
     b4e:	82 30       	cpi	r24, 0x02	; 2
     b50:	89 f0       	breq	.+34     	; 0xb74 <receive_uart+0xf6>
     b52:	15 c0       	rjmp	.+42     	; 0xb7e <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b54:	f6 01       	movw	r30, r12
     b56:	84 a9       	ldd	r24, Z+52	; 0x34
     b58:	95 a9       	ldd	r25, Z+53	; 0x35
     b5a:	93 ab       	std	Z+51, r25	; 0x33
     b5c:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b5e:	0f c0       	rjmp	.+30     	; 0xb7e <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b60:	d6 01       	movw	r26, r12
     b62:	d6 96       	adiw	r26, 0x36	; 54
     b64:	8d 91       	ld	r24, X+
     b66:	9c 91       	ld	r25, X
     b68:	d7 97       	sbiw	r26, 0x37	; 55
     b6a:	d3 96       	adiw	r26, 0x33	; 51
     b6c:	9c 93       	st	X, r25
     b6e:	8e 93       	st	-X, r24
     b70:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b72:	05 c0       	rjmp	.+10     	; 0xb7e <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b74:	f6 01       	movw	r30, r12
     b76:	80 ad       	ldd	r24, Z+56	; 0x38
     b78:	91 ad       	ldd	r25, Z+57	; 0x39
     b7a:	93 ab       	std	Z+51, r25	; 0x33
     b7c:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b7e:	65 e8       	ldi	r22, 0x85	; 133
     b80:	71 e0       	ldi	r23, 0x01	; 1
     b82:	ce 01       	movw	r24, r28
     b84:	01 96       	adiw	r24, 0x01	; 1
     b86:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     b8a:	89 2b       	or	r24, r25
     b8c:	39 f4       	brne	.+14     	; 0xb9c <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b8e:	81 e0       	ldi	r24, 0x01	; 1
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	d6 01       	movw	r26, r12
     b94:	94 96       	adiw	r26, 0x24	; 36
     b96:	9c 93       	st	X, r25
     b98:	8e 93       	st	-X, r24
     b9a:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b9c:	f6 01       	movw	r30, r12
     b9e:	80 81       	ld	r24, Z
     ba0:	91 81       	ldd	r25, Z+1	; 0x01
     ba2:	89 2b       	or	r24, r25
     ba4:	39 f0       	breq	.+14     	; 0xbb4 <receive_uart+0x136>
     ba6:	c5 01       	movw	r24, r10
     ba8:	0b 97       	sbiw	r24, 0x0b	; 11
     baa:	0a 97       	sbiw	r24, 0x0a	; 10
     bac:	18 f4       	brcc	.+6      	; 0xbb4 <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     bae:	86 ef       	ldi	r24, 0xF6	; 246
     bb0:	8a 0d       	add	r24, r10
     bb2:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     bb4:	d6 01       	movw	r26, r12
     bb6:	8d 91       	ld	r24, X+
     bb8:	9c 91       	ld	r25, X
     bba:	11 97       	sbiw	r26, 0x01	; 1
     bbc:	89 2b       	or	r24, r25
     bbe:	39 f0       	breq	.+14     	; 0xbce <receive_uart+0x150>
     bc0:	0a 30       	cpi	r16, 0x0A	; 10
     bc2:	11 05       	cpc	r17, r1
     bc4:	20 f4       	brcc	.+8      	; 0xbce <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     bc6:	8a e0       	ldi	r24, 0x0A	; 10
     bc8:	8a 19       	sub	r24, r10
     bca:	58 96       	adiw	r26, 0x18	; 24
     bcc:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     bce:	f6 01       	movw	r30, r12
     bd0:	80 81       	ld	r24, Z
     bd2:	91 81       	ldd	r25, Z+1	; 0x01
     bd4:	89 2b       	or	r24, r25
     bd6:	31 f0       	breq	.+12     	; 0xbe4 <receive_uart+0x166>
     bd8:	01 2b       	or	r16, r17
     bda:	21 f4       	brne	.+8      	; 0xbe4 <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bdc:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bde:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     be0:	82 e3       	ldi	r24, 0x32	; 50
     be2:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     be4:	d6 01       	movw	r26, r12
     be6:	93 96       	adiw	r26, 0x23	; 35
     be8:	8d 91       	ld	r24, X+
     bea:	9c 91       	ld	r25, X
     bec:	94 97       	sbiw	r26, 0x24	; 36
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	51 f4       	brne	.+20     	; 0xc06 <receive_uart+0x188>
     bf2:	67 e9       	ldi	r22, 0x97	; 151
     bf4:	71 e0       	ldi	r23, 0x01	; 1
     bf6:	ce 01       	movw	r24, r28
     bf8:	01 96       	adiw	r24, 0x01	; 1
     bfa:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     bfe:	89 2b       	or	r24, r25
     c00:	11 f4       	brne	.+4      	; 0xc06 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     c02:	f6 01       	movw	r30, r12
     c04:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     c06:	d6 01       	movw	r26, r12
     c08:	93 96       	adiw	r26, 0x23	; 35
     c0a:	8d 91       	ld	r24, X+
     c0c:	9c 91       	ld	r25, X
     c0e:	94 97       	sbiw	r26, 0x24	; 36
     c10:	01 97       	sbiw	r24, 0x01	; 1
     c12:	59 f4       	brne	.+22     	; 0xc2a <receive_uart+0x1ac>
     c14:	69 e9       	ldi	r22, 0x99	; 153
     c16:	71 e0       	ldi	r23, 0x01	; 1
     c18:	ce 01       	movw	r24, r28
     c1a:	01 96       	adiw	r24, 0x01	; 1
     c1c:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     c20:	89 2b       	or	r24, r25
     c22:	19 f4       	brne	.+6      	; 0xc2a <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     c24:	81 e0       	ldi	r24, 0x01	; 1
     c26:	f6 01       	movw	r30, r12
     c28:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c2a:	d6 01       	movw	r26, r12
     c2c:	93 96       	adiw	r26, 0x23	; 35
     c2e:	8d 91       	ld	r24, X+
     c30:	9c 91       	ld	r25, X
     c32:	94 97       	sbiw	r26, 0x24	; 36
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	59 f4       	brne	.+22     	; 0xc4e <receive_uart+0x1d0>
     c38:	65 eb       	ldi	r22, 0xB5	; 181
     c3a:	71 e0       	ldi	r23, 0x01	; 1
     c3c:	ce 01       	movw	r24, r28
     c3e:	01 96       	adiw	r24, 0x01	; 1
     c40:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     c44:	89 2b       	or	r24, r25
     c46:	19 f4       	brne	.+6      	; 0xc4e <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c48:	82 e0       	ldi	r24, 0x02	; 2
     c4a:	f6 01       	movw	r30, r12
     c4c:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c4e:	d6 01       	movw	r26, r12
     c50:	93 96       	adiw	r26, 0x23	; 35
     c52:	8d 91       	ld	r24, X+
     c54:	9c 91       	ld	r25, X
     c56:	94 97       	sbiw	r26, 0x24	; 36
     c58:	89 2b       	or	r24, r25
     c5a:	59 f4       	brne	.+22     	; 0xc72 <receive_uart+0x1f4>
     c5c:	6b e9       	ldi	r22, 0x9B	; 155
     c5e:	71 e0       	ldi	r23, 0x01	; 1
     c60:	ce 01       	movw	r24, r28
     c62:	01 96       	adiw	r24, 0x01	; 1
     c64:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     c68:	89 2b       	or	r24, r25
     c6a:	19 f4       	brne	.+6      	; 0xc72 <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c6c:	80 e0       	ldi	r24, 0x00	; 0
     c6e:	90 e0       	ldi	r25, 0x00	; 0
     c70:	cd da       	rcall	.-2662   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c72:	f6 01       	movw	r30, r12
     c74:	83 a1       	ldd	r24, Z+35	; 0x23
     c76:	94 a1       	ldd	r25, Z+36	; 0x24
     c78:	89 2b       	or	r24, r25
     c7a:	59 f4       	brne	.+22     	; 0xc92 <receive_uart+0x214>
     c7c:	63 ea       	ldi	r22, 0xA3	; 163
     c7e:	71 e0       	ldi	r23, 0x01	; 1
     c80:	ce 01       	movw	r24, r28
     c82:	01 96       	adiw	r24, 0x01	; 1
     c84:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     c88:	89 2b       	or	r24, r25
     c8a:	19 f4       	brne	.+6      	; 0xc92 <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	bd da       	rcall	.-2694   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c92:	d6 01       	movw	r26, r12
     c94:	93 96       	adiw	r26, 0x23	; 35
     c96:	8d 91       	ld	r24, X+
     c98:	9c 91       	ld	r25, X
     c9a:	94 97       	sbiw	r26, 0x24	; 36
     c9c:	89 2b       	or	r24, r25
     c9e:	a9 f4       	brne	.+42     	; 0xcca <receive_uart+0x24c>
     ca0:	69 ea       	ldi	r22, 0xA9	; 169
     ca2:	71 e0       	ldi	r23, 0x01	; 1
     ca4:	ce 01       	movw	r24, r28
     ca6:	01 96       	adiw	r24, 0x01	; 1
     ca8:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     cac:	89 2b       	or	r24, r25
     cae:	69 f4       	brne	.+26     	; 0xcca <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     cb0:	f6 01       	movw	r30, r12
     cb2:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cb4:	e0 ac       	ldd	r14, Z+56	; 0x38
     cb6:	f1 ac       	ldd	r15, Z+57	; 0x39
     cb8:	06 a9       	ldd	r16, Z+54	; 0x36
     cba:	17 a9       	ldd	r17, Z+55	; 0x37
     cbc:	24 a9       	ldd	r18, Z+52	; 0x34
     cbe:	35 a9       	ldd	r19, Z+53	; 0x35
     cc0:	42 a9       	ldd	r20, Z+50	; 0x32
     cc2:	53 a9       	ldd	r21, Z+51	; 0x33
     cc4:	62 ad       	ldd	r22, Z+58	; 0x3a
     cc6:	83 ad       	ldd	r24, Z+59	; 0x3b
     cc8:	6e da       	rcall	.-2852   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     cca:	d6 01       	movw	r26, r12
     ccc:	93 96       	adiw	r26, 0x23	; 35
     cce:	8d 91       	ld	r24, X+
     cd0:	9c 91       	ld	r25, X
     cd2:	94 97       	sbiw	r26, 0x24	; 36
     cd4:	89 2b       	or	r24, r25
     cd6:	b1 f4       	brne	.+44     	; 0xd04 <receive_uart+0x286>
     cd8:	67 eb       	ldi	r22, 0xB7	; 183
     cda:	71 e0       	ldi	r23, 0x01	; 1
     cdc:	ce 01       	movw	r24, r28
     cde:	01 96       	adiw	r24, 0x01	; 1
     ce0:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     ce4:	89 2b       	or	r24, r25
     ce6:	71 f4       	brne	.+28     	; 0xd04 <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	f6 01       	movw	r30, r12
     cec:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cee:	e0 ac       	ldd	r14, Z+56	; 0x38
     cf0:	f1 ac       	ldd	r15, Z+57	; 0x39
     cf2:	06 a9       	ldd	r16, Z+54	; 0x36
     cf4:	17 a9       	ldd	r17, Z+55	; 0x37
     cf6:	24 a9       	ldd	r18, Z+52	; 0x34
     cf8:	35 a9       	ldd	r19, Z+53	; 0x35
     cfa:	42 a9       	ldd	r20, Z+50	; 0x32
     cfc:	53 a9       	ldd	r21, Z+51	; 0x33
     cfe:	62 ad       	ldd	r22, Z+58	; 0x3a
     d00:	83 ad       	ldd	r24, Z+59	; 0x3b
     d02:	51 da       	rcall	.-2910   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     d04:	d6 01       	movw	r26, r12
     d06:	93 96       	adiw	r26, 0x23	; 35
     d08:	8d 91       	ld	r24, X+
     d0a:	9c 91       	ld	r25, X
     d0c:	94 97       	sbiw	r26, 0x24	; 36
     d0e:	89 2b       	or	r24, r25
     d10:	b1 f4       	brne	.+44     	; 0xd3e <receive_uart+0x2c0>
     d12:	67 ec       	ldi	r22, 0xC7	; 199
     d14:	71 e0       	ldi	r23, 0x01	; 1
     d16:	ce 01       	movw	r24, r28
     d18:	01 96       	adiw	r24, 0x01	; 1
     d1a:	0e 94 c6 13 	call	0x278c	; 0x278c <strcmp>
     d1e:	89 2b       	or	r24, r25
     d20:	71 f4       	brne	.+28     	; 0xd3e <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     d22:	82 e0       	ldi	r24, 0x02	; 2
     d24:	f6 01       	movw	r30, r12
     d26:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d28:	e0 ac       	ldd	r14, Z+56	; 0x38
     d2a:	f1 ac       	ldd	r15, Z+57	; 0x39
     d2c:	06 a9       	ldd	r16, Z+54	; 0x36
     d2e:	17 a9       	ldd	r17, Z+55	; 0x37
     d30:	24 a9       	ldd	r18, Z+52	; 0x34
     d32:	35 a9       	ldd	r19, Z+53	; 0x35
     d34:	42 a9       	ldd	r20, Z+50	; 0x32
     d36:	53 a9       	ldd	r21, Z+51	; 0x33
     d38:	62 ad       	ldd	r22, Z+58	; 0x3a
     d3a:	83 ad       	ldd	r24, Z+59	; 0x3b
     d3c:	34 da       	rcall	.-2968   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d3e:	d6 01       	movw	r26, r12
     d40:	93 96       	adiw	r26, 0x23	; 35
     d42:	8d 91       	ld	r24, X+
     d44:	9c 91       	ld	r25, X
     d46:	94 97       	sbiw	r26, 0x24	; 36
     d48:	89 2b       	or	r24, r25
     d4a:	41 f4       	brne	.+16     	; 0xd5c <receive_uart+0x2de>
     d4c:	c5 01       	movw	r24, r10
     d4e:	01 97       	sbiw	r24, 0x01	; 1
     d50:	87 3e       	cpi	r24, 0xE7	; 231
     d52:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d54:	18 f4       	brcc	.+6      	; 0xd5c <receive_uart+0x2de>
     d56:	f6 01       	movw	r30, r12
     d58:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d5a:	a2 aa       	std	Z+50, r10	; 0x32
     d5c:	78 d3       	rcall	.+1776   	; 0x144e <uart0_flush>
	}
}
     d5e:	66 96       	adiw	r28, 0x16	; 22
     d60:	0f b6       	in	r0, 0x3f	; 63
     d62:	f8 94       	cli
     d64:	de bf       	out	0x3e, r29	; 62
     d66:	0f be       	out	0x3f, r0	; 63
     d68:	cd bf       	out	0x3d, r28	; 61
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	1f 91       	pop	r17
     d70:	0f 91       	pop	r16
     d72:	ff 90       	pop	r15
     d74:	ef 90       	pop	r14
     d76:	df 90       	pop	r13
     d78:	cf 90       	pop	r12
     d7a:	bf 90       	pop	r11
     d7c:	af 90       	pop	r10
     d7e:	08 95       	ret

00000d80 <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d80:	ef 92       	push	r14
     d82:	ff 92       	push	r15
     d84:	0f 93       	push	r16
     d86:	1f 93       	push	r17
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d90:	88 ed       	ldi	r24, 0xD8	; 216
     d92:	91 e0       	ldi	r25, 0x01	; 1
     d94:	0e 94 ef 13 	call	0x27de	; 0x27de <puts>
	printf("%i", (int16_t)vals.actuator_in_position);
     d98:	8e a5       	ldd	r24, Y+46	; 0x2e
     d9a:	9f a5       	ldd	r25, Y+47	; 0x2f
     d9c:	9f 93       	push	r25
     d9e:	8f 93       	push	r24
     da0:	0f 2e       	mov	r0, r31
     da2:	fa ed       	ldi	r31, 0xDA	; 218
     da4:	ef 2e       	mov	r14, r31
     da6:	f1 e0       	ldi	r31, 0x01	; 1
     da8:	ff 2e       	mov	r15, r31
     daa:	f0 2d       	mov	r31, r0
     dac:	ff 92       	push	r15
     dae:	ef 92       	push	r14
     db0:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     db4:	8c e2       	ldi	r24, 0x2C	; 44
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u", vals.gear_required);
     dbc:	25 96       	adiw	r28, 0x05	; 5
     dbe:	8f ad       	ldd	r24, Y+63	; 0x3f
     dc0:	25 97       	sbiw	r28, 0x05	; 5
     dc2:	1f 92       	push	r1
     dc4:	8f 93       	push	r24
     dc6:	0d ed       	ldi	r16, 0xDD	; 221
     dc8:	11 e0       	ldi	r17, 0x01	; 1
     dca:	1f 93       	push	r17
     dcc:	0f 93       	push	r16
     dce:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     dd2:	8c e2       	ldi	r24, 0x2C	; 44
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.gear_status);
     dda:	24 96       	adiw	r28, 0x04	; 4
     ddc:	8f ad       	ldd	r24, Y+63	; 0x3f
     dde:	24 97       	sbiw	r28, 0x04	; 4
     de0:	1f 92       	push	r1
     de2:	8f 93       	push	r24
     de4:	1f 93       	push	r17
     de6:	0f 93       	push	r16
     de8:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     dec:	8c e2       	ldi	r24, 0x2C	; 44
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u", vals.motor_status);
     df4:	8f a1       	ldd	r24, Y+39	; 0x27
     df6:	1f 92       	push	r1
     df8:	8f 93       	push	r24
     dfa:	1f 93       	push	r17
     dfc:	0f 93       	push	r16
     dfe:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e02:	8c e2       	ldi	r24, 0x2C	; 44
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.message_mode);
     e0a:	88 a5       	ldd	r24, Y+40	; 0x28
     e0c:	1f 92       	push	r1
     e0e:	8f 93       	push	r24
     e10:	1f 93       	push	r17
     e12:	0f 93       	push	r16
     e14:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e18:	8c e2       	ldi	r24, 0x2C	; 44
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.u8_duty_cycle);
     e20:	8a a1       	ldd	r24, Y+34	; 0x22
     e22:	1f 92       	push	r1
     e24:	8f 93       	push	r24
     e26:	1f 93       	push	r17
     e28:	0f 93       	push	r16
     e2a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e2e:	8c e2       	ldi	r24, 0x2C	; 44
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e36:	6b 89       	ldd	r22, Y+19	; 0x13
     e38:	7c 89       	ldd	r23, Y+20	; 0x14
     e3a:	8d 89       	ldd	r24, Y+21	; 0x15
     e3c:	9e 89       	ldd	r25, Y+22	; 0x16
     e3e:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     e42:	7f 93       	push	r23
     e44:	6f 93       	push	r22
     e46:	ff 92       	push	r15
     e48:	ef 92       	push	r14
     e4a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e4e:	8c e2       	ldi	r24, 0x2C	; 44
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e56:	6c a9       	ldd	r22, Y+52	; 0x34
     e58:	7d a9       	ldd	r23, Y+53	; 0x35
     e5a:	8e a9       	ldd	r24, Y+54	; 0x36
     e5c:	9f a9       	ldd	r25, Y+55	; 0x37
     e5e:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     e62:	7f 93       	push	r23
     e64:	6f 93       	push	r22
     e66:	ff 92       	push	r15
     e68:	ef 92       	push	r14
     e6a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e6e:	0f b6       	in	r0, 0x3f	; 63
     e70:	f8 94       	cli
     e72:	de bf       	out	0x3e, r29	; 62
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	cd bf       	out	0x3d, r28	; 61
     e78:	8c e2       	ldi	r24, 0x2C	; 44
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e80:	89 85       	ldd	r24, Y+9	; 0x09
     e82:	9a 85       	ldd	r25, Y+10	; 0x0a
     e84:	9f 93       	push	r25
     e86:	8f 93       	push	r24
     e88:	ff 92       	push	r15
     e8a:	ef 92       	push	r14
     e8c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     e90:	8c e2       	ldi	r24, 0x2C	; 44
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%i",vals.clutch_enabled);
     e98:	8c a5       	ldd	r24, Y+44	; 0x2c
     e9a:	9d a5       	ldd	r25, Y+45	; 0x2d
     e9c:	9f 93       	push	r25
     e9e:	8f 93       	push	r24
     ea0:	ff 92       	push	r15
     ea2:	ef 92       	push	r14
     ea4:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     ea8:	8c e2       	ldi	r24, 0x2C	; 44
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.position_neutral);
     eb0:	8d ad       	ldd	r24, Y+61	; 0x3d
     eb2:	9e ad       	ldd	r25, Y+62	; 0x3e
     eb4:	9f 93       	push	r25
     eb6:	8f 93       	push	r24
     eb8:	1f 93       	push	r17
     eba:	0f 93       	push	r16
     ebc:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     ec0:	8c e2       	ldi	r24, 0x2C	; 44
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.position_gear_1);
     ec8:	21 96       	adiw	r28, 0x01	; 1
     eca:	8e ad       	ldd	r24, Y+62	; 0x3e
     ecc:	9f ad       	ldd	r25, Y+63	; 0x3f
     ece:	21 97       	sbiw	r28, 0x01	; 1
     ed0:	9f 93       	push	r25
     ed2:	8f 93       	push	r24
     ed4:	1f 93       	push	r17
     ed6:	0f 93       	push	r16
     ed8:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     edc:	8c e2       	ldi	r24, 0x2C	; 44
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%u",vals.position_gear_2);	
     ee4:	23 96       	adiw	r28, 0x03	; 3
     ee6:	8e ad       	ldd	r24, Y+62	; 0x3e
     ee8:	9f ad       	ldd	r25, Y+63	; 0x3f
     eea:	23 97       	sbiw	r28, 0x03	; 3
     eec:	9f 93       	push	r25
     eee:	8f 93       	push	r24
     ef0:	1f 93       	push	r17
     ef2:	0f 93       	push	r16
     ef4:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     ef8:	8c e2       	ldi	r24, 0x2C	; 44
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     f00:	88 ad       	ldd	r24, Y+56	; 0x38
     f02:	1f 92       	push	r1
     f04:	8f 93       	push	r24
     f06:	ff 92       	push	r15
     f08:	ef 92       	push	r14
     f0a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	printf(",");
     f0e:	8c e2       	ldi	r24, 0x2C	; 44
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     f16:	68 a9       	ldd	r22, Y+48	; 0x30
     f18:	79 a9       	ldd	r23, Y+49	; 0x31
     f1a:	8a a9       	ldd	r24, Y+50	; 0x32
     f1c:	9b a9       	ldd	r25, Y+51	; 0x33
     f1e:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
     f22:	7f 93       	push	r23
     f24:	6f 93       	push	r22
     f26:	ff 92       	push	r15
     f28:	ef 92       	push	r14
     f2a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <printf>
	
}
     f2e:	0f b6       	in	r0, 0x3f	; 63
     f30:	f8 94       	cli
     f32:	de bf       	out	0x3e, r29	; 62
     f34:	0f be       	out	0x3f, r0	; 63
     f36:	cd bf       	out	0x3d, r28	; 61
     f38:	df 91       	pop	r29
     f3a:	cf 91       	pop	r28
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	ff 90       	pop	r15
     f42:	ef 90       	pop	r14
     f44:	08 95       	ret

00000f46 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f46:	cf 93       	push	r28
     f48:	df 93       	push	r29
     f4a:	cd b7       	in	r28, 0x3d	; 61
     f4c:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f4e:	8b a1       	ldd	r24, Y+35	; 0x23
     f50:	82 30       	cpi	r24, 0x02	; 2
     f52:	91 f1       	breq	.+100    	; 0xfb8 <manage_LEDs+0x72>
     f54:	28 f4       	brcc	.+10     	; 0xf60 <manage_LEDs+0x1a>
     f56:	88 23       	and	r24, r24
     f58:	49 f0       	breq	.+18     	; 0xf6c <manage_LEDs+0x26>
     f5a:	81 30       	cpi	r24, 0x01	; 1
     f5c:	19 f1       	breq	.+70     	; 0xfa4 <manage_LEDs+0x5e>
     f5e:	49 c0       	rjmp	.+146    	; 0xff2 <manage_LEDs+0xac>
     f60:	84 30       	cpi	r24, 0x04	; 4
     f62:	f1 f1       	breq	.+124    	; 0xfe0 <manage_LEDs+0x9a>
     f64:	98 f1       	brcs	.+102    	; 0xfcc <manage_LEDs+0x86>
     f66:	85 30       	cpi	r24, 0x05	; 5
     f68:	99 f0       	breq	.+38     	; 0xf90 <manage_LEDs+0x4a>
     f6a:	43 c0       	rjmp	.+134    	; 0xff2 <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f6c:	80 e4       	ldi	r24, 0x40	; 64
     f6e:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f72:	80 e8       	ldi	r24, 0x80	; 128
     f74:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f78:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f7a:	98 a1       	ldd	r25, Y+32	; 0x20
     f7c:	89 2b       	or	r24, r25
     f7e:	21 f4       	brne	.+8      	; 0xf88 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f80:	80 e2       	ldi	r24, 0x20	; 32
     f82:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
     f86:	35 c0       	rjmp	.+106    	; 0xff2 <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f88:	80 e2       	ldi	r24, 0x20	; 32
     f8a:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
     f8e:	31 c0       	rjmp	.+98     	; 0xff2 <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f90:	80 e2       	ldi	r24, 0x20	; 32
     f92:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f96:	80 e4       	ldi	r24, 0x40	; 64
     f98:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     f9c:	80 e8       	ldi	r24, 0x80	; 128
     f9e:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
		break ;
     fa2:	27 c0       	rjmp	.+78     	; 0xff2 <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     fa4:	80 e2       	ldi	r24, 0x20	; 32
     fa6:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     faa:	80 e8       	ldi	r24, 0x80	; 128
     fac:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fb0:	80 e4       	ldi	r24, 0x40	; 64
     fb2:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_toggle>
		break;
     fb6:	1d c0       	rjmp	.+58     	; 0xff2 <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     fb8:	80 e8       	ldi	r24, 0x80	; 128
     fba:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fbe:	80 e4       	ldi	r24, 0x40	; 64
     fc0:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_toggle>
			rgbled_toggle(LED_RED);
     fc4:	80 e2       	ldi	r24, 0x20	; 32
     fc6:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_toggle>
		break;
     fca:	13 c0       	rjmp	.+38     	; 0xff2 <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     fcc:	80 e2       	ldi	r24, 0x20	; 32
     fce:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fd2:	80 e8       	ldi	r24, 0x80	; 128
     fd4:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fd8:	80 e4       	ldi	r24, 0x40	; 64
     fda:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
		break;
     fde:	09 c0       	rjmp	.+18     	; 0xff2 <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     fe0:	80 e4       	ldi	r24, 0x40	; 64
     fe2:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fe6:	80 e8       	ldi	r24, 0x80	; 128
     fe8:	0e 94 01 11 	call	0x2202	; 0x2202 <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     fec:	80 e2       	ldi	r24, 0x20	; 32
     fee:	0e 94 0b 11 	call	0x2216	; 0x2216 <rgbled_turn_on>
		break;
	}
     ff2:	df 91       	pop	r29
     ff4:	cf 91       	pop	r28
     ff6:	08 95       	ret

00000ff8 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     ff8:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     ffa:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     ffc:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     ffe:	e9 e6       	ldi	r30, 0x69	; 105
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	80 81       	ld	r24, Z
    1004:	84 60       	ori	r24, 0x04	; 4
    1006:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
    1008:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
    100a:	e9 9a       	sbi	0x1d, 1	; 29
    100c:	08 95       	ret

0000100e <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
    100e:	0f 93       	push	r16
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
	
	if (*u16_counter > 70)
    1016:	fb 01       	movw	r30, r22
    1018:	20 81       	ld	r18, Z
    101a:	31 81       	ldd	r19, Z+1	; 0x01
    101c:	27 34       	cpi	r18, 0x47	; 71
    101e:	31 05       	cpc	r19, r1
    1020:	b8 f0       	brcs	.+46     	; 0x1050 <handle_speed_sensor+0x42>
    1022:	eb 01       	movw	r28, r22
    1024:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    1026:	60 81       	ld	r22, Z
    1028:	71 81       	ldd	r23, Z+1	; 0x01
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
    1032:	9b 01       	movw	r18, r22
    1034:	ac 01       	movw	r20, r24
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	76 e7       	ldi	r23, 0x76	; 118
    103a:	88 e8       	ldi	r24, 0x88	; 136
    103c:	96 e4       	ldi	r25, 0x46	; 70
    103e:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
    1042:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
    1046:	f8 01       	movw	r30, r16
    1048:	71 83       	std	Z+1, r23	; 0x01
    104a:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    104c:	19 82       	std	Y+1, r1	; 0x01
    104e:	18 82       	st	Y, r1
	}	
}
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	1f 91       	pop	r17
    1056:	0f 91       	pop	r16
    1058:	08 95       	ret

0000105a <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    105a:	cf 92       	push	r12
    105c:	df 92       	push	r13
    105e:	ef 92       	push	r14
    1060:	ff 92       	push	r15
    1062:	cf 93       	push	r28
    1064:	df 93       	push	r29
    1066:	1f 92       	push	r1
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
    106c:	89 83       	std	Y+1, r24	; 0x01
    106e:	69 01       	movw	r12, r18
    1070:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    1072:	61 30       	cpi	r22, 0x01	; 1
    1074:	19 f5       	brne	.+70     	; 0x10bc <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    1076:	69 81       	ldd	r22, Y+1	; 0x01
    1078:	70 e0       	ldi	r23, 0x00	; 0
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
    1082:	22 e1       	ldi	r18, 0x12	; 18
    1084:	35 e8       	ldi	r19, 0x85	; 133
    1086:	41 e6       	ldi	r20, 0x61	; 97
    1088:	5e e3       	ldi	r21, 0x3E	; 62
    108a:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    108e:	a7 01       	movw	r20, r14
    1090:	96 01       	movw	r18, r12
    1092:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
    1096:	20 e0       	ldi	r18, 0x00	; 0
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	48 ec       	ldi	r20, 0xC8	; 200
    109c:	52 e4       	ldi	r21, 0x42	; 66
    109e:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    10a2:	20 e0       	ldi	r18, 0x00	; 0
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	48 e4       	ldi	r20, 0x48	; 72
    10a8:	52 e4       	ldi	r21, 0x42	; 66
    10aa:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
    10ae:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
    10b2:	86 2f       	mov	r24, r22
		if (Duty == 50)
    10b4:	62 33       	cpi	r22, 0x32	; 50
    10b6:	29 f5       	brne	.+74     	; 0x1102 <__stack+0x3>
		{
			Duty = 52 ;
    10b8:	84 e3       	ldi	r24, 0x34	; 52
    10ba:	23 c0       	rjmp	.+70     	; 0x1102 <__stack+0x3>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    10bc:	62 30       	cpi	r22, 0x02	; 2
    10be:	01 f5       	brne	.+64     	; 0x1100 <__stack+0x1>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    10c0:	69 81       	ldd	r22, Y+1	; 0x01
    10c2:	70 e0       	ldi	r23, 0x00	; 0
    10c4:	80 e0       	ldi	r24, 0x00	; 0
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	0e 94 89 12 	call	0x2512	; 0x2512 <__floatsisf>
    10cc:	23 ee       	ldi	r18, 0xE3	; 227
    10ce:	3e ee       	ldi	r19, 0xEE	; 238
    10d0:	4b e3       	ldi	r20, 0x3B	; 59
    10d2:	5e e3       	ldi	r21, 0x3E	; 62
    10d4:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    10d8:	a7 01       	movw	r20, r14
    10da:	96 01       	movw	r18, r12
    10dc:	0e 94 ee 11 	call	0x23dc	; 0x23dc <__divsf3>
    10e0:	20 e0       	ldi	r18, 0x00	; 0
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	48 ec       	ldi	r20, 0xC8	; 200
    10e6:	52 e4       	ldi	r21, 0x42	; 66
    10e8:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    10ec:	20 e0       	ldi	r18, 0x00	; 0
    10ee:	30 e0       	ldi	r19, 0x00	; 0
    10f0:	48 e4       	ldi	r20, 0x48	; 72
    10f2:	52 e4       	ldi	r21, 0x42	; 66
    10f4:	0e 94 86 11 	call	0x230c	; 0x230c <__addsf3>
    10f8:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixunssfsi>
    10fc:	86 2f       	mov	r24, r22
    10fe:	01 c0       	rjmp	.+2      	; 0x1102 <__stack+0x3>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    1100:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    1102:	0f 90       	pop	r0
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	ff 90       	pop	r15
    110a:	ef 90       	pop	r14
    110c:	df 90       	pop	r13
    110e:	cf 90       	pop	r12
    1110:	08 95       	ret

00001112 <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    1118:	8f 8d       	ldd	r24, Y+31	; 0x1f
    111a:	81 11       	cpse	r24, r1
    111c:	08 c0       	rjmp	.+16     	; 0x112e <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    111e:	82 e3       	ldi	r24, 0x32	; 50
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	9b 8f       	std	Y+27, r25	; 0x1b
    1124:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    1126:	8e e1       	ldi	r24, 0x1E	; 30
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	9d 8f       	std	Y+29, r25	; 0x1d
    112c:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    112e:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    1132:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    1136:	00 97       	sbiw	r24, 0x00	; 0
    1138:	31 f0       	breq	.+12     	; 0x1146 <state_handler+0x34>
	{
		fault_timeout -- ;
    113a:	01 97       	sbiw	r24, 0x01	; 1
    113c:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    1140:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    1144:	05 c0       	rjmp	.+10     	; 0x1150 <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    1146:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    114a:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    114c:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    1150:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1152:	82 30       	cpi	r24, 0x02	; 2
    1154:	09 f4       	brne	.+2      	; 0x1158 <state_handler+0x46>
    1156:	b7 c0       	rjmp	.+366    	; 0x12c6 <state_handler+0x1b4>
    1158:	30 f4       	brcc	.+12     	; 0x1166 <state_handler+0x54>
    115a:	88 23       	and	r24, r24
    115c:	61 f0       	breq	.+24     	; 0x1176 <state_handler+0x64>
    115e:	81 30       	cpi	r24, 0x01	; 1
    1160:	09 f4       	brne	.+2      	; 0x1164 <state_handler+0x52>
    1162:	8f c0       	rjmp	.+286    	; 0x1282 <state_handler+0x170>
    1164:	e1 c0       	rjmp	.+450    	; 0x1328 <state_handler+0x216>
    1166:	84 30       	cpi	r24, 0x04	; 4
    1168:	09 f4       	brne	.+2      	; 0x116c <state_handler+0x5a>
    116a:	cf c0       	rjmp	.+414    	; 0x130a <state_handler+0x1f8>
    116c:	a0 f0       	brcs	.+40     	; 0x1196 <state_handler+0x84>
    116e:	85 30       	cpi	r24, 0x05	; 5
    1170:	09 f4       	brne	.+2      	; 0x1174 <state_handler+0x62>
    1172:	51 c0       	rjmp	.+162    	; 0x1216 <state_handler+0x104>
    1174:	d9 c0       	rjmp	.+434    	; 0x1328 <state_handler+0x216>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    1176:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1178:	9b 8d       	ldd	r25, Y+27	; 0x1b
    117a:	89 2b       	or	r24, r25
    117c:	11 f0       	breq	.+4      	; 0x1182 <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    117e:	83 e0       	ldi	r24, 0x03	; 3
    1180:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	a5 da       	rcall	.-2742   	; 0x6d0 <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    1186:	18 a2       	std	Y+32, r1	; 0x20
    1188:	30 d9       	rcall	.-3488   	; 0x3ea <reset_I>
			vals->u8_brake_cmd = 0;
    118a:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    118c:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    118e:	82 e3       	ldi	r24, 0x32	; 50
    1190:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    1192:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    1194:	c9 c0       	rjmp	.+402    	; 0x1328 <state_handler+0x216>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    1196:	8a a1       	ldd	r24, Y+34	; 0x22
    1198:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    119a:	24 c0       	rjmp	.+72     	; 0x11e4 <state_handler+0xd2>
    119c:	99 da       	rcall	.-2766   	; 0x6d0 <drivers>
				reset_I();
    119e:	25 d9       	rcall	.-3510   	; 0x3ea <reset_I>
    11a0:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    11a2:	89 8f       	std	Y+25, r24	; 0x19
    11a4:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    11a6:	88 23       	and	r24, r24
    11a8:	69 f0       	breq	.+26     	; 0x11c4 <state_handler+0xb2>
    11aa:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11ac:	3b 85       	ldd	r19, Y+11	; 0x0b
    11ae:	4c 85       	ldd	r20, Y+12	; 0x0c
    11b0:	5d 85       	ldd	r21, Y+13	; 0x0d
    11b2:	8b 89       	ldd	r24, Y+19	; 0x13
    11b4:	9c 89       	ldd	r25, Y+20	; 0x14
    11b6:	62 e0       	ldi	r22, 0x02	; 2
    11b8:	50 df       	rcall	.-352    	; 0x105a <compute_synch_duty>
    11ba:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11bc:	89 8d       	ldd	r24, Y+25	; 0x19
    11be:	1e d9       	rcall	.-3524   	; 0x3fc <set_I>
    11c0:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    11c2:	8e 8f       	std	Y+30, r24	; 0x1e
    11c4:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11c6:	88 23       	and	r24, r24
    11c8:	69 f0       	breq	.+26     	; 0x11e4 <state_handler+0xd2>
    11ca:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11cc:	3b 85       	ldd	r19, Y+11	; 0x0b
    11ce:	4c 85       	ldd	r20, Y+12	; 0x0c
    11d0:	5d 85       	ldd	r21, Y+13	; 0x0d
    11d2:	8b 89       	ldd	r24, Y+19	; 0x13
    11d4:	9c 89       	ldd	r25, Y+20	; 0x14
    11d6:	62 e0       	ldi	r22, 0x02	; 2
    11d8:	40 df       	rcall	.-384    	; 0x105a <compute_synch_duty>
    11da:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11dc:	89 8d       	ldd	r24, Y+25	; 0x19
    11de:	0e d9       	rcall	.-3556   	; 0x3fc <set_I>
    11e0:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    11e2:	8e 8f       	std	Y+30, r24	; 0x1e
    11e4:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    11e6:	81 30       	cpi	r24, 0x01	; 1
    11e8:	09 f0       	breq	.+2      	; 0x11ec <state_handler+0xda>
    11ea:	9e c0       	rjmp	.+316    	; 0x1328 <state_handler+0x216>
    11ec:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    11ee:	81 11       	cpse	r24, r1
    11f0:	03 c0       	rjmp	.+6      	; 0x11f8 <state_handler+0xe6>
    11f2:	88 8d       	ldd	r24, Y+24	; 0x18
    11f4:	88 23       	and	r24, r24
    11f6:	41 f0       	breq	.+16     	; 0x1208 <state_handler+0xf6>
    11f8:	8a ad       	ldd	r24, Y+58	; 0x3a
    11fa:	81 11       	cpse	r24, r1
    11fc:	05 c0       	rjmp	.+10     	; 0x1208 <state_handler+0xf6>
				{
					vals->motor_status = ENGAGE;
    11fe:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    1200:	8e 8f       	std	Y+30, r24	; 0x1e
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	62 da       	rcall	.-2876   	; 0x6d0 <drivers>
				vals->gear_required = NEUTRAL ;
    120c:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    120e:	ed d8       	rcall	.-3622   	; 0x3ea <reset_I>
    1210:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1212:	89 8f       	std	Y+25, r24	; 0x19
    1214:	89 c0       	rjmp	.+274    	; 0x1328 <state_handler+0x216>
    1216:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    1218:	8b af       	std	Y+59, r24	; 0x3b
    121a:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    121e:	88 23       	and	r24, r24
    1220:	69 f0       	breq	.+26     	; 0x123c <state_handler+0x12a>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    1222:	2a 85       	ldd	r18, Y+10	; 0x0a
    1224:	3b 85       	ldd	r19, Y+11	; 0x0b
    1226:	4c 85       	ldd	r20, Y+12	; 0x0c
    1228:	5d 85       	ldd	r21, Y+13	; 0x0d
    122a:	6b ad       	ldd	r22, Y+59	; 0x3b
    122c:	8b 89       	ldd	r24, Y+19	; 0x13
    122e:	9c 89       	ldd	r25, Y+20	; 0x14
    1230:	14 df       	rcall	.-472    	; 0x105a <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    1232:	89 8f       	std	Y+25, r24	; 0x19
    1234:	89 8d       	ldd	r24, Y+25	; 0x19
    1236:	e2 d8       	rcall	.-3644   	; 0x3fc <set_I>
				starting_engage = 0;
    1238:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    1240:	ce 01       	movw	r24, r28
    1242:	f7 d8       	rcall	.-3602   	; 0x432 <controller>
    1244:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1246:	44 da       	rcall	.-2936   	; 0x6d0 <drivers>
    1248:	88 8d       	ldd	r24, Y+24	; 0x18
    124a:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    124c:	29 f0       	breq	.+10     	; 0x1258 <state_handler+0x146>
    124e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1250:	81 30       	cpi	r24, 0x01	; 1
    1252:	11 f4       	brne	.+4      	; 0x1258 <state_handler+0x146>
    1254:	82 e0       	ldi	r24, 0x02	; 2
    1256:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    1258:	8f 89       	ldd	r24, Y+23	; 0x17
    125a:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    125c:	21 f0       	breq	.+8      	; 0x1266 <state_handler+0x154>
    125e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1260:	81 30       	cpi	r24, 0x01	; 1
    1262:	09 f4       	brne	.+2      	; 0x1266 <state_handler+0x154>
    1264:	8e 8f       	std	Y+30, r24	; 0x1e
    1266:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    1268:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    126a:	5e c0       	rjmp	.+188    	; 0x1328 <state_handler+0x216>
    126c:	88 8d       	ldd	r24, Y+24	; 0x18
    126e:	81 11       	cpse	r24, r1
    1270:	5b c0       	rjmp	.+182    	; 0x1328 <state_handler+0x216>
    1272:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1274:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1276:	89 2b       	or	r24, r25
    1278:	09 f0       	breq	.+2      	; 0x127c <state_handler+0x16a>
    127a:	56 c0       	rjmp	.+172    	; 0x1328 <state_handler+0x216>
			{
				vals->motor_status = IDLE;
    127c:	83 e0       	ldi	r24, 0x03	; 3
    127e:	8e 8f       	std	Y+30, r24	; 0x1e
    1280:	53 c0       	rjmp	.+166    	; 0x1328 <state_handler+0x216>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    1282:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    1284:	ce 01       	movw	r24, r28
    1286:	d5 d8       	rcall	.-3670   	; 0x432 <controller>
    1288:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    128a:	22 da       	rcall	.-3004   	; 0x6d0 <drivers>
    128c:	8f 89       	ldd	r24, Y+23	; 0x17
    128e:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1290:	06 c0       	rjmp	.+12     	; 0x129e <state_handler+0x18c>
    1292:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1294:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1296:	89 2b       	or	r24, r25
    1298:	11 f4       	brne	.+4      	; 0x129e <state_handler+0x18c>
    129a:	83 e0       	ldi	r24, 0x03	; 3
    129c:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    129e:	8a a1       	ldd	r24, Y+34	; 0x22
    12a0:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12a2:	41 f4       	brne	.+16     	; 0x12b4 <state_handler+0x1a2>
    12a4:	8a ad       	ldd	r24, Y+58	; 0x3a
    12a6:	81 11       	cpse	r24, r1
    12a8:	05 c0       	rjmp	.+10     	; 0x12b4 <state_handler+0x1a2>
    12aa:	85 e0       	ldi	r24, 0x05	; 5
    12ac:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12ae:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    12b0:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    12b4:	88 8d       	ldd	r24, Y+24	; 0x18
    12b6:	88 23       	and	r24, r24
    12b8:	b9 f1       	breq	.+110    	; 0x1328 <state_handler+0x216>
    12ba:	8f 89       	ldd	r24, Y+23	; 0x17
    12bc:	81 11       	cpse	r24, r1
    12be:	34 c0       	rjmp	.+104    	; 0x1328 <state_handler+0x216>
			{
				vals->motor_status = BRAKE;
    12c0:	82 e0       	ldi	r24, 0x02	; 2
    12c2:	8e 8f       	std	Y+30, r24	; 0x1e
    12c4:	31 c0       	rjmp	.+98     	; 0x1328 <state_handler+0x216>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12c6:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12c8:	ce 01       	movw	r24, r28
    12ca:	b3 d8       	rcall	.-3738   	; 0x432 <controller>
    12cc:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12ce:	00 da       	rcall	.-3072   	; 0x6d0 <drivers>
    12d0:	88 8d       	ldd	r24, Y+24	; 0x18
    12d2:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12d4:	06 c0       	rjmp	.+12     	; 0x12e2 <state_handler+0x1d0>
    12d6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12d8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12da:	89 2b       	or	r24, r25
    12dc:	11 f4       	brne	.+4      	; 0x12e2 <state_handler+0x1d0>
    12de:	83 e0       	ldi	r24, 0x03	; 3
    12e0:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12e2:	8a a1       	ldd	r24, Y+34	; 0x22
    12e4:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12e6:	41 f4       	brne	.+16     	; 0x12f8 <state_handler+0x1e6>
    12e8:	8a ad       	ldd	r24, Y+58	; 0x3a
    12ea:	81 11       	cpse	r24, r1
    12ec:	05 c0       	rjmp	.+10     	; 0x12f8 <state_handler+0x1e6>
    12ee:	85 e0       	ldi	r24, 0x05	; 5
    12f0:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    12f8:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    12fa:	81 11       	cpse	r24, r1
    12fc:	15 c0       	rjmp	.+42     	; 0x1328 <state_handler+0x216>
    12fe:	8f 89       	ldd	r24, Y+23	; 0x17
    1300:	88 23       	and	r24, r24
    1302:	91 f0       	breq	.+36     	; 0x1328 <state_handler+0x216>
			{
				vals->motor_status = ACCEL;
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	8e 8f       	std	Y+30, r24	; 0x1e
    1308:	0f c0       	rjmp	.+30     	; 0x1328 <state_handler+0x216>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    130a:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    130e:	81 11       	cpse	r24, r1
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <state_handler+0x204>
			{
				vals->motor_status = IDLE;
    1312:	83 e0       	ldi	r24, 0x03	; 3
    1314:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	db d9       	rcall	.-3146   	; 0x6d0 <drivers>
    131a:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    131c:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    131e:	65 d8       	rcall	.-3894   	; 0x3ea <reset_I>
			reset_I(); //reset integrator
    1320:	18 8e       	std	Y+24, r1	; 0x18
    1322:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    1324:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    1326:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    1328:	8e 8d       	ldd	r24, Y+30	; 0x1e
    132a:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    132c:	49 f0       	breq	.+18     	; 0x1340 <state_handler+0x22e>
    132e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1330:	81 30       	cpi	r24, 0x01	; 1
    1332:	31 f0       	breq	.+12     	; 0x1340 <state_handler+0x22e>
    1334:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1336:	82 30       	cpi	r24, 0x02	; 2
    1338:	19 f0       	breq	.+6      	; 0x1340 <state_handler+0x22e>
    133a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    133c:	85 30       	cpi	r24, 0x05	; 5
    133e:	29 f4       	brne	.+10     	; 0x134a <state_handler+0x238>
    1340:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1342:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1344:	89 2b       	or	r24, r25
    1346:	09 f4       	brne	.+2      	; 0x134a <state_handler+0x238>
    1348:	1e 8e       	std	Y+30, r1	; 0x1e
    134a:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    134c:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    134e:	08 95       	ret

00001350 <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    1350:	cf 93       	push	r28
    1352:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    1354:	8e b1       	in	r24, 0x0e	; 14
    1356:	87 7c       	andi	r24, 0xC7	; 199
    1358:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    135a:	8d b1       	in	r24, 0x0d	; 13
    135c:	88 63       	ori	r24, 0x38	; 56
    135e:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    1360:	a1 e9       	ldi	r26, 0x91	; 145
    1362:	b0 e0       	ldi	r27, 0x00	; 0
    1364:	8c 91       	ld	r24, X
    1366:	80 61       	ori	r24, 0x10	; 16
    1368:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    136a:	8c 91       	ld	r24, X
    136c:	87 7f       	andi	r24, 0xF7	; 247
    136e:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    1370:	e0 e9       	ldi	r30, 0x90	; 144
    1372:	f0 e0       	ldi	r31, 0x00	; 0
    1374:	80 81       	ld	r24, Z
    1376:	82 60       	ori	r24, 0x02	; 2
    1378:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    137a:	80 81       	ld	r24, Z
    137c:	8e 7f       	andi	r24, 0xFE	; 254
    137e:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    1380:	80 81       	ld	r24, Z
    1382:	80 68       	ori	r24, 0x80	; 128
    1384:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    1386:	80 81       	ld	r24, Z
    1388:	8f 7b       	andi	r24, 0xBF	; 191
    138a:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    138c:	80 81       	ld	r24, Z
    138e:	80 62       	ori	r24, 0x20	; 32
    1390:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    1392:	80 81       	ld	r24, Z
    1394:	8f 7e       	andi	r24, 0xEF	; 239
    1396:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    1398:	80 81       	ld	r24, Z
    139a:	88 60       	ori	r24, 0x08	; 8
    139c:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    139e:	80 81       	ld	r24, Z
    13a0:	8b 7f       	andi	r24, 0xFB	; 251
    13a2:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    13a4:	8c 91       	ld	r24, X
    13a6:	81 60       	ori	r24, 0x01	; 1
    13a8:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    13aa:	8c 91       	ld	r24, X
    13ac:	89 7f       	andi	r24, 0xF9	; 249
    13ae:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    13b0:	c6 e9       	ldi	r28, 0x96	; 150
    13b2:	d0 e0       	ldi	r29, 0x00	; 0
    13b4:	85 e8       	ldi	r24, 0x85	; 133
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	99 83       	std	Y+1, r25	; 0x01
    13ba:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    13bc:	68 81       	ld	r22, Y
    13be:	79 81       	ldd	r23, Y+1	; 0x01
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
    13c8:	20 e0       	ldi	r18, 0x00	; 0
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	40 e0       	ldi	r20, 0x00	; 0
    13ce:	5f e3       	ldi	r21, 0x3F	; 63
    13d0:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    13d4:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
    13d8:	e8 e9       	ldi	r30, 0x98	; 152
    13da:	f0 e0       	ldi	r31, 0x00	; 0
    13dc:	71 83       	std	Z+1, r23	; 0x01
    13de:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    13e0:	88 81       	ld	r24, Y
    13e2:	99 81       	ldd	r25, Y+1	; 0x01
    13e4:	20 81       	ld	r18, Z
    13e6:	31 81       	ldd	r19, Z+1	; 0x01
    13e8:	82 1b       	sub	r24, r18
    13ea:	93 0b       	sbc	r25, r19
    13ec:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    13f0:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    13f4:	68 81       	ld	r22, Y
    13f6:	79 81       	ldd	r23, Y+1	; 0x01
    13f8:	80 e0       	ldi	r24, 0x00	; 0
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	0e 94 87 12 	call	0x250e	; 0x250e <__floatunsisf>
    1400:	20 e0       	ldi	r18, 0x00	; 0
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	40 e0       	ldi	r20, 0x00	; 0
    1406:	5f e3       	ldi	r21, 0x3F	; 63
    1408:	0e 94 3d 13 	call	0x267a	; 0x267a <__mulsf3>
    140c:	0e 94 56 12 	call	0x24ac	; 0x24ac <__fixsfsi>
    1410:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    1414:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    1418:	df 91       	pop	r29
    141a:	cf 91       	pop	r28
    141c:	08 95       	ret

0000141e <uart0_putc>:
    141e:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    1422:	9f 5f       	subi	r25, 0xFF	; 255
    1424:	9f 71       	andi	r25, 0x1F	; 31
    1426:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    142a:	92 17       	cp	r25, r18
    142c:	e1 f3       	breq	.-8      	; 0x1426 <uart0_putc+0x8>
    142e:	e9 2f       	mov	r30, r25
    1430:	f0 e0       	ldi	r31, 0x00	; 0
    1432:	e5 5d       	subi	r30, 0xD5	; 213
    1434:	fb 4f       	sbci	r31, 0xFB	; 251
    1436:	80 83       	st	Z, r24
    1438:	2f b7       	in	r18, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    1440:	e1 ec       	ldi	r30, 0xC1	; 193
    1442:	f0 e0       	ldi	r31, 0x00	; 0
    1444:	80 81       	ld	r24, Z
    1446:	80 62       	ori	r24, 0x20	; 32
    1448:	80 83       	st	Z, r24
    144a:	2f bf       	out	0x3f, r18	; 63
    144c:	08 95       	ret

0000144e <uart0_flush>:
    144e:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    1452:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    1456:	98 13       	cpse	r25, r24
    1458:	fa cf       	rjmp	.-12     	; 0x144e <uart0_flush>
    145a:	08 95       	ret

0000145c <uart1_putc>:
    145c:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    1460:	9f 5f       	subi	r25, 0xFF	; 255
    1462:	9f 71       	andi	r25, 0x1F	; 31
    1464:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    1468:	92 17       	cp	r25, r18
    146a:	e1 f3       	breq	.-8      	; 0x1464 <uart1_putc+0x8>
    146c:	e9 2f       	mov	r30, r25
    146e:	f0 e0       	ldi	r31, 0x00	; 0
    1470:	ea 51       	subi	r30, 0x1A	; 26
    1472:	fc 4f       	sbci	r31, 0xFC	; 252
    1474:	80 83       	st	Z, r24
    1476:	2f b7       	in	r18, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    147e:	e9 ec       	ldi	r30, 0xC9	; 201
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	80 62       	ori	r24, 0x20	; 32
    1486:	80 83       	st	Z, r24
    1488:	2f bf       	out	0x3f, r18	; 63
    148a:	08 95       	ret

0000148c <uart_putchar>:
    148c:	cf 93       	push	r28
    148e:	c8 2f       	mov	r28, r24
    1490:	fb 01       	movw	r30, r22
    1492:	84 85       	ldd	r24, Z+12	; 0x0c
    1494:	95 85       	ldd	r25, Z+13	; 0x0d
    1496:	01 97       	sbiw	r24, 0x01	; 1
    1498:	39 f0       	breq	.+14     	; 0x14a8 <uart_putchar+0x1c>
    149a:	ca 30       	cpi	r28, 0x0A	; 10
    149c:	11 f4       	brne	.+4      	; 0x14a2 <uart_putchar+0x16>
    149e:	8d e0       	ldi	r24, 0x0D	; 13
    14a0:	be df       	rcall	.-132    	; 0x141e <uart0_putc>
    14a2:	8c 2f       	mov	r24, r28
    14a4:	bc df       	rcall	.-136    	; 0x141e <uart0_putc>
    14a6:	06 c0       	rjmp	.+12     	; 0x14b4 <uart_putchar+0x28>
    14a8:	ca 30       	cpi	r28, 0x0A	; 10
    14aa:	11 f4       	brne	.+4      	; 0x14b0 <uart_putchar+0x24>
    14ac:	8d e0       	ldi	r24, 0x0D	; 13
    14ae:	d6 df       	rcall	.-84     	; 0x145c <uart1_putc>
    14b0:	8c 2f       	mov	r24, r28
    14b2:	d4 df       	rcall	.-88     	; 0x145c <uart1_putc>
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	cf 91       	pop	r28
    14ba:	08 95       	ret

000014bc <uart0_getc>:
    14bc:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    14c0:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    14c4:	89 17       	cp	r24, r25
    14c6:	59 f0       	breq	.+22     	; 0x14de <uart0_getc+0x22>
    14c8:	8f 5f       	subi	r24, 0xFF	; 255
    14ca:	98 2f       	mov	r25, r24
    14cc:	9f 71       	andi	r25, 0x1F	; 31
    14ce:	e9 2f       	mov	r30, r25
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	ed 53       	subi	r30, 0x3D	; 61
    14d4:	fc 4f       	sbci	r31, 0xFC	; 252
    14d6:	80 81       	ld	r24, Z
    14d8:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    14dc:	08 95       	ret
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	08 95       	ret

000014e2 <uart0_getln>:
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
    14ea:	ec 01       	movw	r28, r24
    14ec:	61 30       	cpi	r22, 0x01	; 1
    14ee:	b1 f0       	breq	.+44     	; 0x151c <uart0_getln+0x3a>
    14f0:	62 50       	subi	r22, 0x02	; 2
    14f2:	06 2f       	mov	r16, r22
    14f4:	10 e0       	ldi	r17, 0x00	; 0
    14f6:	0f 5f       	subi	r16, 0xFF	; 255
    14f8:	1f 4f       	sbci	r17, 0xFF	; 255
    14fa:	08 0f       	add	r16, r24
    14fc:	19 1f       	adc	r17, r25
    14fe:	de df       	rcall	.-68     	; 0x14bc <uart0_getc>
    1500:	88 83       	st	Y, r24
    1502:	88 23       	and	r24, r24
    1504:	e1 f3       	breq	.-8      	; 0x14fe <uart0_getln+0x1c>
    1506:	8d 30       	cpi	r24, 0x0D	; 13
    1508:	21 f4       	brne	.+8      	; 0x1512 <uart0_getln+0x30>
    150a:	d8 df       	rcall	.-80     	; 0x14bc <uart0_getc>
    150c:	88 23       	and	r24, r24
    150e:	e9 f3       	breq	.-6      	; 0x150a <uart0_getln+0x28>
    1510:	05 c0       	rjmp	.+10     	; 0x151c <uart0_getln+0x3a>
    1512:	21 96       	adiw	r28, 0x01	; 1
    1514:	c0 17       	cp	r28, r16
    1516:	d1 07       	cpc	r29, r17
    1518:	91 f7       	brne	.-28     	; 0x14fe <uart0_getln+0x1c>
    151a:	e8 01       	movw	r28, r16
    151c:	18 82       	st	Y, r1
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	1f 91       	pop	r17
    1524:	0f 91       	pop	r16
    1526:	08 95       	ret

00001528 <uart0_getData>:
    1528:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    152c:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    1530:	89 17       	cp	r24, r25
    1532:	61 f0       	breq	.+24     	; 0x154c <uart0_getData+0x24>
    1534:	8f 5f       	subi	r24, 0xFF	; 255
    1536:	8f 71       	andi	r24, 0x1F	; 31
    1538:	e8 2f       	mov	r30, r24
    153a:	f0 e0       	ldi	r31, 0x00	; 0
    153c:	ed 53       	subi	r30, 0x3D	; 61
    153e:	fc 4f       	sbci	r31, 0xFC	; 252
    1540:	90 81       	ld	r25, Z
    1542:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    1546:	89 2f       	mov	r24, r25
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	08 95       	ret
    154c:	8f ef       	ldi	r24, 0xFF	; 255
    154e:	9f ef       	ldi	r25, 0xFF	; 255
    1550:	08 95       	ret

00001552 <uart1_getData>:
    1552:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    1556:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    155a:	89 17       	cp	r24, r25
    155c:	61 f0       	breq	.+24     	; 0x1576 <uart1_getData+0x24>
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	8f 71       	andi	r24, 0x1F	; 31
    1562:	e8 2f       	mov	r30, r24
    1564:	f0 e0       	ldi	r31, 0x00	; 0
    1566:	e9 5f       	subi	r30, 0xF9	; 249
    1568:	fb 4f       	sbci	r31, 0xFB	; 251
    156a:	90 81       	ld	r25, Z
    156c:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    1570:	89 2f       	mov	r24, r25
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	08 95       	ret
    1576:	8f ef       	ldi	r24, 0xFF	; 255
    1578:	9f ef       	ldi	r25, 0xFF	; 255
    157a:	08 95       	ret

0000157c <uart_getchar>:
    157c:	cf 93       	push	r28
    157e:	df 93       	push	r29
    1580:	fc 01       	movw	r30, r24
    1582:	84 85       	ldd	r24, Z+12	; 0x0c
    1584:	95 85       	ldd	r25, Z+13	; 0x0d
    1586:	01 97       	sbiw	r24, 0x01	; 1
    1588:	41 f0       	breq	.+16     	; 0x159a <uart_getchar+0x1e>
    158a:	ce df       	rcall	.-100    	; 0x1528 <uart0_getData>
    158c:	ec 01       	movw	r28, r24
    158e:	99 23       	and	r25, r25
    1590:	e4 f3       	brlt	.-8      	; 0x158a <uart_getchar+0xe>
    1592:	45 df       	rcall	.-374    	; 0x141e <uart0_putc>
    1594:	ce 01       	movw	r24, r28
    1596:	99 27       	eor	r25, r25
    1598:	07 c0       	rjmp	.+14     	; 0x15a8 <uart_getchar+0x2c>
    159a:	db df       	rcall	.-74     	; 0x1552 <uart1_getData>
    159c:	ec 01       	movw	r28, r24
    159e:	99 23       	and	r25, r25
    15a0:	e4 f3       	brlt	.-8      	; 0x159a <uart_getchar+0x1e>
    15a2:	5c df       	rcall	.-328    	; 0x145c <uart1_putc>
    15a4:	ce 01       	movw	r24, r28
    15a6:	99 27       	eor	r25, r25
    15a8:	99 27       	eor	r25, r25
    15aa:	df 91       	pop	r29
    15ac:	cf 91       	pop	r28
    15ae:	08 95       	ret

000015b0 <__vector_22>:
    15b0:	0f 93       	push	r16
    15b2:	0f b7       	in	r16, 0x3f	; 63
    15b4:	ef 93       	push	r30
    15b6:	ff 93       	push	r31
    15b8:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    15bc:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    15c0:	e3 95       	inc	r30
    15c2:	ef 71       	andi	r30, 0x1F	; 31
    15c4:	ef 13       	cpse	r30, r31
    15c6:	05 c0       	rjmp	.+10     	; 0x15d2 <USART0_TX_CONTINUE>
    15c8:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15cc:	ff 7d       	andi	r31, 0xDF	; 223
    15ce:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015d2 <USART0_TX_CONTINUE>:
    15d2:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    15d6:	f0 e0       	ldi	r31, 0x00	; 0
    15d8:	e5 5d       	subi	r30, 0xD5	; 213
    15da:	fb 4f       	sbci	r31, 0xFB	; 251
    15dc:	e0 81       	ld	r30, Z
    15de:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

000015e2 <USART0_TX_EXIT>:
    15e2:	ff 91       	pop	r31
    15e4:	ef 91       	pop	r30
    15e6:	0f bf       	out	0x3f, r16	; 63
    15e8:	0f 91       	pop	r16
    15ea:	18 95       	reti

000015ec <__vector_21>:
    15ec:	0f 93       	push	r16
    15ee:	0f b7       	in	r16, 0x3f	; 63
    15f0:	9f 93       	push	r25
    15f2:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    15f6:	ef 93       	push	r30
    15f8:	ff 93       	push	r31
    15fa:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    15fe:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    1602:	e3 95       	inc	r30
    1604:	ef 71       	andi	r30, 0x1F	; 31
    1606:	fe 17       	cp	r31, r30
    1608:	31 f0       	breq	.+12     	; 0x1616 <USART0_RX_EXIT>
    160a:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    160e:	f0 e0       	ldi	r31, 0x00	; 0
    1610:	ed 53       	subi	r30, 0x3D	; 61
    1612:	fc 4f       	sbci	r31, 0xFC	; 252
    1614:	90 83       	st	Z, r25

00001616 <USART0_RX_EXIT>:
    1616:	ff 91       	pop	r31
    1618:	ef 91       	pop	r30
    161a:	9f 91       	pop	r25
    161c:	0f bf       	out	0x3f, r16	; 63
    161e:	0f 91       	pop	r16
    1620:	18 95       	reti

00001622 <__vector_33>:
    1622:	0f 93       	push	r16
    1624:	0f b7       	in	r16, 0x3f	; 63
    1626:	ef 93       	push	r30
    1628:	ff 93       	push	r31
    162a:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    162e:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    1632:	e3 95       	inc	r30
    1634:	ef 71       	andi	r30, 0x1F	; 31
    1636:	ef 13       	cpse	r30, r31
    1638:	05 c0       	rjmp	.+10     	; 0x1644 <USART1_TX_CONTINUE>
    163a:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    163e:	ff 7d       	andi	r31, 0xDF	; 223
    1640:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

00001644 <USART1_TX_CONTINUE>:
    1644:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    1648:	f0 e0       	ldi	r31, 0x00	; 0
    164a:	ea 51       	subi	r30, 0x1A	; 26
    164c:	fc 4f       	sbci	r31, 0xFC	; 252
    164e:	e0 81       	ld	r30, Z
    1650:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

00001654 <USART1_TX_EXIT>:
    1654:	ff 91       	pop	r31
    1656:	ef 91       	pop	r30
    1658:	0f bf       	out	0x3f, r16	; 63
    165a:	0f 91       	pop	r16
    165c:	18 95       	reti

0000165e <__vector_32>:
    165e:	0f 93       	push	r16
    1660:	0f b7       	in	r16, 0x3f	; 63
    1662:	9f 93       	push	r25
    1664:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1668:	ef 93       	push	r30
    166a:	ff 93       	push	r31
    166c:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    1670:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    1674:	e3 95       	inc	r30
    1676:	ef 71       	andi	r30, 0x1F	; 31
    1678:	fe 17       	cp	r31, r30
    167a:	31 f0       	breq	.+12     	; 0x1688 <USART1_RX_EXIT>
    167c:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    1680:	f0 e0       	ldi	r31, 0x00	; 0
    1682:	e9 5f       	subi	r30, 0xF9	; 249
    1684:	fb 4f       	sbci	r31, 0xFB	; 251
    1686:	90 83       	st	Z, r25

00001688 <USART1_RX_EXIT>:
    1688:	ff 91       	pop	r31
    168a:	ef 91       	pop	r30
    168c:	9f 91       	pop	r25
    168e:	0f bf       	out	0x3f, r16	; 63
    1690:	0f 91       	pop	r16
    1692:	18 95       	reti

00001694 <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    1694:	e1 e8       	ldi	r30, 0x81	; 129
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	80 81       	ld	r24, Z
    169a:	83 60       	ori	r24, 0x03	; 3
    169c:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    169e:	80 81       	ld	r24, Z
    16a0:	88 60       	ori	r24, 0x08	; 8
    16a2:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    16a4:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    16a8:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    16ac:	ef e6       	ldi	r30, 0x6F	; 111
    16ae:	f0 e0       	ldi	r31, 0x00	; 0
    16b0:	80 81       	ld	r24, Z
    16b2:	82 60       	ori	r24, 0x02	; 2
    16b4:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    16b6:	8d e7       	ldi	r24, 0x7D	; 125
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16be:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16c2:	08 95       	ret

000016c4 <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    16c4:	84 b5       	in	r24, 0x24	; 36
    16c6:	85 60       	ori	r24, 0x05	; 5
    16c8:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16ca:	84 b5       	in	r24, 0x24	; 36
    16cc:	88 60       	ori	r24, 0x08	; 8
    16ce:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16d0:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16d2:	ee e6       	ldi	r30, 0x6E	; 110
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	80 81       	ld	r24, Z
    16d8:	82 60       	ori	r24, 0x02	; 2
    16da:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    16dc:	87 e2       	ldi	r24, 0x27	; 39
    16de:	87 bd       	out	0x27, r24	; 39
    16e0:	08 95       	ret

000016e2 <main>:
};


int main(void)	
{
	cli();
    16e2:	f8 94       	cli
	rgbled_init();
    16e4:	92 d5       	rcall	.+2852   	; 0x220a <rgbled_init>
	DWC_init();
    16e6:	11 d2       	rcall	.+1058   	; 0x1b0a <DWC_init>
	pwm_init();
    16e8:	33 de       	rcall	.-922    	; 0x1350 <pwm_init>
    16ea:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    16ec:	70 e0       	ldi	r23, 0x00	; 0
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    16f2:	71 d4       	rcall	.+2274   	; 0x1fd6 <can_init>
	timer0_init_ts();
    16f4:	cf df       	rcall	.-98     	; 0x1694 <timer1_init_ts>
    16f6:	e6 df       	rcall	.-52     	; 0x16c4 <timer0_init_ts>
	speed_init();
    16f8:	7f dc       	rcall	.-1794   	; 0xff8 <speed_init>
    16fa:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    16fc:	95 d5       	rcall	.+2858   	; 0x2228 <spi_init>
    16fe:	82 e1       	ldi	r24, 0x12	; 18
    1700:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    1702:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    1706:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    170a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    170e:	88 e9       	ldi	r24, 0x98	; 152
    1710:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    1714:	eb e4       	ldi	r30, 0x4B	; 75
    1716:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    1718:	84 e0       	ldi	r24, 0x04	; 4
    171a:	91 e0       	ldi	r25, 0x01	; 1
    171c:	93 83       	std	Z+3, r25	; 0x03
    171e:	82 83       	std	Z+2, r24	; 0x02
    1720:	91 83       	std	Z+1, r25	; 0x01
    1722:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    1724:	0e 94 66 03 	call	0x6cc	; 0x6cc <drivers_init>
	drivers_init();
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	0e 94 68 03 	call	0x6d0	; 0x6d0 <drivers>
	drivers(0);
    172e:	78 94       	sei
	sei();
    1730:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    1732:	67 e9       	ldi	r22, 0x97	; 151
    1734:	73 e0       	ldi	r23, 0x03	; 3
    1736:	82 e1       	ldi	r24, 0x12	; 18
    1738:	91 e0       	ldi	r25, 0x01	; 1
    173a:	c5 d8       	rcall	.-3702   	; 0x8c6 <handle_can>
    173c:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    173e:	91 e0       	ldi	r25, 0x01	; 1
    1740:	9e d9       	rcall	.-3268   	; 0xa7e <receive_uart>
    1742:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1746:	88 23       	and	r24, r24
    1748:	09 f4       	brne	.+2      	; 0x174c <main+0x6a>
    174a:	41 c0       	rjmp	.+130    	; 0x17ce <main+0xec>
    174c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1750:	88 23       	and	r24, r24
    1752:	f1 f0       	breq	.+60     	; 0x1790 <main+0xae>
    1754:	8d b7       	in	r24, 0x3d	; 61
    1756:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    1758:	cd 97       	sbiw	r24, 0x3d	; 61
    175a:	0f b6       	in	r0, 0x3f	; 63
    175c:	f8 94       	cli
    175e:	9e bf       	out	0x3e, r25	; 62
    1760:	0f be       	out	0x3f, r0	; 63
    1762:	8d bf       	out	0x3d, r24	; 61
    1764:	ad b7       	in	r26, 0x3d	; 61
    1766:	be b7       	in	r27, 0x3e	; 62
    1768:	11 96       	adiw	r26, 0x01	; 1
    176a:	8d e3       	ldi	r24, 0x3D	; 61
    176c:	e2 e1       	ldi	r30, 0x12	; 18
    176e:	f1 e0       	ldi	r31, 0x01	; 1
    1770:	01 90       	ld	r0, Z+
    1772:	0d 92       	st	X+, r0
    1774:	8a 95       	dec	r24
    1776:	e1 f7       	brne	.-8      	; 0x1770 <main+0x8e>
    1778:	fd d8       	rcall	.-3590   	; 0x974 <handle_motor_status_can_msg>
    177a:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    177e:	8d b7       	in	r24, 0x3d	; 61
    1780:	9e b7       	in	r25, 0x3e	; 62
    1782:	cd 96       	adiw	r24, 0x3d	; 61
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	9e bf       	out	0x3e, r25	; 62
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	8d bf       	out	0x3d, r24	; 61
    178e:	1d c0       	rjmp	.+58     	; 0x17ca <main+0xe8>
    1790:	8d b7       	in	r24, 0x3d	; 61
    1792:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    1794:	cd 97       	sbiw	r24, 0x3d	; 61
    1796:	0f b6       	in	r0, 0x3f	; 63
    1798:	f8 94       	cli
    179a:	9e bf       	out	0x3e, r25	; 62
    179c:	0f be       	out	0x3f, r0	; 63
    179e:	8d bf       	out	0x3d, r24	; 61
    17a0:	ad b7       	in	r26, 0x3d	; 61
    17a2:	be b7       	in	r27, 0x3e	; 62
    17a4:	11 96       	adiw	r26, 0x01	; 1
    17a6:	8d e3       	ldi	r24, 0x3D	; 61
    17a8:	e2 e1       	ldi	r30, 0x12	; 18
    17aa:	f1 e0       	ldi	r31, 0x01	; 1
    17ac:	01 90       	ld	r0, Z+
    17ae:	0d 92       	st	X+, r0
    17b0:	8a 95       	dec	r24
    17b2:	e1 f7       	brne	.-8      	; 0x17ac <main+0xca>
    17b4:	4e d9       	rcall	.-3428   	; 0xa52 <handle_clutch_cmd_can_msg>
    17b6:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    17ba:	8d b7       	in	r24, 0x3d	; 61
    17bc:	9e b7       	in	r25, 0x3e	; 62
    17be:	cd 96       	adiw	r24, 0x3d	; 61
    17c0:	0f b6       	in	r0, 0x3f	; 63
    17c2:	f8 94       	cli
    17c4:	9e bf       	out	0x3e, r25	; 62
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	8d bf       	out	0x3d, r24	; 61
    17ca:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17ce:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17d2:	88 23       	and	r24, r24
    17d4:	09 f4       	brne	.+2      	; 0x17d8 <main+0xf6>
    17d6:	ad cf       	rjmp	.-166    	; 0x1732 <main+0x50>
    17d8:	8d b7       	in	r24, 0x3d	; 61
    17da:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    17dc:	cd 97       	sbiw	r24, 0x3d	; 61
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	f8 94       	cli
    17e2:	9e bf       	out	0x3e, r25	; 62
    17e4:	0f be       	out	0x3f, r0	; 63
    17e6:	8d bf       	out	0x3d, r24	; 61
    17e8:	ad b7       	in	r26, 0x3d	; 61
    17ea:	be b7       	in	r27, 0x3e	; 62
    17ec:	11 96       	adiw	r26, 0x01	; 1
    17ee:	8d e3       	ldi	r24, 0x3D	; 61
    17f0:	e2 e1       	ldi	r30, 0x12	; 18
    17f2:	f1 e0       	ldi	r31, 0x01	; 1
    17f4:	01 90       	ld	r0, Z+
    17f6:	0d 92       	st	X+, r0
    17f8:	8a 95       	dec	r24
    17fa:	e1 f7       	brne	.-8      	; 0x17f4 <main+0x112>
    17fc:	c1 da       	rcall	.-2686   	; 0xd80 <send_uart>
    17fe:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    1802:	8d b7       	in	r24, 0x3d	; 61
    1804:	9e b7       	in	r25, 0x3e	; 62
    1806:	cd 96       	adiw	r24, 0x3d	; 61
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	f8 94       	cli
    180c:	9e bf       	out	0x3e, r25	; 62
    180e:	0f be       	out	0x3f, r0	; 63
    1810:	8d bf       	out	0x3d, r24	; 61
    1812:	8f cf       	rjmp	.-226    	; 0x1732 <main+0x50>

00001814 <__vector_16>:
    1814:	1f 92       	push	r1
    1816:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	0f 92       	push	r0
    181c:	11 24       	eor	r1, r1
    181e:	0b b6       	in	r0, 0x3b	; 59
    1820:	0f 92       	push	r0
    1822:	ef 92       	push	r14
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	2f 93       	push	r18
    182a:	3f 93       	push	r19
    182c:	4f 93       	push	r20
    182e:	5f 93       	push	r21
    1830:	6f 93       	push	r22
    1832:	7f 93       	push	r23
    1834:	8f 93       	push	r24
    1836:	9f 93       	push	r25
    1838:	af 93       	push	r26
    183a:	bf 93       	push	r27
    183c:	ef 93       	push	r30
    183e:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1840:	82 e1       	ldi	r24, 0x12	; 18
    1842:	91 e0       	ldi	r25, 0x01	; 1
    1844:	63 d1       	rcall	.+710    	; 0x1b0c <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1846:	82 e1       	ldi	r24, 0x12	; 18
    1848:	91 e0       	ldi	r25, 0x01	; 1
    184a:	63 dc       	rcall	.-1850   	; 0x1112 <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    184c:	82 e1       	ldi	r24, 0x12	; 18
    184e:	91 e0       	ldi	r25, 0x01	; 1
    1850:	0e 94 9f 01 	call	0x33e	; 0x33e <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    1854:	82 e1       	ldi	r24, 0x12	; 18
    1856:	91 e0       	ldi	r25, 0x01	; 1
    1858:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    185c:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1860:	87 30       	cpi	r24, 0x07	; 7
    1862:	09 f0       	breq	.+2      	; 0x1866 <__vector_16+0x52>
    1864:	51 c0       	rjmp	.+162    	; 0x1908 <__vector_16+0xf4>
	{
		b_send_can = 1;
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    186c:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1870:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    1874:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    1878:	89 2b       	or	r24, r25
    187a:	b1 f0       	breq	.+44     	; 0x18a8 <__vector_16+0x94>
    187c:	e2 e1       	ldi	r30, 0x12	; 18
    187e:	f1 e0       	ldi	r31, 0x01	; 1
    1880:	97 8d       	ldd	r25, Z+31	; 0x1f
    1882:	27 8d       	ldd	r18, Z+31	; 0x1f
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	91 30       	cpi	r25, 0x01	; 1
    1888:	09 f0       	breq	.+2      	; 0x188c <__vector_16+0x78>
    188a:	80 e0       	ldi	r24, 0x00	; 0
    188c:	81 11       	cpse	r24, r1
    188e:	05 c0       	rjmp	.+10     	; 0x189a <__vector_16+0x86>
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	21 11       	cpse	r18, r1
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	88 23       	and	r24, r24
    1898:	39 f0       	breq	.+14     	; 0x18a8 <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    189a:	e2 e1       	ldi	r30, 0x12	; 18
    189c:	f1 e0       	ldi	r31, 0x01	; 1
    189e:	82 8d       	ldd	r24, Z+26	; 0x1a
    18a0:	93 8d       	ldd	r25, Z+27	; 0x1b
    18a2:	01 97       	sbiw	r24, 0x01	; 1
    18a4:	93 8f       	std	Z+27, r25	; 0x1b
    18a6:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    18a8:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    18ac:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    18b0:	89 2b       	or	r24, r25
    18b2:	b1 f0       	breq	.+44     	; 0x18e0 <__vector_16+0xcc>
    18b4:	e2 e1       	ldi	r30, 0x12	; 18
    18b6:	f1 e0       	ldi	r31, 0x01	; 1
    18b8:	97 8d       	ldd	r25, Z+31	; 0x1f
    18ba:	27 8d       	ldd	r18, Z+31	; 0x1f
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	91 30       	cpi	r25, 0x01	; 1
    18c0:	09 f0       	breq	.+2      	; 0x18c4 <__vector_16+0xb0>
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	81 11       	cpse	r24, r1
    18c6:	05 c0       	rjmp	.+10     	; 0x18d2 <__vector_16+0xbe>
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	21 11       	cpse	r18, r1
    18cc:	80 e0       	ldi	r24, 0x00	; 0
    18ce:	88 23       	and	r24, r24
    18d0:	39 f0       	breq	.+14     	; 0x18e0 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18d2:	e2 e1       	ldi	r30, 0x12	; 18
    18d4:	f1 e0       	ldi	r31, 0x01	; 1
    18d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    18d8:	95 8d       	ldd	r25, Z+29	; 0x1d
    18da:	01 97       	sbiw	r24, 0x01	; 1
    18dc:	95 8f       	std	Z+29, r25	; 0x1d
    18de:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    18e0:	e2 e1       	ldi	r30, 0x12	; 18
    18e2:	f1 e0       	ldi	r31, 0x01	; 1
    18e4:	02 85       	ldd	r16, Z+10	; 0x0a
    18e6:	13 85       	ldd	r17, Z+11	; 0x0b
    18e8:	24 85       	ldd	r18, Z+12	; 0x0c
    18ea:	35 85       	ldd	r19, Z+13	; 0x0d
    18ec:	46 81       	ldd	r20, Z+6	; 0x06
    18ee:	57 81       	ldd	r21, Z+7	; 0x07
    18f0:	60 85       	ldd	r22, Z+8	; 0x08
    18f2:	71 85       	ldd	r23, Z+9	; 0x09
    18f4:	0f 2e       	mov	r0, r31
    18f6:	f9 e2       	ldi	r31, 0x29	; 41
    18f8:	ef 2e       	mov	r14, r31
    18fa:	f0 2d       	mov	r31, r0
    18fc:	80 e2       	ldi	r24, 0x20	; 32
    18fe:	91 e0       	ldi	r25, 0x01	; 1
    1900:	e6 d1       	rcall	.+972    	; 0x1cce <handle_joulemeter>
		systic_counter_fast = 0;
    1902:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    1906:	03 c0       	rjmp	.+6      	; 0x190e <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    1908:	8f 5f       	subi	r24, 0xFF	; 255
    190a:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    190e:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    1912:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    1916:	84 36       	cpi	r24, 0x64	; 100
    1918:	91 05       	cpc	r25, r1
    191a:	01 f5       	brne	.+64     	; 0x195c <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    191c:	8d b7       	in	r24, 0x3d	; 61
    191e:	9e b7       	in	r25, 0x3e	; 62
    1920:	cd 97       	sbiw	r24, 0x3d	; 61
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	f8 94       	cli
    1926:	9e bf       	out	0x3e, r25	; 62
    1928:	0f be       	out	0x3f, r0	; 63
    192a:	8d bf       	out	0x3d, r24	; 61
    192c:	ad b7       	in	r26, 0x3d	; 61
    192e:	be b7       	in	r27, 0x3e	; 62
    1930:	11 96       	adiw	r26, 0x01	; 1
    1932:	8d e3       	ldi	r24, 0x3D	; 61
    1934:	e2 e1       	ldi	r30, 0x12	; 18
    1936:	f1 e0       	ldi	r31, 0x01	; 1
    1938:	01 90       	ld	r0, Z+
    193a:	0d 92       	st	X+, r0
    193c:	8a 95       	dec	r24
    193e:	e1 f7       	brne	.-8      	; 0x1938 <__vector_16+0x124>
    1940:	02 db       	rcall	.-2556   	; 0xf46 <manage_LEDs>
		systic_counter_slow = 0;
    1942:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1946:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    194a:	8d b7       	in	r24, 0x3d	; 61
    194c:	9e b7       	in	r25, 0x3e	; 62
    194e:	cd 96       	adiw	r24, 0x3d	; 61
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	9e bf       	out	0x3e, r25	; 62
    1956:	0f be       	out	0x3f, r0	; 63
    1958:	8d bf       	out	0x3d, r24	; 61
    195a:	05 c0       	rjmp	.+10     	; 0x1966 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    1962:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1966:	ff 91       	pop	r31
    1968:	ef 91       	pop	r30
    196a:	bf 91       	pop	r27
    196c:	af 91       	pop	r26
    196e:	9f 91       	pop	r25
    1970:	8f 91       	pop	r24
    1972:	7f 91       	pop	r23
    1974:	6f 91       	pop	r22
    1976:	5f 91       	pop	r21
    1978:	4f 91       	pop	r20
    197a:	3f 91       	pop	r19
    197c:	2f 91       	pop	r18
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	ef 90       	pop	r14
    1984:	0f 90       	pop	r0
    1986:	0b be       	out	0x3b, r0	; 59
    1988:	0f 90       	pop	r0
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	0f 90       	pop	r0
    198e:	1f 90       	pop	r1
    1990:	18 95       	reti

00001992 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    1992:	1f 92       	push	r1
    1994:	0f 92       	push	r0
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	0f 92       	push	r0
    199a:	11 24       	eor	r1, r1
    199c:	0b b6       	in	r0, 0x3b	; 59
    199e:	0f 92       	push	r0
    19a0:	2f 93       	push	r18
    19a2:	3f 93       	push	r19
    19a4:	4f 93       	push	r20
    19a6:	5f 93       	push	r21
    19a8:	6f 93       	push	r22
    19aa:	7f 93       	push	r23
    19ac:	8f 93       	push	r24
    19ae:	9f 93       	push	r25
    19b0:	af 93       	push	r26
    19b2:	bf 93       	push	r27
    19b4:	ef 93       	push	r30
    19b6:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    19b8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19bc:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19c0:	80 3d       	cpi	r24, 0xD0	; 208
    19c2:	97 40       	sbci	r25, 0x07	; 7
    19c4:	50 f4       	brcc	.+20     	; 0x19da <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19c6:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19ca:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19ce:	01 96       	adiw	r24, 0x01	; 1
    19d0:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19d4:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19d8:	08 c0       	rjmp	.+16     	; 0x19ea <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19da:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    19de:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    19e2:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    19e6:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    19ea:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19ee:	87 30       	cpi	r24, 0x07	; 7
    19f0:	41 f4       	brne	.+16     	; 0x1a02 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    19f2:	84 e1       	ldi	r24, 0x14	; 20
    19f4:	91 e0       	ldi	r25, 0x01	; 1
    19f6:	0e 94 41 04 	call	0x882	; 0x882 <SPI_handler_7>
		u8_SPI_count = 0 ;
    19fa:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    19fe:	80 e0       	ldi	r24, 0x00	; 0
    1a00:	13 c0       	rjmp	.+38     	; 0x1a28 <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1a02:	86 30       	cpi	r24, 0x06	; 6
    1a04:	49 f4       	brne	.+18     	; 0x1a18 <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1a06:	8d e3       	ldi	r24, 0x3D	; 61
    1a08:	91 e0       	ldi	r25, 0x01	; 1
    1a0a:	0e 94 ee 03 	call	0x7dc	; 0x7dc <SPI_handler_6>
		u8_SPI_count ++ ;
    1a0e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a12:	8f 5f       	subi	r24, 0xFF	; 255
    1a14:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1a18:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a1c:	85 30       	cpi	r24, 0x05	; 5
    1a1e:	21 f4       	brne	.+8      	; 0x1a28 <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1a20:	86 e0       	ldi	r24, 0x06	; 6
    1a22:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a26:	13 c0       	rjmp	.+38     	; 0x1a4e <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a28:	84 30       	cpi	r24, 0x04	; 4
    1a2a:	49 f4       	brne	.+18     	; 0x1a3e <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a2c:	84 e2       	ldi	r24, 0x24	; 36
    1a2e:	91 e0       	ldi	r25, 0x01	; 1
    1a30:	0e 94 cd 03 	call	0x79a	; 0x79a <SPI_handler_4>
		u8_SPI_count ++ ;
    1a34:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a38:	8f 5f       	subi	r24, 0xFF	; 255
    1a3a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a3e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a42:	83 30       	cpi	r24, 0x03	; 3
    1a44:	21 f4       	brne	.+8      	; 0x1a4e <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a46:	84 e0       	ldi	r24, 0x04	; 4
    1a48:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a4c:	13 c0       	rjmp	.+38     	; 0x1a74 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a4e:	82 30       	cpi	r24, 0x02	; 2
    1a50:	21 f4       	brne	.+8      	; 0x1a5a <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a52:	83 e0       	ldi	r24, 0x03	; 3
    1a54:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a58:	1a c0       	rjmp	.+52     	; 0x1a8e <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a5a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a5e:	81 30       	cpi	r24, 0x01	; 1
    1a60:	49 f4       	brne	.+18     	; 0x1a74 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a62:	88 e1       	ldi	r24, 0x18	; 24
    1a64:	91 e0       	ldi	r25, 0x01	; 1
    1a66:	0e 94 ab 03 	call	0x756	; 0x756 <SPI_handler_1>
		u8_SPI_count ++ ;
    1a6a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a6e:	8f 5f       	subi	r24, 0xFF	; 255
    1a70:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a74:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a78:	81 11       	cpse	r24, r1
    1a7a:	09 c0       	rjmp	.+18     	; 0x1a8e <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1a7c:	8c e1       	ldi	r24, 0x1C	; 28
    1a7e:	91 e0       	ldi	r25, 0x01	; 1
    1a80:	0e 94 6e 03 	call	0x6dc	; 0x6dc <SPI_handler_0>
		u8_SPI_count ++ ;
    1a84:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1a8e:	ff 91       	pop	r31
    1a90:	ef 91       	pop	r30
    1a92:	bf 91       	pop	r27
    1a94:	af 91       	pop	r26
    1a96:	9f 91       	pop	r25
    1a98:	8f 91       	pop	r24
    1a9a:	7f 91       	pop	r23
    1a9c:	6f 91       	pop	r22
    1a9e:	5f 91       	pop	r21
    1aa0:	4f 91       	pop	r20
    1aa2:	3f 91       	pop	r19
    1aa4:	2f 91       	pop	r18
    1aa6:	0f 90       	pop	r0
    1aa8:	0b be       	out	0x3b, r0	; 59
    1aaa:	0f 90       	pop	r0
    1aac:	0f be       	out	0x3f, r0	; 63
    1aae:	0f 90       	pop	r0
    1ab0:	1f 90       	pop	r1
    1ab2:	18 95       	reti

00001ab4 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1ab4:	1f 92       	push	r1
    1ab6:	0f 92       	push	r0
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	0f 92       	push	r0
    1abc:	11 24       	eor	r1, r1
    1abe:	0b b6       	in	r0, 0x3b	; 59
    1ac0:	0f 92       	push	r0
    1ac2:	2f 93       	push	r18
    1ac4:	3f 93       	push	r19
    1ac6:	4f 93       	push	r20
    1ac8:	5f 93       	push	r21
    1aca:	6f 93       	push	r22
    1acc:	7f 93       	push	r23
    1ace:	8f 93       	push	r24
    1ad0:	9f 93       	push	r25
    1ad2:	af 93       	push	r26
    1ad4:	bf 93       	push	r27
    1ad6:	ef 93       	push	r30
    1ad8:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1ada:	60 e0       	ldi	r22, 0x00	; 0
    1adc:	72 e0       	ldi	r23, 0x02	; 2
    1ade:	85 e2       	ldi	r24, 0x25	; 37
    1ae0:	91 e0       	ldi	r25, 0x01	; 1
    1ae2:	95 da       	rcall	.-2774   	; 0x100e <handle_speed_sensor>
}
    1ae4:	ff 91       	pop	r31
    1ae6:	ef 91       	pop	r30
    1ae8:	bf 91       	pop	r27
    1aea:	af 91       	pop	r26
    1aec:	9f 91       	pop	r25
    1aee:	8f 91       	pop	r24
    1af0:	7f 91       	pop	r23
    1af2:	6f 91       	pop	r22
    1af4:	5f 91       	pop	r21
    1af6:	4f 91       	pop	r20
    1af8:	3f 91       	pop	r19
    1afa:	2f 91       	pop	r18
    1afc:	0f 90       	pop	r0
    1afe:	0b be       	out	0x3b, r0	; 59
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	0f 90       	pop	r0
    1b06:	1f 90       	pop	r1
    1b08:	18 95       	reti

00001b0a <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1b0a:	08 95       	ret

00001b0c <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1b0c:	7a 99       	sbic	0x0f, 2	; 15
    1b0e:	03 c0       	rjmp	.+6      	; 0x1b16 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1b10:	fc 01       	movw	r30, r24
    1b12:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1b14:	10 8e       	std	Z+24, r1	; 0x18
    1b16:	08 95       	ret

00001b18 <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1b18:	8f 92       	push	r8
    1b1a:	9f 92       	push	r9
    1b1c:	af 92       	push	r10
    1b1e:	bf 92       	push	r11
    1b20:	cf 92       	push	r12
    1b22:	df 92       	push	r13
    1b24:	ef 92       	push	r14
    1b26:	ff 92       	push	r15
    1b28:	0f 93       	push	r16
    1b2a:	1f 93       	push	r17
    1b2c:	cf 93       	push	r28
    1b2e:	df 93       	push	r29
    1b30:	00 d0       	rcall	.+0      	; 0x1b32 <handle_current_sensor+0x1a>
    1b32:	00 d0       	rcall	.+0      	; 0x1b34 <handle_current_sensor+0x1c>
    1b34:	cd b7       	in	r28, 0x3d	; 61
    1b36:	de b7       	in	r29, 0x3e	; 62
    1b38:	8c 01       	movw	r16, r24
    1b3a:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b3c:	80 e0       	ldi	r24, 0x00	; 0
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	e6 d4       	rcall	.+2508   	; 0x250e <__floatunsisf>
    1b42:	20 e0       	ldi	r18, 0x00	; 0
    1b44:	30 e0       	ldi	r19, 0x00	; 0
    1b46:	40 ea       	ldi	r20, 0xA0	; 160
    1b48:	50 e4       	ldi	r21, 0x40	; 64
    1b4a:	97 d5       	rcall	.+2862   	; 0x267a <__mulsf3>
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	40 e8       	ldi	r20, 0x80	; 128
    1b52:	59 e3       	ldi	r21, 0x39	; 57
    1b54:	92 d5       	rcall	.+2852   	; 0x267a <__mulsf3>
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e0       	ldi	r20, 0x00	; 0
    1b5c:	51 e4       	ldi	r21, 0x41	; 65
    1b5e:	8d d5       	rcall	.+2842   	; 0x267a <__mulsf3>
    1b60:	20 e0       	ldi	r18, 0x00	; 0
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	40 ea       	ldi	r20, 0xA0	; 160
    1b66:	51 e4       	ldi	r21, 0x41	; 65
    1b68:	d0 d3       	rcall	.+1952   	; 0x230a <__subsf3>
    1b6a:	69 83       	std	Y+1, r22	; 0x01
    1b6c:	7a 83       	std	Y+2, r23	; 0x02
    1b6e:	8b 83       	std	Y+3, r24	; 0x03
    1b70:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b72:	ff 20       	and	r15, r15
    1b74:	49 f0       	breq	.+18     	; 0x1b88 <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b76:	89 81       	ldd	r24, Y+1	; 0x01
    1b78:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7a:	ab 81       	ldd	r26, Y+3	; 0x03
    1b7c:	bc 81       	ldd	r27, Y+4	; 0x04
    1b7e:	89 83       	std	Y+1, r24	; 0x01
    1b80:	9a 83       	std	Y+2, r25	; 0x02
    1b82:	ab 83       	std	Y+3, r26	; 0x03
    1b84:	bc 83       	std	Y+4, r27	; 0x04
    1b86:	08 c0       	rjmp	.+16     	; 0x1b98 <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b88:	89 81       	ldd	r24, Y+1	; 0x01
    1b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8c:	ab 81       	ldd	r26, Y+3	; 0x03
    1b8e:	bc 81       	ldd	r27, Y+4	; 0x04
    1b90:	89 83       	std	Y+1, r24	; 0x01
    1b92:	9a 83       	std	Y+2, r25	; 0x02
    1b94:	ab 83       	std	Y+3, r26	; 0x03
    1b96:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1b98:	f8 01       	movw	r30, r16
    1b9a:	60 81       	ld	r22, Z
    1b9c:	71 81       	ldd	r23, Z+1	; 0x01
    1b9e:	82 81       	ldd	r24, Z+2	; 0x02
    1ba0:	93 81       	ldd	r25, Z+3	; 0x03
    1ba2:	89 80       	ldd	r8, Y+1	; 0x01
    1ba4:	9a 80       	ldd	r9, Y+2	; 0x02
    1ba6:	ab 80       	ldd	r10, Y+3	; 0x03
    1ba8:	bc 80       	ldd	r11, Y+4	; 0x04
    1baa:	26 e6       	ldi	r18, 0x66	; 102
    1bac:	36 e6       	ldi	r19, 0x66	; 102
    1bae:	46 e6       	ldi	r20, 0x66	; 102
    1bb0:	5f e3       	ldi	r21, 0x3F	; 63
    1bb2:	63 d5       	rcall	.+2758   	; 0x267a <__mulsf3>
    1bb4:	6b 01       	movw	r12, r22
    1bb6:	7c 01       	movw	r14, r24
    1bb8:	2d ec       	ldi	r18, 0xCD	; 205
    1bba:	3c ec       	ldi	r19, 0xCC	; 204
    1bbc:	4c ec       	ldi	r20, 0xCC	; 204
    1bbe:	5d e3       	ldi	r21, 0x3D	; 61
    1bc0:	c5 01       	movw	r24, r10
    1bc2:	b4 01       	movw	r22, r8
    1bc4:	5a d5       	rcall	.+2740   	; 0x267a <__mulsf3>
    1bc6:	9b 01       	movw	r18, r22
    1bc8:	ac 01       	movw	r20, r24
    1bca:	c7 01       	movw	r24, r14
    1bcc:	b6 01       	movw	r22, r12
    1bce:	9e d3       	rcall	.+1852   	; 0x230c <__addsf3>
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	60 83       	st	Z, r22
    1bd4:	71 83       	std	Z+1, r23	; 0x01
    1bd6:	82 83       	std	Z+2, r24	; 0x02
    1bd8:	93 83       	std	Z+3, r25	; 0x03
}
    1bda:	0f 90       	pop	r0
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	0f 90       	pop	r0
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	1f 91       	pop	r17
    1be8:	0f 91       	pop	r16
    1bea:	ff 90       	pop	r15
    1bec:	ef 90       	pop	r14
    1bee:	df 90       	pop	r13
    1bf0:	cf 90       	pop	r12
    1bf2:	bf 90       	pop	r11
    1bf4:	af 90       	pop	r10
    1bf6:	9f 90       	pop	r9
    1bf8:	8f 90       	pop	r8
    1bfa:	08 95       	ret

00001bfc <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1bfc:	cf 92       	push	r12
    1bfe:	df 92       	push	r13
    1c00:	ef 92       	push	r14
    1c02:	ff 92       	push	r15
    1c04:	cf 93       	push	r28
    1c06:	df 93       	push	r29
    1c08:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	7f d4       	rcall	.+2302   	; 0x250e <__floatunsisf>
    1c10:	20 e0       	ldi	r18, 0x00	; 0
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	40 ea       	ldi	r20, 0xA0	; 160
    1c16:	50 e4       	ldi	r21, 0x40	; 64
    1c18:	30 d5       	rcall	.+2656   	; 0x267a <__mulsf3>
    1c1a:	20 e0       	ldi	r18, 0x00	; 0
    1c1c:	30 e0       	ldi	r19, 0x00	; 0
    1c1e:	40 e8       	ldi	r20, 0x80	; 128
    1c20:	59 e3       	ldi	r21, 0x39	; 57
    1c22:	2b d5       	rcall	.+2646   	; 0x267a <__mulsf3>
    1c24:	6b 01       	movw	r12, r22
    1c26:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c28:	2d ec       	ldi	r18, 0xCD	; 205
    1c2a:	3c ec       	ldi	r19, 0xCC	; 204
    1c2c:	4c e6       	ldi	r20, 0x6C	; 108
    1c2e:	50 e4       	ldi	r21, 0x40	; 64
    1c30:	d1 d3       	rcall	.+1954   	; 0x23d4 <__cmpsf2>
    1c32:	18 16       	cp	r1, r24
    1c34:	74 f0       	brlt	.+28     	; 0x1c52 <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c36:	20 e0       	ldi	r18, 0x00	; 0
    1c38:	30 e0       	ldi	r19, 0x00	; 0
    1c3a:	40 ea       	ldi	r20, 0xA0	; 160
    1c3c:	51 e4       	ldi	r21, 0x41	; 65
    1c3e:	c7 01       	movw	r24, r14
    1c40:	b6 01       	movw	r22, r12
    1c42:	1b d5       	rcall	.+2614   	; 0x267a <__mulsf3>
    1c44:	20 e0       	ldi	r18, 0x00	; 0
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	40 eb       	ldi	r20, 0xB0	; 176
    1c4a:	51 e4       	ldi	r21, 0x41	; 65
    1c4c:	5e d3       	rcall	.+1724   	; 0x230a <__subsf3>
    1c4e:	33 d4       	rcall	.+2150   	; 0x24b6 <__fixunssfsi>
    1c50:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c52:	26 e6       	ldi	r18, 0x66	; 102
    1c54:	36 e6       	ldi	r19, 0x66	; 102
    1c56:	46 e9       	ldi	r20, 0x96	; 150
    1c58:	50 e4       	ldi	r21, 0x40	; 64
    1c5a:	c7 01       	movw	r24, r14
    1c5c:	b6 01       	movw	r22, r12
    1c5e:	ba d3       	rcall	.+1908   	; 0x23d4 <__cmpsf2>
    1c60:	18 16       	cp	r1, r24
    1c62:	bc f0       	brlt	.+46     	; 0x1c92 <handle_temp_sensor+0x96>
    1c64:	2d ec       	ldi	r18, 0xCD	; 205
    1c66:	3c ec       	ldi	r19, 0xCC	; 204
    1c68:	4c e6       	ldi	r20, 0x6C	; 108
    1c6a:	50 e4       	ldi	r21, 0x40	; 64
    1c6c:	c7 01       	movw	r24, r14
    1c6e:	b6 01       	movw	r22, r12
    1c70:	00 d5       	rcall	.+2560   	; 0x2672 <__gesf2>
    1c72:	18 16       	cp	r1, r24
    1c74:	74 f4       	brge	.+28     	; 0x1c92 <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c76:	20 e0       	ldi	r18, 0x00	; 0
    1c78:	30 e0       	ldi	r19, 0x00	; 0
    1c7a:	4e e5       	ldi	r20, 0x5E	; 94
    1c7c:	52 e4       	ldi	r21, 0x42	; 66
    1c7e:	c7 01       	movw	r24, r14
    1c80:	b6 01       	movw	r22, r12
    1c82:	fb d4       	rcall	.+2550   	; 0x267a <__mulsf3>
    1c84:	20 e0       	ldi	r18, 0x00	; 0
    1c86:	30 e8       	ldi	r19, 0x80	; 128
    1c88:	4b e1       	ldi	r20, 0x1B	; 27
    1c8a:	53 e4       	ldi	r21, 0x43	; 67
    1c8c:	3e d3       	rcall	.+1660   	; 0x230a <__subsf3>
    1c8e:	13 d4       	rcall	.+2086   	; 0x24b6 <__fixunssfsi>
    1c90:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c92:	26 e6       	ldi	r18, 0x66	; 102
    1c94:	36 e6       	ldi	r19, 0x66	; 102
    1c96:	46 e9       	ldi	r20, 0x96	; 150
    1c98:	50 e4       	ldi	r21, 0x40	; 64
    1c9a:	c7 01       	movw	r24, r14
    1c9c:	b6 01       	movw	r22, r12
    1c9e:	e9 d4       	rcall	.+2514   	; 0x2672 <__gesf2>
    1ca0:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1ca2:	74 f4       	brge	.+28     	; 0x1cc0 <handle_temp_sensor+0xc4>
    1ca4:	20 e0       	ldi	r18, 0x00	; 0
    1ca6:	30 e0       	ldi	r19, 0x00	; 0
    1ca8:	48 e4       	ldi	r20, 0x48	; 72
    1caa:	53 e4       	ldi	r21, 0x43	; 67
    1cac:	c7 01       	movw	r24, r14
    1cae:	b6 01       	movw	r22, r12
    1cb0:	e4 d4       	rcall	.+2504   	; 0x267a <__mulsf3>
    1cb2:	20 e0       	ldi	r18, 0x00	; 0
    1cb4:	30 e0       	ldi	r19, 0x00	; 0
    1cb6:	42 e5       	ldi	r20, 0x52	; 82
    1cb8:	54 e4       	ldi	r21, 0x44	; 68
    1cba:	27 d3       	rcall	.+1614   	; 0x230a <__subsf3>
    1cbc:	fc d3       	rcall	.+2040   	; 0x24b6 <__fixunssfsi>
    1cbe:	68 83       	st	Y, r22
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
	}
}
    1cc4:	ff 90       	pop	r15
    1cc6:	ef 90       	pop	r14
    1cc8:	df 90       	pop	r13
    1cca:	cf 90       	pop	r12
    1ccc:	08 95       	ret

00001cce <handle_joulemeter>:
    1cce:	4f 92       	push	r4
    1cd0:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cd2:	6f 92       	push	r6
    1cd4:	7f 92       	push	r7
    1cd6:	8f 92       	push	r8
    1cd8:	9f 92       	push	r9
    1cda:	af 92       	push	r10
    1cdc:	bf 92       	push	r11
    1cde:	cf 92       	push	r12
    1ce0:	df 92       	push	r13
    1ce2:	ef 92       	push	r14
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	28 97       	sbiw	r28, 0x08	; 8
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	cd bf       	out	0x3d, r28	; 61
    1cfc:	6c 01       	movw	r12, r24
    1cfe:	49 83       	std	Y+1, r20	; 0x01
    1d00:	5a 83       	std	Y+2, r21	; 0x02
    1d02:	6b 83       	std	Y+3, r22	; 0x03
    1d04:	7c 83       	std	Y+4, r23	; 0x04
    1d06:	0d 83       	std	Y+5, r16	; 0x05
    1d08:	1e 83       	std	Y+6, r17	; 0x06
    1d0a:	2f 83       	std	Y+7, r18	; 0x07
    1d0c:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1d0e:	6d 81       	ldd	r22, Y+5	; 0x05
    1d10:	7e 81       	ldd	r23, Y+6	; 0x06
    1d12:	8f 81       	ldd	r24, Y+7	; 0x07
    1d14:	98 85       	ldd	r25, Y+8	; 0x08
    1d16:	29 81       	ldd	r18, Y+1	; 0x01
    1d18:	3a 81       	ldd	r19, Y+2	; 0x02
    1d1a:	4b 81       	ldd	r20, Y+3	; 0x03
    1d1c:	5c 81       	ldd	r21, Y+4	; 0x04
    1d1e:	f6 01       	movw	r30, r12
    1d20:	80 80       	ld	r8, Z
    1d22:	91 80       	ldd	r9, Z+1	; 0x01
    1d24:	a2 80       	ldd	r10, Z+2	; 0x02
    1d26:	b3 80       	ldd	r11, Z+3	; 0x03
    1d28:	a8 d4       	rcall	.+2384   	; 0x267a <__mulsf3>
    1d2a:	2b 01       	movw	r4, r22
    1d2c:	3c 01       	movw	r6, r24
    1d2e:	6e 2d       	mov	r22, r14
    1d30:	70 e0       	ldi	r23, 0x00	; 0
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	eb d3       	rcall	.+2006   	; 0x250e <__floatunsisf>
    1d38:	9b 01       	movw	r18, r22
    1d3a:	ac 01       	movw	r20, r24
    1d3c:	c3 01       	movw	r24, r6
    1d3e:	b2 01       	movw	r22, r4
    1d40:	9c d4       	rcall	.+2360   	; 0x267a <__mulsf3>
    1d42:	20 e0       	ldi	r18, 0x00	; 0
    1d44:	30 e0       	ldi	r19, 0x00	; 0
    1d46:	4a e7       	ldi	r20, 0x7A	; 122
    1d48:	54 e4       	ldi	r21, 0x44	; 68
    1d4a:	48 d3       	rcall	.+1680   	; 0x23dc <__divsf3>
    1d4c:	a5 01       	movw	r20, r10
    1d4e:	94 01       	movw	r18, r8
    1d50:	dd d2       	rcall	.+1466   	; 0x230c <__addsf3>
    1d52:	f6 01       	movw	r30, r12
    1d54:	60 83       	st	Z, r22
    1d56:	71 83       	std	Z+1, r23	; 0x01
    1d58:	82 83       	std	Z+2, r24	; 0x02
    1d5a:	93 83       	std	Z+3, r25	; 0x03
}
    1d5c:	28 96       	adiw	r28, 0x08	; 8
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	1f 91       	pop	r17
    1d6e:	0f 91       	pop	r16
    1d70:	ef 90       	pop	r14
    1d72:	df 90       	pop	r13
    1d74:	cf 90       	pop	r12
    1d76:	bf 90       	pop	r11
    1d78:	af 90       	pop	r10
    1d7a:	9f 90       	pop	r9
    1d7c:	8f 90       	pop	r8
    1d7e:	7f 90       	pop	r7
    1d80:	6f 90       	pop	r6
    1d82:	5f 90       	pop	r5
    1d84:	4f 90       	pop	r4
    1d86:	08 95       	ret

00001d88 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	88 30       	cpi	r24, 0x08	; 8
    1d8c:	91 05       	cpc	r25, r1
    1d8e:	88 f5       	brcc	.+98     	; 0x1df2 <Set_ADC_Channel_ext+0x6a>
    1d90:	fc 01       	movw	r30, r24
    1d92:	e6 5b       	subi	r30, 0xB6	; 182
    1d94:	ff 4f       	sbci	r31, 0xFF	; 255
    1d96:	d4 c4       	rjmp	.+2472   	; 0x2740 <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d98:	86 e0       	ldi	r24, 0x06	; 6
    1d9a:	fb 01       	movw	r30, r22
    1d9c:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1d9e:	11 82       	std	Z+1, r1	; 0x01
		break;
    1da0:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1da2:	86 e0       	ldi	r24, 0x06	; 6
    1da4:	fb 01       	movw	r30, r22
    1da6:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1da8:	80 e4       	ldi	r24, 0x40	; 64
    1daa:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dac:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1dae:	86 e0       	ldi	r24, 0x06	; 6
    1db0:	fb 01       	movw	r30, r22
    1db2:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1db4:	80 e8       	ldi	r24, 0x80	; 128
    1db6:	81 83       	std	Z+1, r24	; 0x01
		break;
    1db8:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1dba:	86 e0       	ldi	r24, 0x06	; 6
    1dbc:	fb 01       	movw	r30, r22
    1dbe:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1dc0:	80 ec       	ldi	r24, 0xC0	; 192
    1dc2:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dc4:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dc6:	87 e0       	ldi	r24, 0x07	; 7
    1dc8:	fb 01       	movw	r30, r22
    1dca:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1dcc:	11 82       	std	Z+1, r1	; 0x01
		break;
    1dce:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dd0:	87 e0       	ldi	r24, 0x07	; 7
    1dd2:	fb 01       	movw	r30, r22
    1dd4:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1dd6:	80 e4       	ldi	r24, 0x40	; 64
    1dd8:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dda:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1ddc:	87 e0       	ldi	r24, 0x07	; 7
    1dde:	fb 01       	movw	r30, r22
    1de0:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1de2:	80 e8       	ldi	r24, 0x80	; 128
    1de4:	81 83       	std	Z+1, r24	; 0x01
		break;
    1de6:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1de8:	87 e0       	ldi	r24, 0x07	; 7
    1dea:	fb 01       	movw	r30, r22
    1dec:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1dee:	80 ec       	ldi	r24, 0xC0	; 192
    1df0:	81 83       	std	Z+1, r24	; 0x01
    1df2:	08 95       	ret

00001df4 <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1df4:	1f 92       	push	r1
    1df6:	0f 92       	push	r0
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	0f 92       	push	r0
    1dfc:	11 24       	eor	r1, r1
    1dfe:	0b b6       	in	r0, 0x3b	; 59
    1e00:	0f 92       	push	r0
    1e02:	2f 93       	push	r18
    1e04:	3f 93       	push	r19
    1e06:	4f 93       	push	r20
    1e08:	5f 93       	push	r21
    1e0a:	6f 93       	push	r22
    1e0c:	8f 93       	push	r24
    1e0e:	9f 93       	push	r25
    1e10:	af 93       	push	r26
    1e12:	bf 93       	push	r27
    1e14:	ef 93       	push	r30
    1e16:	ff 93       	push	r31
    1e18:	cf 93       	push	r28
    1e1a:	df 93       	push	r29
    1e1c:	1f 92       	push	r1
    1e1e:	cd b7       	in	r28, 0x3d	; 61
    1e20:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1e22:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e26:	80 ff       	sbrs	r24, 0
    1e28:	47 c0       	rjmp	.+142    	; 0x1eb8 <__vector_18+0xc4>
    1e2a:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e2e:	90 ff       	sbrs	r25, 0
    1e30:	43 c0       	rjmp	.+134    	; 0x1eb8 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e32:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e36:	ee ee       	ldi	r30, 0xEE	; 238
    1e38:	f0 e0       	ldi	r31, 0x00	; 0
    1e3a:	80 81       	ld	r24, Z
    1e3c:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e3e:	80 81       	ld	r24, Z
    1e40:	8f 7b       	andi	r24, 0xBF	; 191
    1e42:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e44:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e48:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e4c:	98 17       	cp	r25, r24
    1e4e:	89 f1       	breq	.+98     	; 0x1eb2 <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e50:	8f 70       	andi	r24, 0x0F	; 15
    1e52:	2b e0       	ldi	r18, 0x0B	; 11
    1e54:	82 9f       	mul	r24, r18
    1e56:	c0 01       	movw	r24, r0
    1e58:	11 24       	eor	r1, r1
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	e1 54       	subi	r30, 0x41	; 65
    1e5e:	fd 4f       	sbci	r31, 0xFD	; 253
    1e60:	20 81       	ld	r18, Z
    1e62:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e66:	20 81       	ld	r18, Z
    1e68:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e6c:	21 81       	ldd	r18, Z+1	; 0x01
    1e6e:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e72:	23 81       	ldd	r18, Z+3	; 0x03
    1e74:	aa ef       	ldi	r26, 0xFA	; 250
    1e76:	b0 e0       	ldi	r27, 0x00	; 0
    1e78:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e7a:	24 81       	ldd	r18, Z+4	; 0x04
    1e7c:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1e7e:	25 81       	ldd	r18, Z+5	; 0x05
    1e80:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e82:	26 81       	ldd	r18, Z+6	; 0x06
    1e84:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e86:	27 81       	ldd	r18, Z+7	; 0x07
    1e88:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e8a:	20 85       	ldd	r18, Z+8	; 0x08
    1e8c:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e8e:	21 85       	ldd	r18, Z+9	; 0x09
    1e90:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e92:	22 85       	ldd	r18, Z+10	; 0x0a
    1e94:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1e96:	fc 01       	movw	r30, r24
    1e98:	ef 53       	subi	r30, 0x3F	; 63
    1e9a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e9c:	80 81       	ld	r24, Z
    1e9e:	8f 70       	andi	r24, 0x0F	; 15
    1ea0:	80 64       	ori	r24, 0x40	; 64
    1ea2:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1ea6:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1eb0:	7d c0       	rjmp	.+250    	; 0x1fac <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1eb2:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1eb6:	7a c0       	rjmp	.+244    	; 0x1fac <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1eb8:	81 ff       	sbrs	r24, 1
    1eba:	78 c0       	rjmp	.+240    	; 0x1fac <__vector_18+0x1b8>
    1ebc:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1ec0:	81 ff       	sbrs	r24, 1
    1ec2:	74 c0       	rjmp	.+232    	; 0x1fac <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1ec4:	80 e1       	ldi	r24, 0x10	; 16
    1ec6:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1eca:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ece:	28 2f       	mov	r18, r24
    1ed0:	30 e0       	ldi	r19, 0x00	; 0
    1ed2:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1ed6:	29 1b       	sub	r18, r25
    1ed8:	31 09       	sbc	r19, r1
    1eda:	2f 77       	andi	r18, 0x7F	; 127
    1edc:	33 27       	eor	r19, r19
    1ede:	20 31       	cpi	r18, 0x10	; 16
    1ee0:	31 05       	cpc	r19, r1
    1ee2:	0c f0       	brlt	.+2      	; 0x1ee6 <__vector_18+0xf2>
    1ee4:	58 c0       	rjmp	.+176    	; 0x1f96 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1ee6:	e8 2f       	mov	r30, r24
    1ee8:	ef 70       	andi	r30, 0x0F	; 15
    1eea:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1eee:	2e 2f       	mov	r18, r30
    1ef0:	30 e0       	ldi	r19, 0x00	; 0
    1ef2:	4b e0       	ldi	r20, 0x0B	; 11
    1ef4:	e4 9f       	mul	r30, r20
    1ef6:	f0 01       	movw	r30, r0
    1ef8:	11 24       	eor	r1, r1
    1efa:	e1 5f       	subi	r30, 0xF1	; 241
    1efc:	fd 4f       	sbci	r31, 0xFD	; 253
    1efe:	9f 70       	andi	r25, 0x0F	; 15
    1f00:	42 81       	ldd	r20, Z+2	; 0x02
    1f02:	40 7f       	andi	r20, 0xF0	; 240
    1f04:	94 2b       	or	r25, r20
    1f06:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1f08:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1f0c:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f10:	40 7e       	andi	r20, 0xE0	; 224
    1f12:	97 70       	andi	r25, 0x07	; 7
    1f14:	94 2b       	or	r25, r20
    1f16:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1f18:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1f1c:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1f1e:	aa ef       	ldi	r26, 0xFA	; 250
    1f20:	b0 e0       	ldi	r27, 0x00	; 0
    1f22:	9c 91       	ld	r25, X
    1f24:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f26:	9c 91       	ld	r25, X
    1f28:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f2a:	9c 91       	ld	r25, X
    1f2c:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f2e:	9c 91       	ld	r25, X
    1f30:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f32:	9c 91       	ld	r25, X
    1f34:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f36:	9c 91       	ld	r25, X
    1f38:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f3a:	9c 91       	ld	r25, X
    1f3c:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f3e:	9c 91       	ld	r25, X
    1f40:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f42:	8f 5f       	subi	r24, 0xFF	; 255
    1f44:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f48:	40 81       	ld	r20, Z
    1f4a:	42 95       	swap	r20
    1f4c:	46 95       	lsr	r20
    1f4e:	47 70       	andi	r20, 0x07	; 7
    1f50:	51 81       	ldd	r21, Z+1	; 0x01
    1f52:	65 2f       	mov	r22, r21
    1f54:	66 0f       	add	r22, r22
    1f56:	66 0f       	add	r22, r22
    1f58:	66 0f       	add	r22, r22
    1f5a:	86 2f       	mov	r24, r22
    1f5c:	84 2b       	or	r24, r20
    1f5e:	95 2f       	mov	r25, r21
    1f60:	92 95       	swap	r25
    1f62:	96 95       	lsr	r25
    1f64:	97 70       	andi	r25, 0x07	; 7
    1f66:	89 2b       	or	r24, r25
    1f68:	b1 f4       	brne	.+44     	; 0x1f96 <__vector_18+0x1a2>
    1f6a:	8b e0       	ldi	r24, 0x0B	; 11
    1f6c:	82 9f       	mul	r24, r18
    1f6e:	f0 01       	movw	r30, r0
    1f70:	83 9f       	mul	r24, r19
    1f72:	f0 0d       	add	r31, r0
    1f74:	11 24       	eor	r1, r1
    1f76:	e1 5f       	subi	r30, 0xF1	; 241
    1f78:	fd 4f       	sbci	r31, 0xFD	; 253
    1f7a:	83 81       	ldd	r24, Z+3	; 0x03
    1f7c:	83 30       	cpi	r24, 0x03	; 3
    1f7e:	59 f4       	brne	.+22     	; 0x1f96 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1f80:	98 e0       	ldi	r25, 0x08	; 8
    1f82:	88 e1       	ldi	r24, 0x18	; 24
    1f84:	0f b6       	in	r0, 0x3f	; 63
    1f86:	f8 94       	cli
    1f88:	a8 95       	wdr
    1f8a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f94:	ff cf       	rjmp	.-2      	; 0x1f94 <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1f96:	ee ee       	ldi	r30, 0xEE	; 238
    1f98:	f0 e0       	ldi	r31, 0x00	; 0
    1f9a:	80 81       	ld	r24, Z
    1f9c:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1f9e:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1fa0:	80 81       	ld	r24, Z
    1fa2:	8f 7d       	andi	r24, 0xDF	; 223
    1fa4:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1fa6:	80 e8       	ldi	r24, 0x80	; 128
    1fa8:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1fac:	0f 90       	pop	r0
    1fae:	df 91       	pop	r29
    1fb0:	cf 91       	pop	r28
    1fb2:	ff 91       	pop	r31
    1fb4:	ef 91       	pop	r30
    1fb6:	bf 91       	pop	r27
    1fb8:	af 91       	pop	r26
    1fba:	9f 91       	pop	r25
    1fbc:	8f 91       	pop	r24
    1fbe:	6f 91       	pop	r22
    1fc0:	5f 91       	pop	r21
    1fc2:	4f 91       	pop	r20
    1fc4:	3f 91       	pop	r19
    1fc6:	2f 91       	pop	r18
    1fc8:	0f 90       	pop	r0
    1fca:	0b be       	out	0x3b, r0	; 59
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63
    1fd0:	0f 90       	pop	r0
    1fd2:	1f 90       	pop	r1
    1fd4:	18 95       	reti

00001fd6 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1fd6:	cf 93       	push	r28
    1fd8:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1fda:	e8 ed       	ldi	r30, 0xD8	; 216
    1fdc:	f0 e0       	ldi	r31, 0x00	; 0
    1fde:	21 e0       	ldi	r18, 0x01	; 1
    1fe0:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1fe2:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1fe6:	2c e0       	ldi	r18, 0x0C	; 12
    1fe8:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1fec:	27 e3       	ldi	r18, 0x37	; 55
    1fee:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1ff2:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1ff6:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1ffa:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1ffe:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    2002:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    2006:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    200a:	cd ee       	ldi	r28, 0xED	; 237
    200c:	d0 e0       	ldi	r29, 0x00	; 0
    200e:	18 82       	st	Y, r1
	CANSTMOB = 0;
    2010:	ae ee       	ldi	r26, 0xEE	; 238
    2012:	b0 e0       	ldi	r27, 0x00	; 0
    2014:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    2016:	20 e1       	ldi	r18, 0x10	; 16
    2018:	28 83       	st	Y, r18
	CANSTMOB = 0;
    201a:	1c 92       	st	X, r1
	CANIDM4 = 0;
    201c:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    2020:	28 2f       	mov	r18, r24
    2022:	22 95       	swap	r18
    2024:	22 0f       	add	r18, r18
    2026:	20 7e       	andi	r18, 0xE0	; 224
    2028:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    202c:	96 95       	lsr	r25
    202e:	87 95       	ror	r24
    2030:	96 95       	lsr	r25
    2032:	87 95       	ror	r24
    2034:	96 95       	lsr	r25
    2036:	87 95       	ror	r24
    2038:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    203c:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    2040:	86 2f       	mov	r24, r22
    2042:	82 95       	swap	r24
    2044:	88 0f       	add	r24, r24
    2046:	80 7e       	andi	r24, 0xE0	; 224
    2048:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    204c:	76 95       	lsr	r23
    204e:	67 95       	ror	r22
    2050:	76 95       	lsr	r23
    2052:	67 95       	ror	r22
    2054:	76 95       	lsr	r23
    2056:	67 95       	ror	r22
    2058:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    205c:	80 e8       	ldi	r24, 0x80	; 128
    205e:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    2062:	83 e0       	ldi	r24, 0x03	; 3
    2064:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    2068:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    206c:	80 eb       	ldi	r24, 0xB0	; 176
    206e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    2072:	82 e0       	ldi	r24, 0x02	; 2
    2074:	80 83       	st	Z, r24

	reset = 0;
    2076:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	08 95       	ret

00002080 <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    2080:	cf 93       	push	r28
    2082:	df 93       	push	r29
    2084:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    2086:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    208a:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    208e:	24 17       	cp	r18, r20
    2090:	89 f1       	breq	.+98     	; 0x20f4 <can_read_message_if_new+0x74>
    2092:	a4 2f       	mov	r26, r20
    2094:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    2096:	8b e0       	ldi	r24, 0x0B	; 11
    2098:	a8 9f       	mul	r26, r24
    209a:	b0 01       	movw	r22, r0
    209c:	11 24       	eor	r1, r1
    209e:	fb 01       	movw	r30, r22
    20a0:	e1 5f       	subi	r30, 0xF1	; 241
    20a2:	fd 4f       	sbci	r31, 0xFD	; 253
    20a4:	20 81       	ld	r18, Z
    20a6:	22 95       	swap	r18
    20a8:	26 95       	lsr	r18
    20aa:	27 70       	andi	r18, 0x07	; 7
    20ac:	31 81       	ldd	r19, Z+1	; 0x01
    20ae:	53 2f       	mov	r21, r19
    20b0:	55 0f       	add	r21, r21
    20b2:	55 0f       	add	r21, r21
    20b4:	55 0f       	add	r21, r21
    20b6:	25 2b       	or	r18, r21
    20b8:	32 95       	swap	r19
    20ba:	36 95       	lsr	r19
    20bc:	37 70       	andi	r19, 0x07	; 7
    20be:	28 83       	st	Y, r18
    20c0:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    20c2:	fb 01       	movw	r30, r22
    20c4:	ef 5e       	subi	r30, 0xEF	; 239
    20c6:	fd 4f       	sbci	r31, 0xFD	; 253
    20c8:	20 81       	ld	r18, Z
    20ca:	2f 70       	andi	r18, 0x0F	; 15
    20cc:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20ce:	22 23       	and	r18, r18
    20d0:	99 f0       	breq	.+38     	; 0x20f8 <can_read_message_if_new+0x78>
    20d2:	db 01       	movw	r26, r22
    20d4:	ae 5e       	subi	r26, 0xEE	; 238
    20d6:	bd 4f       	sbci	r27, 0xFD	; 253
    20d8:	fe 01       	movw	r30, r28
    20da:	33 96       	adiw	r30, 0x03	; 3
    20dc:	30 e0       	ldi	r19, 0x00	; 0
    20de:	2d 5f       	subi	r18, 0xFD	; 253
    20e0:	3f 4f       	sbci	r19, 0xFF	; 255
    20e2:	ce 01       	movw	r24, r28
    20e4:	82 0f       	add	r24, r18
    20e6:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    20e8:	2d 91       	ld	r18, X+
    20ea:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    20ec:	e8 17       	cp	r30, r24
    20ee:	f9 07       	cpc	r31, r25
    20f0:	d9 f7       	brne	.-10     	; 0x20e8 <can_read_message_if_new+0x68>
    20f2:	02 c0       	rjmp	.+4      	; 0x20f8 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	04 c0       	rjmp	.+8      	; 0x2100 <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    20f8:	4f 5f       	subi	r20, 0xFF	; 255
    20fa:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    20fe:	81 e0       	ldi	r24, 0x01	; 1
}
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	08 95       	ret

00002106 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    210c:	ab ed       	ldi	r26, 0xDB	; 219
    210e:	b0 e0       	ldi	r27, 0x00	; 0
    2110:	8c 91       	ld	r24, X
    2112:	8f 77       	andi	r24, 0x7F	; 127
    2114:	8c 93       	st	X, r24

	if (!tx_busy) {
    2116:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    211a:	81 11       	cpse	r24, r1
    211c:	27 c0       	rjmp	.+78     	; 0x216c <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    211e:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    2122:	80 81       	ld	r24, Z
    2124:	82 95       	swap	r24
    2126:	88 0f       	add	r24, r24
    2128:	80 7e       	andi	r24, 0xE0	; 224
    212a:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    212e:	80 81       	ld	r24, Z
    2130:	91 81       	ldd	r25, Z+1	; 0x01
    2132:	96 95       	lsr	r25
    2134:	87 95       	ror	r24
    2136:	96 95       	lsr	r25
    2138:	87 95       	ror	r24
    213a:	96 95       	lsr	r25
    213c:	87 95       	ror	r24
    213e:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2142:	df 01       	movw	r26, r30
    2144:	13 96       	adiw	r26, 0x03	; 3
    2146:	9f 01       	movw	r18, r30
    2148:	25 5f       	subi	r18, 0xF5	; 245
    214a:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    214c:	ca ef       	ldi	r28, 0xFA	; 250
    214e:	d0 e0       	ldi	r29, 0x00	; 0
    2150:	9d 91       	ld	r25, X+
    2152:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    2154:	a2 17       	cp	r26, r18
    2156:	b3 07       	cpc	r27, r19
    2158:	d9 f7       	brne	.-10     	; 0x2150 <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    2160:	82 81       	ldd	r24, Z+2	; 0x02
    2162:	80 64       	ori	r24, 0x40	; 64
    2164:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	43 c0       	rjmp	.+134    	; 0x21f2 <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    216c:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    2170:	82 2f       	mov	r24, r18
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    2178:	83 1b       	sub	r24, r19
    217a:	91 09       	sbc	r25, r1
    217c:	8f 77       	andi	r24, 0x7F	; 127
    217e:	99 27       	eor	r25, r25
    2180:	40 97       	sbiw	r24, 0x10	; 16
    2182:	b1 f1       	breq	.+108    	; 0x21f0 <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    2184:	a2 2f       	mov	r26, r18
    2186:	af 70       	andi	r26, 0x0F	; 15
    2188:	8b e0       	ldi	r24, 0x0B	; 11
    218a:	a8 9f       	mul	r26, r24
    218c:	d0 01       	movw	r26, r0
    218e:	11 24       	eor	r1, r1
    2190:	ed 01       	movw	r28, r26
    2192:	c1 54       	subi	r28, 0x41	; 65
    2194:	dd 4f       	sbci	r29, 0xFD	; 253
    2196:	80 81       	ld	r24, Z
    2198:	98 2f       	mov	r25, r24
    219a:	92 95       	swap	r25
    219c:	99 0f       	add	r25, r25
    219e:	90 7e       	andi	r25, 0xE0	; 224
    21a0:	88 81       	ld	r24, Y
    21a2:	8f 71       	andi	r24, 0x1F	; 31
    21a4:	89 2b       	or	r24, r25
    21a6:	88 83       	st	Y, r24
    21a8:	80 81       	ld	r24, Z
    21aa:	98 2f       	mov	r25, r24
    21ac:	96 95       	lsr	r25
    21ae:	96 95       	lsr	r25
    21b0:	96 95       	lsr	r25
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
    21b4:	80 7e       	andi	r24, 0xE0	; 224
    21b6:	89 2b       	or	r24, r25
    21b8:	89 83       	std	Y+1, r24	; 0x01
    21ba:	91 81       	ldd	r25, Z+1	; 0x01
    21bc:	92 95       	swap	r25
    21be:	99 0f       	add	r25, r25
    21c0:	90 7e       	andi	r25, 0xE0	; 224
    21c2:	8f 71       	andi	r24, 0x1F	; 31
    21c4:	89 2b       	or	r24, r25
    21c6:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21c8:	82 81       	ldd	r24, Z+2	; 0x02
    21ca:	98 2f       	mov	r25, r24
    21cc:	9f 70       	andi	r25, 0x0F	; 15
    21ce:	8a 81       	ldd	r24, Y+2	; 0x02
    21d0:	80 7f       	andi	r24, 0xF0	; 240
    21d2:	89 2b       	or	r24, r25
    21d4:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21d6:	ae 53       	subi	r26, 0x3E	; 62
    21d8:	bd 4f       	sbci	r27, 0xFD	; 253
    21da:	33 96       	adiw	r30, 0x03	; 3
    21dc:	88 e0       	ldi	r24, 0x08	; 8
    21de:	01 90       	ld	r0, Z+
    21e0:	0d 92       	st	X+, r0
    21e2:	8a 95       	dec	r24
    21e4:	e1 f7       	brne	.-8      	; 0x21de <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    21e6:	2f 5f       	subi	r18, 0xFF	; 255
    21e8:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	01 c0       	rjmp	.+2      	; 0x21f2 <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    21f0:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    21f2:	eb ed       	ldi	r30, 0xDB	; 219
    21f4:	f0 e0       	ldi	r31, 0x00	; 0
    21f6:	90 81       	ld	r25, Z
    21f8:	90 68       	ori	r25, 0x80	; 128
    21fa:	90 83       	st	Z, r25

	return result;
    21fc:	df 91       	pop	r29
    21fe:	cf 91       	pop	r28
    2200:	08 95       	ret

00002202 <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    2202:	95 b1       	in	r25, 0x05	; 5
    2204:	89 2b       	or	r24, r25
    2206:	85 b9       	out	0x05, r24	; 5
    2208:	08 95       	ret

0000220a <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    220a:	84 b1       	in	r24, 0x04	; 4
    220c:	80 6e       	ori	r24, 0xE0	; 224
    220e:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    2210:	80 ee       	ldi	r24, 0xE0	; 224
    2212:	f7 cf       	rjmp	.-18     	; 0x2202 <rgbled_turn_off>
    2214:	08 95       	ret

00002216 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2216:	95 b1       	in	r25, 0x05	; 5
    2218:	80 95       	com	r24
    221a:	98 23       	and	r25, r24
    221c:	95 b9       	out	0x05, r25	; 5
    221e:	08 95       	ret

00002220 <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    2220:	95 b1       	in	r25, 0x05	; 5
    2222:	89 27       	eor	r24, r25
    2224:	85 b9       	out	0x05, r24	; 5
    2226:	08 95       	ret

00002228 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    2228:	94 b1       	in	r25, 0x04	; 4
    222a:	97 60       	ori	r25, 0x07	; 7
    222c:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    222e:	82 fb       	bst	r24, 2
    2230:	99 27       	eor	r25, r25
    2232:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    2234:	28 2f       	mov	r18, r24
    2236:	22 70       	andi	r18, 0x02	; 2
    2238:	81 70       	andi	r24, 0x01	; 1
    223a:	80 65       	ori	r24, 0x50	; 80
    223c:	82 2b       	or	r24, r18
    223e:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    2240:	8c b5       	in	r24, 0x2c	; 44
    2242:	83 7f       	andi	r24, 0xF3	; 243
    2244:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2246:	9d bd       	out	0x2d, r25	; 45
    2248:	08 95       	ret

0000224a <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    224a:	cf 93       	push	r28
    224c:	df 93       	push	r29
    224e:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    2250:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    2252:	41 15       	cp	r20, r1
    2254:	51 05       	cpc	r21, r1
    2256:	c1 f0       	breq	.+48     	; 0x2288 <spi_trancieve+0x3e>
    2258:	fb 01       	movw	r30, r22
    225a:	dc 01       	movw	r26, r24
    225c:	46 0f       	add	r20, r22
    225e:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    2260:	8f ef       	ldi	r24, 0xFF	; 255
    2262:	20 97       	sbiw	r28, 0x00	; 0
    2264:	11 f0       	breq	.+4      	; 0x226a <spi_trancieve+0x20>
    2266:	9c 91       	ld	r25, X
    2268:	01 c0       	rjmp	.+2      	; 0x226c <spi_trancieve+0x22>
    226a:	98 2f       	mov	r25, r24
    226c:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    226e:	0d b4       	in	r0, 0x2d	; 45
    2270:	07 fe       	sbrs	r0, 7
    2272:	fd cf       	rjmp	.-6      	; 0x226e <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    2274:	61 15       	cp	r22, r1
    2276:	71 05       	cpc	r23, r1
    2278:	11 f0       	breq	.+4      	; 0x227e <spi_trancieve+0x34>
    227a:	9e b5       	in	r25, 0x2e	; 46
    227c:	90 83       	st	Z, r25
    227e:	31 96       	adiw	r30, 0x01	; 1
    2280:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    2282:	e4 17       	cp	r30, r20
    2284:	f5 07       	cpc	r31, r21
    2286:	69 f7       	brne	.-38     	; 0x2262 <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2288:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    228a:	28 9a       	sbi	0x05, 0	; 5
	}
}
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	08 95       	ret

00002292 <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    2292:	1f 92       	push	r1
    2294:	0f 92       	push	r0
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	0f 92       	push	r0
    229a:	11 24       	eor	r1, r1
    229c:	0b b6       	in	r0, 0x3b	; 59
    229e:	0f 92       	push	r0
    22a0:	2f 93       	push	r18
    22a2:	3f 93       	push	r19
    22a4:	4f 93       	push	r20
    22a6:	5f 93       	push	r21
    22a8:	6f 93       	push	r22
    22aa:	7f 93       	push	r23
    22ac:	8f 93       	push	r24
    22ae:	af 93       	push	r26
    22b0:	bf 93       	push	r27
    22b2:	ef 93       	push	r30
    22b4:	ff 93       	push	r31
    22b6:	af e8       	ldi	r26, 0x8F	; 143
    22b8:	b3 e0       	ldi	r27, 0x03	; 3
    22ba:	ef e6       	ldi	r30, 0x6F	; 111
    22bc:	f3 e0       	ldi	r31, 0x03	; 3
    22be:	2f e8       	ldi	r18, 0x8F	; 143
    22c0:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    22c2:	8d 91       	ld	r24, X+
    22c4:	88 23       	and	r24, r24
    22c6:	59 f0       	breq	.+22     	; 0x22de <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22c8:	40 81       	ld	r20, Z
    22ca:	51 81       	ldd	r21, Z+1	; 0x01
    22cc:	62 81       	ldd	r22, Z+2	; 0x02
    22ce:	73 81       	ldd	r23, Z+3	; 0x03
    22d0:	50 5e       	subi	r21, 0xE0	; 224
    22d2:	6f 4f       	sbci	r22, 0xFF	; 255
    22d4:	7f 4f       	sbci	r23, 0xFF	; 255
    22d6:	40 83       	st	Z, r20
    22d8:	51 83       	std	Z+1, r21	; 0x01
    22da:	62 83       	std	Z+2, r22	; 0x02
    22dc:	73 83       	std	Z+3, r23	; 0x03
    22de:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    22e0:	e2 17       	cp	r30, r18
    22e2:	f3 07       	cpc	r31, r19
    22e4:	71 f7       	brne	.-36     	; 0x22c2 <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    22e6:	ff 91       	pop	r31
    22e8:	ef 91       	pop	r30
    22ea:	bf 91       	pop	r27
    22ec:	af 91       	pop	r26
    22ee:	8f 91       	pop	r24
    22f0:	7f 91       	pop	r23
    22f2:	6f 91       	pop	r22
    22f4:	5f 91       	pop	r21
    22f6:	4f 91       	pop	r20
    22f8:	3f 91       	pop	r19
    22fa:	2f 91       	pop	r18
    22fc:	0f 90       	pop	r0
    22fe:	0b be       	out	0x3b, r0	; 59
    2300:	0f 90       	pop	r0
    2302:	0f be       	out	0x3f, r0	; 63
    2304:	0f 90       	pop	r0
    2306:	1f 90       	pop	r1
    2308:	18 95       	reti

0000230a <__subsf3>:
    230a:	50 58       	subi	r21, 0x80	; 128

0000230c <__addsf3>:
    230c:	bb 27       	eor	r27, r27
    230e:	aa 27       	eor	r26, r26
    2310:	0e d0       	rcall	.+28     	; 0x232e <__addsf3x>
    2312:	75 c1       	rjmp	.+746    	; 0x25fe <__fp_round>
    2314:	66 d1       	rcall	.+716    	; 0x25e2 <__fp_pscA>
    2316:	30 f0       	brcs	.+12     	; 0x2324 <__addsf3+0x18>
    2318:	6b d1       	rcall	.+726    	; 0x25f0 <__fp_pscB>
    231a:	20 f0       	brcs	.+8      	; 0x2324 <__addsf3+0x18>
    231c:	31 f4       	brne	.+12     	; 0x232a <__addsf3+0x1e>
    231e:	9f 3f       	cpi	r25, 0xFF	; 255
    2320:	11 f4       	brne	.+4      	; 0x2326 <__addsf3+0x1a>
    2322:	1e f4       	brtc	.+6      	; 0x232a <__addsf3+0x1e>
    2324:	5b c1       	rjmp	.+694    	; 0x25dc <__fp_nan>
    2326:	0e f4       	brtc	.+2      	; 0x232a <__addsf3+0x1e>
    2328:	e0 95       	com	r30
    232a:	e7 fb       	bst	r30, 7
    232c:	51 c1       	rjmp	.+674    	; 0x25d0 <__fp_inf>

0000232e <__addsf3x>:
    232e:	e9 2f       	mov	r30, r25
    2330:	77 d1       	rcall	.+750    	; 0x2620 <__fp_split3>
    2332:	80 f3       	brcs	.-32     	; 0x2314 <__addsf3+0x8>
    2334:	ba 17       	cp	r27, r26
    2336:	62 07       	cpc	r22, r18
    2338:	73 07       	cpc	r23, r19
    233a:	84 07       	cpc	r24, r20
    233c:	95 07       	cpc	r25, r21
    233e:	18 f0       	brcs	.+6      	; 0x2346 <__addsf3x+0x18>
    2340:	71 f4       	brne	.+28     	; 0x235e <__addsf3x+0x30>
    2342:	9e f5       	brtc	.+102    	; 0x23aa <__addsf3x+0x7c>
    2344:	8f c1       	rjmp	.+798    	; 0x2664 <__fp_zero>
    2346:	0e f4       	brtc	.+2      	; 0x234a <__addsf3x+0x1c>
    2348:	e0 95       	com	r30
    234a:	0b 2e       	mov	r0, r27
    234c:	ba 2f       	mov	r27, r26
    234e:	a0 2d       	mov	r26, r0
    2350:	0b 01       	movw	r0, r22
    2352:	b9 01       	movw	r22, r18
    2354:	90 01       	movw	r18, r0
    2356:	0c 01       	movw	r0, r24
    2358:	ca 01       	movw	r24, r20
    235a:	a0 01       	movw	r20, r0
    235c:	11 24       	eor	r1, r1
    235e:	ff 27       	eor	r31, r31
    2360:	59 1b       	sub	r21, r25
    2362:	99 f0       	breq	.+38     	; 0x238a <__addsf3x+0x5c>
    2364:	59 3f       	cpi	r21, 0xF9	; 249
    2366:	50 f4       	brcc	.+20     	; 0x237c <__addsf3x+0x4e>
    2368:	50 3e       	cpi	r21, 0xE0	; 224
    236a:	68 f1       	brcs	.+90     	; 0x23c6 <__addsf3x+0x98>
    236c:	1a 16       	cp	r1, r26
    236e:	f0 40       	sbci	r31, 0x00	; 0
    2370:	a2 2f       	mov	r26, r18
    2372:	23 2f       	mov	r18, r19
    2374:	34 2f       	mov	r19, r20
    2376:	44 27       	eor	r20, r20
    2378:	58 5f       	subi	r21, 0xF8	; 248
    237a:	f3 cf       	rjmp	.-26     	; 0x2362 <__addsf3x+0x34>
    237c:	46 95       	lsr	r20
    237e:	37 95       	ror	r19
    2380:	27 95       	ror	r18
    2382:	a7 95       	ror	r26
    2384:	f0 40       	sbci	r31, 0x00	; 0
    2386:	53 95       	inc	r21
    2388:	c9 f7       	brne	.-14     	; 0x237c <__addsf3x+0x4e>
    238a:	7e f4       	brtc	.+30     	; 0x23aa <__addsf3x+0x7c>
    238c:	1f 16       	cp	r1, r31
    238e:	ba 0b       	sbc	r27, r26
    2390:	62 0b       	sbc	r22, r18
    2392:	73 0b       	sbc	r23, r19
    2394:	84 0b       	sbc	r24, r20
    2396:	ba f0       	brmi	.+46     	; 0x23c6 <__addsf3x+0x98>
    2398:	91 50       	subi	r25, 0x01	; 1
    239a:	a1 f0       	breq	.+40     	; 0x23c4 <__addsf3x+0x96>
    239c:	ff 0f       	add	r31, r31
    239e:	bb 1f       	adc	r27, r27
    23a0:	66 1f       	adc	r22, r22
    23a2:	77 1f       	adc	r23, r23
    23a4:	88 1f       	adc	r24, r24
    23a6:	c2 f7       	brpl	.-16     	; 0x2398 <__addsf3x+0x6a>
    23a8:	0e c0       	rjmp	.+28     	; 0x23c6 <__addsf3x+0x98>
    23aa:	ba 0f       	add	r27, r26
    23ac:	62 1f       	adc	r22, r18
    23ae:	73 1f       	adc	r23, r19
    23b0:	84 1f       	adc	r24, r20
    23b2:	48 f4       	brcc	.+18     	; 0x23c6 <__addsf3x+0x98>
    23b4:	87 95       	ror	r24
    23b6:	77 95       	ror	r23
    23b8:	67 95       	ror	r22
    23ba:	b7 95       	ror	r27
    23bc:	f7 95       	ror	r31
    23be:	9e 3f       	cpi	r25, 0xFE	; 254
    23c0:	08 f0       	brcs	.+2      	; 0x23c4 <__addsf3x+0x96>
    23c2:	b3 cf       	rjmp	.-154    	; 0x232a <__addsf3+0x1e>
    23c4:	93 95       	inc	r25
    23c6:	88 0f       	add	r24, r24
    23c8:	08 f0       	brcs	.+2      	; 0x23cc <__addsf3x+0x9e>
    23ca:	99 27       	eor	r25, r25
    23cc:	ee 0f       	add	r30, r30
    23ce:	97 95       	ror	r25
    23d0:	87 95       	ror	r24
    23d2:	08 95       	ret

000023d4 <__cmpsf2>:
    23d4:	d9 d0       	rcall	.+434    	; 0x2588 <__fp_cmp>
    23d6:	08 f4       	brcc	.+2      	; 0x23da <__cmpsf2+0x6>
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	08 95       	ret

000023dc <__divsf3>:
    23dc:	0c d0       	rcall	.+24     	; 0x23f6 <__divsf3x>
    23de:	0f c1       	rjmp	.+542    	; 0x25fe <__fp_round>
    23e0:	07 d1       	rcall	.+526    	; 0x25f0 <__fp_pscB>
    23e2:	40 f0       	brcs	.+16     	; 0x23f4 <__divsf3+0x18>
    23e4:	fe d0       	rcall	.+508    	; 0x25e2 <__fp_pscA>
    23e6:	30 f0       	brcs	.+12     	; 0x23f4 <__divsf3+0x18>
    23e8:	21 f4       	brne	.+8      	; 0x23f2 <__divsf3+0x16>
    23ea:	5f 3f       	cpi	r21, 0xFF	; 255
    23ec:	19 f0       	breq	.+6      	; 0x23f4 <__divsf3+0x18>
    23ee:	f0 c0       	rjmp	.+480    	; 0x25d0 <__fp_inf>
    23f0:	51 11       	cpse	r21, r1
    23f2:	39 c1       	rjmp	.+626    	; 0x2666 <__fp_szero>
    23f4:	f3 c0       	rjmp	.+486    	; 0x25dc <__fp_nan>

000023f6 <__divsf3x>:
    23f6:	14 d1       	rcall	.+552    	; 0x2620 <__fp_split3>
    23f8:	98 f3       	brcs	.-26     	; 0x23e0 <__divsf3+0x4>

000023fa <__divsf3_pse>:
    23fa:	99 23       	and	r25, r25
    23fc:	c9 f3       	breq	.-14     	; 0x23f0 <__divsf3+0x14>
    23fe:	55 23       	and	r21, r21
    2400:	b1 f3       	breq	.-20     	; 0x23ee <__divsf3+0x12>
    2402:	95 1b       	sub	r25, r21
    2404:	55 0b       	sbc	r21, r21
    2406:	bb 27       	eor	r27, r27
    2408:	aa 27       	eor	r26, r26
    240a:	62 17       	cp	r22, r18
    240c:	73 07       	cpc	r23, r19
    240e:	84 07       	cpc	r24, r20
    2410:	38 f0       	brcs	.+14     	; 0x2420 <__divsf3_pse+0x26>
    2412:	9f 5f       	subi	r25, 0xFF	; 255
    2414:	5f 4f       	sbci	r21, 0xFF	; 255
    2416:	22 0f       	add	r18, r18
    2418:	33 1f       	adc	r19, r19
    241a:	44 1f       	adc	r20, r20
    241c:	aa 1f       	adc	r26, r26
    241e:	a9 f3       	breq	.-22     	; 0x240a <__divsf3_pse+0x10>
    2420:	33 d0       	rcall	.+102    	; 0x2488 <__divsf3_pse+0x8e>
    2422:	0e 2e       	mov	r0, r30
    2424:	3a f0       	brmi	.+14     	; 0x2434 <__divsf3_pse+0x3a>
    2426:	e0 e8       	ldi	r30, 0x80	; 128
    2428:	30 d0       	rcall	.+96     	; 0x248a <__divsf3_pse+0x90>
    242a:	91 50       	subi	r25, 0x01	; 1
    242c:	50 40       	sbci	r21, 0x00	; 0
    242e:	e6 95       	lsr	r30
    2430:	00 1c       	adc	r0, r0
    2432:	ca f7       	brpl	.-14     	; 0x2426 <__divsf3_pse+0x2c>
    2434:	29 d0       	rcall	.+82     	; 0x2488 <__divsf3_pse+0x8e>
    2436:	fe 2f       	mov	r31, r30
    2438:	27 d0       	rcall	.+78     	; 0x2488 <__divsf3_pse+0x8e>
    243a:	66 0f       	add	r22, r22
    243c:	77 1f       	adc	r23, r23
    243e:	88 1f       	adc	r24, r24
    2440:	bb 1f       	adc	r27, r27
    2442:	26 17       	cp	r18, r22
    2444:	37 07       	cpc	r19, r23
    2446:	48 07       	cpc	r20, r24
    2448:	ab 07       	cpc	r26, r27
    244a:	b0 e8       	ldi	r27, 0x80	; 128
    244c:	09 f0       	breq	.+2      	; 0x2450 <__divsf3_pse+0x56>
    244e:	bb 0b       	sbc	r27, r27
    2450:	80 2d       	mov	r24, r0
    2452:	bf 01       	movw	r22, r30
    2454:	ff 27       	eor	r31, r31
    2456:	93 58       	subi	r25, 0x83	; 131
    2458:	5f 4f       	sbci	r21, 0xFF	; 255
    245a:	2a f0       	brmi	.+10     	; 0x2466 <__divsf3_pse+0x6c>
    245c:	9e 3f       	cpi	r25, 0xFE	; 254
    245e:	51 05       	cpc	r21, r1
    2460:	68 f0       	brcs	.+26     	; 0x247c <__divsf3_pse+0x82>
    2462:	b6 c0       	rjmp	.+364    	; 0x25d0 <__fp_inf>
    2464:	00 c1       	rjmp	.+512    	; 0x2666 <__fp_szero>
    2466:	5f 3f       	cpi	r21, 0xFF	; 255
    2468:	ec f3       	brlt	.-6      	; 0x2464 <__divsf3_pse+0x6a>
    246a:	98 3e       	cpi	r25, 0xE8	; 232
    246c:	dc f3       	brlt	.-10     	; 0x2464 <__divsf3_pse+0x6a>
    246e:	86 95       	lsr	r24
    2470:	77 95       	ror	r23
    2472:	67 95       	ror	r22
    2474:	b7 95       	ror	r27
    2476:	f7 95       	ror	r31
    2478:	9f 5f       	subi	r25, 0xFF	; 255
    247a:	c9 f7       	brne	.-14     	; 0x246e <__divsf3_pse+0x74>
    247c:	88 0f       	add	r24, r24
    247e:	91 1d       	adc	r25, r1
    2480:	96 95       	lsr	r25
    2482:	87 95       	ror	r24
    2484:	97 f9       	bld	r25, 7
    2486:	08 95       	ret
    2488:	e1 e0       	ldi	r30, 0x01	; 1
    248a:	66 0f       	add	r22, r22
    248c:	77 1f       	adc	r23, r23
    248e:	88 1f       	adc	r24, r24
    2490:	bb 1f       	adc	r27, r27
    2492:	62 17       	cp	r22, r18
    2494:	73 07       	cpc	r23, r19
    2496:	84 07       	cpc	r24, r20
    2498:	ba 07       	cpc	r27, r26
    249a:	20 f0       	brcs	.+8      	; 0x24a4 <__divsf3_pse+0xaa>
    249c:	62 1b       	sub	r22, r18
    249e:	73 0b       	sbc	r23, r19
    24a0:	84 0b       	sbc	r24, r20
    24a2:	ba 0b       	sbc	r27, r26
    24a4:	ee 1f       	adc	r30, r30
    24a6:	88 f7       	brcc	.-30     	; 0x248a <__divsf3_pse+0x90>
    24a8:	e0 95       	com	r30
    24aa:	08 95       	ret

000024ac <__fixsfsi>:
    24ac:	04 d0       	rcall	.+8      	; 0x24b6 <__fixunssfsi>
    24ae:	68 94       	set
    24b0:	b1 11       	cpse	r27, r1
    24b2:	d9 c0       	rjmp	.+434    	; 0x2666 <__fp_szero>
    24b4:	08 95       	ret

000024b6 <__fixunssfsi>:
    24b6:	bc d0       	rcall	.+376    	; 0x2630 <__fp_splitA>
    24b8:	88 f0       	brcs	.+34     	; 0x24dc <__fixunssfsi+0x26>
    24ba:	9f 57       	subi	r25, 0x7F	; 127
    24bc:	90 f0       	brcs	.+36     	; 0x24e2 <__fixunssfsi+0x2c>
    24be:	b9 2f       	mov	r27, r25
    24c0:	99 27       	eor	r25, r25
    24c2:	b7 51       	subi	r27, 0x17	; 23
    24c4:	a0 f0       	brcs	.+40     	; 0x24ee <__fixunssfsi+0x38>
    24c6:	d1 f0       	breq	.+52     	; 0x24fc <__fixunssfsi+0x46>
    24c8:	66 0f       	add	r22, r22
    24ca:	77 1f       	adc	r23, r23
    24cc:	88 1f       	adc	r24, r24
    24ce:	99 1f       	adc	r25, r25
    24d0:	1a f0       	brmi	.+6      	; 0x24d8 <__fixunssfsi+0x22>
    24d2:	ba 95       	dec	r27
    24d4:	c9 f7       	brne	.-14     	; 0x24c8 <__fixunssfsi+0x12>
    24d6:	12 c0       	rjmp	.+36     	; 0x24fc <__fixunssfsi+0x46>
    24d8:	b1 30       	cpi	r27, 0x01	; 1
    24da:	81 f0       	breq	.+32     	; 0x24fc <__fixunssfsi+0x46>
    24dc:	c3 d0       	rcall	.+390    	; 0x2664 <__fp_zero>
    24de:	b1 e0       	ldi	r27, 0x01	; 1
    24e0:	08 95       	ret
    24e2:	c0 c0       	rjmp	.+384    	; 0x2664 <__fp_zero>
    24e4:	67 2f       	mov	r22, r23
    24e6:	78 2f       	mov	r23, r24
    24e8:	88 27       	eor	r24, r24
    24ea:	b8 5f       	subi	r27, 0xF8	; 248
    24ec:	39 f0       	breq	.+14     	; 0x24fc <__fixunssfsi+0x46>
    24ee:	b9 3f       	cpi	r27, 0xF9	; 249
    24f0:	cc f3       	brlt	.-14     	; 0x24e4 <__fixunssfsi+0x2e>
    24f2:	86 95       	lsr	r24
    24f4:	77 95       	ror	r23
    24f6:	67 95       	ror	r22
    24f8:	b3 95       	inc	r27
    24fa:	d9 f7       	brne	.-10     	; 0x24f2 <__fixunssfsi+0x3c>
    24fc:	3e f4       	brtc	.+14     	; 0x250c <__fixunssfsi+0x56>
    24fe:	90 95       	com	r25
    2500:	80 95       	com	r24
    2502:	70 95       	com	r23
    2504:	61 95       	neg	r22
    2506:	7f 4f       	sbci	r23, 0xFF	; 255
    2508:	8f 4f       	sbci	r24, 0xFF	; 255
    250a:	9f 4f       	sbci	r25, 0xFF	; 255
    250c:	08 95       	ret

0000250e <__floatunsisf>:
    250e:	e8 94       	clt
    2510:	09 c0       	rjmp	.+18     	; 0x2524 <__floatsisf+0x12>

00002512 <__floatsisf>:
    2512:	97 fb       	bst	r25, 7
    2514:	3e f4       	brtc	.+14     	; 0x2524 <__floatsisf+0x12>
    2516:	90 95       	com	r25
    2518:	80 95       	com	r24
    251a:	70 95       	com	r23
    251c:	61 95       	neg	r22
    251e:	7f 4f       	sbci	r23, 0xFF	; 255
    2520:	8f 4f       	sbci	r24, 0xFF	; 255
    2522:	9f 4f       	sbci	r25, 0xFF	; 255
    2524:	99 23       	and	r25, r25
    2526:	a9 f0       	breq	.+42     	; 0x2552 <__floatsisf+0x40>
    2528:	f9 2f       	mov	r31, r25
    252a:	96 e9       	ldi	r25, 0x96	; 150
    252c:	bb 27       	eor	r27, r27
    252e:	93 95       	inc	r25
    2530:	f6 95       	lsr	r31
    2532:	87 95       	ror	r24
    2534:	77 95       	ror	r23
    2536:	67 95       	ror	r22
    2538:	b7 95       	ror	r27
    253a:	f1 11       	cpse	r31, r1
    253c:	f8 cf       	rjmp	.-16     	; 0x252e <__floatsisf+0x1c>
    253e:	fa f4       	brpl	.+62     	; 0x257e <__floatsisf+0x6c>
    2540:	bb 0f       	add	r27, r27
    2542:	11 f4       	brne	.+4      	; 0x2548 <__floatsisf+0x36>
    2544:	60 ff       	sbrs	r22, 0
    2546:	1b c0       	rjmp	.+54     	; 0x257e <__floatsisf+0x6c>
    2548:	6f 5f       	subi	r22, 0xFF	; 255
    254a:	7f 4f       	sbci	r23, 0xFF	; 255
    254c:	8f 4f       	sbci	r24, 0xFF	; 255
    254e:	9f 4f       	sbci	r25, 0xFF	; 255
    2550:	16 c0       	rjmp	.+44     	; 0x257e <__floatsisf+0x6c>
    2552:	88 23       	and	r24, r24
    2554:	11 f0       	breq	.+4      	; 0x255a <__floatsisf+0x48>
    2556:	96 e9       	ldi	r25, 0x96	; 150
    2558:	11 c0       	rjmp	.+34     	; 0x257c <__floatsisf+0x6a>
    255a:	77 23       	and	r23, r23
    255c:	21 f0       	breq	.+8      	; 0x2566 <__floatsisf+0x54>
    255e:	9e e8       	ldi	r25, 0x8E	; 142
    2560:	87 2f       	mov	r24, r23
    2562:	76 2f       	mov	r23, r22
    2564:	05 c0       	rjmp	.+10     	; 0x2570 <__floatsisf+0x5e>
    2566:	66 23       	and	r22, r22
    2568:	71 f0       	breq	.+28     	; 0x2586 <__floatsisf+0x74>
    256a:	96 e8       	ldi	r25, 0x86	; 134
    256c:	86 2f       	mov	r24, r22
    256e:	70 e0       	ldi	r23, 0x00	; 0
    2570:	60 e0       	ldi	r22, 0x00	; 0
    2572:	2a f0       	brmi	.+10     	; 0x257e <__floatsisf+0x6c>
    2574:	9a 95       	dec	r25
    2576:	66 0f       	add	r22, r22
    2578:	77 1f       	adc	r23, r23
    257a:	88 1f       	adc	r24, r24
    257c:	da f7       	brpl	.-10     	; 0x2574 <__floatsisf+0x62>
    257e:	88 0f       	add	r24, r24
    2580:	96 95       	lsr	r25
    2582:	87 95       	ror	r24
    2584:	97 f9       	bld	r25, 7
    2586:	08 95       	ret

00002588 <__fp_cmp>:
    2588:	99 0f       	add	r25, r25
    258a:	00 08       	sbc	r0, r0
    258c:	55 0f       	add	r21, r21
    258e:	aa 0b       	sbc	r26, r26
    2590:	e0 e8       	ldi	r30, 0x80	; 128
    2592:	fe ef       	ldi	r31, 0xFE	; 254
    2594:	16 16       	cp	r1, r22
    2596:	17 06       	cpc	r1, r23
    2598:	e8 07       	cpc	r30, r24
    259a:	f9 07       	cpc	r31, r25
    259c:	c0 f0       	brcs	.+48     	; 0x25ce <__fp_cmp+0x46>
    259e:	12 16       	cp	r1, r18
    25a0:	13 06       	cpc	r1, r19
    25a2:	e4 07       	cpc	r30, r20
    25a4:	f5 07       	cpc	r31, r21
    25a6:	98 f0       	brcs	.+38     	; 0x25ce <__fp_cmp+0x46>
    25a8:	62 1b       	sub	r22, r18
    25aa:	73 0b       	sbc	r23, r19
    25ac:	84 0b       	sbc	r24, r20
    25ae:	95 0b       	sbc	r25, r21
    25b0:	39 f4       	brne	.+14     	; 0x25c0 <__fp_cmp+0x38>
    25b2:	0a 26       	eor	r0, r26
    25b4:	61 f0       	breq	.+24     	; 0x25ce <__fp_cmp+0x46>
    25b6:	23 2b       	or	r18, r19
    25b8:	24 2b       	or	r18, r20
    25ba:	25 2b       	or	r18, r21
    25bc:	21 f4       	brne	.+8      	; 0x25c6 <__fp_cmp+0x3e>
    25be:	08 95       	ret
    25c0:	0a 26       	eor	r0, r26
    25c2:	09 f4       	brne	.+2      	; 0x25c6 <__fp_cmp+0x3e>
    25c4:	a1 40       	sbci	r26, 0x01	; 1
    25c6:	a6 95       	lsr	r26
    25c8:	8f ef       	ldi	r24, 0xFF	; 255
    25ca:	81 1d       	adc	r24, r1
    25cc:	81 1d       	adc	r24, r1
    25ce:	08 95       	ret

000025d0 <__fp_inf>:
    25d0:	97 f9       	bld	r25, 7
    25d2:	9f 67       	ori	r25, 0x7F	; 127
    25d4:	80 e8       	ldi	r24, 0x80	; 128
    25d6:	70 e0       	ldi	r23, 0x00	; 0
    25d8:	60 e0       	ldi	r22, 0x00	; 0
    25da:	08 95       	ret

000025dc <__fp_nan>:
    25dc:	9f ef       	ldi	r25, 0xFF	; 255
    25de:	80 ec       	ldi	r24, 0xC0	; 192
    25e0:	08 95       	ret

000025e2 <__fp_pscA>:
    25e2:	00 24       	eor	r0, r0
    25e4:	0a 94       	dec	r0
    25e6:	16 16       	cp	r1, r22
    25e8:	17 06       	cpc	r1, r23
    25ea:	18 06       	cpc	r1, r24
    25ec:	09 06       	cpc	r0, r25
    25ee:	08 95       	ret

000025f0 <__fp_pscB>:
    25f0:	00 24       	eor	r0, r0
    25f2:	0a 94       	dec	r0
    25f4:	12 16       	cp	r1, r18
    25f6:	13 06       	cpc	r1, r19
    25f8:	14 06       	cpc	r1, r20
    25fa:	05 06       	cpc	r0, r21
    25fc:	08 95       	ret

000025fe <__fp_round>:
    25fe:	09 2e       	mov	r0, r25
    2600:	03 94       	inc	r0
    2602:	00 0c       	add	r0, r0
    2604:	11 f4       	brne	.+4      	; 0x260a <__fp_round+0xc>
    2606:	88 23       	and	r24, r24
    2608:	52 f0       	brmi	.+20     	; 0x261e <__fp_round+0x20>
    260a:	bb 0f       	add	r27, r27
    260c:	40 f4       	brcc	.+16     	; 0x261e <__fp_round+0x20>
    260e:	bf 2b       	or	r27, r31
    2610:	11 f4       	brne	.+4      	; 0x2616 <__fp_round+0x18>
    2612:	60 ff       	sbrs	r22, 0
    2614:	04 c0       	rjmp	.+8      	; 0x261e <__fp_round+0x20>
    2616:	6f 5f       	subi	r22, 0xFF	; 255
    2618:	7f 4f       	sbci	r23, 0xFF	; 255
    261a:	8f 4f       	sbci	r24, 0xFF	; 255
    261c:	9f 4f       	sbci	r25, 0xFF	; 255
    261e:	08 95       	ret

00002620 <__fp_split3>:
    2620:	57 fd       	sbrc	r21, 7
    2622:	90 58       	subi	r25, 0x80	; 128
    2624:	44 0f       	add	r20, r20
    2626:	55 1f       	adc	r21, r21
    2628:	59 f0       	breq	.+22     	; 0x2640 <__fp_splitA+0x10>
    262a:	5f 3f       	cpi	r21, 0xFF	; 255
    262c:	71 f0       	breq	.+28     	; 0x264a <__fp_splitA+0x1a>
    262e:	47 95       	ror	r20

00002630 <__fp_splitA>:
    2630:	88 0f       	add	r24, r24
    2632:	97 fb       	bst	r25, 7
    2634:	99 1f       	adc	r25, r25
    2636:	61 f0       	breq	.+24     	; 0x2650 <__fp_splitA+0x20>
    2638:	9f 3f       	cpi	r25, 0xFF	; 255
    263a:	79 f0       	breq	.+30     	; 0x265a <__fp_splitA+0x2a>
    263c:	87 95       	ror	r24
    263e:	08 95       	ret
    2640:	12 16       	cp	r1, r18
    2642:	13 06       	cpc	r1, r19
    2644:	14 06       	cpc	r1, r20
    2646:	55 1f       	adc	r21, r21
    2648:	f2 cf       	rjmp	.-28     	; 0x262e <__fp_split3+0xe>
    264a:	46 95       	lsr	r20
    264c:	f1 df       	rcall	.-30     	; 0x2630 <__fp_splitA>
    264e:	08 c0       	rjmp	.+16     	; 0x2660 <__fp_splitA+0x30>
    2650:	16 16       	cp	r1, r22
    2652:	17 06       	cpc	r1, r23
    2654:	18 06       	cpc	r1, r24
    2656:	99 1f       	adc	r25, r25
    2658:	f1 cf       	rjmp	.-30     	; 0x263c <__fp_splitA+0xc>
    265a:	86 95       	lsr	r24
    265c:	71 05       	cpc	r23, r1
    265e:	61 05       	cpc	r22, r1
    2660:	08 94       	sec
    2662:	08 95       	ret

00002664 <__fp_zero>:
    2664:	e8 94       	clt

00002666 <__fp_szero>:
    2666:	bb 27       	eor	r27, r27
    2668:	66 27       	eor	r22, r22
    266a:	77 27       	eor	r23, r23
    266c:	cb 01       	movw	r24, r22
    266e:	97 f9       	bld	r25, 7
    2670:	08 95       	ret

00002672 <__gesf2>:
    2672:	8a df       	rcall	.-236    	; 0x2588 <__fp_cmp>
    2674:	08 f4       	brcc	.+2      	; 0x2678 <__gesf2+0x6>
    2676:	8f ef       	ldi	r24, 0xFF	; 255
    2678:	08 95       	ret

0000267a <__mulsf3>:
    267a:	0b d0       	rcall	.+22     	; 0x2692 <__mulsf3x>
    267c:	c0 cf       	rjmp	.-128    	; 0x25fe <__fp_round>
    267e:	b1 df       	rcall	.-158    	; 0x25e2 <__fp_pscA>
    2680:	28 f0       	brcs	.+10     	; 0x268c <__mulsf3+0x12>
    2682:	b6 df       	rcall	.-148    	; 0x25f0 <__fp_pscB>
    2684:	18 f0       	brcs	.+6      	; 0x268c <__mulsf3+0x12>
    2686:	95 23       	and	r25, r21
    2688:	09 f0       	breq	.+2      	; 0x268c <__mulsf3+0x12>
    268a:	a2 cf       	rjmp	.-188    	; 0x25d0 <__fp_inf>
    268c:	a7 cf       	rjmp	.-178    	; 0x25dc <__fp_nan>
    268e:	11 24       	eor	r1, r1
    2690:	ea cf       	rjmp	.-44     	; 0x2666 <__fp_szero>

00002692 <__mulsf3x>:
    2692:	c6 df       	rcall	.-116    	; 0x2620 <__fp_split3>
    2694:	a0 f3       	brcs	.-24     	; 0x267e <__mulsf3+0x4>

00002696 <__mulsf3_pse>:
    2696:	95 9f       	mul	r25, r21
    2698:	d1 f3       	breq	.-12     	; 0x268e <__mulsf3+0x14>
    269a:	95 0f       	add	r25, r21
    269c:	50 e0       	ldi	r21, 0x00	; 0
    269e:	55 1f       	adc	r21, r21
    26a0:	62 9f       	mul	r22, r18
    26a2:	f0 01       	movw	r30, r0
    26a4:	72 9f       	mul	r23, r18
    26a6:	bb 27       	eor	r27, r27
    26a8:	f0 0d       	add	r31, r0
    26aa:	b1 1d       	adc	r27, r1
    26ac:	63 9f       	mul	r22, r19
    26ae:	aa 27       	eor	r26, r26
    26b0:	f0 0d       	add	r31, r0
    26b2:	b1 1d       	adc	r27, r1
    26b4:	aa 1f       	adc	r26, r26
    26b6:	64 9f       	mul	r22, r20
    26b8:	66 27       	eor	r22, r22
    26ba:	b0 0d       	add	r27, r0
    26bc:	a1 1d       	adc	r26, r1
    26be:	66 1f       	adc	r22, r22
    26c0:	82 9f       	mul	r24, r18
    26c2:	22 27       	eor	r18, r18
    26c4:	b0 0d       	add	r27, r0
    26c6:	a1 1d       	adc	r26, r1
    26c8:	62 1f       	adc	r22, r18
    26ca:	73 9f       	mul	r23, r19
    26cc:	b0 0d       	add	r27, r0
    26ce:	a1 1d       	adc	r26, r1
    26d0:	62 1f       	adc	r22, r18
    26d2:	83 9f       	mul	r24, r19
    26d4:	a0 0d       	add	r26, r0
    26d6:	61 1d       	adc	r22, r1
    26d8:	22 1f       	adc	r18, r18
    26da:	74 9f       	mul	r23, r20
    26dc:	33 27       	eor	r19, r19
    26de:	a0 0d       	add	r26, r0
    26e0:	61 1d       	adc	r22, r1
    26e2:	23 1f       	adc	r18, r19
    26e4:	84 9f       	mul	r24, r20
    26e6:	60 0d       	add	r22, r0
    26e8:	21 1d       	adc	r18, r1
    26ea:	82 2f       	mov	r24, r18
    26ec:	76 2f       	mov	r23, r22
    26ee:	6a 2f       	mov	r22, r26
    26f0:	11 24       	eor	r1, r1
    26f2:	9f 57       	subi	r25, 0x7F	; 127
    26f4:	50 40       	sbci	r21, 0x00	; 0
    26f6:	8a f0       	brmi	.+34     	; 0x271a <__mulsf3_pse+0x84>
    26f8:	e1 f0       	breq	.+56     	; 0x2732 <__mulsf3_pse+0x9c>
    26fa:	88 23       	and	r24, r24
    26fc:	4a f0       	brmi	.+18     	; 0x2710 <__mulsf3_pse+0x7a>
    26fe:	ee 0f       	add	r30, r30
    2700:	ff 1f       	adc	r31, r31
    2702:	bb 1f       	adc	r27, r27
    2704:	66 1f       	adc	r22, r22
    2706:	77 1f       	adc	r23, r23
    2708:	88 1f       	adc	r24, r24
    270a:	91 50       	subi	r25, 0x01	; 1
    270c:	50 40       	sbci	r21, 0x00	; 0
    270e:	a9 f7       	brne	.-22     	; 0x26fa <__mulsf3_pse+0x64>
    2710:	9e 3f       	cpi	r25, 0xFE	; 254
    2712:	51 05       	cpc	r21, r1
    2714:	70 f0       	brcs	.+28     	; 0x2732 <__mulsf3_pse+0x9c>
    2716:	5c cf       	rjmp	.-328    	; 0x25d0 <__fp_inf>
    2718:	a6 cf       	rjmp	.-180    	; 0x2666 <__fp_szero>
    271a:	5f 3f       	cpi	r21, 0xFF	; 255
    271c:	ec f3       	brlt	.-6      	; 0x2718 <__mulsf3_pse+0x82>
    271e:	98 3e       	cpi	r25, 0xE8	; 232
    2720:	dc f3       	brlt	.-10     	; 0x2718 <__mulsf3_pse+0x82>
    2722:	86 95       	lsr	r24
    2724:	77 95       	ror	r23
    2726:	67 95       	ror	r22
    2728:	b7 95       	ror	r27
    272a:	f7 95       	ror	r31
    272c:	e7 95       	ror	r30
    272e:	9f 5f       	subi	r25, 0xFF	; 255
    2730:	c1 f7       	brne	.-16     	; 0x2722 <__mulsf3_pse+0x8c>
    2732:	fe 2b       	or	r31, r30
    2734:	88 0f       	add	r24, r24
    2736:	91 1d       	adc	r25, r1
    2738:	96 95       	lsr	r25
    273a:	87 95       	ror	r24
    273c:	97 f9       	bld	r25, 7
    273e:	08 95       	ret

00002740 <__tablejump2__>:
    2740:	ee 0f       	add	r30, r30
    2742:	ff 1f       	adc	r31, r31
    2744:	00 24       	eor	r0, r0
    2746:	00 1c       	adc	r0, r0
    2748:	0b be       	out	0x3b, r0	; 59
    274a:	07 90       	elpm	r0, Z+
    274c:	f6 91       	elpm	r31, Z
    274e:	e0 2d       	mov	r30, r0
    2750:	09 94       	ijmp

00002752 <atoi>:
    2752:	fc 01       	movw	r30, r24
    2754:	88 27       	eor	r24, r24
    2756:	99 27       	eor	r25, r25
    2758:	e8 94       	clt
    275a:	21 91       	ld	r18, Z+
    275c:	20 32       	cpi	r18, 0x20	; 32
    275e:	e9 f3       	breq	.-6      	; 0x275a <atoi+0x8>
    2760:	29 30       	cpi	r18, 0x09	; 9
    2762:	10 f0       	brcs	.+4      	; 0x2768 <atoi+0x16>
    2764:	2e 30       	cpi	r18, 0x0E	; 14
    2766:	c8 f3       	brcs	.-14     	; 0x275a <atoi+0x8>
    2768:	2b 32       	cpi	r18, 0x2B	; 43
    276a:	39 f0       	breq	.+14     	; 0x277a <atoi+0x28>
    276c:	2d 32       	cpi	r18, 0x2D	; 45
    276e:	31 f4       	brne	.+12     	; 0x277c <atoi+0x2a>
    2770:	68 94       	set
    2772:	03 c0       	rjmp	.+6      	; 0x277a <atoi+0x28>
    2774:	14 d0       	rcall	.+40     	; 0x279e <__mulhi_const_10>
    2776:	82 0f       	add	r24, r18
    2778:	91 1d       	adc	r25, r1
    277a:	21 91       	ld	r18, Z+
    277c:	20 53       	subi	r18, 0x30	; 48
    277e:	2a 30       	cpi	r18, 0x0A	; 10
    2780:	c8 f3       	brcs	.-14     	; 0x2774 <atoi+0x22>
    2782:	1e f4       	brtc	.+6      	; 0x278a <atoi+0x38>
    2784:	90 95       	com	r25
    2786:	81 95       	neg	r24
    2788:	9f 4f       	sbci	r25, 0xFF	; 255
    278a:	08 95       	ret

0000278c <strcmp>:
    278c:	fb 01       	movw	r30, r22
    278e:	dc 01       	movw	r26, r24
    2790:	8d 91       	ld	r24, X+
    2792:	01 90       	ld	r0, Z+
    2794:	80 19       	sub	r24, r0
    2796:	01 10       	cpse	r0, r1
    2798:	d9 f3       	breq	.-10     	; 0x2790 <strcmp+0x4>
    279a:	99 0b       	sbc	r25, r25
    279c:	08 95       	ret

0000279e <__mulhi_const_10>:
    279e:	7a e0       	ldi	r23, 0x0A	; 10
    27a0:	97 9f       	mul	r25, r23
    27a2:	90 2d       	mov	r25, r0
    27a4:	87 9f       	mul	r24, r23
    27a6:	80 2d       	mov	r24, r0
    27a8:	91 0d       	add	r25, r1
    27aa:	11 24       	eor	r1, r1
    27ac:	08 95       	ret

000027ae <printf>:
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	cd b7       	in	r28, 0x3d	; 61
    27b4:	de b7       	in	r29, 0x3e	; 62
    27b6:	ae 01       	movw	r20, r28
    27b8:	4b 5f       	subi	r20, 0xFB	; 251
    27ba:	5f 4f       	sbci	r21, 0xFF	; 255
    27bc:	fa 01       	movw	r30, r20
    27be:	61 91       	ld	r22, Z+
    27c0:	71 91       	ld	r23, Z+
    27c2:	af 01       	movw	r20, r30
    27c4:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27c8:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27cc:	38 d0       	rcall	.+112    	; 0x283e <vfprintf>
    27ce:	df 91       	pop	r29
    27d0:	cf 91       	pop	r28
    27d2:	08 95       	ret

000027d4 <putchar>:
    27d4:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27d8:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27dc:	43 c2       	rjmp	.+1158   	; 0x2c64 <fputc>

000027de <puts>:
    27de:	0f 93       	push	r16
    27e0:	1f 93       	push	r17
    27e2:	cf 93       	push	r28
    27e4:	df 93       	push	r29
    27e6:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    27ea:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    27ee:	23 81       	ldd	r18, Z+3	; 0x03
    27f0:	21 ff       	sbrs	r18, 1
    27f2:	1b c0       	rjmp	.+54     	; 0x282a <puts+0x4c>
    27f4:	8c 01       	movw	r16, r24
    27f6:	d0 e0       	ldi	r29, 0x00	; 0
    27f8:	c0 e0       	ldi	r28, 0x00	; 0
    27fa:	f8 01       	movw	r30, r16
    27fc:	81 91       	ld	r24, Z+
    27fe:	8f 01       	movw	r16, r30
    2800:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    2804:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    2808:	db 01       	movw	r26, r22
    280a:	18 96       	adiw	r26, 0x08	; 8
    280c:	ed 91       	ld	r30, X+
    280e:	fc 91       	ld	r31, X
    2810:	19 97       	sbiw	r26, 0x09	; 9
    2812:	88 23       	and	r24, r24
    2814:	31 f0       	breq	.+12     	; 0x2822 <puts+0x44>
    2816:	09 95       	icall
    2818:	89 2b       	or	r24, r25
    281a:	79 f3       	breq	.-34     	; 0x27fa <puts+0x1c>
    281c:	df ef       	ldi	r29, 0xFF	; 255
    281e:	cf ef       	ldi	r28, 0xFF	; 255
    2820:	ec cf       	rjmp	.-40     	; 0x27fa <puts+0x1c>
    2822:	8a e0       	ldi	r24, 0x0A	; 10
    2824:	09 95       	icall
    2826:	89 2b       	or	r24, r25
    2828:	19 f0       	breq	.+6      	; 0x2830 <puts+0x52>
    282a:	8f ef       	ldi	r24, 0xFF	; 255
    282c:	9f ef       	ldi	r25, 0xFF	; 255
    282e:	02 c0       	rjmp	.+4      	; 0x2834 <puts+0x56>
    2830:	8d 2f       	mov	r24, r29
    2832:	9c 2f       	mov	r25, r28
    2834:	df 91       	pop	r29
    2836:	cf 91       	pop	r28
    2838:	1f 91       	pop	r17
    283a:	0f 91       	pop	r16
    283c:	08 95       	ret

0000283e <vfprintf>:
    283e:	2f 92       	push	r2
    2840:	3f 92       	push	r3
    2842:	4f 92       	push	r4
    2844:	5f 92       	push	r5
    2846:	6f 92       	push	r6
    2848:	7f 92       	push	r7
    284a:	8f 92       	push	r8
    284c:	9f 92       	push	r9
    284e:	af 92       	push	r10
    2850:	bf 92       	push	r11
    2852:	cf 92       	push	r12
    2854:	df 92       	push	r13
    2856:	ef 92       	push	r14
    2858:	ff 92       	push	r15
    285a:	0f 93       	push	r16
    285c:	1f 93       	push	r17
    285e:	cf 93       	push	r28
    2860:	df 93       	push	r29
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	2b 97       	sbiw	r28, 0x0b	; 11
    2868:	0f b6       	in	r0, 0x3f	; 63
    286a:	f8 94       	cli
    286c:	de bf       	out	0x3e, r29	; 62
    286e:	0f be       	out	0x3f, r0	; 63
    2870:	cd bf       	out	0x3d, r28	; 61
    2872:	6c 01       	movw	r12, r24
    2874:	7b 01       	movw	r14, r22
    2876:	8a 01       	movw	r16, r20
    2878:	fc 01       	movw	r30, r24
    287a:	17 82       	std	Z+7, r1	; 0x07
    287c:	16 82       	std	Z+6, r1	; 0x06
    287e:	83 81       	ldd	r24, Z+3	; 0x03
    2880:	81 ff       	sbrs	r24, 1
    2882:	bf c1       	rjmp	.+894    	; 0x2c02 <vfprintf+0x3c4>
    2884:	ce 01       	movw	r24, r28
    2886:	01 96       	adiw	r24, 0x01	; 1
    2888:	3c 01       	movw	r6, r24
    288a:	f6 01       	movw	r30, r12
    288c:	93 81       	ldd	r25, Z+3	; 0x03
    288e:	f7 01       	movw	r30, r14
    2890:	93 fd       	sbrc	r25, 3
    2892:	85 91       	lpm	r24, Z+
    2894:	93 ff       	sbrs	r25, 3
    2896:	81 91       	ld	r24, Z+
    2898:	7f 01       	movw	r14, r30
    289a:	88 23       	and	r24, r24
    289c:	09 f4       	brne	.+2      	; 0x28a0 <vfprintf+0x62>
    289e:	ad c1       	rjmp	.+858    	; 0x2bfa <vfprintf+0x3bc>
    28a0:	85 32       	cpi	r24, 0x25	; 37
    28a2:	39 f4       	brne	.+14     	; 0x28b2 <vfprintf+0x74>
    28a4:	93 fd       	sbrc	r25, 3
    28a6:	85 91       	lpm	r24, Z+
    28a8:	93 ff       	sbrs	r25, 3
    28aa:	81 91       	ld	r24, Z+
    28ac:	7f 01       	movw	r14, r30
    28ae:	85 32       	cpi	r24, 0x25	; 37
    28b0:	21 f4       	brne	.+8      	; 0x28ba <vfprintf+0x7c>
    28b2:	b6 01       	movw	r22, r12
    28b4:	90 e0       	ldi	r25, 0x00	; 0
    28b6:	d6 d1       	rcall	.+940    	; 0x2c64 <fputc>
    28b8:	e8 cf       	rjmp	.-48     	; 0x288a <vfprintf+0x4c>
    28ba:	91 2c       	mov	r9, r1
    28bc:	21 2c       	mov	r2, r1
    28be:	31 2c       	mov	r3, r1
    28c0:	ff e1       	ldi	r31, 0x1F	; 31
    28c2:	f3 15       	cp	r31, r3
    28c4:	d8 f0       	brcs	.+54     	; 0x28fc <vfprintf+0xbe>
    28c6:	8b 32       	cpi	r24, 0x2B	; 43
    28c8:	79 f0       	breq	.+30     	; 0x28e8 <vfprintf+0xaa>
    28ca:	38 f4       	brcc	.+14     	; 0x28da <vfprintf+0x9c>
    28cc:	80 32       	cpi	r24, 0x20	; 32
    28ce:	79 f0       	breq	.+30     	; 0x28ee <vfprintf+0xb0>
    28d0:	83 32       	cpi	r24, 0x23	; 35
    28d2:	a1 f4       	brne	.+40     	; 0x28fc <vfprintf+0xbe>
    28d4:	23 2d       	mov	r18, r3
    28d6:	20 61       	ori	r18, 0x10	; 16
    28d8:	1d c0       	rjmp	.+58     	; 0x2914 <vfprintf+0xd6>
    28da:	8d 32       	cpi	r24, 0x2D	; 45
    28dc:	61 f0       	breq	.+24     	; 0x28f6 <vfprintf+0xb8>
    28de:	80 33       	cpi	r24, 0x30	; 48
    28e0:	69 f4       	brne	.+26     	; 0x28fc <vfprintf+0xbe>
    28e2:	23 2d       	mov	r18, r3
    28e4:	21 60       	ori	r18, 0x01	; 1
    28e6:	16 c0       	rjmp	.+44     	; 0x2914 <vfprintf+0xd6>
    28e8:	83 2d       	mov	r24, r3
    28ea:	82 60       	ori	r24, 0x02	; 2
    28ec:	38 2e       	mov	r3, r24
    28ee:	e3 2d       	mov	r30, r3
    28f0:	e4 60       	ori	r30, 0x04	; 4
    28f2:	3e 2e       	mov	r3, r30
    28f4:	2a c0       	rjmp	.+84     	; 0x294a <vfprintf+0x10c>
    28f6:	f3 2d       	mov	r31, r3
    28f8:	f8 60       	ori	r31, 0x08	; 8
    28fa:	1d c0       	rjmp	.+58     	; 0x2936 <vfprintf+0xf8>
    28fc:	37 fc       	sbrc	r3, 7
    28fe:	2d c0       	rjmp	.+90     	; 0x295a <vfprintf+0x11c>
    2900:	20 ed       	ldi	r18, 0xD0	; 208
    2902:	28 0f       	add	r18, r24
    2904:	2a 30       	cpi	r18, 0x0A	; 10
    2906:	40 f0       	brcs	.+16     	; 0x2918 <vfprintf+0xda>
    2908:	8e 32       	cpi	r24, 0x2E	; 46
    290a:	b9 f4       	brne	.+46     	; 0x293a <vfprintf+0xfc>
    290c:	36 fc       	sbrc	r3, 6
    290e:	75 c1       	rjmp	.+746    	; 0x2bfa <vfprintf+0x3bc>
    2910:	23 2d       	mov	r18, r3
    2912:	20 64       	ori	r18, 0x40	; 64
    2914:	32 2e       	mov	r3, r18
    2916:	19 c0       	rjmp	.+50     	; 0x294a <vfprintf+0x10c>
    2918:	36 fe       	sbrs	r3, 6
    291a:	06 c0       	rjmp	.+12     	; 0x2928 <vfprintf+0xea>
    291c:	8a e0       	ldi	r24, 0x0A	; 10
    291e:	98 9e       	mul	r9, r24
    2920:	20 0d       	add	r18, r0
    2922:	11 24       	eor	r1, r1
    2924:	92 2e       	mov	r9, r18
    2926:	11 c0       	rjmp	.+34     	; 0x294a <vfprintf+0x10c>
    2928:	ea e0       	ldi	r30, 0x0A	; 10
    292a:	2e 9e       	mul	r2, r30
    292c:	20 0d       	add	r18, r0
    292e:	11 24       	eor	r1, r1
    2930:	22 2e       	mov	r2, r18
    2932:	f3 2d       	mov	r31, r3
    2934:	f0 62       	ori	r31, 0x20	; 32
    2936:	3f 2e       	mov	r3, r31
    2938:	08 c0       	rjmp	.+16     	; 0x294a <vfprintf+0x10c>
    293a:	8c 36       	cpi	r24, 0x6C	; 108
    293c:	21 f4       	brne	.+8      	; 0x2946 <vfprintf+0x108>
    293e:	83 2d       	mov	r24, r3
    2940:	80 68       	ori	r24, 0x80	; 128
    2942:	38 2e       	mov	r3, r24
    2944:	02 c0       	rjmp	.+4      	; 0x294a <vfprintf+0x10c>
    2946:	88 36       	cpi	r24, 0x68	; 104
    2948:	41 f4       	brne	.+16     	; 0x295a <vfprintf+0x11c>
    294a:	f7 01       	movw	r30, r14
    294c:	93 fd       	sbrc	r25, 3
    294e:	85 91       	lpm	r24, Z+
    2950:	93 ff       	sbrs	r25, 3
    2952:	81 91       	ld	r24, Z+
    2954:	7f 01       	movw	r14, r30
    2956:	81 11       	cpse	r24, r1
    2958:	b3 cf       	rjmp	.-154    	; 0x28c0 <vfprintf+0x82>
    295a:	98 2f       	mov	r25, r24
    295c:	9f 7d       	andi	r25, 0xDF	; 223
    295e:	95 54       	subi	r25, 0x45	; 69
    2960:	93 30       	cpi	r25, 0x03	; 3
    2962:	28 f4       	brcc	.+10     	; 0x296e <vfprintf+0x130>
    2964:	0c 5f       	subi	r16, 0xFC	; 252
    2966:	1f 4f       	sbci	r17, 0xFF	; 255
    2968:	9f e3       	ldi	r25, 0x3F	; 63
    296a:	99 83       	std	Y+1, r25	; 0x01
    296c:	0d c0       	rjmp	.+26     	; 0x2988 <vfprintf+0x14a>
    296e:	83 36       	cpi	r24, 0x63	; 99
    2970:	31 f0       	breq	.+12     	; 0x297e <vfprintf+0x140>
    2972:	83 37       	cpi	r24, 0x73	; 115
    2974:	71 f0       	breq	.+28     	; 0x2992 <vfprintf+0x154>
    2976:	83 35       	cpi	r24, 0x53	; 83
    2978:	09 f0       	breq	.+2      	; 0x297c <vfprintf+0x13e>
    297a:	55 c0       	rjmp	.+170    	; 0x2a26 <vfprintf+0x1e8>
    297c:	20 c0       	rjmp	.+64     	; 0x29be <vfprintf+0x180>
    297e:	f8 01       	movw	r30, r16
    2980:	80 81       	ld	r24, Z
    2982:	89 83       	std	Y+1, r24	; 0x01
    2984:	0e 5f       	subi	r16, 0xFE	; 254
    2986:	1f 4f       	sbci	r17, 0xFF	; 255
    2988:	88 24       	eor	r8, r8
    298a:	83 94       	inc	r8
    298c:	91 2c       	mov	r9, r1
    298e:	53 01       	movw	r10, r6
    2990:	12 c0       	rjmp	.+36     	; 0x29b6 <vfprintf+0x178>
    2992:	28 01       	movw	r4, r16
    2994:	f2 e0       	ldi	r31, 0x02	; 2
    2996:	4f 0e       	add	r4, r31
    2998:	51 1c       	adc	r5, r1
    299a:	f8 01       	movw	r30, r16
    299c:	a0 80       	ld	r10, Z
    299e:	b1 80       	ldd	r11, Z+1	; 0x01
    29a0:	36 fe       	sbrs	r3, 6
    29a2:	03 c0       	rjmp	.+6      	; 0x29aa <vfprintf+0x16c>
    29a4:	69 2d       	mov	r22, r9
    29a6:	70 e0       	ldi	r23, 0x00	; 0
    29a8:	02 c0       	rjmp	.+4      	; 0x29ae <vfprintf+0x170>
    29aa:	6f ef       	ldi	r22, 0xFF	; 255
    29ac:	7f ef       	ldi	r23, 0xFF	; 255
    29ae:	c5 01       	movw	r24, r10
    29b0:	4e d1       	rcall	.+668    	; 0x2c4e <strnlen>
    29b2:	4c 01       	movw	r8, r24
    29b4:	82 01       	movw	r16, r4
    29b6:	f3 2d       	mov	r31, r3
    29b8:	ff 77       	andi	r31, 0x7F	; 127
    29ba:	3f 2e       	mov	r3, r31
    29bc:	15 c0       	rjmp	.+42     	; 0x29e8 <vfprintf+0x1aa>
    29be:	28 01       	movw	r4, r16
    29c0:	22 e0       	ldi	r18, 0x02	; 2
    29c2:	42 0e       	add	r4, r18
    29c4:	51 1c       	adc	r5, r1
    29c6:	f8 01       	movw	r30, r16
    29c8:	a0 80       	ld	r10, Z
    29ca:	b1 80       	ldd	r11, Z+1	; 0x01
    29cc:	36 fe       	sbrs	r3, 6
    29ce:	03 c0       	rjmp	.+6      	; 0x29d6 <vfprintf+0x198>
    29d0:	69 2d       	mov	r22, r9
    29d2:	70 e0       	ldi	r23, 0x00	; 0
    29d4:	02 c0       	rjmp	.+4      	; 0x29da <vfprintf+0x19c>
    29d6:	6f ef       	ldi	r22, 0xFF	; 255
    29d8:	7f ef       	ldi	r23, 0xFF	; 255
    29da:	c5 01       	movw	r24, r10
    29dc:	2d d1       	rcall	.+602    	; 0x2c38 <strnlen_P>
    29de:	4c 01       	movw	r8, r24
    29e0:	f3 2d       	mov	r31, r3
    29e2:	f0 68       	ori	r31, 0x80	; 128
    29e4:	3f 2e       	mov	r3, r31
    29e6:	82 01       	movw	r16, r4
    29e8:	33 fc       	sbrc	r3, 3
    29ea:	19 c0       	rjmp	.+50     	; 0x2a1e <vfprintf+0x1e0>
    29ec:	82 2d       	mov	r24, r2
    29ee:	90 e0       	ldi	r25, 0x00	; 0
    29f0:	88 16       	cp	r8, r24
    29f2:	99 06       	cpc	r9, r25
    29f4:	a0 f4       	brcc	.+40     	; 0x2a1e <vfprintf+0x1e0>
    29f6:	b6 01       	movw	r22, r12
    29f8:	80 e2       	ldi	r24, 0x20	; 32
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	33 d1       	rcall	.+614    	; 0x2c64 <fputc>
    29fe:	2a 94       	dec	r2
    2a00:	f5 cf       	rjmp	.-22     	; 0x29ec <vfprintf+0x1ae>
    2a02:	f5 01       	movw	r30, r10
    2a04:	37 fc       	sbrc	r3, 7
    2a06:	85 91       	lpm	r24, Z+
    2a08:	37 fe       	sbrs	r3, 7
    2a0a:	81 91       	ld	r24, Z+
    2a0c:	5f 01       	movw	r10, r30
    2a0e:	b6 01       	movw	r22, r12
    2a10:	90 e0       	ldi	r25, 0x00	; 0
    2a12:	28 d1       	rcall	.+592    	; 0x2c64 <fputc>
    2a14:	21 10       	cpse	r2, r1
    2a16:	2a 94       	dec	r2
    2a18:	21 e0       	ldi	r18, 0x01	; 1
    2a1a:	82 1a       	sub	r8, r18
    2a1c:	91 08       	sbc	r9, r1
    2a1e:	81 14       	cp	r8, r1
    2a20:	91 04       	cpc	r9, r1
    2a22:	79 f7       	brne	.-34     	; 0x2a02 <vfprintf+0x1c4>
    2a24:	e1 c0       	rjmp	.+450    	; 0x2be8 <vfprintf+0x3aa>
    2a26:	84 36       	cpi	r24, 0x64	; 100
    2a28:	11 f0       	breq	.+4      	; 0x2a2e <vfprintf+0x1f0>
    2a2a:	89 36       	cpi	r24, 0x69	; 105
    2a2c:	39 f5       	brne	.+78     	; 0x2a7c <vfprintf+0x23e>
    2a2e:	f8 01       	movw	r30, r16
    2a30:	37 fe       	sbrs	r3, 7
    2a32:	07 c0       	rjmp	.+14     	; 0x2a42 <vfprintf+0x204>
    2a34:	60 81       	ld	r22, Z
    2a36:	71 81       	ldd	r23, Z+1	; 0x01
    2a38:	82 81       	ldd	r24, Z+2	; 0x02
    2a3a:	93 81       	ldd	r25, Z+3	; 0x03
    2a3c:	0c 5f       	subi	r16, 0xFC	; 252
    2a3e:	1f 4f       	sbci	r17, 0xFF	; 255
    2a40:	08 c0       	rjmp	.+16     	; 0x2a52 <vfprintf+0x214>
    2a42:	60 81       	ld	r22, Z
    2a44:	71 81       	ldd	r23, Z+1	; 0x01
    2a46:	07 2e       	mov	r0, r23
    2a48:	00 0c       	add	r0, r0
    2a4a:	88 0b       	sbc	r24, r24
    2a4c:	99 0b       	sbc	r25, r25
    2a4e:	0e 5f       	subi	r16, 0xFE	; 254
    2a50:	1f 4f       	sbci	r17, 0xFF	; 255
    2a52:	f3 2d       	mov	r31, r3
    2a54:	ff 76       	andi	r31, 0x6F	; 111
    2a56:	3f 2e       	mov	r3, r31
    2a58:	97 ff       	sbrs	r25, 7
    2a5a:	09 c0       	rjmp	.+18     	; 0x2a6e <vfprintf+0x230>
    2a5c:	90 95       	com	r25
    2a5e:	80 95       	com	r24
    2a60:	70 95       	com	r23
    2a62:	61 95       	neg	r22
    2a64:	7f 4f       	sbci	r23, 0xFF	; 255
    2a66:	8f 4f       	sbci	r24, 0xFF	; 255
    2a68:	9f 4f       	sbci	r25, 0xFF	; 255
    2a6a:	f0 68       	ori	r31, 0x80	; 128
    2a6c:	3f 2e       	mov	r3, r31
    2a6e:	2a e0       	ldi	r18, 0x0A	; 10
    2a70:	30 e0       	ldi	r19, 0x00	; 0
    2a72:	a3 01       	movw	r20, r6
    2a74:	33 d1       	rcall	.+614    	; 0x2cdc <__ultoa_invert>
    2a76:	88 2e       	mov	r8, r24
    2a78:	86 18       	sub	r8, r6
    2a7a:	44 c0       	rjmp	.+136    	; 0x2b04 <vfprintf+0x2c6>
    2a7c:	85 37       	cpi	r24, 0x75	; 117
    2a7e:	31 f4       	brne	.+12     	; 0x2a8c <vfprintf+0x24e>
    2a80:	23 2d       	mov	r18, r3
    2a82:	2f 7e       	andi	r18, 0xEF	; 239
    2a84:	b2 2e       	mov	r11, r18
    2a86:	2a e0       	ldi	r18, 0x0A	; 10
    2a88:	30 e0       	ldi	r19, 0x00	; 0
    2a8a:	25 c0       	rjmp	.+74     	; 0x2ad6 <vfprintf+0x298>
    2a8c:	93 2d       	mov	r25, r3
    2a8e:	99 7f       	andi	r25, 0xF9	; 249
    2a90:	b9 2e       	mov	r11, r25
    2a92:	8f 36       	cpi	r24, 0x6F	; 111
    2a94:	c1 f0       	breq	.+48     	; 0x2ac6 <vfprintf+0x288>
    2a96:	18 f4       	brcc	.+6      	; 0x2a9e <vfprintf+0x260>
    2a98:	88 35       	cpi	r24, 0x58	; 88
    2a9a:	79 f0       	breq	.+30     	; 0x2aba <vfprintf+0x27c>
    2a9c:	ae c0       	rjmp	.+348    	; 0x2bfa <vfprintf+0x3bc>
    2a9e:	80 37       	cpi	r24, 0x70	; 112
    2aa0:	19 f0       	breq	.+6      	; 0x2aa8 <vfprintf+0x26a>
    2aa2:	88 37       	cpi	r24, 0x78	; 120
    2aa4:	21 f0       	breq	.+8      	; 0x2aae <vfprintf+0x270>
    2aa6:	a9 c0       	rjmp	.+338    	; 0x2bfa <vfprintf+0x3bc>
    2aa8:	e9 2f       	mov	r30, r25
    2aaa:	e0 61       	ori	r30, 0x10	; 16
    2aac:	be 2e       	mov	r11, r30
    2aae:	b4 fe       	sbrs	r11, 4
    2ab0:	0d c0       	rjmp	.+26     	; 0x2acc <vfprintf+0x28e>
    2ab2:	fb 2d       	mov	r31, r11
    2ab4:	f4 60       	ori	r31, 0x04	; 4
    2ab6:	bf 2e       	mov	r11, r31
    2ab8:	09 c0       	rjmp	.+18     	; 0x2acc <vfprintf+0x28e>
    2aba:	34 fe       	sbrs	r3, 4
    2abc:	0a c0       	rjmp	.+20     	; 0x2ad2 <vfprintf+0x294>
    2abe:	29 2f       	mov	r18, r25
    2ac0:	26 60       	ori	r18, 0x06	; 6
    2ac2:	b2 2e       	mov	r11, r18
    2ac4:	06 c0       	rjmp	.+12     	; 0x2ad2 <vfprintf+0x294>
    2ac6:	28 e0       	ldi	r18, 0x08	; 8
    2ac8:	30 e0       	ldi	r19, 0x00	; 0
    2aca:	05 c0       	rjmp	.+10     	; 0x2ad6 <vfprintf+0x298>
    2acc:	20 e1       	ldi	r18, 0x10	; 16
    2ace:	30 e0       	ldi	r19, 0x00	; 0
    2ad0:	02 c0       	rjmp	.+4      	; 0x2ad6 <vfprintf+0x298>
    2ad2:	20 e1       	ldi	r18, 0x10	; 16
    2ad4:	32 e0       	ldi	r19, 0x02	; 2
    2ad6:	f8 01       	movw	r30, r16
    2ad8:	b7 fe       	sbrs	r11, 7
    2ada:	07 c0       	rjmp	.+14     	; 0x2aea <vfprintf+0x2ac>
    2adc:	60 81       	ld	r22, Z
    2ade:	71 81       	ldd	r23, Z+1	; 0x01
    2ae0:	82 81       	ldd	r24, Z+2	; 0x02
    2ae2:	93 81       	ldd	r25, Z+3	; 0x03
    2ae4:	0c 5f       	subi	r16, 0xFC	; 252
    2ae6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ae8:	06 c0       	rjmp	.+12     	; 0x2af6 <vfprintf+0x2b8>
    2aea:	60 81       	ld	r22, Z
    2aec:	71 81       	ldd	r23, Z+1	; 0x01
    2aee:	80 e0       	ldi	r24, 0x00	; 0
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	0e 5f       	subi	r16, 0xFE	; 254
    2af4:	1f 4f       	sbci	r17, 0xFF	; 255
    2af6:	a3 01       	movw	r20, r6
    2af8:	f1 d0       	rcall	.+482    	; 0x2cdc <__ultoa_invert>
    2afa:	88 2e       	mov	r8, r24
    2afc:	86 18       	sub	r8, r6
    2afe:	fb 2d       	mov	r31, r11
    2b00:	ff 77       	andi	r31, 0x7F	; 127
    2b02:	3f 2e       	mov	r3, r31
    2b04:	36 fe       	sbrs	r3, 6
    2b06:	0d c0       	rjmp	.+26     	; 0x2b22 <vfprintf+0x2e4>
    2b08:	23 2d       	mov	r18, r3
    2b0a:	2e 7f       	andi	r18, 0xFE	; 254
    2b0c:	a2 2e       	mov	r10, r18
    2b0e:	89 14       	cp	r8, r9
    2b10:	58 f4       	brcc	.+22     	; 0x2b28 <vfprintf+0x2ea>
    2b12:	34 fe       	sbrs	r3, 4
    2b14:	0b c0       	rjmp	.+22     	; 0x2b2c <vfprintf+0x2ee>
    2b16:	32 fc       	sbrc	r3, 2
    2b18:	09 c0       	rjmp	.+18     	; 0x2b2c <vfprintf+0x2ee>
    2b1a:	83 2d       	mov	r24, r3
    2b1c:	8e 7e       	andi	r24, 0xEE	; 238
    2b1e:	a8 2e       	mov	r10, r24
    2b20:	05 c0       	rjmp	.+10     	; 0x2b2c <vfprintf+0x2ee>
    2b22:	b8 2c       	mov	r11, r8
    2b24:	a3 2c       	mov	r10, r3
    2b26:	03 c0       	rjmp	.+6      	; 0x2b2e <vfprintf+0x2f0>
    2b28:	b8 2c       	mov	r11, r8
    2b2a:	01 c0       	rjmp	.+2      	; 0x2b2e <vfprintf+0x2f0>
    2b2c:	b9 2c       	mov	r11, r9
    2b2e:	a4 fe       	sbrs	r10, 4
    2b30:	0f c0       	rjmp	.+30     	; 0x2b50 <vfprintf+0x312>
    2b32:	fe 01       	movw	r30, r28
    2b34:	e8 0d       	add	r30, r8
    2b36:	f1 1d       	adc	r31, r1
    2b38:	80 81       	ld	r24, Z
    2b3a:	80 33       	cpi	r24, 0x30	; 48
    2b3c:	21 f4       	brne	.+8      	; 0x2b46 <vfprintf+0x308>
    2b3e:	9a 2d       	mov	r25, r10
    2b40:	99 7e       	andi	r25, 0xE9	; 233
    2b42:	a9 2e       	mov	r10, r25
    2b44:	09 c0       	rjmp	.+18     	; 0x2b58 <vfprintf+0x31a>
    2b46:	a2 fe       	sbrs	r10, 2
    2b48:	06 c0       	rjmp	.+12     	; 0x2b56 <vfprintf+0x318>
    2b4a:	b3 94       	inc	r11
    2b4c:	b3 94       	inc	r11
    2b4e:	04 c0       	rjmp	.+8      	; 0x2b58 <vfprintf+0x31a>
    2b50:	8a 2d       	mov	r24, r10
    2b52:	86 78       	andi	r24, 0x86	; 134
    2b54:	09 f0       	breq	.+2      	; 0x2b58 <vfprintf+0x31a>
    2b56:	b3 94       	inc	r11
    2b58:	a3 fc       	sbrc	r10, 3
    2b5a:	10 c0       	rjmp	.+32     	; 0x2b7c <vfprintf+0x33e>
    2b5c:	a0 fe       	sbrs	r10, 0
    2b5e:	06 c0       	rjmp	.+12     	; 0x2b6c <vfprintf+0x32e>
    2b60:	b2 14       	cp	r11, r2
    2b62:	80 f4       	brcc	.+32     	; 0x2b84 <vfprintf+0x346>
    2b64:	28 0c       	add	r2, r8
    2b66:	92 2c       	mov	r9, r2
    2b68:	9b 18       	sub	r9, r11
    2b6a:	0d c0       	rjmp	.+26     	; 0x2b86 <vfprintf+0x348>
    2b6c:	b2 14       	cp	r11, r2
    2b6e:	58 f4       	brcc	.+22     	; 0x2b86 <vfprintf+0x348>
    2b70:	b6 01       	movw	r22, r12
    2b72:	80 e2       	ldi	r24, 0x20	; 32
    2b74:	90 e0       	ldi	r25, 0x00	; 0
    2b76:	76 d0       	rcall	.+236    	; 0x2c64 <fputc>
    2b78:	b3 94       	inc	r11
    2b7a:	f8 cf       	rjmp	.-16     	; 0x2b6c <vfprintf+0x32e>
    2b7c:	b2 14       	cp	r11, r2
    2b7e:	18 f4       	brcc	.+6      	; 0x2b86 <vfprintf+0x348>
    2b80:	2b 18       	sub	r2, r11
    2b82:	02 c0       	rjmp	.+4      	; 0x2b88 <vfprintf+0x34a>
    2b84:	98 2c       	mov	r9, r8
    2b86:	21 2c       	mov	r2, r1
    2b88:	a4 fe       	sbrs	r10, 4
    2b8a:	0f c0       	rjmp	.+30     	; 0x2baa <vfprintf+0x36c>
    2b8c:	b6 01       	movw	r22, r12
    2b8e:	80 e3       	ldi	r24, 0x30	; 48
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	68 d0       	rcall	.+208    	; 0x2c64 <fputc>
    2b94:	a2 fe       	sbrs	r10, 2
    2b96:	16 c0       	rjmp	.+44     	; 0x2bc4 <vfprintf+0x386>
    2b98:	a1 fc       	sbrc	r10, 1
    2b9a:	03 c0       	rjmp	.+6      	; 0x2ba2 <vfprintf+0x364>
    2b9c:	88 e7       	ldi	r24, 0x78	; 120
    2b9e:	90 e0       	ldi	r25, 0x00	; 0
    2ba0:	02 c0       	rjmp	.+4      	; 0x2ba6 <vfprintf+0x368>
    2ba2:	88 e5       	ldi	r24, 0x58	; 88
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	b6 01       	movw	r22, r12
    2ba8:	0c c0       	rjmp	.+24     	; 0x2bc2 <vfprintf+0x384>
    2baa:	8a 2d       	mov	r24, r10
    2bac:	86 78       	andi	r24, 0x86	; 134
    2bae:	51 f0       	breq	.+20     	; 0x2bc4 <vfprintf+0x386>
    2bb0:	a1 fe       	sbrs	r10, 1
    2bb2:	02 c0       	rjmp	.+4      	; 0x2bb8 <vfprintf+0x37a>
    2bb4:	8b e2       	ldi	r24, 0x2B	; 43
    2bb6:	01 c0       	rjmp	.+2      	; 0x2bba <vfprintf+0x37c>
    2bb8:	80 e2       	ldi	r24, 0x20	; 32
    2bba:	a7 fc       	sbrc	r10, 7
    2bbc:	8d e2       	ldi	r24, 0x2D	; 45
    2bbe:	b6 01       	movw	r22, r12
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	50 d0       	rcall	.+160    	; 0x2c64 <fputc>
    2bc4:	89 14       	cp	r8, r9
    2bc6:	30 f4       	brcc	.+12     	; 0x2bd4 <vfprintf+0x396>
    2bc8:	b6 01       	movw	r22, r12
    2bca:	80 e3       	ldi	r24, 0x30	; 48
    2bcc:	90 e0       	ldi	r25, 0x00	; 0
    2bce:	4a d0       	rcall	.+148    	; 0x2c64 <fputc>
    2bd0:	9a 94       	dec	r9
    2bd2:	f8 cf       	rjmp	.-16     	; 0x2bc4 <vfprintf+0x386>
    2bd4:	8a 94       	dec	r8
    2bd6:	f3 01       	movw	r30, r6
    2bd8:	e8 0d       	add	r30, r8
    2bda:	f1 1d       	adc	r31, r1
    2bdc:	80 81       	ld	r24, Z
    2bde:	b6 01       	movw	r22, r12
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	40 d0       	rcall	.+128    	; 0x2c64 <fputc>
    2be4:	81 10       	cpse	r8, r1
    2be6:	f6 cf       	rjmp	.-20     	; 0x2bd4 <vfprintf+0x396>
    2be8:	22 20       	and	r2, r2
    2bea:	09 f4       	brne	.+2      	; 0x2bee <vfprintf+0x3b0>
    2bec:	4e ce       	rjmp	.-868    	; 0x288a <vfprintf+0x4c>
    2bee:	b6 01       	movw	r22, r12
    2bf0:	80 e2       	ldi	r24, 0x20	; 32
    2bf2:	90 e0       	ldi	r25, 0x00	; 0
    2bf4:	37 d0       	rcall	.+110    	; 0x2c64 <fputc>
    2bf6:	2a 94       	dec	r2
    2bf8:	f7 cf       	rjmp	.-18     	; 0x2be8 <vfprintf+0x3aa>
    2bfa:	f6 01       	movw	r30, r12
    2bfc:	86 81       	ldd	r24, Z+6	; 0x06
    2bfe:	97 81       	ldd	r25, Z+7	; 0x07
    2c00:	02 c0       	rjmp	.+4      	; 0x2c06 <vfprintf+0x3c8>
    2c02:	8f ef       	ldi	r24, 0xFF	; 255
    2c04:	9f ef       	ldi	r25, 0xFF	; 255
    2c06:	2b 96       	adiw	r28, 0x0b	; 11
    2c08:	0f b6       	in	r0, 0x3f	; 63
    2c0a:	f8 94       	cli
    2c0c:	de bf       	out	0x3e, r29	; 62
    2c0e:	0f be       	out	0x3f, r0	; 63
    2c10:	cd bf       	out	0x3d, r28	; 61
    2c12:	df 91       	pop	r29
    2c14:	cf 91       	pop	r28
    2c16:	1f 91       	pop	r17
    2c18:	0f 91       	pop	r16
    2c1a:	ff 90       	pop	r15
    2c1c:	ef 90       	pop	r14
    2c1e:	df 90       	pop	r13
    2c20:	cf 90       	pop	r12
    2c22:	bf 90       	pop	r11
    2c24:	af 90       	pop	r10
    2c26:	9f 90       	pop	r9
    2c28:	8f 90       	pop	r8
    2c2a:	7f 90       	pop	r7
    2c2c:	6f 90       	pop	r6
    2c2e:	5f 90       	pop	r5
    2c30:	4f 90       	pop	r4
    2c32:	3f 90       	pop	r3
    2c34:	2f 90       	pop	r2
    2c36:	08 95       	ret

00002c38 <strnlen_P>:
    2c38:	fc 01       	movw	r30, r24
    2c3a:	05 90       	lpm	r0, Z+
    2c3c:	61 50       	subi	r22, 0x01	; 1
    2c3e:	70 40       	sbci	r23, 0x00	; 0
    2c40:	01 10       	cpse	r0, r1
    2c42:	d8 f7       	brcc	.-10     	; 0x2c3a <strnlen_P+0x2>
    2c44:	80 95       	com	r24
    2c46:	90 95       	com	r25
    2c48:	8e 0f       	add	r24, r30
    2c4a:	9f 1f       	adc	r25, r31
    2c4c:	08 95       	ret

00002c4e <strnlen>:
    2c4e:	fc 01       	movw	r30, r24
    2c50:	61 50       	subi	r22, 0x01	; 1
    2c52:	70 40       	sbci	r23, 0x00	; 0
    2c54:	01 90       	ld	r0, Z+
    2c56:	01 10       	cpse	r0, r1
    2c58:	d8 f7       	brcc	.-10     	; 0x2c50 <strnlen+0x2>
    2c5a:	80 95       	com	r24
    2c5c:	90 95       	com	r25
    2c5e:	8e 0f       	add	r24, r30
    2c60:	9f 1f       	adc	r25, r31
    2c62:	08 95       	ret

00002c64 <fputc>:
    2c64:	0f 93       	push	r16
    2c66:	1f 93       	push	r17
    2c68:	cf 93       	push	r28
    2c6a:	df 93       	push	r29
    2c6c:	fb 01       	movw	r30, r22
    2c6e:	23 81       	ldd	r18, Z+3	; 0x03
    2c70:	21 fd       	sbrc	r18, 1
    2c72:	03 c0       	rjmp	.+6      	; 0x2c7a <fputc+0x16>
    2c74:	8f ef       	ldi	r24, 0xFF	; 255
    2c76:	9f ef       	ldi	r25, 0xFF	; 255
    2c78:	2c c0       	rjmp	.+88     	; 0x2cd2 <fputc+0x6e>
    2c7a:	22 ff       	sbrs	r18, 2
    2c7c:	16 c0       	rjmp	.+44     	; 0x2caa <fputc+0x46>
    2c7e:	46 81       	ldd	r20, Z+6	; 0x06
    2c80:	57 81       	ldd	r21, Z+7	; 0x07
    2c82:	24 81       	ldd	r18, Z+4	; 0x04
    2c84:	35 81       	ldd	r19, Z+5	; 0x05
    2c86:	42 17       	cp	r20, r18
    2c88:	53 07       	cpc	r21, r19
    2c8a:	44 f4       	brge	.+16     	; 0x2c9c <fputc+0x38>
    2c8c:	a0 81       	ld	r26, Z
    2c8e:	b1 81       	ldd	r27, Z+1	; 0x01
    2c90:	9d 01       	movw	r18, r26
    2c92:	2f 5f       	subi	r18, 0xFF	; 255
    2c94:	3f 4f       	sbci	r19, 0xFF	; 255
    2c96:	31 83       	std	Z+1, r19	; 0x01
    2c98:	20 83       	st	Z, r18
    2c9a:	8c 93       	st	X, r24
    2c9c:	26 81       	ldd	r18, Z+6	; 0x06
    2c9e:	37 81       	ldd	r19, Z+7	; 0x07
    2ca0:	2f 5f       	subi	r18, 0xFF	; 255
    2ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ca4:	37 83       	std	Z+7, r19	; 0x07
    2ca6:	26 83       	std	Z+6, r18	; 0x06
    2ca8:	14 c0       	rjmp	.+40     	; 0x2cd2 <fputc+0x6e>
    2caa:	8b 01       	movw	r16, r22
    2cac:	ec 01       	movw	r28, r24
    2cae:	fb 01       	movw	r30, r22
    2cb0:	00 84       	ldd	r0, Z+8	; 0x08
    2cb2:	f1 85       	ldd	r31, Z+9	; 0x09
    2cb4:	e0 2d       	mov	r30, r0
    2cb6:	09 95       	icall
    2cb8:	89 2b       	or	r24, r25
    2cba:	e1 f6       	brne	.-72     	; 0x2c74 <fputc+0x10>
    2cbc:	d8 01       	movw	r26, r16
    2cbe:	16 96       	adiw	r26, 0x06	; 6
    2cc0:	8d 91       	ld	r24, X+
    2cc2:	9c 91       	ld	r25, X
    2cc4:	17 97       	sbiw	r26, 0x07	; 7
    2cc6:	01 96       	adiw	r24, 0x01	; 1
    2cc8:	17 96       	adiw	r26, 0x07	; 7
    2cca:	9c 93       	st	X, r25
    2ccc:	8e 93       	st	-X, r24
    2cce:	16 97       	sbiw	r26, 0x06	; 6
    2cd0:	ce 01       	movw	r24, r28
    2cd2:	df 91       	pop	r29
    2cd4:	cf 91       	pop	r28
    2cd6:	1f 91       	pop	r17
    2cd8:	0f 91       	pop	r16
    2cda:	08 95       	ret

00002cdc <__ultoa_invert>:
    2cdc:	fa 01       	movw	r30, r20
    2cde:	aa 27       	eor	r26, r26
    2ce0:	28 30       	cpi	r18, 0x08	; 8
    2ce2:	51 f1       	breq	.+84     	; 0x2d38 <__ultoa_invert+0x5c>
    2ce4:	20 31       	cpi	r18, 0x10	; 16
    2ce6:	81 f1       	breq	.+96     	; 0x2d48 <__ultoa_invert+0x6c>
    2ce8:	e8 94       	clt
    2cea:	6f 93       	push	r22
    2cec:	6e 7f       	andi	r22, 0xFE	; 254
    2cee:	6e 5f       	subi	r22, 0xFE	; 254
    2cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf2:	8f 4f       	sbci	r24, 0xFF	; 255
    2cf4:	9f 4f       	sbci	r25, 0xFF	; 255
    2cf6:	af 4f       	sbci	r26, 0xFF	; 255
    2cf8:	b1 e0       	ldi	r27, 0x01	; 1
    2cfa:	3e d0       	rcall	.+124    	; 0x2d78 <__ultoa_invert+0x9c>
    2cfc:	b4 e0       	ldi	r27, 0x04	; 4
    2cfe:	3c d0       	rcall	.+120    	; 0x2d78 <__ultoa_invert+0x9c>
    2d00:	67 0f       	add	r22, r23
    2d02:	78 1f       	adc	r23, r24
    2d04:	89 1f       	adc	r24, r25
    2d06:	9a 1f       	adc	r25, r26
    2d08:	a1 1d       	adc	r26, r1
    2d0a:	68 0f       	add	r22, r24
    2d0c:	79 1f       	adc	r23, r25
    2d0e:	8a 1f       	adc	r24, r26
    2d10:	91 1d       	adc	r25, r1
    2d12:	a1 1d       	adc	r26, r1
    2d14:	6a 0f       	add	r22, r26
    2d16:	71 1d       	adc	r23, r1
    2d18:	81 1d       	adc	r24, r1
    2d1a:	91 1d       	adc	r25, r1
    2d1c:	a1 1d       	adc	r26, r1
    2d1e:	20 d0       	rcall	.+64     	; 0x2d60 <__ultoa_invert+0x84>
    2d20:	09 f4       	brne	.+2      	; 0x2d24 <__ultoa_invert+0x48>
    2d22:	68 94       	set
    2d24:	3f 91       	pop	r19
    2d26:	2a e0       	ldi	r18, 0x0A	; 10
    2d28:	26 9f       	mul	r18, r22
    2d2a:	11 24       	eor	r1, r1
    2d2c:	30 19       	sub	r19, r0
    2d2e:	30 5d       	subi	r19, 0xD0	; 208
    2d30:	31 93       	st	Z+, r19
    2d32:	de f6       	brtc	.-74     	; 0x2cea <__ultoa_invert+0xe>
    2d34:	cf 01       	movw	r24, r30
    2d36:	08 95       	ret
    2d38:	46 2f       	mov	r20, r22
    2d3a:	47 70       	andi	r20, 0x07	; 7
    2d3c:	40 5d       	subi	r20, 0xD0	; 208
    2d3e:	41 93       	st	Z+, r20
    2d40:	b3 e0       	ldi	r27, 0x03	; 3
    2d42:	0f d0       	rcall	.+30     	; 0x2d62 <__ultoa_invert+0x86>
    2d44:	c9 f7       	brne	.-14     	; 0x2d38 <__ultoa_invert+0x5c>
    2d46:	f6 cf       	rjmp	.-20     	; 0x2d34 <__ultoa_invert+0x58>
    2d48:	46 2f       	mov	r20, r22
    2d4a:	4f 70       	andi	r20, 0x0F	; 15
    2d4c:	40 5d       	subi	r20, 0xD0	; 208
    2d4e:	4a 33       	cpi	r20, 0x3A	; 58
    2d50:	18 f0       	brcs	.+6      	; 0x2d58 <__ultoa_invert+0x7c>
    2d52:	49 5d       	subi	r20, 0xD9	; 217
    2d54:	31 fd       	sbrc	r19, 1
    2d56:	40 52       	subi	r20, 0x20	; 32
    2d58:	41 93       	st	Z+, r20
    2d5a:	02 d0       	rcall	.+4      	; 0x2d60 <__ultoa_invert+0x84>
    2d5c:	a9 f7       	brne	.-22     	; 0x2d48 <__ultoa_invert+0x6c>
    2d5e:	ea cf       	rjmp	.-44     	; 0x2d34 <__ultoa_invert+0x58>
    2d60:	b4 e0       	ldi	r27, 0x04	; 4
    2d62:	a6 95       	lsr	r26
    2d64:	97 95       	ror	r25
    2d66:	87 95       	ror	r24
    2d68:	77 95       	ror	r23
    2d6a:	67 95       	ror	r22
    2d6c:	ba 95       	dec	r27
    2d6e:	c9 f7       	brne	.-14     	; 0x2d62 <__ultoa_invert+0x86>
    2d70:	00 97       	sbiw	r24, 0x00	; 0
    2d72:	61 05       	cpc	r22, r1
    2d74:	71 05       	cpc	r23, r1
    2d76:	08 95       	ret
    2d78:	9b 01       	movw	r18, r22
    2d7a:	ac 01       	movw	r20, r24
    2d7c:	0a 2e       	mov	r0, r26
    2d7e:	06 94       	lsr	r0
    2d80:	57 95       	ror	r21
    2d82:	47 95       	ror	r20
    2d84:	37 95       	ror	r19
    2d86:	27 95       	ror	r18
    2d88:	ba 95       	dec	r27
    2d8a:	c9 f7       	brne	.-14     	; 0x2d7e <__ultoa_invert+0xa2>
    2d8c:	62 0f       	add	r22, r18
    2d8e:	73 1f       	adc	r23, r19
    2d90:	84 1f       	adc	r24, r20
    2d92:	95 1f       	adc	r25, r21
    2d94:	a0 1d       	adc	r26, r0
    2d96:	08 95       	ret

00002d98 <eeprom_read_word>:
    2d98:	a8 e1       	ldi	r26, 0x18	; 24
    2d9a:	b0 e0       	ldi	r27, 0x00	; 0
    2d9c:	42 e0       	ldi	r20, 0x02	; 2
    2d9e:	50 e0       	ldi	r21, 0x00	; 0
    2da0:	05 c0       	rjmp	.+10     	; 0x2dac <eeprom_read_blraw>

00002da2 <eeprom_write_word>:
    2da2:	12 d0       	rcall	.+36     	; 0x2dc8 <eeprom_write_byte>
    2da4:	27 2f       	mov	r18, r23
    2da6:	11 c0       	rjmp	.+34     	; 0x2dca <eeprom_write_r18>

00002da8 <eeprom_read_block>:
    2da8:	dc 01       	movw	r26, r24
    2daa:	cb 01       	movw	r24, r22

00002dac <eeprom_read_blraw>:
    2dac:	fc 01       	movw	r30, r24
    2dae:	f9 99       	sbic	0x1f, 1	; 31
    2db0:	fe cf       	rjmp	.-4      	; 0x2dae <eeprom_read_blraw+0x2>
    2db2:	06 c0       	rjmp	.+12     	; 0x2dc0 <eeprom_read_blraw+0x14>
    2db4:	f2 bd       	out	0x22, r31	; 34
    2db6:	e1 bd       	out	0x21, r30	; 33
    2db8:	f8 9a       	sbi	0x1f, 0	; 31
    2dba:	31 96       	adiw	r30, 0x01	; 1
    2dbc:	00 b4       	in	r0, 0x20	; 32
    2dbe:	0d 92       	st	X+, r0
    2dc0:	41 50       	subi	r20, 0x01	; 1
    2dc2:	50 40       	sbci	r21, 0x00	; 0
    2dc4:	b8 f7       	brcc	.-18     	; 0x2db4 <eeprom_read_blraw+0x8>
    2dc6:	08 95       	ret

00002dc8 <eeprom_write_byte>:
    2dc8:	26 2f       	mov	r18, r22

00002dca <eeprom_write_r18>:
    2dca:	f9 99       	sbic	0x1f, 1	; 31
    2dcc:	fe cf       	rjmp	.-4      	; 0x2dca <eeprom_write_r18>
    2dce:	92 bd       	out	0x22, r25	; 34
    2dd0:	81 bd       	out	0x21, r24	; 33
    2dd2:	20 bd       	out	0x20, r18	; 32
    2dd4:	0f b6       	in	r0, 0x3f	; 63
    2dd6:	f8 94       	cli
    2dd8:	fa 9a       	sbi	0x1f, 2	; 31
    2dda:	f9 9a       	sbi	0x1f, 1	; 31
    2ddc:	0f be       	out	0x3f, r0	; 63
    2dde:	01 96       	adiw	r24, 0x01	; 1
    2de0:	08 95       	ret

00002de2 <_exit>:
    2de2:	f8 94       	cli

00002de4 <__stop_program>:
    2de4:	ff cf       	rjmp	.-2      	; 0x2de4 <__stop_program>
