
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002d3a  00002dce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d3a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000026b  008001e0  008001e0  00002eae  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002eae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002f3c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000568  00000000  00000000  00002f80  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006f14  00000000  00000000  000034e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001db5  00000000  00000000  0000a3fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003215  00000000  00000000  0000c1b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001080  00000000  00000000  0000f3c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a09  00000000  00000000  00010448  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000046c5  00000000  00000000  00011e51  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000448  00000000  00000000  00016516  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 19 0d 	jmp	0x1a32	; 0x1a32 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 cd 0b 	jmp	0x179a	; 0x179a <__vector_16>
      44:	0c 94 08 11 	jmp	0x2210	; 0x2210 <__vector_17>
      48:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 bd 0a 	jmp	0x157a	; 0x157a <__vector_21>
      58:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 f6 0a 	jmp	0x15ec	; 0x15ec <__vector_32>
      84:	0c 94 d8 0a 	jmp	0x15b0	; 0x15b0 <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	8b 0e       	add	r8, r27
      96:	90 0e       	add	r9, r16
      98:	96 0e       	add	r9, r22
      9a:	9c 0e       	add	r9, r28
      9c:	a2 0e       	add	r10, r18
      9e:	a7 0e       	add	r10, r23
      a0:	ad 0e       	add	r10, r29
      a2:	b3 0e       	add	r11, r19

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	ea e3       	ldi	r30, 0x3A	; 58
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	ab 34       	cpi	r26, 0x4B	; 75
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 38 0b 	call	0x1670	; 0x1670 <main>
      de:	0c 94 9b 16 	jmp	0x2d36	; 0x2d36 <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_save_position>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	81 30       	cpi	r24, 0x01	; 1
      e6:	69 f0       	breq	.+26     	; 0x102 <actuator_save_position+0x1e>
      e8:	18 f0       	brcs	.+6      	; 0xf0 <actuator_save_position+0xc>
      ea:	82 30       	cpi	r24, 0x02	; 2
      ec:	99 f0       	breq	.+38     	; 0x114 <actuator_save_position+0x30>
      ee:	08 95       	ret
      f0:	ca 01       	movw	r24, r20
      f2:	b9 01       	movw	r22, r18
      f4:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
      f8:	8a e2       	ldi	r24, 0x2A	; 42
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	0c 94 8b 16 	jmp	0x2d16	; 0x2d16 <eeprom_write_word>
     100:	08 95       	ret
     102:	ca 01       	movw	r24, r20
     104:	b9 01       	movw	r22, r18
     106:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     10a:	8e e2       	ldi	r24, 0x2E	; 46
     10c:	90 e0       	ldi	r25, 0x00	; 0
     10e:	0c 94 8b 16 	jmp	0x2d16	; 0x2d16 <eeprom_write_word>
     112:	08 95       	ret
     114:	ca 01       	movw	r24, r20
     116:	b9 01       	movw	r22, r18
     118:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     11c:	8c e2       	ldi	r24, 0x2C	; 44
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	0c 94 8b 16 	jmp	0x2d16	; 0x2d16 <eeprom_write_word>
     124:	08 95       	ret

00000126 <actuator_pwm>:
     126:	89 2b       	or	r24, r25
     128:	29 f0       	breq	.+10     	; 0x134 <actuator_pwm+0xe>
     12a:	81 e0       	ldi	r24, 0x01	; 1
     12c:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     130:	75 9a       	sbi	0x0e, 5	; 14
     132:	08 95       	ret
     134:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     138:	75 98       	cbi	0x0e, 5	; 14
     13a:	08 95       	ret

0000013c <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     13c:	4f 92       	push	r4
     13e:	5f 92       	push	r5
     140:	6f 92       	push	r6
     142:	7f 92       	push	r7
     144:	9f 92       	push	r9
     146:	af 92       	push	r10
     148:	bf 92       	push	r11
     14a:	cf 92       	push	r12
     14c:	df 92       	push	r13
     14e:	ef 92       	push	r14
     150:	ff 92       	push	r15
     152:	0f 93       	push	r16
     154:	1f 93       	push	r17
     156:	cf 93       	push	r28
     158:	df 93       	push	r29
     15a:	ec 01       	movw	r28, r24
     15c:	96 2e       	mov	r9, r22
     15e:	c6 01       	movw	r24, r12
     160:	b5 01       	movw	r22, r10
			2) Position_ERROR
			3) actuator_duty_cycle
			4) gear_status
*/
	float kp = 0.7; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value 
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     162:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     166:	87 01       	movw	r16, r14
     168:	06 1b       	sub	r16, r22
     16a:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     16c:	b8 01       	movw	r22, r16
     16e:	01 2e       	mov	r0, r17
     170:	00 0c       	add	r0, r0
     172:	88 0b       	sbc	r24, r24
     174:	99 0b       	sbc	r25, r25
     176:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     17a:	2b 01       	movw	r4, r22
     17c:	3c 01       	movw	r6, r24
     17e:	23 e3       	ldi	r18, 0x33	; 51
     180:	33 e3       	ldi	r19, 0x33	; 51
     182:	43 e3       	ldi	r20, 0x33	; 51
     184:	5f e3       	ldi	r21, 0x3F	; 63
     186:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     18a:	20 e0       	ldi	r18, 0x00	; 0
     18c:	30 e0       	ldi	r19, 0x00	; 0
     18e:	45 e8       	ldi	r20, 0x85	; 133
     190:	52 e4       	ldi	r21, 0x42	; 66
     192:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     196:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     19a:	6b 01       	movw	r12, r22
     19c:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	40 e2       	ldi	r20, 0x20	; 32
     1a4:	51 e4       	ldi	r21, 0x41	; 65
     1a6:	c3 01       	movw	r24, r6
     1a8:	b2 01       	movw	r22, r4
     1aa:	0e 94 a9 11 	call	0x2352	; 0x2352 <__cmpsf2>
     1ae:	88 23       	and	r24, r24
     1b0:	c4 f5       	brge	.+112    	; 0x222 <actuator_set_position+0xe6>
     1b2:	20 e0       	ldi	r18, 0x00	; 0
     1b4:	30 e0       	ldi	r19, 0x00	; 0
     1b6:	40 e2       	ldi	r20, 0x20	; 32
     1b8:	51 ec       	ldi	r21, 0xC1	; 193
     1ba:	c3 01       	movw	r24, r6
     1bc:	b2 01       	movw	r22, r4
     1be:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <__gesf2>
     1c2:	18 16       	cp	r1, r24
     1c4:	74 f5       	brge	.+92     	; 0x222 <actuator_set_position+0xe6>
     1c6:	30 c0       	rjmp	.+96     	; 0x228 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     1c8:	8c 81       	ldd	r24, Y+4	; 0x04
     1ca:	9d 81       	ldd	r25, Y+5	; 0x05
     1cc:	00 97       	sbiw	r24, 0x00	; 0
     1ce:	29 f0       	breq	.+10     	; 0x1da <actuator_set_position+0x9e>
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	89 f4       	brne	.+34     	; 0x1f6 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     1d4:	1b 82       	std	Y+3, r1	; 0x03
     1d6:	1a 82       	std	Y+2, r1	; 0x02
		break;
     1d8:	0e c0       	rjmp	.+28     	; 0x1f6 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     1da:	10 16       	cp	r1, r16
     1dc:	11 06       	cpc	r1, r17
     1de:	2c f4       	brge	.+10     	; 0x1ea <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	9b 83       	std	Y+3, r25	; 0x03
     1e6:	8a 83       	std	Y+2, r24	; 0x02
     1e8:	06 c0       	rjmp	.+12     	; 0x1f6 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     1ea:	11 23       	and	r17, r17
     1ec:	24 f4       	brge	.+8      	; 0x1f6 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     1ee:	82 e0       	ldi	r24, 0x02	; 2
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	9b 83       	std	Y+3, r25	; 0x03
     1f4:	8a 83       	std	Y+2, r24	; 0x02
     1f6:	c6 01       	movw	r24, r12
     1f8:	83 38       	cpi	r24, 0x83	; 131
     1fa:	91 05       	cpc	r25, r1
     1fc:	14 f0       	brlt	.+4      	; 0x202 <actuator_set_position+0xc6>
     1fe:	82 e8       	ldi	r24, 0x82	; 130
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	6c 01       	movw	r12, r24
     204:	99 23       	and	r25, r25
     206:	14 f4       	brge	.+4      	; 0x20c <actuator_set_position+0xd0>
     208:	c1 2c       	mov	r12, r1
     20a:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     20c:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     210:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     214:	db 86       	std	Y+11, r13	; 0x0b
     216:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     218:	4e 82       	std	Y+6, r4	; 0x06
     21a:	5f 82       	std	Y+7, r5	; 0x07
     21c:	68 86       	std	Y+8, r6	; 0x08
     21e:	79 86       	std	Y+9, r7	; 0x09
}
     220:	0c c0       	rjmp	.+24     	; 0x23a <actuator_set_position+0xfe>
	{
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
	} else
	{
		actuator_values->actuator_in_position = 0;
     222:	1d 82       	std	Y+5, r1	; 0x05
     224:	1c 82       	std	Y+4, r1	; 0x04
     226:	d0 cf       	rjmp	.-96     	; 0x1c8 <actuator_set_position+0x8c>
	
	//Is the actuator with in an acceptable error
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     228:	81 e0       	ldi	r24, 0x01	; 1
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	9d 83       	std	Y+5, r25	; 0x05
     22e:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     230:	89 2d       	mov	r24, r9
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	99 83       	std	Y+1, r25	; 0x01
     236:	88 83       	st	Y, r24
     238:	c7 cf       	rjmp	.-114    	; 0x1c8 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     23a:	df 91       	pop	r29
     23c:	cf 91       	pop	r28
     23e:	1f 91       	pop	r17
     240:	0f 91       	pop	r16
     242:	ff 90       	pop	r15
     244:	ef 90       	pop	r14
     246:	df 90       	pop	r13
     248:	cf 90       	pop	r12
     24a:	bf 90       	pop	r11
     24c:	af 90       	pop	r10
     24e:	9f 90       	pop	r9
     250:	7f 90       	pop	r7
     252:	6f 90       	pop	r6
     254:	5f 90       	pop	r5
     256:	4f 90       	pop	r4
     258:	08 95       	ret

0000025a <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     25a:	af 92       	push	r10
     25c:	bf 92       	push	r11
     25e:	cf 92       	push	r12
     260:	df 92       	push	r13
     262:	ef 92       	push	r14
     264:	ff 92       	push	r15
     266:	0f 93       	push	r16
     268:	1f 93       	push	r17
     26a:	cf 93       	push	r28
     26c:	df 93       	push	r29
     26e:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     270:	8b a1       	ldd	r24, Y+35	; 0x23
     272:	9c a1       	ldd	r25, Y+36	; 0x24
     274:	89 2b       	or	r24, r25
     276:	a9 f1       	breq	.+106    	; 0x2e2 <actuator_p_controller+0x88>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     278:	8b ad       	ldd	r24, Y+59	; 0x3b
     27a:	81 30       	cpi	r24, 0x01	; 1
     27c:	39 f0       	breq	.+14     	; 0x28c <actuator_p_controller+0x32>
     27e:	18 f0       	brcs	.+6      	; 0x286 <actuator_p_controller+0x2c>
     280:	82 30       	cpi	r24, 0x02	; 2
     282:	39 f0       	breq	.+14     	; 0x292 <actuator_p_controller+0x38>
     284:	09 c0       	rjmp	.+18     	; 0x298 <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     286:	ec a8       	ldd	r14, Y+52	; 0x34
     288:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     28a:	08 c0       	rjmp	.+16     	; 0x29c <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     28c:	ee a8       	ldd	r14, Y+54	; 0x36
     28e:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     290:	05 c0       	rjmp	.+10     	; 0x29c <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     292:	e8 ac       	ldd	r14, Y+56	; 0x38
     294:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     296:	02 c0       	rjmp	.+4      	; 0x29c <actuator_p_controller+0x42>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     298:	e1 2c       	mov	r14, r1
     29a:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     29c:	ab a4       	ldd	r10, Y+43	; 0x2b
     29e:	bc a4       	ldd	r11, Y+44	; 0x2c
     2a0:	cd a4       	ldd	r12, Y+45	; 0x2d
     2a2:	de a4       	ldd	r13, Y+46	; 0x2e
     2a4:	0f a5       	ldd	r16, Y+47	; 0x2f
     2a6:	2f a1       	ldd	r18, Y+39	; 0x27
     2a8:	38 a5       	ldd	r19, Y+40	; 0x28
     2aa:	49 a5       	ldd	r20, Y+41	; 0x29
     2ac:	5a a5       	ldd	r21, Y+42	; 0x2a
     2ae:	6b ad       	ldd	r22, Y+59	; 0x3b
     2b0:	10 e0       	ldi	r17, 0x00	; 0
     2b2:	80 ee       	ldi	r24, 0xE0	; 224
     2b4:	91 e0       	ldi	r25, 0x01	; 1
     2b6:	42 df       	rcall	.-380    	; 0x13c <actuator_set_position>
		//UPDATE ComValues
		vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
     2b8:	e0 ee       	ldi	r30, 0xE0	; 224
     2ba:	f1 e0       	ldi	r31, 0x01	; 1
     2bc:	82 85       	ldd	r24, Z+10	; 0x0a
     2be:	93 85       	ldd	r25, Z+11	; 0x0b
     2c0:	8f a7       	std	Y+47, r24	; 0x2f
		vals->actuator_direction = ActuatorComValues.actuator_direction;
     2c2:	82 81       	ldd	r24, Z+2	; 0x02
     2c4:	93 81       	ldd	r25, Z+3	; 0x03
     2c6:	8c af       	std	Y+60, r24	; 0x3c
		vals->gear_status = ActuatorComValues.clutch_state;
     2c8:	80 81       	ld	r24, Z
     2ca:	91 81       	ldd	r25, Z+1	; 0x01
     2cc:	8a af       	std	Y+58, r24	; 0x3a
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
		
		if (ActuatorComValues.actuator_in_position)
     2ce:	84 81       	ldd	r24, Z+4	; 0x04
     2d0:	95 81       	ldd	r25, Z+5	; 0x05
     2d2:	89 2b       	or	r24, r25
     2d4:	b1 f1       	breq	.+108    	; 0x342 <actuator_p_controller+0xe8>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     2d6:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     2da:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     2de:	8a af       	std	Y+58, r24	; 0x3a
     2e0:	30 c0       	rjmp	.+96     	; 0x342 <actuator_p_controller+0xe8>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     2e2:	ea a8       	ldd	r14, Y+50	; 0x32
     2e4:	fb a8       	ldd	r15, Y+51	; 0x33
		vals->uart_debug = target_position;
     2e6:	b7 01       	movw	r22, r14
     2e8:	80 e0       	ldi	r24, 0x00	; 0
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     2f0:	6f a3       	std	Y+39, r22	; 0x27
     2f2:	78 a7       	std	Y+40, r23	; 0x28
     2f4:	89 a7       	std	Y+41, r24	; 0x29
     2f6:	9a a7       	std	Y+42, r25	; 0x2a
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     2f8:	ab a4       	ldd	r10, Y+43	; 0x2b
     2fa:	bc a4       	ldd	r11, Y+44	; 0x2c
     2fc:	cd a4       	ldd	r12, Y+45	; 0x2d
     2fe:	de a4       	ldd	r13, Y+46	; 0x2e
     300:	0f a5       	ldd	r16, Y+47	; 0x2f
     302:	2f a1       	ldd	r18, Y+39	; 0x27
     304:	38 a5       	ldd	r19, Y+40	; 0x28
     306:	49 a5       	ldd	r20, Y+41	; 0x29
     308:	5a a5       	ldd	r21, Y+42	; 0x2a
     30a:	6b ad       	ldd	r22, Y+59	; 0x3b
     30c:	10 e0       	ldi	r17, 0x00	; 0
     30e:	80 ee       	ldi	r24, 0xE0	; 224
     310:	91 e0       	ldi	r25, 0x01	; 1
     312:	14 df       	rcall	.-472    	; 0x13c <actuator_set_position>
		//UPDATE ComValues
		vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
     314:	e0 ee       	ldi	r30, 0xE0	; 224
     316:	f1 e0       	ldi	r31, 0x01	; 1
     318:	82 85       	ldd	r24, Z+10	; 0x0a
     31a:	93 85       	ldd	r25, Z+11	; 0x0b
     31c:	8f a7       	std	Y+47, r24	; 0x2f
		vals->actuator_direction = ActuatorComValues.actuator_direction;
     31e:	82 81       	ldd	r24, Z+2	; 0x02
     320:	93 81       	ldd	r25, Z+3	; 0x03
     322:	8c af       	std	Y+60, r24	; 0x3c
		vals->gear_status = ActuatorComValues.clutch_state;
     324:	80 81       	ld	r24, Z
     326:	91 81       	ldd	r25, Z+1	; 0x01
     328:	8a af       	std	Y+58, r24	; 0x3a
		vals->uart_debug = ActuatorComValues.actuator_in_position;
     32a:	64 81       	ldd	r22, Z+4	; 0x04
     32c:	75 81       	ldd	r23, Z+5	; 0x05
     32e:	07 2e       	mov	r0, r23
     330:	00 0c       	add	r0, r0
     332:	88 0b       	sbc	r24, r24
     334:	99 0b       	sbc	r25, r25
     336:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     33a:	6f a3       	std	Y+39, r22	; 0x27
     33c:	78 a7       	std	Y+40, r23	; 0x28
     33e:	89 a7       	std	Y+41, r24	; 0x29
     340:	9a a7       	std	Y+42, r25	; 0x2a
	}
}
     342:	df 91       	pop	r29
     344:	cf 91       	pop	r28
     346:	1f 91       	pop	r17
     348:	0f 91       	pop	r16
     34a:	ff 90       	pop	r15
     34c:	ef 90       	pop	r14
     34e:	df 90       	pop	r13
     350:	cf 90       	pop	r12
     352:	bf 90       	pop	r11
     354:	af 90       	pop	r10
     356:	08 95       	ret

00000358 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     358:	10 92 ed 01 	sts	0x01ED, r1	; 0x8001ed <f32_Integrator>
     35c:	10 92 ee 01 	sts	0x01EE, r1	; 0x8001ee <f32_Integrator+0x1>
     360:	10 92 ef 01 	sts	0x01EF, r1	; 0x8001ef <f32_Integrator+0x2>
     364:	10 92 f0 01 	sts	0x01F0, r1	; 0x8001f0 <f32_Integrator+0x3>
     368:	08 95       	ret

0000036a <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     36a:	68 2f       	mov	r22, r24
     36c:	70 e0       	ldi	r23, 0x00	; 0
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	90 e0       	ldi	r25, 0x00	; 0
     372:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     376:	20 e0       	ldi	r18, 0x00	; 0
     378:	30 e0       	ldi	r19, 0x00	; 0
     37a:	48 e4       	ldi	r20, 0x48	; 72
     37c:	52 e4       	ldi	r21, 0x42	; 66
     37e:	0e 94 44 11 	call	0x2288	; 0x2288 <__subsf3>
     382:	27 ed       	ldi	r18, 0xD7	; 215
     384:	33 ea       	ldi	r19, 0xA3	; 163
     386:	48 e8       	ldi	r20, 0x88	; 136
     388:	51 e4       	ldi	r21, 0x41	; 65
     38a:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     38e:	60 93 ed 01 	sts	0x01ED, r22	; 0x8001ed <f32_Integrator>
     392:	70 93 ee 01 	sts	0x01EE, r23	; 0x8001ee <f32_Integrator+0x1>
     396:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <f32_Integrator+0x2>
     39a:	90 93 f0 01 	sts	0x01F0, r25	; 0x8001f0 <f32_Integrator+0x3>
     39e:	08 95       	ret

000003a0 <controller>:
}

void controller(volatile ModuleValues_t *vals){
     3a0:	8f 92       	push	r8
     3a2:	9f 92       	push	r9
     3a4:	af 92       	push	r10
     3a6:	bf 92       	push	r11
     3a8:	cf 92       	push	r12
     3aa:	df 92       	push	r13
     3ac:	ef 92       	push	r14
     3ae:	ff 92       	push	r15
     3b0:	0f 93       	push	r16
     3b2:	1f 93       	push	r17
     3b4:	cf 93       	push	r28
     3b6:	df 93       	push	r29
     3b8:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     3ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
     3bc:	82 30       	cpi	r24, 0x02	; 2
     3be:	21 f4       	brne	.+8      	; 0x3c8 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     3c0:	68 8d       	ldd	r22, Y+24	; 0x18
     3c2:	16 2f       	mov	r17, r22
     3c4:	11 95       	neg	r17
     3c6:	01 c0       	rjmp	.+2      	; 0x3ca <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     3c8:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     3ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	09 f4       	brne	.+2      	; 0x3d2 <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     3d0:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     3d2:	89 a1       	ldd	r24, Y+33	; 0x21
     3d4:	81 11       	cpse	r24, r1
     3d6:	7b c0       	rjmp	.+246    	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     3d8:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     3dc:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     3e0:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     3e4:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	4e eb       	ldi	r20, 0xBE	; 190
     3ee:	52 e4       	ldi	r21, 0x42	; 66
     3f0:	c7 01       	movw	r24, r14
     3f2:	b6 01       	movw	r22, r12
     3f4:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <__gesf2>
     3f8:	88 23       	and	r24, r24
     3fa:	54 f4       	brge	.+20     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3fc:	20 e0       	ldi	r18, 0x00	; 0
     3fe:	30 e0       	ldi	r19, 0x00	; 0
     400:	48 e4       	ldi	r20, 0x48	; 72
     402:	52 e4       	ldi	r21, 0x42	; 66
     404:	c7 01       	movw	r24, r14
     406:	b6 01       	movw	r22, r12
     408:	0e 94 a9 11 	call	0x2352	; 0x2352 <__cmpsf2>
     40c:	18 16       	cp	r1, r24
     40e:	6c f0       	brlt	.+26     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
		{
			b_saturation = 1 ;
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	80 93 ec 01 	sts	0x01EC, r24	; 0x8001ec <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     416:	61 2f       	mov	r22, r17
     418:	11 0f       	add	r17, r17
     41a:	77 0b       	sbc	r23, r23
     41c:	88 0b       	sbc	r24, r24
     41e:	99 0b       	sbc	r25, r25
     420:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     424:	6b 01       	movw	r12, r22
     426:	7c 01       	movw	r14, r24
     428:	25 c0       	rjmp	.+74     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     42a:	10 92 ec 01 	sts	0x01EC, r1	; 0x8001ec <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     42e:	61 2f       	mov	r22, r17
     430:	11 0f       	add	r17, r17
     432:	77 0b       	sbc	r23, r23
     434:	88 0b       	sbc	r24, r24
     436:	99 0b       	sbc	r25, r25
     438:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     43c:	6b 01       	movw	r12, r22
     43e:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     440:	2a e0       	ldi	r18, 0x0A	; 10
     442:	37 ed       	ldi	r19, 0xD7	; 215
     444:	43 ea       	ldi	r20, 0xA3	; 163
     446:	5b e3       	ldi	r21, 0x3B	; 59
     448:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     44c:	9b 01       	movw	r18, r22
     44e:	ac 01       	movw	r20, r24
     450:	60 91 ed 01 	lds	r22, 0x01ED	; 0x8001ed <f32_Integrator>
     454:	70 91 ee 01 	lds	r23, 0x01EE	; 0x8001ee <f32_Integrator+0x1>
     458:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <f32_Integrator+0x2>
     45c:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <f32_Integrator+0x3>
     460:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     464:	60 93 ed 01 	sts	0x01ED, r22	; 0x8001ed <f32_Integrator>
     468:	70 93 ee 01 	sts	0x01EE, r23	; 0x8001ee <f32_Integrator+0x1>
     46c:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <f32_Integrator+0x2>
     470:	90 93 f0 01 	sts	0x01F0, r25	; 0x8001f0 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     474:	27 ed       	ldi	r18, 0xD7	; 215
     476:	33 ea       	ldi	r19, 0xA3	; 163
     478:	48 e8       	ldi	r20, 0x88	; 136
     47a:	51 e4       	ldi	r21, 0x41	; 65
     47c:	60 91 ed 01 	lds	r22, 0x01ED	; 0x8001ed <f32_Integrator>
     480:	70 91 ee 01 	lds	r23, 0x01EE	; 0x8001ee <f32_Integrator+0x1>
     484:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <f32_Integrator+0x2>
     488:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <f32_Integrator+0x3>
     48c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     490:	4b 01       	movw	r8, r22
     492:	5c 01       	movw	r10, r24
     494:	27 e8       	ldi	r18, 0x87	; 135
     496:	3f eb       	ldi	r19, 0xBF	; 191
     498:	46 e2       	ldi	r20, 0x26	; 38
     49a:	5e e3       	ldi	r21, 0x3E	; 62
     49c:	c7 01       	movw	r24, r14
     49e:	b6 01       	movw	r22, r12
     4a0:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     4a4:	9b 01       	movw	r18, r22
     4a6:	ac 01       	movw	r20, r24
     4a8:	c5 01       	movw	r24, r10
     4aa:	b4 01       	movw	r22, r8
     4ac:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     4b0:	20 e0       	ldi	r18, 0x00	; 0
     4b2:	30 e0       	ldi	r19, 0x00	; 0
     4b4:	48 e4       	ldi	r20, 0x48	; 72
     4b6:	52 e4       	ldi	r21, 0x42	; 66
     4b8:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     4bc:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     4c0:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     4c4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     4c8:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     4cc:	11 c0       	rjmp	.+34     	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
	
	}else if (vals->ctrl_type == PWM)
     4ce:	89 a1       	ldd	r24, Y+33	; 0x21
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	71 f4       	brne	.+28     	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     4d4:	69 8d       	ldd	r22, Y+25	; 0x19
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     4e0:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     4e4:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     4e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     4ec:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     4f0:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     4f4:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     4f8:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     4fc:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     500:	20 e0       	ldi	r18, 0x00	; 0
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	4e eb       	ldi	r20, 0xBE	; 190
     506:	52 e4       	ldi	r21, 0x42	; 66
     508:	c7 01       	movw	r24, r14
     50a:	b6 01       	movw	r22, r12
     50c:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <__gesf2>
     510:	18 16       	cp	r1, r24
     512:	6c f4       	brge	.+26     	; 0x52e <__LOCK_REGION_LENGTH__+0x12e>
	{
		f32_DutyCycleCmd = 95;
     514:	80 e0       	ldi	r24, 0x00	; 0
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	ae eb       	ldi	r26, 0xBE	; 190
     51a:	b2 e4       	ldi	r27, 0x42	; 66
     51c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     520:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     524:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     528:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     52c:	16 c0       	rjmp	.+44     	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	48 e4       	ldi	r20, 0x48	; 72
     534:	52 e4       	ldi	r21, 0x42	; 66
     536:	c7 01       	movw	r24, r14
     538:	b6 01       	movw	r22, r12
     53a:	0e 94 a9 11 	call	0x2352	; 0x2352 <__cmpsf2>
     53e:	88 23       	and	r24, r24
     540:	64 f4       	brge	.+24     	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
	{
		f32_DutyCycleCmd = 50;
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	a8 e4       	ldi	r26, 0x48	; 72
     548:	b2 e4       	ldi	r27, 0x42	; 66
     54a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     54e:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     552:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     556:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     55a:	06 e9       	ldi	r16, 0x96	; 150
     55c:	10 e0       	ldi	r17, 0x00	; 0
     55e:	f8 01       	movw	r30, r16
     560:	e0 80       	ld	r14, Z
     562:	f1 80       	ldd	r15, Z+1	; 0x01
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	48 ec       	ldi	r20, 0xC8	; 200
     56a:	52 e4       	ldi	r21, 0x42	; 66
     56c:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     570:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     574:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     578:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     57c:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     580:	4b 01       	movw	r8, r22
     582:	5c 01       	movw	r10, r24
     584:	b7 01       	movw	r22, r14
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	90 e0       	ldi	r25, 0x00	; 0
     58a:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     58e:	9b 01       	movw	r18, r22
     590:	ac 01       	movw	r20, r24
     592:	c5 01       	movw	r24, r10
     594:	b4 01       	movw	r22, r8
     596:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     59a:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     59e:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     5a2:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     5a6:	f8 01       	movw	r30, r16
     5a8:	60 81       	ld	r22, Z
     5aa:	71 81       	ldd	r23, Z+1	; 0x01
     5ac:	00 81       	ld	r16, Z
     5ae:	11 81       	ldd	r17, Z+1	; 0x01
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     5b8:	6b 01       	movw	r12, r22
     5ba:	7c 01       	movw	r14, r24
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	30 e0       	ldi	r19, 0x00	; 0
     5c0:	48 ec       	ldi	r20, 0xC8	; 200
     5c2:	52 e4       	ldi	r21, 0x42	; 66
     5c4:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5c8:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5cc:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     5d0:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     5d4:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     5d8:	4b 01       	movw	r8, r22
     5da:	5c 01       	movw	r10, r24
     5dc:	b8 01       	movw	r22, r16
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     5e6:	9b 01       	movw	r18, r22
     5e8:	ac 01       	movw	r20, r24
     5ea:	c5 01       	movw	r24, r10
     5ec:	b4 01       	movw	r22, r8
     5ee:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     5f2:	9b 01       	movw	r18, r22
     5f4:	ac 01       	movw	r20, r24
     5f6:	c7 01       	movw	r24, r14
     5f8:	b6 01       	movw	r22, r12
     5fa:	0e 94 44 11 	call	0x2288	; 0x2288 <__subsf3>
     5fe:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     602:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     606:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     60a:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     60e:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     612:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     616:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     61a:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     61e:	69 8f       	std	Y+25, r22	; 0x19

}
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	1f 91       	pop	r17
     626:	0f 91       	pop	r16
     628:	ff 90       	pop	r15
     62a:	ef 90       	pop	r14
     62c:	df 90       	pop	r13
     62e:	cf 90       	pop	r12
     630:	bf 90       	pop	r11
     632:	af 90       	pop	r10
     634:	9f 90       	pop	r9
     636:	8f 90       	pop	r8
     638:	08 95       	ret

0000063a <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     63a:	53 9a       	sbi	0x0a, 3	; 10
     63c:	08 95       	ret

0000063e <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     63e:	81 30       	cpi	r24, 0x01	; 1
     640:	11 f4       	brne	.+4      	; 0x646 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     642:	5b 9a       	sbi	0x0b, 3	; 11
     644:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     646:	5b 98       	cbi	0x0b, 3	; 11
     648:	08 95       	ret

0000064a <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     64a:	cf 93       	push	r28
     64c:	df 93       	push	r29
     64e:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     650:	64 ef       	ldi	r22, 0xF4	; 244
     652:	71 e0       	ldi	r23, 0x01	; 1
     654:	80 e0       	ldi	r24, 0x00	; 0
     656:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	43 e0       	ldi	r20, 0x03	; 3
     65e:	50 e0       	ldi	r21, 0x00	; 0
     660:	61 ef       	ldi	r22, 0xF1	; 241
     662:	71 e0       	ldi	r23, 0x01	; 1
     664:	84 ef       	ldi	r24, 0xF4	; 244
     666:	91 e0       	ldi	r25, 0x01	; 1
     668:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     66c:	e1 ef       	ldi	r30, 0xF1	; 241
     66e:	f1 e0       	ldi	r31, 0x01	; 1
     670:	61 81       	ldd	r22, Z+1	; 0x01
     672:	6f 71       	andi	r22, 0x1F	; 31
     674:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     676:	70 e0       	ldi	r23, 0x00	; 0
     678:	76 2f       	mov	r23, r22
     67a:	66 27       	eor	r22, r22
     67c:	82 81       	ldd	r24, Z+2	; 0x02
     67e:	68 2b       	or	r22, r24
     680:	80 e0       	ldi	r24, 0x00	; 0
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     688:	20 e0       	ldi	r18, 0x00	; 0
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	49 e8       	ldi	r20, 0x89	; 137
     68e:	52 e4       	ldi	r21, 0x42	; 66
     690:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     694:	20 e0       	ldi	r18, 0x00	; 0
     696:	30 e0       	ldi	r19, 0x00	; 0
     698:	40 e2       	ldi	r20, 0x20	; 32
     69a:	51 e4       	ldi	r21, 0x41	; 65
     69c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     6a0:	20 e0       	ldi	r18, 0x00	; 0
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	48 e8       	ldi	r20, 0x88	; 136
     6a6:	51 e4       	ldi	r21, 0x41	; 65
     6a8:	0e 94 44 11 	call	0x2288	; 0x2288 <__subsf3>
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	a9 01       	movw	r20, r18
     6b2:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     6b6:	68 83       	st	Y, r22
     6b8:	79 83       	std	Y+1, r23	; 0x01
     6ba:	8a 83       	std	Y+2, r24	; 0x02
     6bc:	9b 83       	std	Y+3, r25	; 0x03
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	08 95       	ret

000006c4 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     6c4:	cf 93       	push	r28
     6c6:	df 93       	push	r29
     6c8:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     6ca:	64 ef       	ldi	r22, 0xF4	; 244
     6cc:	71 e0       	ldi	r23, 0x01	; 1
     6ce:	81 e0       	ldi	r24, 0x01	; 1
     6d0:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6d4:	21 e0       	ldi	r18, 0x01	; 1
     6d6:	43 e0       	ldi	r20, 0x03	; 3
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	61 ef       	ldi	r22, 0xF1	; 241
     6dc:	71 e0       	ldi	r23, 0x01	; 1
     6de:	84 ef       	ldi	r24, 0xF4	; 244
     6e0:	91 e0       	ldi	r25, 0x01	; 1
     6e2:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6e6:	e1 ef       	ldi	r30, 0xF1	; 241
     6e8:	f1 e0       	ldi	r31, 0x01	; 1
     6ea:	61 81       	ldd	r22, Z+1	; 0x01
     6ec:	6f 71       	andi	r22, 0x1F	; 31
     6ee:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     6f0:	70 e0       	ldi	r23, 0x00	; 0
     6f2:	76 2f       	mov	r23, r22
     6f4:	66 27       	eor	r22, r22
     6f6:	82 81       	ldd	r24, Z+2	; 0x02
     6f8:	68 2b       	or	r22, r24
     6fa:	41 e0       	ldi	r20, 0x01	; 1
     6fc:	ce 01       	movw	r24, r28
     6fe:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <handle_current_sensor>
}
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	08 95       	ret

00000708 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     708:	cf 93       	push	r28
     70a:	df 93       	push	r29
     70c:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     70e:	64 ef       	ldi	r22, 0xF4	; 244
     710:	71 e0       	ldi	r23, 0x01	; 1
     712:	84 e0       	ldi	r24, 0x04	; 4
     714:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     718:	21 e0       	ldi	r18, 0x01	; 1
     71a:	43 e0       	ldi	r20, 0x03	; 3
     71c:	50 e0       	ldi	r21, 0x00	; 0
     71e:	61 ef       	ldi	r22, 0xF1	; 241
     720:	71 e0       	ldi	r23, 0x01	; 1
     722:	84 ef       	ldi	r24, 0xF4	; 244
     724:	91 e0       	ldi	r25, 0x01	; 1
     726:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     72a:	e1 ef       	ldi	r30, 0xF1	; 241
     72c:	f1 e0       	ldi	r31, 0x01	; 1
     72e:	61 81       	ldd	r22, Z+1	; 0x01
     730:	6f 71       	andi	r22, 0x1F	; 31
     732:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     734:	70 e0       	ldi	r23, 0x00	; 0
     736:	76 2f       	mov	r23, r22
     738:	66 27       	eor	r22, r22
     73a:	82 81       	ldd	r24, Z+2	; 0x02
     73c:	68 2b       	or	r22, r24
     73e:	ce 01       	movw	r24, r28
     740:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <handle_temp_sensor>
}
     744:	df 91       	pop	r29
     746:	cf 91       	pop	r28
     748:	08 95       	ret

0000074a <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     74a:	0f 93       	push	r16
     74c:	1f 93       	push	r17
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	00 d0       	rcall	.+0      	; 0x754 <SPI_handler_6+0xa>
     754:	00 d0       	rcall	.+0      	; 0x756 <SPI_handler_6+0xc>
     756:	cd b7       	in	r28, 0x3d	; 61
     758:	de b7       	in	r29, 0x3e	; 62
     75a:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     75c:	64 ef       	ldi	r22, 0xF4	; 244
     75e:	71 e0       	ldi	r23, 0x01	; 1
     760:	86 e0       	ldi	r24, 0x06	; 6
     762:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     766:	21 e0       	ldi	r18, 0x01	; 1
     768:	43 e0       	ldi	r20, 0x03	; 3
     76a:	50 e0       	ldi	r21, 0x00	; 0
     76c:	61 ef       	ldi	r22, 0xF1	; 241
     76e:	71 e0       	ldi	r23, 0x01	; 1
     770:	84 ef       	ldi	r24, 0xF4	; 244
     772:	91 e0       	ldi	r25, 0x01	; 1
     774:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     778:	e1 ef       	ldi	r30, 0xF1	; 241
     77a:	f1 e0       	ldi	r31, 0x01	; 1
     77c:	61 81       	ldd	r22, Z+1	; 0x01
     77e:	6f 71       	andi	r22, 0x1F	; 31
     780:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     782:	70 e0       	ldi	r23, 0x00	; 0
     784:	76 2f       	mov	r23, r22
     786:	66 27       	eor	r22, r22
     788:	82 81       	ldd	r24, Z+2	; 0x02
     78a:	68 2b       	or	r22, r24
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     794:	20 e0       	ldi	r18, 0x00	; 0
     796:	30 e0       	ldi	r19, 0x00	; 0
     798:	40 ea       	ldi	r20, 0xA0	; 160
     79a:	50 e4       	ldi	r21, 0x40	; 64
     79c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     7a0:	20 e0       	ldi	r18, 0x00	; 0
     7a2:	30 e0       	ldi	r19, 0x00	; 0
     7a4:	40 e8       	ldi	r20, 0x80	; 128
     7a6:	59 e3       	ldi	r21, 0x39	; 57
     7a8:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     7b4:	69 81       	ldd	r22, Y+1	; 0x01
     7b6:	7a 81       	ldd	r23, Y+2	; 0x02
     7b8:	8b 81       	ldd	r24, Y+3	; 0x03
     7ba:	9c 81       	ldd	r25, Y+4	; 0x04
     7bc:	20 e0       	ldi	r18, 0x00	; 0
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	48 ec       	ldi	r20, 0xC8	; 200
     7c2:	52 e4       	ldi	r21, 0x42	; 66
     7c4:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     7c8:	20 e0       	ldi	r18, 0x00	; 0
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	48 ec       	ldi	r20, 0xC8	; 200
     7ce:	51 e4       	ldi	r21, 0x41	; 65
     7d0:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
     7d4:	f8 01       	movw	r30, r16
     7d6:	60 83       	st	Z, r22
     7d8:	71 83       	std	Z+1, r23	; 0x01
     7da:	82 83       	std	Z+2, r24	; 0x02
     7dc:	93 83       	std	Z+3, r25	; 0x03
}
     7de:	0f 90       	pop	r0
     7e0:	0f 90       	pop	r0
     7e2:	0f 90       	pop	r0
     7e4:	0f 90       	pop	r0
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	1f 91       	pop	r17
     7ec:	0f 91       	pop	r16
     7ee:	08 95       	ret

000007f0 <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     7f6:	64 ef       	ldi	r22, 0xF4	; 244
     7f8:	71 e0       	ldi	r23, 0x01	; 1
     7fa:	87 e0       	ldi	r24, 0x07	; 7
     7fc:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	43 e0       	ldi	r20, 0x03	; 3
     804:	50 e0       	ldi	r21, 0x00	; 0
     806:	61 ef       	ldi	r22, 0xF1	; 241
     808:	71 e0       	ldi	r23, 0x01	; 1
     80a:	84 ef       	ldi	r24, 0xF4	; 244
     80c:	91 e0       	ldi	r25, 0x01	; 1
     80e:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     812:	e1 ef       	ldi	r30, 0xF1	; 241
     814:	f1 e0       	ldi	r31, 0x01	; 1
     816:	61 81       	ldd	r22, Z+1	; 0x01
     818:	6f 71       	andi	r22, 0x1F	; 31
     81a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	76 2f       	mov	r23, r22
     820:	66 27       	eor	r22, r22
     822:	82 81       	ldd	r24, Z+2	; 0x02
     824:	68 2b       	or	r22, r24
     826:	40 e0       	ldi	r20, 0x00	; 0
     828:	ce 01       	movw	r24, r28
     82a:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <handle_current_sensor>
}
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
     832:	08 95       	ret

00000834 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     834:	0f 93       	push	r16
     836:	1f 93       	push	r17
     838:	cf 93       	push	r28
     83a:	df 93       	push	r29
     83c:	8c 01       	movw	r16, r24
     83e:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     840:	cb 01       	movw	r24, r22
     842:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <can_read_message_if_new>
     846:	88 23       	and	r24, r24
     848:	09 f4       	brne	.+2      	; 0x84c <handle_can+0x18>
     84a:	46 c0       	rjmp	.+140    	; 0x8d8 <handle_can+0xa4>
     84c:	f8 01       	movw	r30, r16
     84e:	86 8d       	ldd	r24, Z+30	; 0x1e
     850:	84 30       	cpi	r24, 0x04	; 4
     852:	09 f4       	brne	.+2      	; 0x856 <handle_can+0x22>
     854:	41 c0       	rjmp	.+130    	; 0x8d8 <handle_can+0xa4>
		switch (rx->id){
     856:	88 81       	ld	r24, Y
     858:	99 81       	ldd	r25, Y+1	; 0x01
     85a:	80 32       	cpi	r24, 0x20	; 32
     85c:	f1 e0       	ldi	r31, 0x01	; 1
     85e:	9f 07       	cpc	r25, r31
     860:	91 f1       	breq	.+100    	; 0x8c6 <handle_can+0x92>
     862:	80 33       	cpi	r24, 0x30	; 48
     864:	92 40       	sbci	r25, 0x02	; 2
     866:	c1 f5       	brne	.+112    	; 0x8d8 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	f8 01       	movw	r30, r16
     86c:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     86e:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     870:	82 e3       	ldi	r24, 0x32	; 50
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	93 8f       	std	Z+27, r25	; 0x1b
     876:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     878:	8e 81       	ldd	r24, Y+6	; 0x06
     87a:	89 30       	cpi	r24, 0x09	; 9
     87c:	40 f0       	brcs	.+16     	; 0x88e <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     87e:	86 95       	lsr	r24
     880:	86 95       	lsr	r24
     882:	86 95       	lsr	r24
     884:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     886:	8e e1       	ldi	r24, 0x1E	; 30
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	95 8f       	std	Z+29, r25	; 0x1d
     88c:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     88e:	8f 81       	ldd	r24, Y+7	; 0x07
     890:	89 30       	cpi	r24, 0x09	; 9
     892:	88 f0       	brcs	.+34     	; 0x8b6 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     894:	8d 81       	ldd	r24, Y+5	; 0x05
     896:	9d ec       	ldi	r25, 0xCD	; 205
     898:	89 9f       	mul	r24, r25
     89a:	81 2d       	mov	r24, r1
     89c:	11 24       	eor	r1, r1
     89e:	86 95       	lsr	r24
     8a0:	86 95       	lsr	r24
     8a2:	86 95       	lsr	r24
     8a4:	f8 01       	movw	r30, r16
     8a6:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     8a8:	8e e1       	ldi	r24, 0x1E	; 30
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	95 8f       	std	Z+29, r25	; 0x1d
     8ae:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     8b0:	8f 81       	ldd	r24, Y+7	; 0x07
     8b2:	89 30       	cpi	r24, 0x09	; 9
     8b4:	10 f4       	brcc	.+4      	; 0x8ba <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     8b6:	f8 01       	movw	r30, r16
     8b8:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     8ba:	8e 81       	ldd	r24, Y+6	; 0x06
     8bc:	89 30       	cpi	r24, 0x09	; 9
     8be:	60 f4       	brcc	.+24     	; 0x8d8 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     8c0:	f8 01       	movw	r30, r16
     8c2:	17 8a       	std	Z+23, r1	; 0x17
     8c4:	09 c0       	rjmp	.+18     	; 0x8d8 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     8c6:	81 e0       	ldi	r24, 0x01	; 1
     8c8:	f8 01       	movw	r30, r16
     8ca:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     8cc:	8b 81       	ldd	r24, Y+3	; 0x03
     8ce:	9c 81       	ldd	r25, Y+4	; 0x04
     8d0:	96 8b       	std	Z+22, r25	; 0x16
     8d2:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     8d4:	8d 81       	ldd	r24, Y+5	; 0x05
     8d6:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	1f 91       	pop	r17
     8de:	0f 91       	pop	r16
     8e0:	08 95       	ret

000008e2 <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
     8e6:	cf 93       	push	r28
     8e8:	df 93       	push	r29
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     8ee:	02 eb       	ldi	r16, 0xB2	; 178
     8f0:	13 e0       	ldi	r17, 0x03	; 3
     8f2:	80 e5       	ldi	r24, 0x50	; 80
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	f8 01       	movw	r30, r16
     8f8:	91 83       	std	Z+1, r25	; 0x01
     8fa:	80 83       	st	Z, r24
	txFrame.length = 8;
     8fc:	88 e0       	ldi	r24, 0x08	; 8
     8fe:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     900:	8d a1       	ldd	r24, Y+37	; 0x25
     902:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     904:	69 85       	ldd	r22, Y+9	; 0x09
     906:	7a 85       	ldd	r23, Y+10	; 0x0a
     908:	8b 85       	ldd	r24, Y+11	; 0x0b
     90a:	9c 85       	ldd	r25, Y+12	; 0x0c
     90c:	20 e0       	ldi	r18, 0x00	; 0
     90e:	30 e0       	ldi	r19, 0x00	; 0
     910:	40 e2       	ldi	r20, 0x20	; 32
     912:	51 e4       	ldi	r21, 0x41	; 65
     914:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     918:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     91c:	f8 01       	movw	r30, r16
     91e:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     920:	69 89       	ldd	r22, Y+17	; 0x11
     922:	7a 89       	ldd	r23, Y+18	; 0x12
     924:	8b 89       	ldd	r24, Y+19	; 0x13
     926:	9c 89       	ldd	r25, Y+20	; 0x14
     928:	20 e0       	ldi	r18, 0x00	; 0
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	40 e2       	ldi	r20, 0x20	; 32
     92e:	51 e4       	ldi	r21, 0x41	; 65
     930:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     934:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     938:	f8 01       	movw	r30, r16
     93a:	76 83       	std	Z+6, r23	; 0x06
     93c:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     93e:	6d 89       	ldd	r22, Y+21	; 0x15
     940:	7e 89       	ldd	r23, Y+22	; 0x16
     942:	8f 89       	ldd	r24, Y+23	; 0x17
     944:	98 8d       	ldd	r25, Y+24	; 0x18
     946:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     94a:	07 2e       	mov	r0, r23
     94c:	00 0c       	add	r0, r0
     94e:	88 0b       	sbc	r24, r24
     950:	99 0b       	sbc	r25, r25
     952:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
     956:	20 e0       	ldi	r18, 0x00	; 0
     958:	30 e0       	ldi	r19, 0x00	; 0
     95a:	48 ec       	ldi	r20, 0xC8	; 200
     95c:	52 e4       	ldi	r21, 0x42	; 66
     95e:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     962:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     966:	9b 01       	movw	r18, r22
     968:	77 23       	and	r23, r23
     96a:	24 f4       	brge	.+8      	; 0x974 <handle_motor_status_can_msg+0x92>
     96c:	22 27       	eor	r18, r18
     96e:	33 27       	eor	r19, r19
     970:	26 1b       	sub	r18, r22
     972:	37 0b       	sbc	r19, r23
     974:	30 93 ba 03 	sts	0x03BA, r19	; 0x8003ba <txFrame+0x8>
     978:	20 93 b9 03 	sts	0x03B9, r18	; 0x8003b9 <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     97c:	6a 8d       	ldd	r22, Y+26	; 0x1a
     97e:	7b 8d       	ldd	r23, Y+27	; 0x1b
     980:	02 eb       	ldi	r16, 0xB2	; 178
     982:	13 e0       	ldi	r17, 0x03	; 3
     984:	80 e0       	ldi	r24, 0x00	; 0
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     98c:	26 e6       	ldi	r18, 0x66	; 102
     98e:	36 e6       	ldi	r19, 0x66	; 102
     990:	46 e6       	ldi	r20, 0x66	; 102
     992:	50 e4       	ldi	r21, 0x40	; 64
     994:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     998:	20 e0       	ldi	r18, 0x00	; 0
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	40 e0       	ldi	r20, 0x00	; 0
     99e:	5f e3       	ldi	r21, 0x3F	; 63
     9a0:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
     9a4:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     9a8:	f8 01       	movw	r30, r16
     9aa:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     9ac:	89 8d       	ldd	r24, Y+25	; 0x19
     9ae:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     9b0:	c8 01       	movw	r24, r16
     9b2:	0e 94 42 10 	call	0x2084	; 0x2084 <can_send_message>
}
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	1f 91       	pop	r17
     9bc:	0f 91       	pop	r16
     9be:	08 95       	ret

000009c0 <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	cd b7       	in	r28, 0x3d	; 61
     9c6:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     9c8:	e7 ea       	ldi	r30, 0xA7	; 167
     9ca:	f3 e0       	ldi	r31, 0x03	; 3
     9cc:	81 e5       	ldi	r24, 0x51	; 81
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	91 83       	std	Z+1, r25	; 0x01
     9d2:	80 83       	st	Z, r24
	txFrame1.length = 1;
     9d4:	81 e0       	ldi	r24, 0x01	; 1
     9d6:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     9d8:	21 96       	adiw	r28, 0x01	; 1
     9da:	8f ad       	ldd	r24, Y+63	; 0x3f
     9dc:	21 97       	sbiw	r28, 0x01	; 1
     9de:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     9e0:	cf 01       	movw	r24, r30
     9e2:	0e 94 42 10 	call	0x2084	; 0x2084 <can_send_message>
}
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	08 95       	ret

000009ec <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     9ec:	6f 92       	push	r6
     9ee:	7f 92       	push	r7
     9f0:	8f 92       	push	r8
     9f2:	9f 92       	push	r9
     9f4:	af 92       	push	r10
     9f6:	bf 92       	push	r11
     9f8:	cf 92       	push	r12
     9fa:	df 92       	push	r13
     9fc:	ef 92       	push	r14
     9fe:	ff 92       	push	r15
     a00:	0f 93       	push	r16
     a02:	1f 93       	push	r17
     a04:	cf 93       	push	r28
     a06:	df 93       	push	r29
     a08:	cd b7       	in	r28, 0x3d	; 61
     a0a:	de b7       	in	r29, 0x3e	; 62
     a0c:	66 97       	sbiw	r28, 0x16	; 22
     a0e:	0f b6       	in	r0, 0x3f	; 63
     a10:	f8 94       	cli
     a12:	de bf       	out	0x3e, r29	; 62
     a14:	0f be       	out	0x3f, r0	; 63
     a16:	cd bf       	out	0x3d, r28	; 61
     a18:	5c 01       	movw	r10, r24
	
	char uart_characters_received[22] = {0};
     a1a:	fe 01       	movw	r30, r28
     a1c:	31 96       	adiw	r30, 0x01	; 1
     a1e:	96 e1       	ldi	r25, 0x16	; 22
     a20:	df 01       	movw	r26, r30
     a22:	1d 92       	st	X+, r1
     a24:	9a 95       	dec	r25
     a26:	e9 f7       	brne	.-6      	; 0xa22 <receive_uart+0x36>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     a28:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <rx0_Head>
     a2c:	20 91 df 03 	lds	r18, 0x03DF	; 0x8003df <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     a30:	92 1b       	sub	r25, r18
     a32:	9f 71       	andi	r25, 0x1F	; 31
     a34:	09 f4       	brne	.+2      	; 0xa38 <receive_uart+0x4c>
     a36:	70 c1       	rjmp	.+736    	; 0xd18 <receive_uart+0x32c>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     a38:	f5 01       	movw	r30, r10
     a3a:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     a3c:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     a3e:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     a40:	66 e1       	ldi	r22, 0x16	; 22
     a42:	ce 01       	movw	r24, r28
     a44:	01 96       	adiw	r24, 0x01	; 1
     a46:	14 d5       	rcall	.+2600   	; 0x1470 <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     a48:	ce 01       	movw	r24, r28
     a4a:	01 96       	adiw	r24, 0x01	; 1
     a4c:	0e 94 68 13 	call	0x26d0	; 0x26d0 <atoi>
     a50:	18 2f       	mov	r17, r24
     a52:	88 2e       	mov	r8, r24
     a54:	99 2e       	mov	r9, r25
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     a56:	d5 01       	movw	r26, r10
     a58:	8d 91       	ld	r24, X+
     a5a:	9c 91       	ld	r25, X
     a5c:	89 2b       	or	r24, r25
     a5e:	71 f4       	brne	.+28     	; 0xa7c <receive_uart+0x90>
     a60:	6f e4       	ldi	r22, 0x4F	; 79
     a62:	71 e0       	ldi	r23, 0x01	; 1
     a64:	ce 01       	movw	r24, r28
     a66:	01 96       	adiw	r24, 0x01	; 1
     a68:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     a6c:	89 2b       	or	r24, r25
     a6e:	31 f4       	brne	.+12     	; 0xa7c <receive_uart+0x90>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     a70:	f5 01       	movw	r30, r10
     a72:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	91 83       	std	Z+1, r25	; 0x01
     a7a:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     a7c:	d5 01       	movw	r26, r10
     a7e:	8d 91       	ld	r24, X+
     a80:	9c 91       	ld	r25, X
     a82:	89 2b       	or	r24, r25
     a84:	71 f0       	breq	.+28     	; 0xaa2 <receive_uart+0xb6>
     a86:	61 e6       	ldi	r22, 0x61	; 97
     a88:	71 e0       	ldi	r23, 0x01	; 1
     a8a:	ce 01       	movw	r24, r28
     a8c:	01 96       	adiw	r24, 0x01	; 1
     a8e:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     a92:	89 2b       	or	r24, r25
     a94:	31 f4       	brne	.+12     	; 0xaa2 <receive_uart+0xb6>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     a96:	f5 01       	movw	r30, r10
     a98:	11 82       	std	Z+1, r1	; 0x01
     a9a:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     a9c:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     a9e:	15 8e       	std	Z+29, r1	; 0x1d
     aa0:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     aa2:	62 e7       	ldi	r22, 0x72	; 114
     aa4:	71 e0       	ldi	r23, 0x01	; 1
     aa6:	ce 01       	movw	r24, r28
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     aae:	89 2b       	or	r24, r25
     ab0:	11 f5       	brne	.+68     	; 0xaf6 <receive_uart+0x10a>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     ab2:	d5 01       	movw	r26, r10
     ab4:	94 96       	adiw	r26, 0x24	; 36
     ab6:	1c 92       	st	X, r1
     ab8:	1e 92       	st	-X, r1
     aba:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     abc:	da 96       	adiw	r26, 0x3a	; 58
     abe:	8c 91       	ld	r24, X
     ac0:	81 30       	cpi	r24, 0x01	; 1
     ac2:	51 f0       	breq	.+20     	; 0xad8 <receive_uart+0xec>
     ac4:	18 f0       	brcs	.+6      	; 0xacc <receive_uart+0xe0>
     ac6:	82 30       	cpi	r24, 0x02	; 2
     ac8:	89 f0       	breq	.+34     	; 0xaec <receive_uart+0x100>
     aca:	15 c0       	rjmp	.+42     	; 0xaf6 <receive_uart+0x10a>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     acc:	f5 01       	movw	r30, r10
     ace:	84 a9       	ldd	r24, Z+52	; 0x34
     ad0:	95 a9       	ldd	r25, Z+53	; 0x35
     ad2:	93 ab       	std	Z+51, r25	; 0x33
     ad4:	82 ab       	std	Z+50, r24	; 0x32
				break;
     ad6:	0f c0       	rjmp	.+30     	; 0xaf6 <receive_uart+0x10a>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     ad8:	d5 01       	movw	r26, r10
     ada:	d6 96       	adiw	r26, 0x36	; 54
     adc:	8d 91       	ld	r24, X+
     ade:	9c 91       	ld	r25, X
     ae0:	d7 97       	sbiw	r26, 0x37	; 55
     ae2:	d3 96       	adiw	r26, 0x33	; 51
     ae4:	9c 93       	st	X, r25
     ae6:	8e 93       	st	-X, r24
     ae8:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     aea:	05 c0       	rjmp	.+10     	; 0xaf6 <receive_uart+0x10a>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     aec:	f5 01       	movw	r30, r10
     aee:	80 ad       	ldd	r24, Z+56	; 0x38
     af0:	91 ad       	ldd	r25, Z+57	; 0x39
     af2:	93 ab       	std	Z+51, r25	; 0x33
     af4:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     af6:	65 e8       	ldi	r22, 0x85	; 133
     af8:	71 e0       	ldi	r23, 0x01	; 1
     afa:	ce 01       	movw	r24, r28
     afc:	01 96       	adiw	r24, 0x01	; 1
     afe:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     b02:	89 2b       	or	r24, r25
     b04:	39 f4       	brne	.+14     	; 0xb14 <receive_uart+0x128>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	d5 01       	movw	r26, r10
     b0c:	94 96       	adiw	r26, 0x24	; 36
     b0e:	9c 93       	st	X, r25
     b10:	8e 93       	st	-X, r24
     b12:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b14:	f5 01       	movw	r30, r10
     b16:	80 81       	ld	r24, Z
     b18:	91 81       	ldd	r25, Z+1	; 0x01
     b1a:	89 2b       	or	r24, r25
     b1c:	39 f0       	breq	.+14     	; 0xb2c <receive_uart+0x140>
     b1e:	c4 01       	movw	r24, r8
     b20:	0b 97       	sbiw	r24, 0x0b	; 11
     b22:	0a 97       	sbiw	r24, 0x0a	; 10
     b24:	18 f4       	brcc	.+6      	; 0xb2c <receive_uart+0x140>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     b26:	86 ef       	ldi	r24, 0xF6	; 246
     b28:	81 0f       	add	r24, r17
     b2a:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     b2c:	d5 01       	movw	r26, r10
     b2e:	8d 91       	ld	r24, X+
     b30:	9c 91       	ld	r25, X
     b32:	89 2b       	or	r24, r25
     b34:	41 f0       	breq	.+16     	; 0xb46 <receive_uart+0x15a>
     b36:	ba e0       	ldi	r27, 0x0A	; 10
     b38:	8b 16       	cp	r8, r27
     b3a:	91 04       	cpc	r9, r1
     b3c:	20 f4       	brcc	.+8      	; 0xb46 <receive_uart+0x15a>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     b3e:	8a e0       	ldi	r24, 0x0A	; 10
     b40:	81 1b       	sub	r24, r17
     b42:	f5 01       	movw	r30, r10
     b44:	80 8f       	std	Z+24, r24	; 0x18
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     b46:	d5 01       	movw	r26, r10
     b48:	8d 91       	ld	r24, X+
     b4a:	9c 91       	ld	r25, X
     b4c:	11 97       	sbiw	r26, 0x01	; 1
     b4e:	89 2b       	or	r24, r25
     b50:	61 f0       	breq	.+24     	; 0xb6a <receive_uart+0x17e>
     b52:	81 14       	cp	r8, r1
     b54:	91 04       	cpc	r9, r1
     b56:	49 f4       	brne	.+18     	; 0xb6a <receive_uart+0x17e>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     b58:	57 96       	adiw	r26, 0x17	; 23
     b5a:	1c 92       	st	X, r1
     b5c:	57 97       	sbiw	r26, 0x17	; 23
			vals->u8_brake_cmd = 0;
     b5e:	58 96       	adiw	r26, 0x18	; 24
     b60:	1c 92       	st	X, r1
     b62:	58 97       	sbiw	r26, 0x18	; 24
			vals->u8_duty_cycle = 50;
     b64:	82 e3       	ldi	r24, 0x32	; 50
     b66:	59 96       	adiw	r26, 0x19	; 25
     b68:	8c 93       	st	X, r24
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     b6a:	f5 01       	movw	r30, r10
     b6c:	83 a1       	ldd	r24, Z+35	; 0x23
     b6e:	94 a1       	ldd	r25, Z+36	; 0x24
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	59 f4       	brne	.+22     	; 0xb8a <receive_uart+0x19e>
     b74:	67 e9       	ldi	r22, 0x97	; 151
     b76:	71 e0       	ldi	r23, 0x01	; 1
     b78:	ce 01       	movw	r24, r28
     b7a:	01 96       	adiw	r24, 0x01	; 1
     b7c:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     b80:	89 2b       	or	r24, r25
     b82:	19 f4       	brne	.+6      	; 0xb8a <receive_uart+0x19e>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     b84:	d5 01       	movw	r26, r10
     b86:	db 96       	adiw	r26, 0x3b	; 59
     b88:	1c 92       	st	X, r1
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     b8a:	f5 01       	movw	r30, r10
     b8c:	83 a1       	ldd	r24, Z+35	; 0x23
     b8e:	94 a1       	ldd	r25, Z+36	; 0x24
     b90:	01 97       	sbiw	r24, 0x01	; 1
     b92:	99 f4       	brne	.+38     	; 0xbba <receive_uart+0x1ce>
     b94:	69 e9       	ldi	r22, 0x99	; 153
     b96:	71 e0       	ldi	r23, 0x01	; 1
     b98:	ce 01       	movw	r24, r28
     b9a:	01 96       	adiw	r24, 0x01	; 1
     b9c:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     ba0:	89 2b       	or	r24, r25
     ba2:	59 f4       	brne	.+22     	; 0xbba <receive_uart+0x1ce>
		{
			vals->uart_debug = 77;
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	aa e9       	ldi	r26, 0x9A	; 154
     baa:	b2 e4       	ldi	r27, 0x42	; 66
     bac:	f5 01       	movw	r30, r10
     bae:	87 a3       	std	Z+39, r24	; 0x27
     bb0:	90 a7       	std	Z+40, r25	; 0x28
     bb2:	a1 a7       	std	Z+41, r26	; 0x29
     bb4:	b2 a7       	std	Z+42, r27	; 0x2a
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     bba:	d5 01       	movw	r26, r10
     bbc:	93 96       	adiw	r26, 0x23	; 35
     bbe:	8d 91       	ld	r24, X+
     bc0:	9c 91       	ld	r25, X
     bc2:	94 97       	sbiw	r26, 0x24	; 36
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	59 f4       	brne	.+22     	; 0xbde <receive_uart+0x1f2>
     bc8:	65 eb       	ldi	r22, 0xB5	; 181
     bca:	71 e0       	ldi	r23, 0x01	; 1
     bcc:	ce 01       	movw	r24, r28
     bce:	01 96       	adiw	r24, 0x01	; 1
     bd0:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     bd4:	89 2b       	or	r24, r25
     bd6:	19 f4       	brne	.+6      	; 0xbde <receive_uart+0x1f2>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     bd8:	82 e0       	ldi	r24, 0x02	; 2
     bda:	f5 01       	movw	r30, r10
     bdc:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     bde:	d5 01       	movw	r26, r10
     be0:	93 96       	adiw	r26, 0x23	; 35
     be2:	8d 91       	ld	r24, X+
     be4:	9c 91       	ld	r25, X
     be6:	94 97       	sbiw	r26, 0x24	; 36
     be8:	89 2b       	or	r24, r25
     bea:	59 f4       	brne	.+22     	; 0xc02 <receive_uart+0x216>
     bec:	6b e9       	ldi	r22, 0x9B	; 155
     bee:	71 e0       	ldi	r23, 0x01	; 1
     bf0:	ce 01       	movw	r24, r28
     bf2:	01 96       	adiw	r24, 0x01	; 1
     bf4:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     bf8:	89 2b       	or	r24, r25
     bfa:	19 f4       	brne	.+6      	; 0xc02 <receive_uart+0x216>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     bfc:	80 e0       	ldi	r24, 0x00	; 0
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	92 da       	rcall	.-2780   	; 0x126 <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c02:	f5 01       	movw	r30, r10
     c04:	83 a1       	ldd	r24, Z+35	; 0x23
     c06:	94 a1       	ldd	r25, Z+36	; 0x24
     c08:	89 2b       	or	r24, r25
     c0a:	59 f4       	brne	.+22     	; 0xc22 <receive_uart+0x236>
     c0c:	63 ea       	ldi	r22, 0xA3	; 163
     c0e:	71 e0       	ldi	r23, 0x01	; 1
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     c18:	89 2b       	or	r24, r25
     c1a:	19 f4       	brne	.+6      	; 0xc22 <receive_uart+0x236>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c1c:	81 e0       	ldi	r24, 0x01	; 1
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	82 da       	rcall	.-2812   	; 0x126 <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c22:	d5 01       	movw	r26, r10
     c24:	93 96       	adiw	r26, 0x23	; 35
     c26:	8d 91       	ld	r24, X+
     c28:	9c 91       	ld	r25, X
     c2a:	94 97       	sbiw	r26, 0x24	; 36
     c2c:	89 2b       	or	r24, r25
     c2e:	29 f5       	brne	.+74     	; 0xc7a <receive_uart+0x28e>
     c30:	69 ea       	ldi	r22, 0xA9	; 169
     c32:	71 e0       	ldi	r23, 0x01	; 1
     c34:	ce 01       	movw	r24, r28
     c36:	01 96       	adiw	r24, 0x01	; 1
     c38:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     c3c:	89 2b       	or	r24, r25
     c3e:	e9 f4       	brne	.+58     	; 0xc7a <receive_uart+0x28e>
		{
			vals->uart_debug = 77;
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	aa e9       	ldi	r26, 0x9A	; 154
     c46:	b2 e4       	ldi	r27, 0x42	; 66
     c48:	f5 01       	movw	r30, r10
     c4a:	87 a3       	std	Z+39, r24	; 0x27
     c4c:	90 a7       	std	Z+40, r25	; 0x28
     c4e:	a1 a7       	std	Z+41, r26	; 0x29
     c50:	b2 a7       	std	Z+42, r27	; 0x2a
			vals->gear_required = NEUTRAL;
     c52:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     c54:	c0 ac       	ldd	r12, Z+56	; 0x38
     c56:	d1 ac       	ldd	r13, Z+57	; 0x39
     c58:	e6 a8       	ldd	r14, Z+54	; 0x36
     c5a:	f7 a8       	ldd	r15, Z+55	; 0x37
     c5c:	04 a9       	ldd	r16, Z+52	; 0x34
     c5e:	15 a9       	ldd	r17, Z+53	; 0x35
     c60:	62 a9       	ldd	r22, Z+50	; 0x32
     c62:	73 a9       	ldd	r23, Z+51	; 0x33
     c64:	72 ac       	ldd	r7, Z+58	; 0x3a
     c66:	63 ac       	ldd	r6, Z+59	; 0x3b
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     c70:	9b 01       	movw	r18, r22
     c72:	ac 01       	movw	r20, r24
     c74:	67 2d       	mov	r22, r7
     c76:	86 2d       	mov	r24, r6
     c78:	35 da       	rcall	.-2966   	; 0xe4 <actuator_save_position>
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
		}
		*/
		
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     c7a:	d5 01       	movw	r26, r10
     c7c:	93 96       	adiw	r26, 0x23	; 35
     c7e:	8d 91       	ld	r24, X+
     c80:	9c 91       	ld	r25, X
     c82:	94 97       	sbiw	r26, 0x24	; 36
     c84:	89 2b       	or	r24, r25
     c86:	c1 f4       	brne	.+48     	; 0xcb8 <receive_uart+0x2cc>
     c88:	67 eb       	ldi	r22, 0xB7	; 183
     c8a:	71 e0       	ldi	r23, 0x01	; 1
     c8c:	ce 01       	movw	r24, r28
     c8e:	01 96       	adiw	r24, 0x01	; 1
     c90:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     c94:	89 2b       	or	r24, r25
     c96:	81 f4       	brne	.+32     	; 0xcb8 <receive_uart+0x2cc>
		{
			vals->gear_required = GEAR1;
     c98:	81 e0       	ldi	r24, 0x01	; 1
     c9a:	f5 01       	movw	r30, r10
     c9c:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->f32_actuator_feedback, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     c9e:	c0 ac       	ldd	r12, Z+56	; 0x38
     ca0:	d1 ac       	ldd	r13, Z+57	; 0x39
     ca2:	e6 a8       	ldd	r14, Z+54	; 0x36
     ca4:	f7 a8       	ldd	r15, Z+55	; 0x37
     ca6:	04 a9       	ldd	r16, Z+52	; 0x34
     ca8:	15 a9       	ldd	r17, Z+53	; 0x35
     caa:	23 a5       	ldd	r18, Z+43	; 0x2b
     cac:	34 a5       	ldd	r19, Z+44	; 0x2c
     cae:	45 a5       	ldd	r20, Z+45	; 0x2d
     cb0:	56 a5       	ldd	r21, Z+46	; 0x2e
     cb2:	62 ad       	ldd	r22, Z+58	; 0x3a
     cb4:	83 ad       	ldd	r24, Z+59	; 0x3b
     cb6:	16 da       	rcall	.-3028   	; 0xe4 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cb8:	d5 01       	movw	r26, r10
     cba:	93 96       	adiw	r26, 0x23	; 35
     cbc:	8d 91       	ld	r24, X+
     cbe:	9c 91       	ld	r25, X
     cc0:	94 97       	sbiw	r26, 0x24	; 36
     cc2:	89 2b       	or	r24, r25
     cc4:	c1 f4       	brne	.+48     	; 0xcf6 <receive_uart+0x30a>
     cc6:	67 ec       	ldi	r22, 0xC7	; 199
     cc8:	71 e0       	ldi	r23, 0x01	; 1
     cca:	ce 01       	movw	r24, r28
     ccc:	01 96       	adiw	r24, 0x01	; 1
     cce:	0e 94 85 13 	call	0x270a	; 0x270a <strcmp>
     cd2:	89 2b       	or	r24, r25
     cd4:	81 f4       	brne	.+32     	; 0xcf6 <receive_uart+0x30a>
		{
			vals->gear_required = GEAR2;
     cd6:	82 e0       	ldi	r24, 0x02	; 2
     cd8:	f5 01       	movw	r30, r10
     cda:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->f32_actuator_feedback, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cdc:	c0 ac       	ldd	r12, Z+56	; 0x38
     cde:	d1 ac       	ldd	r13, Z+57	; 0x39
     ce0:	e6 a8       	ldd	r14, Z+54	; 0x36
     ce2:	f7 a8       	ldd	r15, Z+55	; 0x37
     ce4:	04 a9       	ldd	r16, Z+52	; 0x34
     ce6:	15 a9       	ldd	r17, Z+53	; 0x35
     ce8:	23 a5       	ldd	r18, Z+43	; 0x2b
     cea:	34 a5       	ldd	r19, Z+44	; 0x2c
     cec:	45 a5       	ldd	r20, Z+45	; 0x2d
     cee:	56 a5       	ldd	r21, Z+46	; 0x2e
     cf0:	62 ad       	ldd	r22, Z+58	; 0x3a
     cf2:	83 ad       	ldd	r24, Z+59	; 0x3b
     cf4:	f7 d9       	rcall	.-3090   	; 0xe4 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     cf6:	d5 01       	movw	r26, r10
     cf8:	93 96       	adiw	r26, 0x23	; 35
     cfa:	8d 91       	ld	r24, X+
     cfc:	9c 91       	ld	r25, X
     cfe:	94 97       	sbiw	r26, 0x24	; 36
     d00:	89 2b       	or	r24, r25
     d02:	49 f4       	brne	.+18     	; 0xd16 <receive_uart+0x32a>
     d04:	c4 01       	movw	r24, r8
     d06:	01 97       	sbiw	r24, 0x01	; 1
     d08:	87 3e       	cpi	r24, 0xE7	; 231
     d0a:	93 40       	sbci	r25, 0x03	; 3
		{
			vals->gear_required = NEUTRAL;
     d0c:	20 f4       	brcc	.+8      	; 0xd16 <receive_uart+0x32a>
     d0e:	f5 01       	movw	r30, r10
			vals->position_uart_instruction = uart_uint16_received;
     d10:	13 ae       	std	Z+59, r1	; 0x3b
     d12:	93 aa       	std	Z+51, r9	; 0x33
			//uart_flush();
		}
		
		uart_flush();
     d14:	82 aa       	std	Z+50, r8	; 0x32
     d16:	62 d3       	rcall	.+1732   	; 0x13dc <uart0_flush>
	}
}
     d18:	66 96       	adiw	r28, 0x16	; 22
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	de bf       	out	0x3e, r29	; 62
     d20:	0f be       	out	0x3f, r0	; 63
     d22:	cd bf       	out	0x3d, r28	; 61
     d24:	df 91       	pop	r29
     d26:	cf 91       	pop	r28
     d28:	1f 91       	pop	r17
     d2a:	0f 91       	pop	r16
     d2c:	ff 90       	pop	r15
     d2e:	ef 90       	pop	r14
     d30:	df 90       	pop	r13
     d32:	cf 90       	pop	r12
     d34:	bf 90       	pop	r11
     d36:	af 90       	pop	r10
     d38:	9f 90       	pop	r9
     d3a:	8f 90       	pop	r8
     d3c:	7f 90       	pop	r7
     d3e:	6f 90       	pop	r6
     d40:	08 95       	ret

00000d42 <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d42:	ef 92       	push	r14
     d44:	ff 92       	push	r15
     d46:	0f 93       	push	r16
     d48:	1f 93       	push	r17
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	cd b7       	in	r28, 0x3d	; 61
     d50:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d52:	88 ed       	ldi	r24, 0xD8	; 216
     d54:	91 e0       	ldi	r25, 0x01	; 1
     d56:	0e 94 ae 13 	call	0x275c	; 0x275c <puts>
	printf("%u", vals.gear_required);
     d5a:	25 96       	adiw	r28, 0x05	; 5
     d5c:	8f ad       	ldd	r24, Y+63	; 0x3f
     d5e:	25 97       	sbiw	r28, 0x05	; 5
     d60:	1f 92       	push	r1
     d62:	8f 93       	push	r24
     d64:	0a ed       	ldi	r16, 0xDA	; 218
     d66:	11 e0       	ldi	r17, 0x01	; 1
     d68:	1f 93       	push	r17
     d6a:	0f 93       	push	r16
     d6c:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     d70:	8c e2       	ldi	r24, 0x2C	; 44
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u",vals.gear_status);
     d78:	24 96       	adiw	r28, 0x04	; 4
     d7a:	8f ad       	ldd	r24, Y+63	; 0x3f
     d7c:	24 97       	sbiw	r28, 0x04	; 4
     d7e:	1f 92       	push	r1
     d80:	8f 93       	push	r24
     d82:	1f 93       	push	r17
     d84:	0f 93       	push	r16
     d86:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     d8a:	8c e2       	ldi	r24, 0x2C	; 44
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u", vals.motor_status);
     d92:	8f a1       	ldd	r24, Y+39	; 0x27
     d94:	1f 92       	push	r1
     d96:	8f 93       	push	r24
     d98:	1f 93       	push	r17
     d9a:	0f 93       	push	r16
     d9c:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     da0:	8c e2       	ldi	r24, 0x2C	; 44
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u",vals.message_mode);
     da8:	88 a5       	ldd	r24, Y+40	; 0x28
     daa:	1f 92       	push	r1
     dac:	8f 93       	push	r24
     dae:	1f 93       	push	r17
     db0:	0f 93       	push	r16
     db2:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     db6:	8c e2       	ldi	r24, 0x2C	; 44
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u",vals.u8_duty_cycle);
     dbe:	8a a1       	ldd	r24, Y+34	; 0x22
     dc0:	1f 92       	push	r1
     dc2:	8f 93       	push	r24
     dc4:	1f 93       	push	r17
     dc6:	0f 93       	push	r16
     dc8:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     dcc:	8c e2       	ldi	r24, 0x2C	; 44
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     dd4:	6b 89       	ldd	r22, Y+19	; 0x13
     dd6:	7c 89       	ldd	r23, Y+20	; 0x14
     dd8:	8d 89       	ldd	r24, Y+21	; 0x15
     dda:	9e 89       	ldd	r25, Y+22	; 0x16
     ddc:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     de0:	7f 93       	push	r23
     de2:	6f 93       	push	r22
     de4:	0f 2e       	mov	r0, r31
     de6:	fd ed       	ldi	r31, 0xDD	; 221
     de8:	ef 2e       	mov	r14, r31
     dea:	f1 e0       	ldi	r31, 0x01	; 1
     dec:	ff 2e       	mov	r15, r31
     dee:	f0 2d       	mov	r31, r0
     df0:	ff 92       	push	r15
     df2:	ef 92       	push	r14
     df4:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     df8:	8c e2       	ldi	r24, 0x2C	; 44
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e00:	6c a9       	ldd	r22, Y+52	; 0x34
     e02:	7d a9       	ldd	r23, Y+53	; 0x35
     e04:	8e a9       	ldd	r24, Y+54	; 0x36
     e06:	9f a9       	ldd	r25, Y+55	; 0x37
     e08:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     e0c:	7f 93       	push	r23
     e0e:	6f 93       	push	r22
     e10:	ff 92       	push	r15
     e12:	ef 92       	push	r14
     e14:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e18:	8c e2       	ldi	r24, 0x2C	; 44
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e20:	89 85       	ldd	r24, Y+9	; 0x09
     e22:	9a 85       	ldd	r25, Y+10	; 0x0a
     e24:	9f 93       	push	r25
     e26:	8f 93       	push	r24
     e28:	ff 92       	push	r15
     e2a:	ef 92       	push	r14
     e2c:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e30:	0f b6       	in	r0, 0x3f	; 63
     e32:	f8 94       	cli
     e34:	de bf       	out	0x3e, r29	; 62
     e36:	0f be       	out	0x3f, r0	; 63
     e38:	cd bf       	out	0x3d, r28	; 61
     e3a:	8c e2       	ldi	r24, 0x2C	; 44
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%i",vals.clutch_enabled);
     e42:	8c a5       	ldd	r24, Y+44	; 0x2c
     e44:	9d a5       	ldd	r25, Y+45	; 0x2d
     e46:	9f 93       	push	r25
     e48:	8f 93       	push	r24
     e4a:	ff 92       	push	r15
     e4c:	ef 92       	push	r14
     e4e:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e52:	8c e2       	ldi	r24, 0x2C	; 44
     e54:	90 e0       	ldi	r25, 0x00	; 0
     e56:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u",vals.position_neutral);
     e5a:	8d ad       	ldd	r24, Y+61	; 0x3d
     e5c:	9e ad       	ldd	r25, Y+62	; 0x3e
     e5e:	9f 93       	push	r25
     e60:	8f 93       	push	r24
     e62:	1f 93       	push	r17
     e64:	0f 93       	push	r16
     e66:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e6a:	8c e2       	ldi	r24, 0x2C	; 44
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%u",vals.position_gear_1);
     e72:	21 96       	adiw	r28, 0x01	; 1
     e74:	8e ad       	ldd	r24, Y+62	; 0x3e
     e76:	9f ad       	ldd	r25, Y+63	; 0x3f
     e78:	21 97       	sbiw	r28, 0x01	; 1
     e7a:	9f 93       	push	r25
     e7c:	8f 93       	push	r24
     e7e:	1f 93       	push	r17
     e80:	0f 93       	push	r16
     e82:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e86:	8c e2       	ldi	r24, 0x2C	; 44
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	//printf("%u",vals.position_gear_2);	
	//printf(",");
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     e8e:	88 ad       	ldd	r24, Y+56	; 0x38
     e90:	1f 92       	push	r1
     e92:	8f 93       	push	r24
     e94:	ff 92       	push	r15
     e96:	ef 92       	push	r14
     e98:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	printf(",");
     e9c:	8c e2       	ldi	r24, 0x2C	; 44
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	0e 94 a9 13 	call	0x2752	; 0x2752 <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     ea4:	68 a9       	ldd	r22, Y+48	; 0x30
     ea6:	79 a9       	ldd	r23, Y+49	; 0x31
     ea8:	8a a9       	ldd	r24, Y+50	; 0x32
     eaa:	9b a9       	ldd	r25, Y+51	; 0x33
     eac:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
     eb0:	7f 93       	push	r23
     eb2:	6f 93       	push	r22
     eb4:	ff 92       	push	r15
     eb6:	ef 92       	push	r14
     eb8:	0e 94 96 13 	call	0x272c	; 0x272c <printf>
	
}
     ebc:	0f b6       	in	r0, 0x3f	; 63
     ebe:	f8 94       	cli
     ec0:	de bf       	out	0x3e, r29	; 62
     ec2:	0f be       	out	0x3f, r0	; 63
     ec4:	cd bf       	out	0x3d, r28	; 61
     ec6:	df 91       	pop	r29
     ec8:	cf 91       	pop	r28
     eca:	1f 91       	pop	r17
     ecc:	0f 91       	pop	r16
     ece:	ff 90       	pop	r15
     ed0:	ef 90       	pop	r14
     ed2:	08 95       	ret

00000ed4 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	cd b7       	in	r28, 0x3d	; 61
     eda:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     edc:	8b a1       	ldd	r24, Y+35	; 0x23
     ede:	82 30       	cpi	r24, 0x02	; 2
     ee0:	91 f1       	breq	.+100    	; 0xf46 <manage_LEDs+0x72>
     ee2:	28 f4       	brcc	.+10     	; 0xeee <manage_LEDs+0x1a>
     ee4:	88 23       	and	r24, r24
     ee6:	49 f0       	breq	.+18     	; 0xefa <manage_LEDs+0x26>
     ee8:	81 30       	cpi	r24, 0x01	; 1
     eea:	19 f1       	breq	.+70     	; 0xf32 <manage_LEDs+0x5e>
     eec:	49 c0       	rjmp	.+146    	; 0xf80 <manage_LEDs+0xac>
     eee:	84 30       	cpi	r24, 0x04	; 4
     ef0:	f1 f1       	breq	.+124    	; 0xf6e <manage_LEDs+0x9a>
     ef2:	98 f1       	brcs	.+102    	; 0xf5a <manage_LEDs+0x86>
     ef4:	85 30       	cpi	r24, 0x05	; 5
     ef6:	99 f0       	breq	.+38     	; 0xf1e <manage_LEDs+0x4a>
     ef8:	43 c0       	rjmp	.+134    	; 0xf80 <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     efa:	80 e4       	ldi	r24, 0x40	; 64
     efc:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f00:	80 e8       	ldi	r24, 0x80	; 128
     f02:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f06:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f08:	98 a1       	ldd	r25, Y+32	; 0x20
     f0a:	89 2b       	or	r24, r25
     f0c:	21 f4       	brne	.+8      	; 0xf16 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f0e:	80 e2       	ldi	r24, 0x20	; 32
     f10:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
     f14:	35 c0       	rjmp	.+106    	; 0xf80 <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f16:	80 e2       	ldi	r24, 0x20	; 32
     f18:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
     f1c:	31 c0       	rjmp	.+98     	; 0xf80 <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f1e:	80 e2       	ldi	r24, 0x20	; 32
     f20:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f24:	80 e4       	ldi	r24, 0x40	; 64
     f26:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     f2a:	80 e8       	ldi	r24, 0x80	; 128
     f2c:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
		break ;
     f30:	27 c0       	rjmp	.+78     	; 0xf80 <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     f32:	80 e2       	ldi	r24, 0x20	; 32
     f34:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f38:	80 e8       	ldi	r24, 0x80	; 128
     f3a:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     f3e:	80 e4       	ldi	r24, 0x40	; 64
     f40:	0e 94 cf 10 	call	0x219e	; 0x219e <rgbled_toggle>
		break;
     f44:	1d c0       	rjmp	.+58     	; 0xf80 <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     f46:	80 e8       	ldi	r24, 0x80	; 128
     f48:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     f4c:	80 e4       	ldi	r24, 0x40	; 64
     f4e:	0e 94 cf 10 	call	0x219e	; 0x219e <rgbled_toggle>
			rgbled_toggle(LED_RED);
     f52:	80 e2       	ldi	r24, 0x20	; 32
     f54:	0e 94 cf 10 	call	0x219e	; 0x219e <rgbled_toggle>
		break;
     f58:	13 c0       	rjmp	.+38     	; 0xf80 <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     f5a:	80 e2       	ldi	r24, 0x20	; 32
     f5c:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f60:	80 e8       	ldi	r24, 0x80	; 128
     f62:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f66:	80 e4       	ldi	r24, 0x40	; 64
     f68:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
		break;
     f6c:	09 c0       	rjmp	.+18     	; 0xf80 <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     f6e:	80 e4       	ldi	r24, 0x40	; 64
     f70:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f74:	80 e8       	ldi	r24, 0x80	; 128
     f76:	0e 94 c0 10 	call	0x2180	; 0x2180 <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     f7a:	80 e2       	ldi	r24, 0x20	; 32
     f7c:	0e 94 ca 10 	call	0x2194	; 0x2194 <rgbled_turn_on>
		break;
	}
     f80:	df 91       	pop	r29
     f82:	cf 91       	pop	r28
     f84:	08 95       	ret

00000f86 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     f86:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     f88:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     f8a:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     f8c:	e9 e6       	ldi	r30, 0x69	; 105
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	80 81       	ld	r24, Z
     f92:	84 60       	ori	r24, 0x04	; 4
     f94:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
     f96:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
     f98:	e9 9a       	sbi	0x1d, 1	; 29
     f9a:	08 95       	ret

00000f9c <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
     f9c:	0f 93       	push	r16
     f9e:	1f 93       	push	r17
     fa0:	cf 93       	push	r28
     fa2:	df 93       	push	r29
	
	if (*u16_counter > 70)
     fa4:	fb 01       	movw	r30, r22
     fa6:	20 81       	ld	r18, Z
     fa8:	31 81       	ldd	r19, Z+1	; 0x01
     faa:	27 34       	cpi	r18, 0x47	; 71
     fac:	31 05       	cpc	r19, r1
     fae:	b8 f0       	brcs	.+46     	; 0xfde <handle_speed_sensor+0x42>
     fb0:	eb 01       	movw	r28, r22
     fb2:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
     fb4:	60 81       	ld	r22, Z
     fb6:	71 81       	ldd	r23, Z+1	; 0x01
     fb8:	80 e0       	ldi	r24, 0x00	; 0
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
     fc0:	9b 01       	movw	r18, r22
     fc2:	ac 01       	movw	r20, r24
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	76 e7       	ldi	r23, 0x76	; 118
     fc8:	88 e8       	ldi	r24, 0x88	; 136
     fca:	96 e4       	ldi	r25, 0x46	; 70
     fcc:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
     fd0:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
     fd4:	f8 01       	movw	r30, r16
     fd6:	71 83       	std	Z+1, r23	; 0x01
     fd8:	60 83       	st	Z, r22
		*u16_counter = 0 ;
     fda:	19 82       	std	Y+1, r1	; 0x01
     fdc:	18 82       	st	Y, r1
	}	
}
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	1f 91       	pop	r17
     fe4:	0f 91       	pop	r16
     fe6:	08 95       	ret

00000fe8 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
     fe8:	cf 92       	push	r12
     fea:	df 92       	push	r13
     fec:	ef 92       	push	r14
     fee:	ff 92       	push	r15
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	1f 92       	push	r1
     ff6:	cd b7       	in	r28, 0x3d	; 61
     ff8:	de b7       	in	r29, 0x3e	; 62
     ffa:	89 83       	std	Y+1, r24	; 0x01
     ffc:	69 01       	movw	r12, r18
     ffe:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    1000:	61 30       	cpi	r22, 0x01	; 1
    1002:	19 f5       	brne	.+70     	; 0x104a <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    1004:	69 81       	ldd	r22, Y+1	; 0x01
    1006:	70 e0       	ldi	r23, 0x00	; 0
    1008:	80 e0       	ldi	r24, 0x00	; 0
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
    1010:	22 e1       	ldi	r18, 0x12	; 18
    1012:	35 e8       	ldi	r19, 0x85	; 133
    1014:	41 e6       	ldi	r20, 0x61	; 97
    1016:	5e e3       	ldi	r21, 0x3E	; 62
    1018:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    101c:	a7 01       	movw	r20, r14
    101e:	96 01       	movw	r18, r12
    1020:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
    1024:	20 e0       	ldi	r18, 0x00	; 0
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	48 ec       	ldi	r20, 0xC8	; 200
    102a:	52 e4       	ldi	r21, 0x42	; 66
    102c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    1030:	20 e0       	ldi	r18, 0x00	; 0
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	48 e4       	ldi	r20, 0x48	; 72
    1036:	52 e4       	ldi	r21, 0x42	; 66
    1038:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
    103c:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
    1040:	86 2f       	mov	r24, r22
		if (Duty == 50)
    1042:	62 33       	cpi	r22, 0x32	; 50
    1044:	29 f5       	brne	.+74     	; 0x1090 <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
    1046:	84 e3       	ldi	r24, 0x34	; 52
    1048:	23 c0       	rjmp	.+70     	; 0x1090 <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    104a:	62 30       	cpi	r22, 0x02	; 2
    104c:	01 f5       	brne	.+64     	; 0x108e <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    104e:	69 81       	ldd	r22, Y+1	; 0x01
    1050:	70 e0       	ldi	r23, 0x00	; 0
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	0e 94 48 12 	call	0x2490	; 0x2490 <__floatsisf>
    105a:	23 ee       	ldi	r18, 0xE3	; 227
    105c:	3e ee       	ldi	r19, 0xEE	; 238
    105e:	4b e3       	ldi	r20, 0x3B	; 59
    1060:	5e e3       	ldi	r21, 0x3E	; 62
    1062:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    1066:	a7 01       	movw	r20, r14
    1068:	96 01       	movw	r18, r12
    106a:	0e 94 ad 11 	call	0x235a	; 0x235a <__divsf3>
    106e:	20 e0       	ldi	r18, 0x00	; 0
    1070:	30 e0       	ldi	r19, 0x00	; 0
    1072:	48 ec       	ldi	r20, 0xC8	; 200
    1074:	52 e4       	ldi	r21, 0x42	; 66
    1076:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    107a:	20 e0       	ldi	r18, 0x00	; 0
    107c:	30 e0       	ldi	r19, 0x00	; 0
    107e:	48 e4       	ldi	r20, 0x48	; 72
    1080:	52 e4       	ldi	r21, 0x42	; 66
    1082:	0e 94 45 11 	call	0x228a	; 0x228a <__addsf3>
    1086:	0e 94 1a 12 	call	0x2434	; 0x2434 <__fixunssfsi>
    108a:	86 2f       	mov	r24, r22
    108c:	01 c0       	rjmp	.+2      	; 0x1090 <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    108e:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    1090:	0f 90       	pop	r0
    1092:	df 91       	pop	r29
    1094:	cf 91       	pop	r28
    1096:	ff 90       	pop	r15
    1098:	ef 90       	pop	r14
    109a:	df 90       	pop	r13
    109c:	cf 90       	pop	r12
    109e:	08 95       	ret

000010a0 <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    10a6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    10a8:	81 11       	cpse	r24, r1
    10aa:	08 c0       	rjmp	.+16     	; 0x10bc <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    10ac:	82 e3       	ldi	r24, 0x32	; 50
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	9b 8f       	std	Y+27, r25	; 0x1b
    10b2:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    10b4:	8e e1       	ldi	r24, 0x1E	; 30
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	9d 8f       	std	Y+29, r25	; 0x1d
    10ba:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    10bc:	80 91 f7 01 	lds	r24, 0x01F7	; 0x8001f7 <fault_timeout>
    10c0:	90 91 f8 01 	lds	r25, 0x01F8	; 0x8001f8 <fault_timeout+0x1>
    10c4:	00 97       	sbiw	r24, 0x00	; 0
    10c6:	31 f0       	breq	.+12     	; 0x10d4 <state_handler+0x34>
	{
		fault_timeout -- ;
    10c8:	01 97       	sbiw	r24, 0x01	; 1
    10ca:	90 93 f8 01 	sts	0x01F8, r25	; 0x8001f8 <fault_timeout+0x1>
    10ce:	80 93 f7 01 	sts	0x01F7, r24	; 0x8001f7 <fault_timeout>
    10d2:	05 c0       	rjmp	.+10     	; 0x10de <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    10d4:	80 91 f9 01 	lds	r24, 0x01F9	; 0x8001f9 <b_major_fault>
    10d8:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    10da:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <b_major_fault>
	}

	switch(vals->motor_status)
    10de:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10e0:	82 30       	cpi	r24, 0x02	; 2
    10e2:	09 f4       	brne	.+2      	; 0x10e6 <state_handler+0x46>
    10e4:	b7 c0       	rjmp	.+366    	; 0x1254 <__stack+0x155>
    10e6:	30 f4       	brcc	.+12     	; 0x10f4 <state_handler+0x54>
    10e8:	88 23       	and	r24, r24
    10ea:	61 f0       	breq	.+24     	; 0x1104 <__stack+0x5>
    10ec:	81 30       	cpi	r24, 0x01	; 1
    10ee:	09 f4       	brne	.+2      	; 0x10f2 <state_handler+0x52>
    10f0:	8f c0       	rjmp	.+286    	; 0x1210 <__stack+0x111>
    10f2:	e1 c0       	rjmp	.+450    	; 0x12b6 <__stack+0x1b7>
    10f4:	84 30       	cpi	r24, 0x04	; 4
    10f6:	09 f4       	brne	.+2      	; 0x10fa <state_handler+0x5a>
    10f8:	cf c0       	rjmp	.+414    	; 0x1298 <__stack+0x199>
    10fa:	a0 f0       	brcs	.+40     	; 0x1124 <__stack+0x25>
    10fc:	85 30       	cpi	r24, 0x05	; 5
    10fe:	09 f4       	brne	.+2      	; 0x1102 <__stack+0x3>
    1100:	51 c0       	rjmp	.+162    	; 0x11a4 <__stack+0xa5>
    1102:	d9 c0       	rjmp	.+434    	; 0x12b6 <__stack+0x1b7>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    1104:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1106:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1108:	89 2b       	or	r24, r25
    110a:	11 f0       	breq	.+4      	; 0x1110 <__stack+0x11>
			{
				vals->motor_status = IDLE;
    110c:	83 e0       	ldi	r24, 0x03	; 3
    110e:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    1110:	80 e0       	ldi	r24, 0x00	; 0
    1112:	95 da       	rcall	.-2774   	; 0x63e <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    1114:	18 a2       	std	Y+32, r1	; 0x20
    1116:	20 d9       	rcall	.-3520   	; 0x358 <reset_I>
			vals->u8_brake_cmd = 0;
    1118:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    111a:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    111c:	82 e3       	ldi	r24, 0x32	; 50
    111e:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    1120:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    1122:	c9 c0       	rjmp	.+402    	; 0x12b6 <__stack+0x1b7>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    1124:	8a a1       	ldd	r24, Y+34	; 0x22
    1126:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    1128:	24 c0       	rjmp	.+72     	; 0x1172 <__stack+0x73>
    112a:	89 da       	rcall	.-2798   	; 0x63e <drivers>
				reset_I();
    112c:	15 d9       	rcall	.-3542   	; 0x358 <reset_I>
    112e:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1130:	89 8f       	std	Y+25, r24	; 0x19
    1132:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    1134:	88 23       	and	r24, r24
    1136:	69 f0       	breq	.+26     	; 0x1152 <__stack+0x53>
    1138:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    113a:	3b 85       	ldd	r19, Y+11	; 0x0b
    113c:	4c 85       	ldd	r20, Y+12	; 0x0c
    113e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1140:	8b 89       	ldd	r24, Y+19	; 0x13
    1142:	9c 89       	ldd	r25, Y+20	; 0x14
    1144:	62 e0       	ldi	r22, 0x02	; 2
    1146:	50 df       	rcall	.-352    	; 0xfe8 <compute_synch_duty>
    1148:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    114a:	89 8d       	ldd	r24, Y+25	; 0x19
    114c:	0e d9       	rcall	.-3556   	; 0x36a <set_I>
    114e:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    1150:	8e 8f       	std	Y+30, r24	; 0x1e
    1152:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    1154:	88 23       	and	r24, r24
    1156:	69 f0       	breq	.+26     	; 0x1172 <__stack+0x73>
    1158:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    115a:	3b 85       	ldd	r19, Y+11	; 0x0b
    115c:	4c 85       	ldd	r20, Y+12	; 0x0c
    115e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1160:	8b 89       	ldd	r24, Y+19	; 0x13
    1162:	9c 89       	ldd	r25, Y+20	; 0x14
    1164:	62 e0       	ldi	r22, 0x02	; 2
    1166:	40 df       	rcall	.-384    	; 0xfe8 <compute_synch_duty>
    1168:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    116a:	89 8d       	ldd	r24, Y+25	; 0x19
    116c:	fe d8       	rcall	.-3588   	; 0x36a <set_I>
    116e:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    1170:	8e 8f       	std	Y+30, r24	; 0x1e
    1172:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    1174:	81 30       	cpi	r24, 0x01	; 1
    1176:	09 f0       	breq	.+2      	; 0x117a <__stack+0x7b>
    1178:	9e c0       	rjmp	.+316    	; 0x12b6 <__stack+0x1b7>
    117a:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    117c:	81 11       	cpse	r24, r1
    117e:	03 c0       	rjmp	.+6      	; 0x1186 <__stack+0x87>
    1180:	88 8d       	ldd	r24, Y+24	; 0x18
    1182:	88 23       	and	r24, r24
    1184:	41 f0       	breq	.+16     	; 0x1196 <__stack+0x97>
    1186:	8a ad       	ldd	r24, Y+58	; 0x3a
    1188:	81 11       	cpse	r24, r1
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <__stack+0x97>
				{
					vals->motor_status = ENGAGE;
    118c:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    118e:	8e 8f       	std	Y+30, r24	; 0x1e
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <starting_engage>
				}
				drivers(0); //disable
    1196:	80 e0       	ldi	r24, 0x00	; 0
    1198:	52 da       	rcall	.-2908   	; 0x63e <drivers>
				vals->gear_required = NEUTRAL ;
    119a:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    119c:	dd d8       	rcall	.-3654   	; 0x358 <reset_I>
    119e:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    11a0:	89 8f       	std	Y+25, r24	; 0x19
    11a2:	89 c0       	rjmp	.+274    	; 0x12b6 <__stack+0x1b7>
    11a4:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    11a6:	8b af       	std	Y+59, r24	; 0x3b
    11a8:	80 91 f6 01 	lds	r24, 0x01F6	; 0x8001f6 <starting_engage>
			if (starting_engage)
    11ac:	88 23       	and	r24, r24
    11ae:	69 f0       	breq	.+26     	; 0x11ca <__stack+0xcb>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    11b0:	2a 85       	ldd	r18, Y+10	; 0x0a
    11b2:	3b 85       	ldd	r19, Y+11	; 0x0b
    11b4:	4c 85       	ldd	r20, Y+12	; 0x0c
    11b6:	5d 85       	ldd	r21, Y+13	; 0x0d
    11b8:	6b ad       	ldd	r22, Y+59	; 0x3b
    11ba:	8b 89       	ldd	r24, Y+19	; 0x13
    11bc:	9c 89       	ldd	r25, Y+20	; 0x14
    11be:	14 df       	rcall	.-472    	; 0xfe8 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    11c0:	89 8f       	std	Y+25, r24	; 0x19
    11c2:	89 8d       	ldd	r24, Y+25	; 0x19
    11c4:	d2 d8       	rcall	.-3676   	; 0x36a <set_I>
				starting_engage = 0;
    11c6:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    11ce:	ce 01       	movw	r24, r28
    11d0:	e7 d8       	rcall	.-3634   	; 0x3a0 <controller>
    11d2:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    11d4:	34 da       	rcall	.-2968   	; 0x63e <drivers>
    11d6:	88 8d       	ldd	r24, Y+24	; 0x18
    11d8:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    11da:	29 f0       	breq	.+10     	; 0x11e6 <__stack+0xe7>
    11dc:	8a ad       	ldd	r24, Y+58	; 0x3a
    11de:	81 30       	cpi	r24, 0x01	; 1
    11e0:	11 f4       	brne	.+4      	; 0x11e6 <__stack+0xe7>
    11e2:	82 e0       	ldi	r24, 0x02	; 2
    11e4:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    11e6:	8f 89       	ldd	r24, Y+23	; 0x17
    11e8:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    11ea:	21 f0       	breq	.+8      	; 0x11f4 <__stack+0xf5>
    11ec:	8a ad       	ldd	r24, Y+58	; 0x3a
    11ee:	81 30       	cpi	r24, 0x01	; 1
    11f0:	09 f4       	brne	.+2      	; 0x11f4 <__stack+0xf5>
    11f2:	8e 8f       	std	Y+30, r24	; 0x1e
    11f4:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    11f6:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    11f8:	5e c0       	rjmp	.+188    	; 0x12b6 <__stack+0x1b7>
    11fa:	88 8d       	ldd	r24, Y+24	; 0x18
    11fc:	81 11       	cpse	r24, r1
    11fe:	5b c0       	rjmp	.+182    	; 0x12b6 <__stack+0x1b7>
    1200:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1202:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1204:	89 2b       	or	r24, r25
    1206:	09 f0       	breq	.+2      	; 0x120a <__stack+0x10b>
    1208:	56 c0       	rjmp	.+172    	; 0x12b6 <__stack+0x1b7>
			{
				vals->motor_status = IDLE;
    120a:	83 e0       	ldi	r24, 0x03	; 3
    120c:	8e 8f       	std	Y+30, r24	; 0x1e
    120e:	53 c0       	rjmp	.+166    	; 0x12b6 <__stack+0x1b7>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    1210:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    1212:	ce 01       	movw	r24, r28
    1214:	c5 d8       	rcall	.-3702   	; 0x3a0 <controller>
    1216:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1218:	12 da       	rcall	.-3036   	; 0x63e <drivers>
    121a:	8f 89       	ldd	r24, Y+23	; 0x17
    121c:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    121e:	06 c0       	rjmp	.+12     	; 0x122c <__stack+0x12d>
    1220:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1222:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1224:	89 2b       	or	r24, r25
    1226:	11 f4       	brne	.+4      	; 0x122c <__stack+0x12d>
    1228:	83 e0       	ldi	r24, 0x03	; 3
    122a:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    122c:	8a a1       	ldd	r24, Y+34	; 0x22
    122e:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    1230:	41 f4       	brne	.+16     	; 0x1242 <__stack+0x143>
    1232:	8a ad       	ldd	r24, Y+58	; 0x3a
    1234:	81 11       	cpse	r24, r1
    1236:	05 c0       	rjmp	.+10     	; 0x1242 <__stack+0x143>
    1238:	85 e0       	ldi	r24, 0x05	; 5
    123a:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    123c:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    123e:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    1242:	88 8d       	ldd	r24, Y+24	; 0x18
    1244:	88 23       	and	r24, r24
    1246:	b9 f1       	breq	.+110    	; 0x12b6 <__stack+0x1b7>
    1248:	8f 89       	ldd	r24, Y+23	; 0x17
    124a:	81 11       	cpse	r24, r1
    124c:	34 c0       	rjmp	.+104    	; 0x12b6 <__stack+0x1b7>
			{
				vals->motor_status = BRAKE;
    124e:	82 e0       	ldi	r24, 0x02	; 2
    1250:	8e 8f       	std	Y+30, r24	; 0x1e
    1252:	31 c0       	rjmp	.+98     	; 0x12b6 <__stack+0x1b7>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    1254:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    1256:	ce 01       	movw	r24, r28
    1258:	a3 d8       	rcall	.-3770   	; 0x3a0 <controller>
    125a:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    125c:	f0 d9       	rcall	.-3104   	; 0x63e <drivers>
    125e:	88 8d       	ldd	r24, Y+24	; 0x18
    1260:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1262:	06 c0       	rjmp	.+12     	; 0x1270 <__stack+0x171>
    1264:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1266:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1268:	89 2b       	or	r24, r25
    126a:	11 f4       	brne	.+4      	; 0x1270 <__stack+0x171>
    126c:	83 e0       	ldi	r24, 0x03	; 3
    126e:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1270:	8a a1       	ldd	r24, Y+34	; 0x22
    1272:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    1274:	41 f4       	brne	.+16     	; 0x1286 <__stack+0x187>
    1276:	8a ad       	ldd	r24, Y+58	; 0x3a
    1278:	81 11       	cpse	r24, r1
    127a:	05 c0       	rjmp	.+10     	; 0x1286 <__stack+0x187>
    127c:	85 e0       	ldi	r24, 0x05	; 5
    127e:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <starting_engage>
				starting_engage = 1;
    1286:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    1288:	81 11       	cpse	r24, r1
    128a:	15 c0       	rjmp	.+42     	; 0x12b6 <__stack+0x1b7>
    128c:	8f 89       	ldd	r24, Y+23	; 0x17
    128e:	88 23       	and	r24, r24
    1290:	91 f0       	breq	.+36     	; 0x12b6 <__stack+0x1b7>
			{
				vals->motor_status = ACCEL;
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	8e 8f       	std	Y+30, r24	; 0x1e
    1296:	0f c0       	rjmp	.+30     	; 0x12b6 <__stack+0x1b7>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1298:	80 91 f9 01 	lds	r24, 0x01F9	; 0x8001f9 <b_major_fault>
    129c:	81 11       	cpse	r24, r1
    129e:	02 c0       	rjmp	.+4      	; 0x12a4 <__stack+0x1a5>
			{
				vals->motor_status = IDLE;
    12a0:	83 e0       	ldi	r24, 0x03	; 3
    12a2:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    12a4:	80 e0       	ldi	r24, 0x00	; 0
    12a6:	cb d9       	rcall	.-3178   	; 0x63e <drivers>
    12a8:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    12aa:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    12ac:	55 d8       	rcall	.-3926   	; 0x358 <reset_I>
			reset_I(); //reset integrator
    12ae:	18 8e       	std	Y+24, r1	; 0x18
    12b0:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    12b2:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    12b4:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    12b6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12b8:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    12ba:	49 f0       	breq	.+18     	; 0x12ce <__stack+0x1cf>
    12bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12be:	81 30       	cpi	r24, 0x01	; 1
    12c0:	31 f0       	breq	.+12     	; 0x12ce <__stack+0x1cf>
    12c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12c4:	82 30       	cpi	r24, 0x02	; 2
    12c6:	19 f0       	breq	.+6      	; 0x12ce <__stack+0x1cf>
    12c8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ca:	85 30       	cpi	r24, 0x05	; 5
    12cc:	29 f4       	brne	.+10     	; 0x12d8 <__stack+0x1d9>
    12ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12d0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    12d2:	89 2b       	or	r24, r25
    12d4:	09 f4       	brne	.+2      	; 0x12d8 <__stack+0x1d9>
    12d6:	1e 8e       	std	Y+30, r1	; 0x1e
    12d8:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    12da:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    12dc:	08 95       	ret

000012de <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    12e2:	8e b1       	in	r24, 0x0e	; 14
    12e4:	87 7c       	andi	r24, 0xC7	; 199
    12e6:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    12e8:	8d b1       	in	r24, 0x0d	; 13
    12ea:	88 63       	ori	r24, 0x38	; 56
    12ec:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    12ee:	a1 e9       	ldi	r26, 0x91	; 145
    12f0:	b0 e0       	ldi	r27, 0x00	; 0
    12f2:	8c 91       	ld	r24, X
    12f4:	80 61       	ori	r24, 0x10	; 16
    12f6:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    12f8:	8c 91       	ld	r24, X
    12fa:	87 7f       	andi	r24, 0xF7	; 247
    12fc:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    12fe:	e0 e9       	ldi	r30, 0x90	; 144
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	80 81       	ld	r24, Z
    1304:	82 60       	ori	r24, 0x02	; 2
    1306:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    1308:	80 81       	ld	r24, Z
    130a:	8e 7f       	andi	r24, 0xFE	; 254
    130c:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    130e:	80 81       	ld	r24, Z
    1310:	80 68       	ori	r24, 0x80	; 128
    1312:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    1314:	80 81       	ld	r24, Z
    1316:	8f 7b       	andi	r24, 0xBF	; 191
    1318:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    131a:	80 81       	ld	r24, Z
    131c:	80 62       	ori	r24, 0x20	; 32
    131e:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    1320:	80 81       	ld	r24, Z
    1322:	8f 7e       	andi	r24, 0xEF	; 239
    1324:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    1326:	80 81       	ld	r24, Z
    1328:	88 60       	ori	r24, 0x08	; 8
    132a:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    132c:	80 81       	ld	r24, Z
    132e:	8b 7f       	andi	r24, 0xFB	; 251
    1330:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    1332:	8c 91       	ld	r24, X
    1334:	81 60       	ori	r24, 0x01	; 1
    1336:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    1338:	8c 91       	ld	r24, X
    133a:	89 7f       	andi	r24, 0xF9	; 249
    133c:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    133e:	c6 e9       	ldi	r28, 0x96	; 150
    1340:	d0 e0       	ldi	r29, 0x00	; 0
    1342:	85 e8       	ldi	r24, 0x85	; 133
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	99 83       	std	Y+1, r25	; 0x01
    1348:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    134a:	68 81       	ld	r22, Y
    134c:	79 81       	ldd	r23, Y+1	; 0x01
    134e:	80 e0       	ldi	r24, 0x00	; 0
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	40 e0       	ldi	r20, 0x00	; 0
    135c:	5f e3       	ldi	r21, 0x3F	; 63
    135e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    1362:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
    1366:	e8 e9       	ldi	r30, 0x98	; 152
    1368:	f0 e0       	ldi	r31, 0x00	; 0
    136a:	71 83       	std	Z+1, r23	; 0x01
    136c:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    136e:	88 81       	ld	r24, Y
    1370:	99 81       	ldd	r25, Y+1	; 0x01
    1372:	20 81       	ld	r18, Z
    1374:	31 81       	ldd	r19, Z+1	; 0x01
    1376:	82 1b       	sub	r24, r18
    1378:	93 0b       	sbc	r25, r19
    137a:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    137e:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    1382:	68 81       	ld	r22, Y
    1384:	79 81       	ldd	r23, Y+1	; 0x01
    1386:	80 e0       	ldi	r24, 0x00	; 0
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	0e 94 46 12 	call	0x248c	; 0x248c <__floatunsisf>
    138e:	20 e0       	ldi	r18, 0x00	; 0
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	40 e0       	ldi	r20, 0x00	; 0
    1394:	5f e3       	ldi	r21, 0x3F	; 63
    1396:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <__mulsf3>
    139a:	0e 94 15 12 	call	0x242a	; 0x242a <__fixsfsi>
    139e:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    13a2:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	08 95       	ret

000013ac <uart0_putc>:
    13ac:	90 91 00 04 	lds	r25, 0x0400	; 0x800400 <tx0_Head>
    13b0:	9f 5f       	subi	r25, 0xFF	; 255
    13b2:	9f 71       	andi	r25, 0x1F	; 31
    13b4:	20 91 de 03 	lds	r18, 0x03DE	; 0x8003de <tx0_Tail>
    13b8:	92 17       	cp	r25, r18
    13ba:	e1 f3       	breq	.-8      	; 0x13b4 <uart0_putc+0x8>
    13bc:	e9 2f       	mov	r30, r25
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	eb 5d       	subi	r30, 0xDB	; 219
    13c2:	fb 4f       	sbci	r31, 0xFB	; 251
    13c4:	80 83       	st	Z, r24
    13c6:	2f b7       	in	r18, 0x3f	; 63
    13c8:	f8 94       	cli
    13ca:	90 93 00 04 	sts	0x0400, r25	; 0x800400 <tx0_Head>
    13ce:	e1 ec       	ldi	r30, 0xC1	; 193
    13d0:	f0 e0       	ldi	r31, 0x00	; 0
    13d2:	80 81       	ld	r24, Z
    13d4:	80 62       	ori	r24, 0x20	; 32
    13d6:	80 83       	st	Z, r24
    13d8:	2f bf       	out	0x3f, r18	; 63
    13da:	08 95       	ret

000013dc <uart0_flush>:
    13dc:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <tx0_Tail>
    13e0:	80 91 00 04 	lds	r24, 0x0400	; 0x800400 <tx0_Head>
    13e4:	98 13       	cpse	r25, r24
    13e6:	fa cf       	rjmp	.-12     	; 0x13dc <uart0_flush>
    13e8:	08 95       	ret

000013ea <uart1_putc>:
    13ea:	90 91 24 04 	lds	r25, 0x0424	; 0x800424 <tx1_Head>
    13ee:	9f 5f       	subi	r25, 0xFF	; 255
    13f0:	9f 71       	andi	r25, 0x1F	; 31
    13f2:	20 91 22 04 	lds	r18, 0x0422	; 0x800422 <tx1_Tail>
    13f6:	92 17       	cp	r25, r18
    13f8:	e1 f3       	breq	.-8      	; 0x13f2 <uart1_putc+0x8>
    13fa:	e9 2f       	mov	r30, r25
    13fc:	f0 e0       	ldi	r31, 0x00	; 0
    13fe:	e0 52       	subi	r30, 0x20	; 32
    1400:	fc 4f       	sbci	r31, 0xFC	; 252
    1402:	80 83       	st	Z, r24
    1404:	2f b7       	in	r18, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	90 93 24 04 	sts	0x0424, r25	; 0x800424 <tx1_Head>
    140c:	e9 ec       	ldi	r30, 0xC9	; 201
    140e:	f0 e0       	ldi	r31, 0x00	; 0
    1410:	80 81       	ld	r24, Z
    1412:	80 62       	ori	r24, 0x20	; 32
    1414:	80 83       	st	Z, r24
    1416:	2f bf       	out	0x3f, r18	; 63
    1418:	08 95       	ret

0000141a <uart_putchar>:
    141a:	cf 93       	push	r28
    141c:	c8 2f       	mov	r28, r24
    141e:	fb 01       	movw	r30, r22
    1420:	84 85       	ldd	r24, Z+12	; 0x0c
    1422:	95 85       	ldd	r25, Z+13	; 0x0d
    1424:	01 97       	sbiw	r24, 0x01	; 1
    1426:	39 f0       	breq	.+14     	; 0x1436 <uart_putchar+0x1c>
    1428:	ca 30       	cpi	r28, 0x0A	; 10
    142a:	11 f4       	brne	.+4      	; 0x1430 <uart_putchar+0x16>
    142c:	8d e0       	ldi	r24, 0x0D	; 13
    142e:	be df       	rcall	.-132    	; 0x13ac <uart0_putc>
    1430:	8c 2f       	mov	r24, r28
    1432:	bc df       	rcall	.-136    	; 0x13ac <uart0_putc>
    1434:	06 c0       	rjmp	.+12     	; 0x1442 <uart_putchar+0x28>
    1436:	ca 30       	cpi	r28, 0x0A	; 10
    1438:	11 f4       	brne	.+4      	; 0x143e <uart_putchar+0x24>
    143a:	8d e0       	ldi	r24, 0x0D	; 13
    143c:	d6 df       	rcall	.-84     	; 0x13ea <uart1_putc>
    143e:	8c 2f       	mov	r24, r28
    1440:	d4 df       	rcall	.-88     	; 0x13ea <uart1_putc>
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	cf 91       	pop	r28
    1448:	08 95       	ret

0000144a <uart0_getc>:
    144a:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <rx0_Tail>
    144e:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <rx0_Head>
    1452:	89 17       	cp	r24, r25
    1454:	59 f0       	breq	.+22     	; 0x146c <uart0_getc+0x22>
    1456:	8f 5f       	subi	r24, 0xFF	; 255
    1458:	98 2f       	mov	r25, r24
    145a:	9f 71       	andi	r25, 0x1F	; 31
    145c:	e9 2f       	mov	r30, r25
    145e:	f0 e0       	ldi	r31, 0x00	; 0
    1460:	e3 54       	subi	r30, 0x43	; 67
    1462:	fc 4f       	sbci	r31, 0xFC	; 252
    1464:	80 81       	ld	r24, Z
    1466:	90 93 df 03 	sts	0x03DF, r25	; 0x8003df <rx0_Tail>
    146a:	08 95       	ret
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	08 95       	ret

00001470 <uart0_getln>:
    1470:	0f 93       	push	r16
    1472:	1f 93       	push	r17
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	ec 01       	movw	r28, r24
    147a:	61 30       	cpi	r22, 0x01	; 1
    147c:	b1 f0       	breq	.+44     	; 0x14aa <uart0_getln+0x3a>
    147e:	62 50       	subi	r22, 0x02	; 2
    1480:	06 2f       	mov	r16, r22
    1482:	10 e0       	ldi	r17, 0x00	; 0
    1484:	0f 5f       	subi	r16, 0xFF	; 255
    1486:	1f 4f       	sbci	r17, 0xFF	; 255
    1488:	08 0f       	add	r16, r24
    148a:	19 1f       	adc	r17, r25
    148c:	de df       	rcall	.-68     	; 0x144a <uart0_getc>
    148e:	88 83       	st	Y, r24
    1490:	88 23       	and	r24, r24
    1492:	e1 f3       	breq	.-8      	; 0x148c <uart0_getln+0x1c>
    1494:	8d 30       	cpi	r24, 0x0D	; 13
    1496:	21 f4       	brne	.+8      	; 0x14a0 <uart0_getln+0x30>
    1498:	d8 df       	rcall	.-80     	; 0x144a <uart0_getc>
    149a:	88 23       	and	r24, r24
    149c:	e9 f3       	breq	.-6      	; 0x1498 <uart0_getln+0x28>
    149e:	05 c0       	rjmp	.+10     	; 0x14aa <uart0_getln+0x3a>
    14a0:	21 96       	adiw	r28, 0x01	; 1
    14a2:	c0 17       	cp	r28, r16
    14a4:	d1 07       	cpc	r29, r17
    14a6:	91 f7       	brne	.-28     	; 0x148c <uart0_getln+0x1c>
    14a8:	e8 01       	movw	r28, r16
    14aa:	18 82       	st	Y, r1
    14ac:	df 91       	pop	r29
    14ae:	cf 91       	pop	r28
    14b0:	1f 91       	pop	r17
    14b2:	0f 91       	pop	r16
    14b4:	08 95       	ret

000014b6 <uart0_getData>:
    14b6:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <rx0_Tail>
    14ba:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <rx0_Head>
    14be:	89 17       	cp	r24, r25
    14c0:	61 f0       	breq	.+24     	; 0x14da <uart0_getData+0x24>
    14c2:	8f 5f       	subi	r24, 0xFF	; 255
    14c4:	8f 71       	andi	r24, 0x1F	; 31
    14c6:	e8 2f       	mov	r30, r24
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	e3 54       	subi	r30, 0x43	; 67
    14cc:	fc 4f       	sbci	r31, 0xFC	; 252
    14ce:	90 81       	ld	r25, Z
    14d0:	80 93 df 03 	sts	0x03DF, r24	; 0x8003df <rx0_Tail>
    14d4:	89 2f       	mov	r24, r25
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	08 95       	ret
    14da:	8f ef       	ldi	r24, 0xFF	; 255
    14dc:	9f ef       	ldi	r25, 0xFF	; 255
    14de:	08 95       	ret

000014e0 <uart1_getData>:
    14e0:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <rx1_Tail>
    14e4:	90 91 23 04 	lds	r25, 0x0423	; 0x800423 <rx1_Head>
    14e8:	89 17       	cp	r24, r25
    14ea:	61 f0       	breq	.+24     	; 0x1504 <uart1_getData+0x24>
    14ec:	8f 5f       	subi	r24, 0xFF	; 255
    14ee:	8f 71       	andi	r24, 0x1F	; 31
    14f0:	e8 2f       	mov	r30, r24
    14f2:	f0 e0       	ldi	r31, 0x00	; 0
    14f4:	ef 5f       	subi	r30, 0xFF	; 255
    14f6:	fb 4f       	sbci	r31, 0xFB	; 251
    14f8:	90 81       	ld	r25, Z
    14fa:	80 93 dd 03 	sts	0x03DD, r24	; 0x8003dd <rx1_Tail>
    14fe:	89 2f       	mov	r24, r25
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	08 95       	ret
    1504:	8f ef       	ldi	r24, 0xFF	; 255
    1506:	9f ef       	ldi	r25, 0xFF	; 255
    1508:	08 95       	ret

0000150a <uart_getchar>:
    150a:	cf 93       	push	r28
    150c:	df 93       	push	r29
    150e:	fc 01       	movw	r30, r24
    1510:	84 85       	ldd	r24, Z+12	; 0x0c
    1512:	95 85       	ldd	r25, Z+13	; 0x0d
    1514:	01 97       	sbiw	r24, 0x01	; 1
    1516:	41 f0       	breq	.+16     	; 0x1528 <uart_getchar+0x1e>
    1518:	ce df       	rcall	.-100    	; 0x14b6 <uart0_getData>
    151a:	ec 01       	movw	r28, r24
    151c:	99 23       	and	r25, r25
    151e:	e4 f3       	brlt	.-8      	; 0x1518 <uart_getchar+0xe>
    1520:	45 df       	rcall	.-374    	; 0x13ac <uart0_putc>
    1522:	ce 01       	movw	r24, r28
    1524:	99 27       	eor	r25, r25
    1526:	07 c0       	rjmp	.+14     	; 0x1536 <uart_getchar+0x2c>
    1528:	db df       	rcall	.-74     	; 0x14e0 <uart1_getData>
    152a:	ec 01       	movw	r28, r24
    152c:	99 23       	and	r25, r25
    152e:	e4 f3       	brlt	.-8      	; 0x1528 <uart_getchar+0x1e>
    1530:	5c df       	rcall	.-328    	; 0x13ea <uart1_putc>
    1532:	ce 01       	movw	r24, r28
    1534:	99 27       	eor	r25, r25
    1536:	99 27       	eor	r25, r25
    1538:	df 91       	pop	r29
    153a:	cf 91       	pop	r28
    153c:	08 95       	ret

0000153e <__vector_22>:
    153e:	0f 93       	push	r16
    1540:	0f b7       	in	r16, 0x3f	; 63
    1542:	ef 93       	push	r30
    1544:	ff 93       	push	r31
    1546:	e0 91 de 03 	lds	r30, 0x03DE	; 0x8003de <tx0_Tail>
    154a:	f0 91 00 04 	lds	r31, 0x0400	; 0x800400 <tx0_Head>
    154e:	e3 95       	inc	r30
    1550:	ef 71       	andi	r30, 0x1F	; 31
    1552:	ef 13       	cpse	r30, r31
    1554:	05 c0       	rjmp	.+10     	; 0x1560 <USART0_TX_CONTINUE>
    1556:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    155a:	ff 7d       	andi	r31, 0xDF	; 223
    155c:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

00001560 <USART0_TX_CONTINUE>:
    1560:	e0 93 de 03 	sts	0x03DE, r30	; 0x8003de <tx0_Tail>
    1564:	f0 e0       	ldi	r31, 0x00	; 0
    1566:	eb 5d       	subi	r30, 0xDB	; 219
    1568:	fb 4f       	sbci	r31, 0xFB	; 251
    156a:	e0 81       	ld	r30, Z
    156c:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

00001570 <USART0_TX_EXIT>:
    1570:	ff 91       	pop	r31
    1572:	ef 91       	pop	r30
    1574:	0f bf       	out	0x3f, r16	; 63
    1576:	0f 91       	pop	r16
    1578:	18 95       	reti

0000157a <__vector_21>:
    157a:	0f 93       	push	r16
    157c:	0f b7       	in	r16, 0x3f	; 63
    157e:	9f 93       	push	r25
    1580:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1584:	ef 93       	push	r30
    1586:	ff 93       	push	r31
    1588:	e0 91 21 04 	lds	r30, 0x0421	; 0x800421 <rx0_Head>
    158c:	f0 91 df 03 	lds	r31, 0x03DF	; 0x8003df <rx0_Tail>
    1590:	e3 95       	inc	r30
    1592:	ef 71       	andi	r30, 0x1F	; 31
    1594:	fe 17       	cp	r31, r30
    1596:	31 f0       	breq	.+12     	; 0x15a4 <USART0_RX_EXIT>
    1598:	e0 93 21 04 	sts	0x0421, r30	; 0x800421 <rx0_Head>
    159c:	f0 e0       	ldi	r31, 0x00	; 0
    159e:	e3 54       	subi	r30, 0x43	; 67
    15a0:	fc 4f       	sbci	r31, 0xFC	; 252
    15a2:	90 83       	st	Z, r25

000015a4 <USART0_RX_EXIT>:
    15a4:	ff 91       	pop	r31
    15a6:	ef 91       	pop	r30
    15a8:	9f 91       	pop	r25
    15aa:	0f bf       	out	0x3f, r16	; 63
    15ac:	0f 91       	pop	r16
    15ae:	18 95       	reti

000015b0 <__vector_33>:
    15b0:	0f 93       	push	r16
    15b2:	0f b7       	in	r16, 0x3f	; 63
    15b4:	ef 93       	push	r30
    15b6:	ff 93       	push	r31
    15b8:	e0 91 22 04 	lds	r30, 0x0422	; 0x800422 <tx1_Tail>
    15bc:	f0 91 24 04 	lds	r31, 0x0424	; 0x800424 <tx1_Head>
    15c0:	e3 95       	inc	r30
    15c2:	ef 71       	andi	r30, 0x1F	; 31
    15c4:	ef 13       	cpse	r30, r31
    15c6:	05 c0       	rjmp	.+10     	; 0x15d2 <USART1_TX_CONTINUE>
    15c8:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    15cc:	ff 7d       	andi	r31, 0xDF	; 223
    15ce:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

000015d2 <USART1_TX_CONTINUE>:
    15d2:	e0 93 22 04 	sts	0x0422, r30	; 0x800422 <tx1_Tail>
    15d6:	f0 e0       	ldi	r31, 0x00	; 0
    15d8:	e0 52       	subi	r30, 0x20	; 32
    15da:	fc 4f       	sbci	r31, 0xFC	; 252
    15dc:	e0 81       	ld	r30, Z
    15de:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

000015e2 <USART1_TX_EXIT>:
    15e2:	ff 91       	pop	r31
    15e4:	ef 91       	pop	r30
    15e6:	0f bf       	out	0x3f, r16	; 63
    15e8:	0f 91       	pop	r16
    15ea:	18 95       	reti

000015ec <__vector_32>:
    15ec:	0f 93       	push	r16
    15ee:	0f b7       	in	r16, 0x3f	; 63
    15f0:	9f 93       	push	r25
    15f2:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    15f6:	ef 93       	push	r30
    15f8:	ff 93       	push	r31
    15fa:	e0 91 23 04 	lds	r30, 0x0423	; 0x800423 <rx1_Head>
    15fe:	f0 91 dd 03 	lds	r31, 0x03DD	; 0x8003dd <rx1_Tail>
    1602:	e3 95       	inc	r30
    1604:	ef 71       	andi	r30, 0x1F	; 31
    1606:	fe 17       	cp	r31, r30
    1608:	31 f0       	breq	.+12     	; 0x1616 <USART1_RX_EXIT>
    160a:	e0 93 23 04 	sts	0x0423, r30	; 0x800423 <rx1_Head>
    160e:	f0 e0       	ldi	r31, 0x00	; 0
    1610:	ef 5f       	subi	r30, 0xFF	; 255
    1612:	fb 4f       	sbci	r31, 0xFB	; 251
    1614:	90 83       	st	Z, r25

00001616 <USART1_RX_EXIT>:
    1616:	ff 91       	pop	r31
    1618:	ef 91       	pop	r30
    161a:	9f 91       	pop	r25
    161c:	0f bf       	out	0x3f, r16	; 63
    161e:	0f 91       	pop	r16
    1620:	18 95       	reti

00001622 <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    1622:	e1 e8       	ldi	r30, 0x81	; 129
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	83 60       	ori	r24, 0x03	; 3
    162a:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    162c:	80 81       	ld	r24, Z
    162e:	88 60       	ori	r24, 0x08	; 8
    1630:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    1632:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    1636:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    163a:	ef e6       	ldi	r30, 0x6F	; 111
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	80 81       	ld	r24, Z
    1640:	82 60       	ori	r24, 0x02	; 2
    1642:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    1644:	8d e7       	ldi	r24, 0x7D	; 125
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    164c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    1650:	08 95       	ret

00001652 <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    1652:	84 b5       	in	r24, 0x24	; 36
    1654:	85 60       	ori	r24, 0x05	; 5
    1656:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    1658:	84 b5       	in	r24, 0x24	; 36
    165a:	88 60       	ori	r24, 0x08	; 8
    165c:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    165e:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    1660:	ee e6       	ldi	r30, 0x6E	; 110
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	80 81       	ld	r24, Z
    1666:	82 60       	ori	r24, 0x02	; 2
    1668:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    166a:	87 e2       	ldi	r24, 0x27	; 39
    166c:	87 bd       	out	0x27, r24	; 39
    166e:	08 95       	ret

00001670 <main>:
};


int main(void)	
{
	cli();
    1670:	f8 94       	cli
	rgbled_init();
    1672:	8a d5       	rcall	.+2836   	; 0x2188 <rgbled_init>
	DWC_init();
    1674:	09 d2       	rcall	.+1042   	; 0x1a88 <DWC_init>
	pwm_init();
    1676:	33 de       	rcall	.-922    	; 0x12de <pwm_init>
    1678:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    167a:	70 e0       	ldi	r23, 0x00	; 0
    167c:	80 e0       	ldi	r24, 0x00	; 0
    167e:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    1680:	69 d4       	rcall	.+2258   	; 0x1f54 <can_init>
	timer0_init_ts();
    1682:	cf df       	rcall	.-98     	; 0x1622 <timer1_init_ts>
    1684:	e6 df       	rcall	.-52     	; 0x1652 <timer0_init_ts>
	speed_init();
    1686:	7f dc       	rcall	.-1794   	; 0xf86 <speed_init>
    1688:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    168a:	8d d5       	rcall	.+2842   	; 0x21a6 <spi_init>
    168c:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    1690:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1694:	88 e9       	ldi	r24, 0x98	; 152
    1696:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    169a:	e5 e4       	ldi	r30, 0x45	; 69
    169c:	f4 e0       	ldi	r31, 0x04	; 4
	//actuator_init(&ComValues);
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    169e:	84 e0       	ldi	r24, 0x04	; 4
    16a0:	91 e0       	ldi	r25, 0x01	; 1
    16a2:	93 83       	std	Z+3, r25	; 0x03
    16a4:	82 83       	std	Z+2, r24	; 0x02
    16a6:	91 83       	std	Z+1, r25	; 0x01
    16a8:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    16aa:	0e 94 1d 03 	call	0x63a	; 0x63a <drivers_init>
	drivers_init();
    16ae:	80 e0       	ldi	r24, 0x00	; 0
    16b0:	0e 94 1f 03 	call	0x63e	; 0x63e <drivers>
	drivers(0);
    16b4:	78 94       	sei
	sei();
    16b6:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    16b8:	61 e9       	ldi	r22, 0x91	; 145
    16ba:	73 e0       	ldi	r23, 0x03	; 3
    16bc:	82 e1       	ldi	r24, 0x12	; 18
    16be:	91 e0       	ldi	r25, 0x01	; 1
    16c0:	b9 d8       	rcall	.-3726   	; 0x834 <handle_can>
    16c2:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	92 d9       	rcall	.-3292   	; 0x9ec <receive_uart>
    16c8:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    16cc:	88 23       	and	r24, r24
    16ce:	09 f4       	brne	.+2      	; 0x16d2 <main+0x62>
    16d0:	41 c0       	rjmp	.+130    	; 0x1754 <main+0xe4>
    16d2:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    16d6:	88 23       	and	r24, r24
    16d8:	f1 f0       	breq	.+60     	; 0x1716 <main+0xa6>
    16da:	8d b7       	in	r24, 0x3d	; 61
    16dc:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    16de:	cd 97       	sbiw	r24, 0x3d	; 61
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	9e bf       	out	0x3e, r25	; 62
    16e6:	0f be       	out	0x3f, r0	; 63
    16e8:	8d bf       	out	0x3d, r24	; 61
    16ea:	ad b7       	in	r26, 0x3d	; 61
    16ec:	be b7       	in	r27, 0x3e	; 62
    16ee:	11 96       	adiw	r26, 0x01	; 1
    16f0:	8d e3       	ldi	r24, 0x3D	; 61
    16f2:	e2 e1       	ldi	r30, 0x12	; 18
    16f4:	f1 e0       	ldi	r31, 0x01	; 1
    16f6:	01 90       	ld	r0, Z+
    16f8:	0d 92       	st	X+, r0
    16fa:	8a 95       	dec	r24
    16fc:	e1 f7       	brne	.-8      	; 0x16f6 <main+0x86>
    16fe:	f1 d8       	rcall	.-3614   	; 0x8e2 <handle_motor_status_can_msg>
    1700:	10 92 fe 01 	sts	0x01FE, r1	; 0x8001fe <b_select_can_msg>
				b_select_can_msg = 0;
    1704:	8d b7       	in	r24, 0x3d	; 61
    1706:	9e b7       	in	r25, 0x3e	; 62
    1708:	cd 96       	adiw	r24, 0x3d	; 61
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	f8 94       	cli
    170e:	9e bf       	out	0x3e, r25	; 62
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	8d bf       	out	0x3d, r24	; 61
    1714:	1d c0       	rjmp	.+58     	; 0x1750 <main+0xe0>
    1716:	8d b7       	in	r24, 0x3d	; 61
    1718:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    171a:	cd 97       	sbiw	r24, 0x3d	; 61
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	9e bf       	out	0x3e, r25	; 62
    1722:	0f be       	out	0x3f, r0	; 63
    1724:	8d bf       	out	0x3d, r24	; 61
    1726:	ad b7       	in	r26, 0x3d	; 61
    1728:	be b7       	in	r27, 0x3e	; 62
    172a:	11 96       	adiw	r26, 0x01	; 1
    172c:	8d e3       	ldi	r24, 0x3D	; 61
    172e:	e2 e1       	ldi	r30, 0x12	; 18
    1730:	f1 e0       	ldi	r31, 0x01	; 1
    1732:	01 90       	ld	r0, Z+
    1734:	0d 92       	st	X+, r0
    1736:	8a 95       	dec	r24
    1738:	e1 f7       	brne	.-8      	; 0x1732 <main+0xc2>
    173a:	42 d9       	rcall	.-3452   	; 0x9c0 <handle_clutch_cmd_can_msg>
    173c:	c0 93 fe 01 	sts	0x01FE, r28	; 0x8001fe <b_select_can_msg>
				b_select_can_msg = 1;
    1740:	8d b7       	in	r24, 0x3d	; 61
    1742:	9e b7       	in	r25, 0x3e	; 62
    1744:	cd 96       	adiw	r24, 0x3d	; 61
    1746:	0f b6       	in	r0, 0x3f	; 63
    1748:	f8 94       	cli
    174a:	9e bf       	out	0x3e, r25	; 62
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	8d bf       	out	0x3d, r24	; 61
    1750:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_send_can>
			}
			b_send_can = 0;
    1754:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <b_send_uart>
		}
		
		if (b_send_uart)
    1758:	88 23       	and	r24, r24
    175a:	09 f4       	brne	.+2      	; 0x175e <main+0xee>
    175c:	ad cf       	rjmp	.-166    	; 0x16b8 <main+0x48>
    175e:	8d b7       	in	r24, 0x3d	; 61
    1760:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    1762:	cd 97       	sbiw	r24, 0x3d	; 61
    1764:	0f b6       	in	r0, 0x3f	; 63
    1766:	f8 94       	cli
    1768:	9e bf       	out	0x3e, r25	; 62
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	8d bf       	out	0x3d, r24	; 61
    176e:	ad b7       	in	r26, 0x3d	; 61
    1770:	be b7       	in	r27, 0x3e	; 62
    1772:	11 96       	adiw	r26, 0x01	; 1
    1774:	8d e3       	ldi	r24, 0x3D	; 61
    1776:	e2 e1       	ldi	r30, 0x12	; 18
    1778:	f1 e0       	ldi	r31, 0x01	; 1
    177a:	01 90       	ld	r0, Z+
    177c:	0d 92       	st	X+, r0
    177e:	8a 95       	dec	r24
    1780:	e1 f7       	brne	.-8      	; 0x177a <main+0x10a>
    1782:	df da       	rcall	.-2626   	; 0xd42 <send_uart>
    1784:	10 92 fd 01 	sts	0x01FD, r1	; 0x8001fd <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    1788:	8d b7       	in	r24, 0x3d	; 61
    178a:	9e b7       	in	r25, 0x3e	; 62
    178c:	cd 96       	adiw	r24, 0x3d	; 61
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	9e bf       	out	0x3e, r25	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	8d bf       	out	0x3d, r24	; 61
    1798:	8f cf       	rjmp	.-226    	; 0x16b8 <main+0x48>

0000179a <__vector_16>:
    179a:	1f 92       	push	r1
    179c:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    179e:	0f b6       	in	r0, 0x3f	; 63
    17a0:	0f 92       	push	r0
    17a2:	11 24       	eor	r1, r1
    17a4:	0b b6       	in	r0, 0x3b	; 59
    17a6:	0f 92       	push	r0
    17a8:	ef 92       	push	r14
    17aa:	0f 93       	push	r16
    17ac:	1f 93       	push	r17
    17ae:	2f 93       	push	r18
    17b0:	3f 93       	push	r19
    17b2:	4f 93       	push	r20
    17b4:	5f 93       	push	r21
    17b6:	6f 93       	push	r22
    17b8:	7f 93       	push	r23
    17ba:	8f 93       	push	r24
    17bc:	9f 93       	push	r25
    17be:	af 93       	push	r26
    17c0:	bf 93       	push	r27
    17c2:	ef 93       	push	r30
    17c4:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    17c6:	82 e1       	ldi	r24, 0x12	; 18
    17c8:	91 e0       	ldi	r25, 0x01	; 1
    17ca:	5f d1       	rcall	.+702    	; 0x1a8a <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    17cc:	82 e1       	ldi	r24, 0x12	; 18
    17ce:	91 e0       	ldi	r25, 0x01	; 1
    17d0:	67 dc       	rcall	.-1842   	; 0x10a0 <state_handler>
	actuator_p_controller(&ComValues);// manages the actuator's state machine for clutch position 
    17d2:	82 e1       	ldi	r24, 0x12	; 18
    17d4:	91 e0       	ldi	r25, 0x01	; 1
    17d6:	0e 94 2d 01 	call	0x25a	; 0x25a <actuator_p_controller>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    17da:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <systic_counter_fast>
    17de:	87 30       	cpi	r24, 0x07	; 7
    17e0:	09 f0       	breq	.+2      	; 0x17e4 <__vector_16+0x4a>
    17e2:	51 c0       	rjmp	.+162    	; 0x1886 <__vector_16+0xec>
	{
		b_send_can = 1;
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	80 93 ff 01 	sts	0x01FF, r24	; 0x8001ff <b_send_can>
		b_send_uart = 1;
    17ea:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    17ee:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    17f2:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    17f6:	89 2b       	or	r24, r25
    17f8:	b1 f0       	breq	.+44     	; 0x1826 <__vector_16+0x8c>
    17fa:	e2 e1       	ldi	r30, 0x12	; 18
    17fc:	f1 e0       	ldi	r31, 0x01	; 1
    17fe:	97 8d       	ldd	r25, Z+31	; 0x1f
    1800:	27 8d       	ldd	r18, Z+31	; 0x1f
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	91 30       	cpi	r25, 0x01	; 1
    1806:	09 f0       	breq	.+2      	; 0x180a <__vector_16+0x70>
    1808:	80 e0       	ldi	r24, 0x00	; 0
    180a:	81 11       	cpse	r24, r1
    180c:	05 c0       	rjmp	.+10     	; 0x1818 <__vector_16+0x7e>
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	21 11       	cpse	r18, r1
    1812:	80 e0       	ldi	r24, 0x00	; 0
    1814:	88 23       	and	r24, r24
    1816:	39 f0       	breq	.+14     	; 0x1826 <__vector_16+0x8c>
		{
			ComValues.u16_watchdog_can -- ;
    1818:	e2 e1       	ldi	r30, 0x12	; 18
    181a:	f1 e0       	ldi	r31, 0x01	; 1
    181c:	82 8d       	ldd	r24, Z+26	; 0x1a
    181e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1820:	01 97       	sbiw	r24, 0x01	; 1
    1822:	93 8f       	std	Z+27, r25	; 0x1b
    1824:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1826:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    182a:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    182e:	89 2b       	or	r24, r25
    1830:	b1 f0       	breq	.+44     	; 0x185e <__vector_16+0xc4>
    1832:	e2 e1       	ldi	r30, 0x12	; 18
    1834:	f1 e0       	ldi	r31, 0x01	; 1
    1836:	97 8d       	ldd	r25, Z+31	; 0x1f
    1838:	27 8d       	ldd	r18, Z+31	; 0x1f
    183a:	81 e0       	ldi	r24, 0x01	; 1
    183c:	91 30       	cpi	r25, 0x01	; 1
    183e:	09 f0       	breq	.+2      	; 0x1842 <__vector_16+0xa8>
    1840:	80 e0       	ldi	r24, 0x00	; 0
    1842:	81 11       	cpse	r24, r1
    1844:	05 c0       	rjmp	.+10     	; 0x1850 <__vector_16+0xb6>
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	21 11       	cpse	r18, r1
    184a:	80 e0       	ldi	r24, 0x00	; 0
    184c:	88 23       	and	r24, r24
    184e:	39 f0       	breq	.+14     	; 0x185e <__vector_16+0xc4>
		{
			ComValues.u16_watchdog_throttle -- ;
    1850:	e2 e1       	ldi	r30, 0x12	; 18
    1852:	f1 e0       	ldi	r31, 0x01	; 1
    1854:	84 8d       	ldd	r24, Z+28	; 0x1c
    1856:	95 8d       	ldd	r25, Z+29	; 0x1d
    1858:	01 97       	sbiw	r24, 0x01	; 1
    185a:	95 8f       	std	Z+29, r25	; 0x1d
    185c:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    185e:	e2 e1       	ldi	r30, 0x12	; 18
    1860:	f1 e0       	ldi	r31, 0x01	; 1
    1862:	02 85       	ldd	r16, Z+10	; 0x0a
    1864:	13 85       	ldd	r17, Z+11	; 0x0b
    1866:	24 85       	ldd	r18, Z+12	; 0x0c
    1868:	35 85       	ldd	r19, Z+13	; 0x0d
    186a:	46 81       	ldd	r20, Z+6	; 0x06
    186c:	57 81       	ldd	r21, Z+7	; 0x07
    186e:	60 85       	ldd	r22, Z+8	; 0x08
    1870:	71 85       	ldd	r23, Z+9	; 0x09
    1872:	0f 2e       	mov	r0, r31
    1874:	f9 e2       	ldi	r31, 0x29	; 41
    1876:	ef 2e       	mov	r14, r31
    1878:	f0 2d       	mov	r31, r0
    187a:	80 e2       	ldi	r24, 0x20	; 32
    187c:	91 e0       	ldi	r25, 0x01	; 1
    187e:	e6 d1       	rcall	.+972    	; 0x1c4c <handle_joulemeter>
		systic_counter_fast = 0;
    1880:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <systic_counter_fast>
    1884:	03 c0       	rjmp	.+6      	; 0x188c <__vector_16+0xf2>
	
	} else {
		systic_counter_fast ++;
    1886:	8f 5f       	subi	r24, 0xFF	; 255
    1888:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    188c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <systic_counter_slow>
    1890:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <systic_counter_slow+0x1>
    1894:	84 36       	cpi	r24, 0x64	; 100
    1896:	91 05       	cpc	r25, r1
    1898:	01 f5       	brne	.+64     	; 0x18da <__vector_16+0x140>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    189a:	8d b7       	in	r24, 0x3d	; 61
    189c:	9e b7       	in	r25, 0x3e	; 62
    189e:	cd 97       	sbiw	r24, 0x3d	; 61
    18a0:	0f b6       	in	r0, 0x3f	; 63
    18a2:	f8 94       	cli
    18a4:	9e bf       	out	0x3e, r25	; 62
    18a6:	0f be       	out	0x3f, r0	; 63
    18a8:	8d bf       	out	0x3d, r24	; 61
    18aa:	ad b7       	in	r26, 0x3d	; 61
    18ac:	be b7       	in	r27, 0x3e	; 62
    18ae:	11 96       	adiw	r26, 0x01	; 1
    18b0:	8d e3       	ldi	r24, 0x3D	; 61
    18b2:	e2 e1       	ldi	r30, 0x12	; 18
    18b4:	f1 e0       	ldi	r31, 0x01	; 1
    18b6:	01 90       	ld	r0, Z+
    18b8:	0d 92       	st	X+, r0
    18ba:	8a 95       	dec	r24
    18bc:	e1 f7       	brne	.-8      	; 0x18b6 <__vector_16+0x11c>
    18be:	0a db       	rcall	.-2540   	; 0xed4 <manage_LEDs>
		systic_counter_slow = 0;
    18c0:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <systic_counter_slow+0x1>
    18c4:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <systic_counter_slow>
    18c8:	8d b7       	in	r24, 0x3d	; 61
    18ca:	9e b7       	in	r25, 0x3e	; 62
    18cc:	cd 96       	adiw	r24, 0x3d	; 61
    18ce:	0f b6       	in	r0, 0x3f	; 63
    18d0:	f8 94       	cli
    18d2:	9e bf       	out	0x3e, r25	; 62
    18d4:	0f be       	out	0x3f, r0	; 63
    18d6:	8d bf       	out	0x3d, r24	; 61
    18d8:	05 c0       	rjmp	.+10     	; 0x18e4 <__vector_16+0x14a>
		} else {
		systic_counter_slow ++;
    18da:	01 96       	adiw	r24, 0x01	; 1
    18dc:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <systic_counter_slow+0x1>
    18e0:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <systic_counter_slow>
	}
}
    18e4:	ff 91       	pop	r31
    18e6:	ef 91       	pop	r30
    18e8:	bf 91       	pop	r27
    18ea:	af 91       	pop	r26
    18ec:	9f 91       	pop	r25
    18ee:	8f 91       	pop	r24
    18f0:	7f 91       	pop	r23
    18f2:	6f 91       	pop	r22
    18f4:	5f 91       	pop	r21
    18f6:	4f 91       	pop	r20
    18f8:	3f 91       	pop	r19
    18fa:	2f 91       	pop	r18
    18fc:	1f 91       	pop	r17
    18fe:	0f 91       	pop	r16
    1900:	ef 90       	pop	r14
    1902:	0f 90       	pop	r0
    1904:	0b be       	out	0x3b, r0	; 59
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63
    190a:	0f 90       	pop	r0
    190c:	1f 90       	pop	r1
    190e:	18 95       	reti

00001910 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    1910:	1f 92       	push	r1
    1912:	0f 92       	push	r0
    1914:	0f b6       	in	r0, 0x3f	; 63
    1916:	0f 92       	push	r0
    1918:	11 24       	eor	r1, r1
    191a:	0b b6       	in	r0, 0x3b	; 59
    191c:	0f 92       	push	r0
    191e:	2f 93       	push	r18
    1920:	3f 93       	push	r19
    1922:	4f 93       	push	r20
    1924:	5f 93       	push	r21
    1926:	6f 93       	push	r22
    1928:	7f 93       	push	r23
    192a:	8f 93       	push	r24
    192c:	9f 93       	push	r25
    192e:	af 93       	push	r26
    1930:	bf 93       	push	r27
    1932:	ef 93       	push	r30
    1934:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    1936:	80 91 fa 01 	lds	r24, 0x01FA	; 0x8001fa <u16_speed_count>
    193a:	90 91 fb 01 	lds	r25, 0x01FB	; 0x8001fb <u16_speed_count+0x1>
    193e:	80 3d       	cpi	r24, 0xD0	; 208
    1940:	97 40       	sbci	r25, 0x07	; 7
    1942:	50 f4       	brcc	.+20     	; 0x1958 <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    1944:	80 91 fa 01 	lds	r24, 0x01FA	; 0x8001fa <u16_speed_count>
    1948:	90 91 fb 01 	lds	r25, 0x01FB	; 0x8001fb <u16_speed_count+0x1>
    194c:	01 96       	adiw	r24, 0x01	; 1
    194e:	90 93 fb 01 	sts	0x01FB, r25	; 0x8001fb <u16_speed_count+0x1>
    1952:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <u16_speed_count>
    1956:	08 c0       	rjmp	.+16     	; 0x1968 <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    1958:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    195c:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    1960:	10 92 fb 01 	sts	0x01FB, r1	; 0x8001fb <u16_speed_count+0x1>
    1964:	10 92 fa 01 	sts	0x01FA, r1	; 0x8001fa <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    1968:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    196c:	87 30       	cpi	r24, 0x07	; 7
    196e:	41 f4       	brne	.+16     	; 0x1980 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    1970:	84 e1       	ldi	r24, 0x14	; 20
    1972:	91 e0       	ldi	r25, 0x01	; 1
    1974:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <SPI_handler_7>
		u8_SPI_count = 0 ;
    1978:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    197c:	80 e0       	ldi	r24, 0x00	; 0
    197e:	13 c0       	rjmp	.+38     	; 0x19a6 <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1980:	86 30       	cpi	r24, 0x06	; 6
    1982:	49 f4       	brne	.+18     	; 0x1996 <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1984:	8d e3       	ldi	r24, 0x3D	; 61
    1986:	91 e0       	ldi	r25, 0x01	; 1
    1988:	0e 94 a5 03 	call	0x74a	; 0x74a <SPI_handler_6>
		u8_SPI_count ++ ;
    198c:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    1990:	8f 5f       	subi	r24, 0xFF	; 255
    1992:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1996:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    199a:	85 30       	cpi	r24, 0x05	; 5
    199c:	21 f4       	brne	.+8      	; 0x19a6 <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    199e:	86 e0       	ldi	r24, 0x06	; 6
    19a0:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
    19a4:	13 c0       	rjmp	.+38     	; 0x19cc <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    19a6:	84 30       	cpi	r24, 0x04	; 4
    19a8:	49 f4       	brne	.+18     	; 0x19bc <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    19aa:	84 e2       	ldi	r24, 0x24	; 36
    19ac:	91 e0       	ldi	r25, 0x01	; 1
    19ae:	0e 94 84 03 	call	0x708	; 0x708 <SPI_handler_4>
		u8_SPI_count ++ ;
    19b2:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    19b6:	8f 5f       	subi	r24, 0xFF	; 255
    19b8:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    19bc:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    19c0:	83 30       	cpi	r24, 0x03	; 3
    19c2:	21 f4       	brne	.+8      	; 0x19cc <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    19c4:	84 e0       	ldi	r24, 0x04	; 4
    19c6:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
    19ca:	13 c0       	rjmp	.+38     	; 0x19f2 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    19cc:	82 30       	cpi	r24, 0x02	; 2
    19ce:	21 f4       	brne	.+8      	; 0x19d8 <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    19d0:	83 e0       	ldi	r24, 0x03	; 3
    19d2:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
    19d6:	1a c0       	rjmp	.+52     	; 0x1a0c <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    19d8:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    19dc:	81 30       	cpi	r24, 0x01	; 1
    19de:	49 f4       	brne	.+18     	; 0x19f2 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    19e0:	88 e1       	ldi	r24, 0x18	; 24
    19e2:	91 e0       	ldi	r25, 0x01	; 1
    19e4:	0e 94 62 03 	call	0x6c4	; 0x6c4 <SPI_handler_1>
		u8_SPI_count ++ ;
    19e8:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    19ec:	8f 5f       	subi	r24, 0xFF	; 255
    19ee:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    19f2:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    19f6:	81 11       	cpse	r24, r1
    19f8:	09 c0       	rjmp	.+18     	; 0x1a0c <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    19fa:	8c e1       	ldi	r24, 0x1C	; 28
    19fc:	91 e0       	ldi	r25, 0x01	; 1
    19fe:	0e 94 25 03 	call	0x64a	; 0x64a <SPI_handler_0>
		u8_SPI_count ++ ;
    1a02:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <u8_SPI_count>
    1a06:	8f 5f       	subi	r24, 0xFF	; 255
    1a08:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <u8_SPI_count>
	}
}
    1a0c:	ff 91       	pop	r31
    1a0e:	ef 91       	pop	r30
    1a10:	bf 91       	pop	r27
    1a12:	af 91       	pop	r26
    1a14:	9f 91       	pop	r25
    1a16:	8f 91       	pop	r24
    1a18:	7f 91       	pop	r23
    1a1a:	6f 91       	pop	r22
    1a1c:	5f 91       	pop	r21
    1a1e:	4f 91       	pop	r20
    1a20:	3f 91       	pop	r19
    1a22:	2f 91       	pop	r18
    1a24:	0f 90       	pop	r0
    1a26:	0b be       	out	0x3b, r0	; 59
    1a28:	0f 90       	pop	r0
    1a2a:	0f be       	out	0x3f, r0	; 63
    1a2c:	0f 90       	pop	r0
    1a2e:	1f 90       	pop	r1
    1a30:	18 95       	reti

00001a32 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1a32:	1f 92       	push	r1
    1a34:	0f 92       	push	r0
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	0f 92       	push	r0
    1a3a:	11 24       	eor	r1, r1
    1a3c:	0b b6       	in	r0, 0x3b	; 59
    1a3e:	0f 92       	push	r0
    1a40:	2f 93       	push	r18
    1a42:	3f 93       	push	r19
    1a44:	4f 93       	push	r20
    1a46:	5f 93       	push	r21
    1a48:	6f 93       	push	r22
    1a4a:	7f 93       	push	r23
    1a4c:	8f 93       	push	r24
    1a4e:	9f 93       	push	r25
    1a50:	af 93       	push	r26
    1a52:	bf 93       	push	r27
    1a54:	ef 93       	push	r30
    1a56:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1a58:	6a ef       	ldi	r22, 0xFA	; 250
    1a5a:	71 e0       	ldi	r23, 0x01	; 1
    1a5c:	85 e2       	ldi	r24, 0x25	; 37
    1a5e:	91 e0       	ldi	r25, 0x01	; 1
    1a60:	9d da       	rcall	.-2758   	; 0xf9c <handle_speed_sensor>
}
    1a62:	ff 91       	pop	r31
    1a64:	ef 91       	pop	r30
    1a66:	bf 91       	pop	r27
    1a68:	af 91       	pop	r26
    1a6a:	9f 91       	pop	r25
    1a6c:	8f 91       	pop	r24
    1a6e:	7f 91       	pop	r23
    1a70:	6f 91       	pop	r22
    1a72:	5f 91       	pop	r21
    1a74:	4f 91       	pop	r20
    1a76:	3f 91       	pop	r19
    1a78:	2f 91       	pop	r18
    1a7a:	0f 90       	pop	r0
    1a7c:	0b be       	out	0x3b, r0	; 59
    1a7e:	0f 90       	pop	r0
    1a80:	0f be       	out	0x3f, r0	; 63
    1a82:	0f 90       	pop	r0
    1a84:	1f 90       	pop	r1
    1a86:	18 95       	reti

00001a88 <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1a88:	08 95       	ret

00001a8a <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1a8a:	7a 99       	sbic	0x0f, 2	; 15
    1a8c:	03 c0       	rjmp	.+6      	; 0x1a94 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1a8e:	fc 01       	movw	r30, r24
    1a90:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1a92:	10 8e       	std	Z+24, r1	; 0x18
    1a94:	08 95       	ret

00001a96 <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1a96:	8f 92       	push	r8
    1a98:	9f 92       	push	r9
    1a9a:	af 92       	push	r10
    1a9c:	bf 92       	push	r11
    1a9e:	cf 92       	push	r12
    1aa0:	df 92       	push	r13
    1aa2:	ef 92       	push	r14
    1aa4:	ff 92       	push	r15
    1aa6:	0f 93       	push	r16
    1aa8:	1f 93       	push	r17
    1aaa:	cf 93       	push	r28
    1aac:	df 93       	push	r29
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <handle_current_sensor+0x1a>
    1ab0:	00 d0       	rcall	.+0      	; 0x1ab2 <handle_current_sensor+0x1c>
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
    1ab6:	8c 01       	movw	r16, r24
    1ab8:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	e6 d4       	rcall	.+2508   	; 0x248c <__floatunsisf>
    1ac0:	20 e0       	ldi	r18, 0x00	; 0
    1ac2:	30 e0       	ldi	r19, 0x00	; 0
    1ac4:	40 ea       	ldi	r20, 0xA0	; 160
    1ac6:	50 e4       	ldi	r21, 0x40	; 64
    1ac8:	97 d5       	rcall	.+2862   	; 0x25f8 <__mulsf3>
    1aca:	20 e0       	ldi	r18, 0x00	; 0
    1acc:	30 e0       	ldi	r19, 0x00	; 0
    1ace:	40 e8       	ldi	r20, 0x80	; 128
    1ad0:	59 e3       	ldi	r21, 0x39	; 57
    1ad2:	92 d5       	rcall	.+2852   	; 0x25f8 <__mulsf3>
    1ad4:	20 e0       	ldi	r18, 0x00	; 0
    1ad6:	30 e0       	ldi	r19, 0x00	; 0
    1ad8:	40 e0       	ldi	r20, 0x00	; 0
    1ada:	51 e4       	ldi	r21, 0x41	; 65
    1adc:	8d d5       	rcall	.+2842   	; 0x25f8 <__mulsf3>
    1ade:	20 e0       	ldi	r18, 0x00	; 0
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	40 ea       	ldi	r20, 0xA0	; 160
    1ae4:	51 e4       	ldi	r21, 0x41	; 65
    1ae6:	d0 d3       	rcall	.+1952   	; 0x2288 <__subsf3>
    1ae8:	69 83       	std	Y+1, r22	; 0x01
    1aea:	7a 83       	std	Y+2, r23	; 0x02
    1aec:	8b 83       	std	Y+3, r24	; 0x03
    1aee:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1af0:	ff 20       	and	r15, r15
    1af2:	49 f0       	breq	.+18     	; 0x1b06 <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	9a 81       	ldd	r25, Y+2	; 0x02
    1af8:	ab 81       	ldd	r26, Y+3	; 0x03
    1afa:	bc 81       	ldd	r27, Y+4	; 0x04
    1afc:	89 83       	std	Y+1, r24	; 0x01
    1afe:	9a 83       	std	Y+2, r25	; 0x02
    1b00:	ab 83       	std	Y+3, r26	; 0x03
    1b02:	bc 83       	std	Y+4, r27	; 0x04
    1b04:	08 c0       	rjmp	.+16     	; 0x1b16 <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b06:	89 81       	ldd	r24, Y+1	; 0x01
    1b08:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0a:	ab 81       	ldd	r26, Y+3	; 0x03
    1b0c:	bc 81       	ldd	r27, Y+4	; 0x04
    1b0e:	89 83       	std	Y+1, r24	; 0x01
    1b10:	9a 83       	std	Y+2, r25	; 0x02
    1b12:	ab 83       	std	Y+3, r26	; 0x03
    1b14:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1b16:	f8 01       	movw	r30, r16
    1b18:	60 81       	ld	r22, Z
    1b1a:	71 81       	ldd	r23, Z+1	; 0x01
    1b1c:	82 81       	ldd	r24, Z+2	; 0x02
    1b1e:	93 81       	ldd	r25, Z+3	; 0x03
    1b20:	89 80       	ldd	r8, Y+1	; 0x01
    1b22:	9a 80       	ldd	r9, Y+2	; 0x02
    1b24:	ab 80       	ldd	r10, Y+3	; 0x03
    1b26:	bc 80       	ldd	r11, Y+4	; 0x04
    1b28:	26 e6       	ldi	r18, 0x66	; 102
    1b2a:	36 e6       	ldi	r19, 0x66	; 102
    1b2c:	46 e6       	ldi	r20, 0x66	; 102
    1b2e:	5f e3       	ldi	r21, 0x3F	; 63
    1b30:	63 d5       	rcall	.+2758   	; 0x25f8 <__mulsf3>
    1b32:	6b 01       	movw	r12, r22
    1b34:	7c 01       	movw	r14, r24
    1b36:	2d ec       	ldi	r18, 0xCD	; 205
    1b38:	3c ec       	ldi	r19, 0xCC	; 204
    1b3a:	4c ec       	ldi	r20, 0xCC	; 204
    1b3c:	5d e3       	ldi	r21, 0x3D	; 61
    1b3e:	c5 01       	movw	r24, r10
    1b40:	b4 01       	movw	r22, r8
    1b42:	5a d5       	rcall	.+2740   	; 0x25f8 <__mulsf3>
    1b44:	9b 01       	movw	r18, r22
    1b46:	ac 01       	movw	r20, r24
    1b48:	c7 01       	movw	r24, r14
    1b4a:	b6 01       	movw	r22, r12
    1b4c:	9e d3       	rcall	.+1852   	; 0x228a <__addsf3>
    1b4e:	f8 01       	movw	r30, r16
    1b50:	60 83       	st	Z, r22
    1b52:	71 83       	std	Z+1, r23	; 0x01
    1b54:	82 83       	std	Z+2, r24	; 0x02
    1b56:	93 83       	std	Z+3, r25	; 0x03
}
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	df 91       	pop	r29
    1b62:	cf 91       	pop	r28
    1b64:	1f 91       	pop	r17
    1b66:	0f 91       	pop	r16
    1b68:	ff 90       	pop	r15
    1b6a:	ef 90       	pop	r14
    1b6c:	df 90       	pop	r13
    1b6e:	cf 90       	pop	r12
    1b70:	bf 90       	pop	r11
    1b72:	af 90       	pop	r10
    1b74:	9f 90       	pop	r9
    1b76:	8f 90       	pop	r8
    1b78:	08 95       	ret

00001b7a <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1b7a:	cf 92       	push	r12
    1b7c:	df 92       	push	r13
    1b7e:	ef 92       	push	r14
    1b80:	ff 92       	push	r15
    1b82:	cf 93       	push	r28
    1b84:	df 93       	push	r29
    1b86:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1b88:	80 e0       	ldi	r24, 0x00	; 0
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	7f d4       	rcall	.+2302   	; 0x248c <__floatunsisf>
    1b8e:	20 e0       	ldi	r18, 0x00	; 0
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	40 ea       	ldi	r20, 0xA0	; 160
    1b94:	50 e4       	ldi	r21, 0x40	; 64
    1b96:	30 d5       	rcall	.+2656   	; 0x25f8 <__mulsf3>
    1b98:	20 e0       	ldi	r18, 0x00	; 0
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	40 e8       	ldi	r20, 0x80	; 128
    1b9e:	59 e3       	ldi	r21, 0x39	; 57
    1ba0:	2b d5       	rcall	.+2646   	; 0x25f8 <__mulsf3>
    1ba2:	6b 01       	movw	r12, r22
    1ba4:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1ba6:	2d ec       	ldi	r18, 0xCD	; 205
    1ba8:	3c ec       	ldi	r19, 0xCC	; 204
    1baa:	4c e6       	ldi	r20, 0x6C	; 108
    1bac:	50 e4       	ldi	r21, 0x40	; 64
    1bae:	d1 d3       	rcall	.+1954   	; 0x2352 <__cmpsf2>
    1bb0:	18 16       	cp	r1, r24
    1bb2:	74 f0       	brlt	.+28     	; 0x1bd0 <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1bb4:	20 e0       	ldi	r18, 0x00	; 0
    1bb6:	30 e0       	ldi	r19, 0x00	; 0
    1bb8:	40 ea       	ldi	r20, 0xA0	; 160
    1bba:	51 e4       	ldi	r21, 0x41	; 65
    1bbc:	c7 01       	movw	r24, r14
    1bbe:	b6 01       	movw	r22, r12
    1bc0:	1b d5       	rcall	.+2614   	; 0x25f8 <__mulsf3>
    1bc2:	20 e0       	ldi	r18, 0x00	; 0
    1bc4:	30 e0       	ldi	r19, 0x00	; 0
    1bc6:	40 eb       	ldi	r20, 0xB0	; 176
    1bc8:	51 e4       	ldi	r21, 0x41	; 65
    1bca:	5e d3       	rcall	.+1724   	; 0x2288 <__subsf3>
    1bcc:	33 d4       	rcall	.+2150   	; 0x2434 <__fixunssfsi>
    1bce:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1bd0:	26 e6       	ldi	r18, 0x66	; 102
    1bd2:	36 e6       	ldi	r19, 0x66	; 102
    1bd4:	46 e9       	ldi	r20, 0x96	; 150
    1bd6:	50 e4       	ldi	r21, 0x40	; 64
    1bd8:	c7 01       	movw	r24, r14
    1bda:	b6 01       	movw	r22, r12
    1bdc:	ba d3       	rcall	.+1908   	; 0x2352 <__cmpsf2>
    1bde:	18 16       	cp	r1, r24
    1be0:	bc f0       	brlt	.+46     	; 0x1c10 <handle_temp_sensor+0x96>
    1be2:	2d ec       	ldi	r18, 0xCD	; 205
    1be4:	3c ec       	ldi	r19, 0xCC	; 204
    1be6:	4c e6       	ldi	r20, 0x6C	; 108
    1be8:	50 e4       	ldi	r21, 0x40	; 64
    1bea:	c7 01       	movw	r24, r14
    1bec:	b6 01       	movw	r22, r12
    1bee:	00 d5       	rcall	.+2560   	; 0x25f0 <__gesf2>
    1bf0:	18 16       	cp	r1, r24
    1bf2:	74 f4       	brge	.+28     	; 0x1c10 <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1bf4:	20 e0       	ldi	r18, 0x00	; 0
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	4e e5       	ldi	r20, 0x5E	; 94
    1bfa:	52 e4       	ldi	r21, 0x42	; 66
    1bfc:	c7 01       	movw	r24, r14
    1bfe:	b6 01       	movw	r22, r12
    1c00:	fb d4       	rcall	.+2550   	; 0x25f8 <__mulsf3>
    1c02:	20 e0       	ldi	r18, 0x00	; 0
    1c04:	30 e8       	ldi	r19, 0x80	; 128
    1c06:	4b e1       	ldi	r20, 0x1B	; 27
    1c08:	53 e4       	ldi	r21, 0x43	; 67
    1c0a:	3e d3       	rcall	.+1660   	; 0x2288 <__subsf3>
    1c0c:	13 d4       	rcall	.+2086   	; 0x2434 <__fixunssfsi>
    1c0e:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c10:	26 e6       	ldi	r18, 0x66	; 102
    1c12:	36 e6       	ldi	r19, 0x66	; 102
    1c14:	46 e9       	ldi	r20, 0x96	; 150
    1c16:	50 e4       	ldi	r21, 0x40	; 64
    1c18:	c7 01       	movw	r24, r14
    1c1a:	b6 01       	movw	r22, r12
    1c1c:	e9 d4       	rcall	.+2514   	; 0x25f0 <__gesf2>
    1c1e:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1c20:	74 f4       	brge	.+28     	; 0x1c3e <handle_temp_sensor+0xc4>
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	30 e0       	ldi	r19, 0x00	; 0
    1c26:	48 e4       	ldi	r20, 0x48	; 72
    1c28:	53 e4       	ldi	r21, 0x43	; 67
    1c2a:	c7 01       	movw	r24, r14
    1c2c:	b6 01       	movw	r22, r12
    1c2e:	e4 d4       	rcall	.+2504   	; 0x25f8 <__mulsf3>
    1c30:	20 e0       	ldi	r18, 0x00	; 0
    1c32:	30 e0       	ldi	r19, 0x00	; 0
    1c34:	42 e5       	ldi	r20, 0x52	; 82
    1c36:	54 e4       	ldi	r21, 0x44	; 68
    1c38:	27 d3       	rcall	.+1614   	; 0x2288 <__subsf3>
    1c3a:	fc d3       	rcall	.+2040   	; 0x2434 <__fixunssfsi>
    1c3c:	68 83       	st	Y, r22
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
	}
}
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	08 95       	ret

00001c4c <handle_joulemeter>:
    1c4c:	4f 92       	push	r4
    1c4e:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1c50:	6f 92       	push	r6
    1c52:	7f 92       	push	r7
    1c54:	8f 92       	push	r8
    1c56:	9f 92       	push	r9
    1c58:	af 92       	push	r10
    1c5a:	bf 92       	push	r11
    1c5c:	cf 92       	push	r12
    1c5e:	df 92       	push	r13
    1c60:	ef 92       	push	r14
    1c62:	0f 93       	push	r16
    1c64:	1f 93       	push	r17
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	cd b7       	in	r28, 0x3d	; 61
    1c6c:	de b7       	in	r29, 0x3e	; 62
    1c6e:	28 97       	sbiw	r28, 0x08	; 8
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	de bf       	out	0x3e, r29	; 62
    1c76:	0f be       	out	0x3f, r0	; 63
    1c78:	cd bf       	out	0x3d, r28	; 61
    1c7a:	6c 01       	movw	r12, r24
    1c7c:	49 83       	std	Y+1, r20	; 0x01
    1c7e:	5a 83       	std	Y+2, r21	; 0x02
    1c80:	6b 83       	std	Y+3, r22	; 0x03
    1c82:	7c 83       	std	Y+4, r23	; 0x04
    1c84:	0d 83       	std	Y+5, r16	; 0x05
    1c86:	1e 83       	std	Y+6, r17	; 0x06
    1c88:	2f 83       	std	Y+7, r18	; 0x07
    1c8a:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1c8c:	6d 81       	ldd	r22, Y+5	; 0x05
    1c8e:	7e 81       	ldd	r23, Y+6	; 0x06
    1c90:	8f 81       	ldd	r24, Y+7	; 0x07
    1c92:	98 85       	ldd	r25, Y+8	; 0x08
    1c94:	29 81       	ldd	r18, Y+1	; 0x01
    1c96:	3a 81       	ldd	r19, Y+2	; 0x02
    1c98:	4b 81       	ldd	r20, Y+3	; 0x03
    1c9a:	5c 81       	ldd	r21, Y+4	; 0x04
    1c9c:	f6 01       	movw	r30, r12
    1c9e:	80 80       	ld	r8, Z
    1ca0:	91 80       	ldd	r9, Z+1	; 0x01
    1ca2:	a2 80       	ldd	r10, Z+2	; 0x02
    1ca4:	b3 80       	ldd	r11, Z+3	; 0x03
    1ca6:	a8 d4       	rcall	.+2384   	; 0x25f8 <__mulsf3>
    1ca8:	2b 01       	movw	r4, r22
    1caa:	3c 01       	movw	r6, r24
    1cac:	6e 2d       	mov	r22, r14
    1cae:	70 e0       	ldi	r23, 0x00	; 0
    1cb0:	80 e0       	ldi	r24, 0x00	; 0
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	eb d3       	rcall	.+2006   	; 0x248c <__floatunsisf>
    1cb6:	9b 01       	movw	r18, r22
    1cb8:	ac 01       	movw	r20, r24
    1cba:	c3 01       	movw	r24, r6
    1cbc:	b2 01       	movw	r22, r4
    1cbe:	9c d4       	rcall	.+2360   	; 0x25f8 <__mulsf3>
    1cc0:	20 e0       	ldi	r18, 0x00	; 0
    1cc2:	30 e0       	ldi	r19, 0x00	; 0
    1cc4:	4a e7       	ldi	r20, 0x7A	; 122
    1cc6:	54 e4       	ldi	r21, 0x44	; 68
    1cc8:	48 d3       	rcall	.+1680   	; 0x235a <__divsf3>
    1cca:	a5 01       	movw	r20, r10
    1ccc:	94 01       	movw	r18, r8
    1cce:	dd d2       	rcall	.+1466   	; 0x228a <__addsf3>
    1cd0:	f6 01       	movw	r30, r12
    1cd2:	60 83       	st	Z, r22
    1cd4:	71 83       	std	Z+1, r23	; 0x01
    1cd6:	82 83       	std	Z+2, r24	; 0x02
    1cd8:	93 83       	std	Z+3, r25	; 0x03
}
    1cda:	28 96       	adiw	r28, 0x08	; 8
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	f8 94       	cli
    1ce0:	de bf       	out	0x3e, r29	; 62
    1ce2:	0f be       	out	0x3f, r0	; 63
    1ce4:	cd bf       	out	0x3d, r28	; 61
    1ce6:	df 91       	pop	r29
    1ce8:	cf 91       	pop	r28
    1cea:	1f 91       	pop	r17
    1cec:	0f 91       	pop	r16
    1cee:	ef 90       	pop	r14
    1cf0:	df 90       	pop	r13
    1cf2:	cf 90       	pop	r12
    1cf4:	bf 90       	pop	r11
    1cf6:	af 90       	pop	r10
    1cf8:	9f 90       	pop	r9
    1cfa:	8f 90       	pop	r8
    1cfc:	7f 90       	pop	r7
    1cfe:	6f 90       	pop	r6
    1d00:	5f 90       	pop	r5
    1d02:	4f 90       	pop	r4
    1d04:	08 95       	ret

00001d06 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	88 30       	cpi	r24, 0x08	; 8
    1d0a:	91 05       	cpc	r25, r1
    1d0c:	88 f5       	brcc	.+98     	; 0x1d70 <Set_ADC_Channel_ext+0x6a>
    1d0e:	fc 01       	movw	r30, r24
    1d10:	e6 5b       	subi	r30, 0xB6	; 182
    1d12:	ff 4f       	sbci	r31, 0xFF	; 255
    1d14:	d4 c4       	rjmp	.+2472   	; 0x26be <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d16:	86 e0       	ldi	r24, 0x06	; 6
    1d18:	fb 01       	movw	r30, r22
    1d1a:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1d1c:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d1e:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d20:	86 e0       	ldi	r24, 0x06	; 6
    1d22:	fb 01       	movw	r30, r22
    1d24:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1d26:	80 e4       	ldi	r24, 0x40	; 64
    1d28:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d2a:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d2c:	86 e0       	ldi	r24, 0x06	; 6
    1d2e:	fb 01       	movw	r30, r22
    1d30:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1d32:	80 e8       	ldi	r24, 0x80	; 128
    1d34:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d36:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1d38:	86 e0       	ldi	r24, 0x06	; 6
    1d3a:	fb 01       	movw	r30, r22
    1d3c:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1d3e:	80 ec       	ldi	r24, 0xC0	; 192
    1d40:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d42:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d44:	87 e0       	ldi	r24, 0x07	; 7
    1d46:	fb 01       	movw	r30, r22
    1d48:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1d4a:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d4c:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d4e:	87 e0       	ldi	r24, 0x07	; 7
    1d50:	fb 01       	movw	r30, r22
    1d52:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1d54:	80 e4       	ldi	r24, 0x40	; 64
    1d56:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d58:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d5a:	87 e0       	ldi	r24, 0x07	; 7
    1d5c:	fb 01       	movw	r30, r22
    1d5e:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1d60:	80 e8       	ldi	r24, 0x80	; 128
    1d62:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d64:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1d66:	87 e0       	ldi	r24, 0x07	; 7
    1d68:	fb 01       	movw	r30, r22
    1d6a:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1d6c:	80 ec       	ldi	r24, 0xC0	; 192
    1d6e:	81 83       	std	Z+1, r24	; 0x01
    1d70:	08 95       	ret

00001d72 <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1d72:	1f 92       	push	r1
    1d74:	0f 92       	push	r0
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	0f 92       	push	r0
    1d7a:	11 24       	eor	r1, r1
    1d7c:	0b b6       	in	r0, 0x3b	; 59
    1d7e:	0f 92       	push	r0
    1d80:	2f 93       	push	r18
    1d82:	3f 93       	push	r19
    1d84:	4f 93       	push	r20
    1d86:	5f 93       	push	r21
    1d88:	6f 93       	push	r22
    1d8a:	8f 93       	push	r24
    1d8c:	9f 93       	push	r25
    1d8e:	af 93       	push	r26
    1d90:	bf 93       	push	r27
    1d92:	ef 93       	push	r30
    1d94:	ff 93       	push	r31
    1d96:	cf 93       	push	r28
    1d98:	df 93       	push	r29
    1d9a:	1f 92       	push	r1
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1da0:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1da4:	80 ff       	sbrs	r24, 0
    1da6:	47 c0       	rjmp	.+142    	; 0x1e36 <__vector_18+0xc4>
    1da8:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1dac:	90 ff       	sbrs	r25, 0
    1dae:	43 c0       	rjmp	.+134    	; 0x1e36 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1db0:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1db4:	ee ee       	ldi	r30, 0xEE	; 238
    1db6:	f0 e0       	ldi	r31, 0x00	; 0
    1db8:	80 81       	ld	r24, Z
    1dba:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1dbc:	80 81       	ld	r24, Z
    1dbe:	8f 7b       	andi	r24, 0xBF	; 191
    1dc0:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1dc2:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <tx_off>
    1dc6:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <tx_on>
    1dca:	98 17       	cp	r25, r24
    1dcc:	89 f1       	breq	.+98     	; 0x1e30 <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1dce:	8f 70       	andi	r24, 0x0F	; 15
    1dd0:	2b e0       	ldi	r18, 0x0B	; 11
    1dd2:	82 9f       	mul	r24, r18
    1dd4:	c0 01       	movw	r24, r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	fc 01       	movw	r30, r24
    1dda:	e7 54       	subi	r30, 0x47	; 71
    1ddc:	fd 4f       	sbci	r31, 0xFD	; 253
    1dde:	20 81       	ld	r18, Z
    1de0:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1de4:	20 81       	ld	r18, Z
    1de6:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1dea:	21 81       	ldd	r18, Z+1	; 0x01
    1dec:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1df0:	23 81       	ldd	r18, Z+3	; 0x03
    1df2:	aa ef       	ldi	r26, 0xFA	; 250
    1df4:	b0 e0       	ldi	r27, 0x00	; 0
    1df6:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1df8:	24 81       	ldd	r18, Z+4	; 0x04
    1dfa:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1dfc:	25 81       	ldd	r18, Z+5	; 0x05
    1dfe:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e00:	26 81       	ldd	r18, Z+6	; 0x06
    1e02:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e04:	27 81       	ldd	r18, Z+7	; 0x07
    1e06:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e08:	20 85       	ldd	r18, Z+8	; 0x08
    1e0a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e0c:	21 85       	ldd	r18, Z+9	; 0x09
    1e0e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e10:	22 85       	ldd	r18, Z+10	; 0x0a
    1e12:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1e14:	fc 01       	movw	r30, r24
    1e16:	e5 54       	subi	r30, 0x45	; 69
    1e18:	fd 4f       	sbci	r31, 0xFD	; 253
    1e1a:	80 81       	ld	r24, Z
    1e1c:	8f 70       	andi	r24, 0x0F	; 15
    1e1e:	80 64       	ori	r24, 0x40	; 64
    1e20:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1e24:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <tx_off>
    1e28:	8f 5f       	subi	r24, 0xFF	; 255
    1e2a:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <tx_off>
    1e2e:	7d c0       	rjmp	.+250    	; 0x1f2a <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1e30:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <tx_busy>
    1e34:	7a c0       	rjmp	.+244    	; 0x1f2a <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1e36:	81 ff       	sbrs	r24, 1
    1e38:	78 c0       	rjmp	.+240    	; 0x1f2a <__vector_18+0x1b8>
    1e3a:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e3e:	81 ff       	sbrs	r24, 1
    1e40:	74 c0       	rjmp	.+232    	; 0x1f2a <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1e42:	80 e1       	ldi	r24, 0x10	; 16
    1e44:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1e48:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <rx_on>
    1e4c:	28 2f       	mov	r18, r24
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <rx_off>
    1e54:	29 1b       	sub	r18, r25
    1e56:	31 09       	sbc	r19, r1
    1e58:	2f 77       	andi	r18, 0x7F	; 127
    1e5a:	33 27       	eor	r19, r19
    1e5c:	20 31       	cpi	r18, 0x10	; 16
    1e5e:	31 05       	cpc	r19, r1
    1e60:	0c f0       	brlt	.+2      	; 0x1e64 <__vector_18+0xf2>
    1e62:	58 c0       	rjmp	.+176    	; 0x1f14 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1e64:	e8 2f       	mov	r30, r24
    1e66:	ef 70       	andi	r30, 0x0F	; 15
    1e68:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1e6c:	2e 2f       	mov	r18, r30
    1e6e:	30 e0       	ldi	r19, 0x00	; 0
    1e70:	4b e0       	ldi	r20, 0x0B	; 11
    1e72:	e4 9f       	mul	r30, r20
    1e74:	f0 01       	movw	r30, r0
    1e76:	11 24       	eor	r1, r1
    1e78:	e7 5f       	subi	r30, 0xF7	; 247
    1e7a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e7c:	9f 70       	andi	r25, 0x0F	; 15
    1e7e:	42 81       	ldd	r20, Z+2	; 0x02
    1e80:	40 7f       	andi	r20, 0xF0	; 240
    1e82:	94 2b       	or	r25, r20
    1e84:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1e86:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1e8a:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1e8e:	40 7e       	andi	r20, 0xE0	; 224
    1e90:	97 70       	andi	r25, 0x07	; 7
    1e92:	94 2b       	or	r25, r20
    1e94:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1e96:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1e9a:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1e9c:	aa ef       	ldi	r26, 0xFA	; 250
    1e9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ea0:	9c 91       	ld	r25, X
    1ea2:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1ea4:	9c 91       	ld	r25, X
    1ea6:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1ea8:	9c 91       	ld	r25, X
    1eaa:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1eac:	9c 91       	ld	r25, X
    1eae:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1eb0:	9c 91       	ld	r25, X
    1eb2:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1eb4:	9c 91       	ld	r25, X
    1eb6:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1eb8:	9c 91       	ld	r25, X
    1eba:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1ebc:	9c 91       	ld	r25, X
    1ebe:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1ec0:	8f 5f       	subi	r24, 0xFF	; 255
    1ec2:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1ec6:	40 81       	ld	r20, Z
    1ec8:	42 95       	swap	r20
    1eca:	46 95       	lsr	r20
    1ecc:	47 70       	andi	r20, 0x07	; 7
    1ece:	51 81       	ldd	r21, Z+1	; 0x01
    1ed0:	65 2f       	mov	r22, r21
    1ed2:	66 0f       	add	r22, r22
    1ed4:	66 0f       	add	r22, r22
    1ed6:	66 0f       	add	r22, r22
    1ed8:	86 2f       	mov	r24, r22
    1eda:	84 2b       	or	r24, r20
    1edc:	95 2f       	mov	r25, r21
    1ede:	92 95       	swap	r25
    1ee0:	96 95       	lsr	r25
    1ee2:	97 70       	andi	r25, 0x07	; 7
    1ee4:	89 2b       	or	r24, r25
    1ee6:	b1 f4       	brne	.+44     	; 0x1f14 <__vector_18+0x1a2>
    1ee8:	8b e0       	ldi	r24, 0x0B	; 11
    1eea:	82 9f       	mul	r24, r18
    1eec:	f0 01       	movw	r30, r0
    1eee:	83 9f       	mul	r24, r19
    1ef0:	f0 0d       	add	r31, r0
    1ef2:	11 24       	eor	r1, r1
    1ef4:	e7 5f       	subi	r30, 0xF7	; 247
    1ef6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ef8:	83 81       	ldd	r24, Z+3	; 0x03
    1efa:	83 30       	cpi	r24, 0x03	; 3
    1efc:	59 f4       	brne	.+22     	; 0x1f14 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1efe:	98 e0       	ldi	r25, 0x08	; 8
    1f00:	88 e1       	ldi	r24, 0x18	; 24
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	f8 94       	cli
    1f06:	a8 95       	wdr
    1f08:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f12:	ff cf       	rjmp	.-2      	; 0x1f12 <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1f14:	ee ee       	ldi	r30, 0xEE	; 238
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	80 81       	ld	r24, Z
    1f1a:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1f1c:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1f1e:	80 81       	ld	r24, Z
    1f20:	8f 7d       	andi	r24, 0xDF	; 223
    1f22:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1f24:	80 e8       	ldi	r24, 0x80	; 128
    1f26:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1f2a:	0f 90       	pop	r0
    1f2c:	df 91       	pop	r29
    1f2e:	cf 91       	pop	r28
    1f30:	ff 91       	pop	r31
    1f32:	ef 91       	pop	r30
    1f34:	bf 91       	pop	r27
    1f36:	af 91       	pop	r26
    1f38:	9f 91       	pop	r25
    1f3a:	8f 91       	pop	r24
    1f3c:	6f 91       	pop	r22
    1f3e:	5f 91       	pop	r21
    1f40:	4f 91       	pop	r20
    1f42:	3f 91       	pop	r19
    1f44:	2f 91       	pop	r18
    1f46:	0f 90       	pop	r0
    1f48:	0b be       	out	0x3b, r0	; 59
    1f4a:	0f 90       	pop	r0
    1f4c:	0f be       	out	0x3f, r0	; 63
    1f4e:	0f 90       	pop	r0
    1f50:	1f 90       	pop	r1
    1f52:	18 95       	reti

00001f54 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1f58:	e8 ed       	ldi	r30, 0xD8	; 216
    1f5a:	f0 e0       	ldi	r31, 0x00	; 0
    1f5c:	21 e0       	ldi	r18, 0x01	; 1
    1f5e:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1f60:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1f64:	2c e0       	ldi	r18, 0x0C	; 12
    1f66:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1f6a:	27 e3       	ldi	r18, 0x37	; 55
    1f6c:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1f70:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1f74:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1f78:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1f7c:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1f80:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1f84:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    1f88:	cd ee       	ldi	r28, 0xED	; 237
    1f8a:	d0 e0       	ldi	r29, 0x00	; 0
    1f8c:	18 82       	st	Y, r1
	CANSTMOB = 0;
    1f8e:	ae ee       	ldi	r26, 0xEE	; 238
    1f90:	b0 e0       	ldi	r27, 0x00	; 0
    1f92:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    1f94:	20 e1       	ldi	r18, 0x10	; 16
    1f96:	28 83       	st	Y, r18
	CANSTMOB = 0;
    1f98:	1c 92       	st	X, r1
	CANIDM4 = 0;
    1f9a:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    1f9e:	28 2f       	mov	r18, r24
    1fa0:	22 95       	swap	r18
    1fa2:	22 0f       	add	r18, r18
    1fa4:	20 7e       	andi	r18, 0xE0	; 224
    1fa6:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    1faa:	96 95       	lsr	r25
    1fac:	87 95       	ror	r24
    1fae:	96 95       	lsr	r25
    1fb0:	87 95       	ror	r24
    1fb2:	96 95       	lsr	r25
    1fb4:	87 95       	ror	r24
    1fb6:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    1fba:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    1fbe:	86 2f       	mov	r24, r22
    1fc0:	82 95       	swap	r24
    1fc2:	88 0f       	add	r24, r24
    1fc4:	80 7e       	andi	r24, 0xE0	; 224
    1fc6:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    1fca:	76 95       	lsr	r23
    1fcc:	67 95       	ror	r22
    1fce:	76 95       	lsr	r23
    1fd0:	67 95       	ror	r22
    1fd2:	76 95       	lsr	r23
    1fd4:	67 95       	ror	r22
    1fd6:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    1fda:	80 e8       	ldi	r24, 0x80	; 128
    1fdc:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    1fe0:	83 e0       	ldi	r24, 0x03	; 3
    1fe2:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    1fe6:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    1fea:	80 eb       	ldi	r24, 0xB0	; 176
    1fec:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    1ff0:	82 e0       	ldi	r24, 0x02	; 2
    1ff2:	80 83       	st	Z, r24

	reset = 0;
    1ff4:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <reset>
}
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	08 95       	ret

00001ffe <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    2004:	40 91 05 02 	lds	r20, 0x0205	; 0x800205 <rx_off>
    2008:	20 91 04 02 	lds	r18, 0x0204	; 0x800204 <rx_on>
    200c:	24 17       	cp	r18, r20
    200e:	89 f1       	breq	.+98     	; 0x2072 <can_read_message_if_new+0x74>
    2010:	a4 2f       	mov	r26, r20
    2012:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    2014:	8b e0       	ldi	r24, 0x0B	; 11
    2016:	a8 9f       	mul	r26, r24
    2018:	b0 01       	movw	r22, r0
    201a:	11 24       	eor	r1, r1
    201c:	fb 01       	movw	r30, r22
    201e:	e7 5f       	subi	r30, 0xF7	; 247
    2020:	fd 4f       	sbci	r31, 0xFD	; 253
    2022:	20 81       	ld	r18, Z
    2024:	22 95       	swap	r18
    2026:	26 95       	lsr	r18
    2028:	27 70       	andi	r18, 0x07	; 7
    202a:	31 81       	ldd	r19, Z+1	; 0x01
    202c:	53 2f       	mov	r21, r19
    202e:	55 0f       	add	r21, r21
    2030:	55 0f       	add	r21, r21
    2032:	55 0f       	add	r21, r21
    2034:	25 2b       	or	r18, r21
    2036:	32 95       	swap	r19
    2038:	36 95       	lsr	r19
    203a:	37 70       	andi	r19, 0x07	; 7
    203c:	28 83       	st	Y, r18
    203e:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    2040:	fb 01       	movw	r30, r22
    2042:	e5 5f       	subi	r30, 0xF5	; 245
    2044:	fd 4f       	sbci	r31, 0xFD	; 253
    2046:	20 81       	ld	r18, Z
    2048:	2f 70       	andi	r18, 0x0F	; 15
    204a:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    204c:	22 23       	and	r18, r18
    204e:	99 f0       	breq	.+38     	; 0x2076 <can_read_message_if_new+0x78>
    2050:	db 01       	movw	r26, r22
    2052:	a4 5f       	subi	r26, 0xF4	; 244
    2054:	bd 4f       	sbci	r27, 0xFD	; 253
    2056:	fe 01       	movw	r30, r28
    2058:	33 96       	adiw	r30, 0x03	; 3
    205a:	30 e0       	ldi	r19, 0x00	; 0
    205c:	2d 5f       	subi	r18, 0xFD	; 253
    205e:	3f 4f       	sbci	r19, 0xFF	; 255
    2060:	ce 01       	movw	r24, r28
    2062:	82 0f       	add	r24, r18
    2064:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    2066:	2d 91       	ld	r18, X+
    2068:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    206a:	e8 17       	cp	r30, r24
    206c:	f9 07       	cpc	r31, r25
    206e:	d9 f7       	brne	.-10     	; 0x2066 <can_read_message_if_new+0x68>
    2070:	02 c0       	rjmp	.+4      	; 0x2076 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    2072:	80 e0       	ldi	r24, 0x00	; 0
    2074:	04 c0       	rjmp	.+8      	; 0x207e <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    2076:	4f 5f       	subi	r20, 0xFF	; 255
    2078:	40 93 05 02 	sts	0x0205, r20	; 0x800205 <rx_off>
	}

	return true;
    207c:	81 e0       	ldi	r24, 0x01	; 1
}
    207e:	df 91       	pop	r29
    2080:	cf 91       	pop	r28
    2082:	08 95       	ret

00002084 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    208a:	ab ed       	ldi	r26, 0xDB	; 219
    208c:	b0 e0       	ldi	r27, 0x00	; 0
    208e:	8c 91       	ld	r24, X
    2090:	8f 77       	andi	r24, 0x7F	; 127
    2092:	8c 93       	st	X, r24

	if (!tx_busy) {
    2094:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <tx_busy>
    2098:	81 11       	cpse	r24, r1
    209a:	27 c0       	rjmp	.+78     	; 0x20ea <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    209c:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    20a0:	80 81       	ld	r24, Z
    20a2:	82 95       	swap	r24
    20a4:	88 0f       	add	r24, r24
    20a6:	80 7e       	andi	r24, 0xE0	; 224
    20a8:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    20ac:	80 81       	ld	r24, Z
    20ae:	91 81       	ldd	r25, Z+1	; 0x01
    20b0:	96 95       	lsr	r25
    20b2:	87 95       	ror	r24
    20b4:	96 95       	lsr	r25
    20b6:	87 95       	ror	r24
    20b8:	96 95       	lsr	r25
    20ba:	87 95       	ror	r24
    20bc:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    20c0:	df 01       	movw	r26, r30
    20c2:	13 96       	adiw	r26, 0x03	; 3
    20c4:	9f 01       	movw	r18, r30
    20c6:	25 5f       	subi	r18, 0xF5	; 245
    20c8:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    20ca:	ca ef       	ldi	r28, 0xFA	; 250
    20cc:	d0 e0       	ldi	r29, 0x00	; 0
    20ce:	9d 91       	ld	r25, X+
    20d0:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    20d2:	a2 17       	cp	r26, r18
    20d4:	b3 07       	cpc	r27, r19
    20d6:	d9 f7       	brne	.-10     	; 0x20ce <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    20de:	82 81       	ldd	r24, Z+2	; 0x02
    20e0:	80 64       	ori	r24, 0x40	; 64
    20e2:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	43 c0       	rjmp	.+134    	; 0x2170 <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    20ea:	20 91 07 02 	lds	r18, 0x0207	; 0x800207 <tx_on>
    20ee:	82 2f       	mov	r24, r18
    20f0:	90 e0       	ldi	r25, 0x00	; 0
    20f2:	30 91 08 02 	lds	r19, 0x0208	; 0x800208 <tx_off>
    20f6:	83 1b       	sub	r24, r19
    20f8:	91 09       	sbc	r25, r1
    20fa:	8f 77       	andi	r24, 0x7F	; 127
    20fc:	99 27       	eor	r25, r25
    20fe:	40 97       	sbiw	r24, 0x10	; 16
    2100:	b1 f1       	breq	.+108    	; 0x216e <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    2102:	a2 2f       	mov	r26, r18
    2104:	af 70       	andi	r26, 0x0F	; 15
    2106:	8b e0       	ldi	r24, 0x0B	; 11
    2108:	a8 9f       	mul	r26, r24
    210a:	d0 01       	movw	r26, r0
    210c:	11 24       	eor	r1, r1
    210e:	ed 01       	movw	r28, r26
    2110:	c7 54       	subi	r28, 0x47	; 71
    2112:	dd 4f       	sbci	r29, 0xFD	; 253
    2114:	80 81       	ld	r24, Z
    2116:	98 2f       	mov	r25, r24
    2118:	92 95       	swap	r25
    211a:	99 0f       	add	r25, r25
    211c:	90 7e       	andi	r25, 0xE0	; 224
    211e:	88 81       	ld	r24, Y
    2120:	8f 71       	andi	r24, 0x1F	; 31
    2122:	89 2b       	or	r24, r25
    2124:	88 83       	st	Y, r24
    2126:	80 81       	ld	r24, Z
    2128:	98 2f       	mov	r25, r24
    212a:	96 95       	lsr	r25
    212c:	96 95       	lsr	r25
    212e:	96 95       	lsr	r25
    2130:	89 81       	ldd	r24, Y+1	; 0x01
    2132:	80 7e       	andi	r24, 0xE0	; 224
    2134:	89 2b       	or	r24, r25
    2136:	89 83       	std	Y+1, r24	; 0x01
    2138:	91 81       	ldd	r25, Z+1	; 0x01
    213a:	92 95       	swap	r25
    213c:	99 0f       	add	r25, r25
    213e:	90 7e       	andi	r25, 0xE0	; 224
    2140:	8f 71       	andi	r24, 0x1F	; 31
    2142:	89 2b       	or	r24, r25
    2144:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    2146:	82 81       	ldd	r24, Z+2	; 0x02
    2148:	98 2f       	mov	r25, r24
    214a:	9f 70       	andi	r25, 0x0F	; 15
    214c:	8a 81       	ldd	r24, Y+2	; 0x02
    214e:	80 7f       	andi	r24, 0xF0	; 240
    2150:	89 2b       	or	r24, r25
    2152:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    2154:	a4 54       	subi	r26, 0x44	; 68
    2156:	bd 4f       	sbci	r27, 0xFD	; 253
    2158:	33 96       	adiw	r30, 0x03	; 3
    215a:	88 e0       	ldi	r24, 0x08	; 8
    215c:	01 90       	ld	r0, Z+
    215e:	0d 92       	st	X+, r0
    2160:	8a 95       	dec	r24
    2162:	e1 f7       	brne	.-8      	; 0x215c <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    2164:	2f 5f       	subi	r18, 0xFF	; 255
    2166:	20 93 07 02 	sts	0x0207, r18	; 0x800207 <tx_on>
		result = true;
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	01 c0       	rjmp	.+2      	; 0x2170 <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    216e:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    2170:	eb ed       	ldi	r30, 0xDB	; 219
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	90 81       	ld	r25, Z
    2176:	90 68       	ori	r25, 0x80	; 128
    2178:	90 83       	st	Z, r25

	return result;
    217a:	df 91       	pop	r29
    217c:	cf 91       	pop	r28
    217e:	08 95       	ret

00002180 <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    2180:	95 b1       	in	r25, 0x05	; 5
    2182:	89 2b       	or	r24, r25
    2184:	85 b9       	out	0x05, r24	; 5
    2186:	08 95       	ret

00002188 <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    2188:	84 b1       	in	r24, 0x04	; 4
    218a:	80 6e       	ori	r24, 0xE0	; 224
    218c:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    218e:	80 ee       	ldi	r24, 0xE0	; 224
    2190:	f7 cf       	rjmp	.-18     	; 0x2180 <rgbled_turn_off>
    2192:	08 95       	ret

00002194 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2194:	95 b1       	in	r25, 0x05	; 5
    2196:	80 95       	com	r24
    2198:	98 23       	and	r25, r24
    219a:	95 b9       	out	0x05, r25	; 5
    219c:	08 95       	ret

0000219e <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    219e:	95 b1       	in	r25, 0x05	; 5
    21a0:	89 27       	eor	r24, r25
    21a2:	85 b9       	out	0x05, r24	; 5
    21a4:	08 95       	ret

000021a6 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    21a6:	94 b1       	in	r25, 0x04	; 4
    21a8:	97 60       	ori	r25, 0x07	; 7
    21aa:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    21ac:	82 fb       	bst	r24, 2
    21ae:	99 27       	eor	r25, r25
    21b0:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    21b2:	28 2f       	mov	r18, r24
    21b4:	22 70       	andi	r18, 0x02	; 2
    21b6:	81 70       	andi	r24, 0x01	; 1
    21b8:	80 65       	ori	r24, 0x50	; 80
    21ba:	82 2b       	or	r24, r18
    21bc:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    21be:	8c b5       	in	r24, 0x2c	; 44
    21c0:	83 7f       	andi	r24, 0xF3	; 243
    21c2:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    21c4:	9d bd       	out	0x2d, r25	; 45
    21c6:	08 95       	ret

000021c8 <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    21c8:	cf 93       	push	r28
    21ca:	df 93       	push	r29
    21cc:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    21ce:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    21d0:	41 15       	cp	r20, r1
    21d2:	51 05       	cpc	r21, r1
    21d4:	c1 f0       	breq	.+48     	; 0x2206 <spi_trancieve+0x3e>
    21d6:	fb 01       	movw	r30, r22
    21d8:	dc 01       	movw	r26, r24
    21da:	46 0f       	add	r20, r22
    21dc:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    21de:	8f ef       	ldi	r24, 0xFF	; 255
    21e0:	20 97       	sbiw	r28, 0x00	; 0
    21e2:	11 f0       	breq	.+4      	; 0x21e8 <spi_trancieve+0x20>
    21e4:	9c 91       	ld	r25, X
    21e6:	01 c0       	rjmp	.+2      	; 0x21ea <spi_trancieve+0x22>
    21e8:	98 2f       	mov	r25, r24
    21ea:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    21ec:	0d b4       	in	r0, 0x2d	; 45
    21ee:	07 fe       	sbrs	r0, 7
    21f0:	fd cf       	rjmp	.-6      	; 0x21ec <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    21f2:	61 15       	cp	r22, r1
    21f4:	71 05       	cpc	r23, r1
    21f6:	11 f0       	breq	.+4      	; 0x21fc <spi_trancieve+0x34>
    21f8:	9e b5       	in	r25, 0x2e	; 46
    21fa:	90 83       	st	Z, r25
    21fc:	31 96       	adiw	r30, 0x01	; 1
    21fe:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    2200:	e4 17       	cp	r30, r20
    2202:	f5 07       	cpc	r31, r21
    2204:	69 f7       	brne	.-38     	; 0x21e0 <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2206:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    2208:	28 9a       	sbi	0x05, 0	; 5
	}
}
    220a:	df 91       	pop	r29
    220c:	cf 91       	pop	r28
    220e:	08 95       	ret

00002210 <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    2210:	1f 92       	push	r1
    2212:	0f 92       	push	r0
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	0f 92       	push	r0
    2218:	11 24       	eor	r1, r1
    221a:	0b b6       	in	r0, 0x3b	; 59
    221c:	0f 92       	push	r0
    221e:	2f 93       	push	r18
    2220:	3f 93       	push	r19
    2222:	4f 93       	push	r20
    2224:	5f 93       	push	r21
    2226:	6f 93       	push	r22
    2228:	7f 93       	push	r23
    222a:	8f 93       	push	r24
    222c:	af 93       	push	r26
    222e:	bf 93       	push	r27
    2230:	ef 93       	push	r30
    2232:	ff 93       	push	r31
    2234:	a9 e8       	ldi	r26, 0x89	; 137
    2236:	b3 e0       	ldi	r27, 0x03	; 3
    2238:	e9 e6       	ldi	r30, 0x69	; 105
    223a:	f3 e0       	ldi	r31, 0x03	; 3
    223c:	29 e8       	ldi	r18, 0x89	; 137
    223e:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    2240:	8d 91       	ld	r24, X+
    2242:	88 23       	and	r24, r24
    2244:	59 f0       	breq	.+22     	; 0x225c <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    2246:	40 81       	ld	r20, Z
    2248:	51 81       	ldd	r21, Z+1	; 0x01
    224a:	62 81       	ldd	r22, Z+2	; 0x02
    224c:	73 81       	ldd	r23, Z+3	; 0x03
    224e:	50 5e       	subi	r21, 0xE0	; 224
    2250:	6f 4f       	sbci	r22, 0xFF	; 255
    2252:	7f 4f       	sbci	r23, 0xFF	; 255
    2254:	40 83       	st	Z, r20
    2256:	51 83       	std	Z+1, r21	; 0x01
    2258:	62 83       	std	Z+2, r22	; 0x02
    225a:	73 83       	std	Z+3, r23	; 0x03
    225c:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    225e:	e2 17       	cp	r30, r18
    2260:	f3 07       	cpc	r31, r19
    2262:	71 f7       	brne	.-36     	; 0x2240 <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    2264:	ff 91       	pop	r31
    2266:	ef 91       	pop	r30
    2268:	bf 91       	pop	r27
    226a:	af 91       	pop	r26
    226c:	8f 91       	pop	r24
    226e:	7f 91       	pop	r23
    2270:	6f 91       	pop	r22
    2272:	5f 91       	pop	r21
    2274:	4f 91       	pop	r20
    2276:	3f 91       	pop	r19
    2278:	2f 91       	pop	r18
    227a:	0f 90       	pop	r0
    227c:	0b be       	out	0x3b, r0	; 59
    227e:	0f 90       	pop	r0
    2280:	0f be       	out	0x3f, r0	; 63
    2282:	0f 90       	pop	r0
    2284:	1f 90       	pop	r1
    2286:	18 95       	reti

00002288 <__subsf3>:
    2288:	50 58       	subi	r21, 0x80	; 128

0000228a <__addsf3>:
    228a:	bb 27       	eor	r27, r27
    228c:	aa 27       	eor	r26, r26
    228e:	0e d0       	rcall	.+28     	; 0x22ac <__addsf3x>
    2290:	75 c1       	rjmp	.+746    	; 0x257c <__fp_round>
    2292:	66 d1       	rcall	.+716    	; 0x2560 <__fp_pscA>
    2294:	30 f0       	brcs	.+12     	; 0x22a2 <__addsf3+0x18>
    2296:	6b d1       	rcall	.+726    	; 0x256e <__fp_pscB>
    2298:	20 f0       	brcs	.+8      	; 0x22a2 <__addsf3+0x18>
    229a:	31 f4       	brne	.+12     	; 0x22a8 <__addsf3+0x1e>
    229c:	9f 3f       	cpi	r25, 0xFF	; 255
    229e:	11 f4       	brne	.+4      	; 0x22a4 <__addsf3+0x1a>
    22a0:	1e f4       	brtc	.+6      	; 0x22a8 <__addsf3+0x1e>
    22a2:	5b c1       	rjmp	.+694    	; 0x255a <__fp_nan>
    22a4:	0e f4       	brtc	.+2      	; 0x22a8 <__addsf3+0x1e>
    22a6:	e0 95       	com	r30
    22a8:	e7 fb       	bst	r30, 7
    22aa:	51 c1       	rjmp	.+674    	; 0x254e <__fp_inf>

000022ac <__addsf3x>:
    22ac:	e9 2f       	mov	r30, r25
    22ae:	77 d1       	rcall	.+750    	; 0x259e <__fp_split3>
    22b0:	80 f3       	brcs	.-32     	; 0x2292 <__addsf3+0x8>
    22b2:	ba 17       	cp	r27, r26
    22b4:	62 07       	cpc	r22, r18
    22b6:	73 07       	cpc	r23, r19
    22b8:	84 07       	cpc	r24, r20
    22ba:	95 07       	cpc	r25, r21
    22bc:	18 f0       	brcs	.+6      	; 0x22c4 <__addsf3x+0x18>
    22be:	71 f4       	brne	.+28     	; 0x22dc <__addsf3x+0x30>
    22c0:	9e f5       	brtc	.+102    	; 0x2328 <__addsf3x+0x7c>
    22c2:	8f c1       	rjmp	.+798    	; 0x25e2 <__fp_zero>
    22c4:	0e f4       	brtc	.+2      	; 0x22c8 <__addsf3x+0x1c>
    22c6:	e0 95       	com	r30
    22c8:	0b 2e       	mov	r0, r27
    22ca:	ba 2f       	mov	r27, r26
    22cc:	a0 2d       	mov	r26, r0
    22ce:	0b 01       	movw	r0, r22
    22d0:	b9 01       	movw	r22, r18
    22d2:	90 01       	movw	r18, r0
    22d4:	0c 01       	movw	r0, r24
    22d6:	ca 01       	movw	r24, r20
    22d8:	a0 01       	movw	r20, r0
    22da:	11 24       	eor	r1, r1
    22dc:	ff 27       	eor	r31, r31
    22de:	59 1b       	sub	r21, r25
    22e0:	99 f0       	breq	.+38     	; 0x2308 <__addsf3x+0x5c>
    22e2:	59 3f       	cpi	r21, 0xF9	; 249
    22e4:	50 f4       	brcc	.+20     	; 0x22fa <__addsf3x+0x4e>
    22e6:	50 3e       	cpi	r21, 0xE0	; 224
    22e8:	68 f1       	brcs	.+90     	; 0x2344 <__addsf3x+0x98>
    22ea:	1a 16       	cp	r1, r26
    22ec:	f0 40       	sbci	r31, 0x00	; 0
    22ee:	a2 2f       	mov	r26, r18
    22f0:	23 2f       	mov	r18, r19
    22f2:	34 2f       	mov	r19, r20
    22f4:	44 27       	eor	r20, r20
    22f6:	58 5f       	subi	r21, 0xF8	; 248
    22f8:	f3 cf       	rjmp	.-26     	; 0x22e0 <__addsf3x+0x34>
    22fa:	46 95       	lsr	r20
    22fc:	37 95       	ror	r19
    22fe:	27 95       	ror	r18
    2300:	a7 95       	ror	r26
    2302:	f0 40       	sbci	r31, 0x00	; 0
    2304:	53 95       	inc	r21
    2306:	c9 f7       	brne	.-14     	; 0x22fa <__addsf3x+0x4e>
    2308:	7e f4       	brtc	.+30     	; 0x2328 <__addsf3x+0x7c>
    230a:	1f 16       	cp	r1, r31
    230c:	ba 0b       	sbc	r27, r26
    230e:	62 0b       	sbc	r22, r18
    2310:	73 0b       	sbc	r23, r19
    2312:	84 0b       	sbc	r24, r20
    2314:	ba f0       	brmi	.+46     	; 0x2344 <__addsf3x+0x98>
    2316:	91 50       	subi	r25, 0x01	; 1
    2318:	a1 f0       	breq	.+40     	; 0x2342 <__addsf3x+0x96>
    231a:	ff 0f       	add	r31, r31
    231c:	bb 1f       	adc	r27, r27
    231e:	66 1f       	adc	r22, r22
    2320:	77 1f       	adc	r23, r23
    2322:	88 1f       	adc	r24, r24
    2324:	c2 f7       	brpl	.-16     	; 0x2316 <__addsf3x+0x6a>
    2326:	0e c0       	rjmp	.+28     	; 0x2344 <__addsf3x+0x98>
    2328:	ba 0f       	add	r27, r26
    232a:	62 1f       	adc	r22, r18
    232c:	73 1f       	adc	r23, r19
    232e:	84 1f       	adc	r24, r20
    2330:	48 f4       	brcc	.+18     	; 0x2344 <__addsf3x+0x98>
    2332:	87 95       	ror	r24
    2334:	77 95       	ror	r23
    2336:	67 95       	ror	r22
    2338:	b7 95       	ror	r27
    233a:	f7 95       	ror	r31
    233c:	9e 3f       	cpi	r25, 0xFE	; 254
    233e:	08 f0       	brcs	.+2      	; 0x2342 <__addsf3x+0x96>
    2340:	b3 cf       	rjmp	.-154    	; 0x22a8 <__addsf3+0x1e>
    2342:	93 95       	inc	r25
    2344:	88 0f       	add	r24, r24
    2346:	08 f0       	brcs	.+2      	; 0x234a <__addsf3x+0x9e>
    2348:	99 27       	eor	r25, r25
    234a:	ee 0f       	add	r30, r30
    234c:	97 95       	ror	r25
    234e:	87 95       	ror	r24
    2350:	08 95       	ret

00002352 <__cmpsf2>:
    2352:	d9 d0       	rcall	.+434    	; 0x2506 <__fp_cmp>
    2354:	08 f4       	brcc	.+2      	; 0x2358 <__cmpsf2+0x6>
    2356:	81 e0       	ldi	r24, 0x01	; 1
    2358:	08 95       	ret

0000235a <__divsf3>:
    235a:	0c d0       	rcall	.+24     	; 0x2374 <__divsf3x>
    235c:	0f c1       	rjmp	.+542    	; 0x257c <__fp_round>
    235e:	07 d1       	rcall	.+526    	; 0x256e <__fp_pscB>
    2360:	40 f0       	brcs	.+16     	; 0x2372 <__divsf3+0x18>
    2362:	fe d0       	rcall	.+508    	; 0x2560 <__fp_pscA>
    2364:	30 f0       	brcs	.+12     	; 0x2372 <__divsf3+0x18>
    2366:	21 f4       	brne	.+8      	; 0x2370 <__divsf3+0x16>
    2368:	5f 3f       	cpi	r21, 0xFF	; 255
    236a:	19 f0       	breq	.+6      	; 0x2372 <__divsf3+0x18>
    236c:	f0 c0       	rjmp	.+480    	; 0x254e <__fp_inf>
    236e:	51 11       	cpse	r21, r1
    2370:	39 c1       	rjmp	.+626    	; 0x25e4 <__fp_szero>
    2372:	f3 c0       	rjmp	.+486    	; 0x255a <__fp_nan>

00002374 <__divsf3x>:
    2374:	14 d1       	rcall	.+552    	; 0x259e <__fp_split3>
    2376:	98 f3       	brcs	.-26     	; 0x235e <__divsf3+0x4>

00002378 <__divsf3_pse>:
    2378:	99 23       	and	r25, r25
    237a:	c9 f3       	breq	.-14     	; 0x236e <__divsf3+0x14>
    237c:	55 23       	and	r21, r21
    237e:	b1 f3       	breq	.-20     	; 0x236c <__divsf3+0x12>
    2380:	95 1b       	sub	r25, r21
    2382:	55 0b       	sbc	r21, r21
    2384:	bb 27       	eor	r27, r27
    2386:	aa 27       	eor	r26, r26
    2388:	62 17       	cp	r22, r18
    238a:	73 07       	cpc	r23, r19
    238c:	84 07       	cpc	r24, r20
    238e:	38 f0       	brcs	.+14     	; 0x239e <__divsf3_pse+0x26>
    2390:	9f 5f       	subi	r25, 0xFF	; 255
    2392:	5f 4f       	sbci	r21, 0xFF	; 255
    2394:	22 0f       	add	r18, r18
    2396:	33 1f       	adc	r19, r19
    2398:	44 1f       	adc	r20, r20
    239a:	aa 1f       	adc	r26, r26
    239c:	a9 f3       	breq	.-22     	; 0x2388 <__divsf3_pse+0x10>
    239e:	33 d0       	rcall	.+102    	; 0x2406 <__divsf3_pse+0x8e>
    23a0:	0e 2e       	mov	r0, r30
    23a2:	3a f0       	brmi	.+14     	; 0x23b2 <__divsf3_pse+0x3a>
    23a4:	e0 e8       	ldi	r30, 0x80	; 128
    23a6:	30 d0       	rcall	.+96     	; 0x2408 <__divsf3_pse+0x90>
    23a8:	91 50       	subi	r25, 0x01	; 1
    23aa:	50 40       	sbci	r21, 0x00	; 0
    23ac:	e6 95       	lsr	r30
    23ae:	00 1c       	adc	r0, r0
    23b0:	ca f7       	brpl	.-14     	; 0x23a4 <__divsf3_pse+0x2c>
    23b2:	29 d0       	rcall	.+82     	; 0x2406 <__divsf3_pse+0x8e>
    23b4:	fe 2f       	mov	r31, r30
    23b6:	27 d0       	rcall	.+78     	; 0x2406 <__divsf3_pse+0x8e>
    23b8:	66 0f       	add	r22, r22
    23ba:	77 1f       	adc	r23, r23
    23bc:	88 1f       	adc	r24, r24
    23be:	bb 1f       	adc	r27, r27
    23c0:	26 17       	cp	r18, r22
    23c2:	37 07       	cpc	r19, r23
    23c4:	48 07       	cpc	r20, r24
    23c6:	ab 07       	cpc	r26, r27
    23c8:	b0 e8       	ldi	r27, 0x80	; 128
    23ca:	09 f0       	breq	.+2      	; 0x23ce <__divsf3_pse+0x56>
    23cc:	bb 0b       	sbc	r27, r27
    23ce:	80 2d       	mov	r24, r0
    23d0:	bf 01       	movw	r22, r30
    23d2:	ff 27       	eor	r31, r31
    23d4:	93 58       	subi	r25, 0x83	; 131
    23d6:	5f 4f       	sbci	r21, 0xFF	; 255
    23d8:	2a f0       	brmi	.+10     	; 0x23e4 <__divsf3_pse+0x6c>
    23da:	9e 3f       	cpi	r25, 0xFE	; 254
    23dc:	51 05       	cpc	r21, r1
    23de:	68 f0       	brcs	.+26     	; 0x23fa <__divsf3_pse+0x82>
    23e0:	b6 c0       	rjmp	.+364    	; 0x254e <__fp_inf>
    23e2:	00 c1       	rjmp	.+512    	; 0x25e4 <__fp_szero>
    23e4:	5f 3f       	cpi	r21, 0xFF	; 255
    23e6:	ec f3       	brlt	.-6      	; 0x23e2 <__divsf3_pse+0x6a>
    23e8:	98 3e       	cpi	r25, 0xE8	; 232
    23ea:	dc f3       	brlt	.-10     	; 0x23e2 <__divsf3_pse+0x6a>
    23ec:	86 95       	lsr	r24
    23ee:	77 95       	ror	r23
    23f0:	67 95       	ror	r22
    23f2:	b7 95       	ror	r27
    23f4:	f7 95       	ror	r31
    23f6:	9f 5f       	subi	r25, 0xFF	; 255
    23f8:	c9 f7       	brne	.-14     	; 0x23ec <__divsf3_pse+0x74>
    23fa:	88 0f       	add	r24, r24
    23fc:	91 1d       	adc	r25, r1
    23fe:	96 95       	lsr	r25
    2400:	87 95       	ror	r24
    2402:	97 f9       	bld	r25, 7
    2404:	08 95       	ret
    2406:	e1 e0       	ldi	r30, 0x01	; 1
    2408:	66 0f       	add	r22, r22
    240a:	77 1f       	adc	r23, r23
    240c:	88 1f       	adc	r24, r24
    240e:	bb 1f       	adc	r27, r27
    2410:	62 17       	cp	r22, r18
    2412:	73 07       	cpc	r23, r19
    2414:	84 07       	cpc	r24, r20
    2416:	ba 07       	cpc	r27, r26
    2418:	20 f0       	brcs	.+8      	; 0x2422 <__divsf3_pse+0xaa>
    241a:	62 1b       	sub	r22, r18
    241c:	73 0b       	sbc	r23, r19
    241e:	84 0b       	sbc	r24, r20
    2420:	ba 0b       	sbc	r27, r26
    2422:	ee 1f       	adc	r30, r30
    2424:	88 f7       	brcc	.-30     	; 0x2408 <__divsf3_pse+0x90>
    2426:	e0 95       	com	r30
    2428:	08 95       	ret

0000242a <__fixsfsi>:
    242a:	04 d0       	rcall	.+8      	; 0x2434 <__fixunssfsi>
    242c:	68 94       	set
    242e:	b1 11       	cpse	r27, r1
    2430:	d9 c0       	rjmp	.+434    	; 0x25e4 <__fp_szero>
    2432:	08 95       	ret

00002434 <__fixunssfsi>:
    2434:	bc d0       	rcall	.+376    	; 0x25ae <__fp_splitA>
    2436:	88 f0       	brcs	.+34     	; 0x245a <__fixunssfsi+0x26>
    2438:	9f 57       	subi	r25, 0x7F	; 127
    243a:	90 f0       	brcs	.+36     	; 0x2460 <__fixunssfsi+0x2c>
    243c:	b9 2f       	mov	r27, r25
    243e:	99 27       	eor	r25, r25
    2440:	b7 51       	subi	r27, 0x17	; 23
    2442:	a0 f0       	brcs	.+40     	; 0x246c <__fixunssfsi+0x38>
    2444:	d1 f0       	breq	.+52     	; 0x247a <__fixunssfsi+0x46>
    2446:	66 0f       	add	r22, r22
    2448:	77 1f       	adc	r23, r23
    244a:	88 1f       	adc	r24, r24
    244c:	99 1f       	adc	r25, r25
    244e:	1a f0       	brmi	.+6      	; 0x2456 <__fixunssfsi+0x22>
    2450:	ba 95       	dec	r27
    2452:	c9 f7       	brne	.-14     	; 0x2446 <__fixunssfsi+0x12>
    2454:	12 c0       	rjmp	.+36     	; 0x247a <__fixunssfsi+0x46>
    2456:	b1 30       	cpi	r27, 0x01	; 1
    2458:	81 f0       	breq	.+32     	; 0x247a <__fixunssfsi+0x46>
    245a:	c3 d0       	rcall	.+390    	; 0x25e2 <__fp_zero>
    245c:	b1 e0       	ldi	r27, 0x01	; 1
    245e:	08 95       	ret
    2460:	c0 c0       	rjmp	.+384    	; 0x25e2 <__fp_zero>
    2462:	67 2f       	mov	r22, r23
    2464:	78 2f       	mov	r23, r24
    2466:	88 27       	eor	r24, r24
    2468:	b8 5f       	subi	r27, 0xF8	; 248
    246a:	39 f0       	breq	.+14     	; 0x247a <__fixunssfsi+0x46>
    246c:	b9 3f       	cpi	r27, 0xF9	; 249
    246e:	cc f3       	brlt	.-14     	; 0x2462 <__fixunssfsi+0x2e>
    2470:	86 95       	lsr	r24
    2472:	77 95       	ror	r23
    2474:	67 95       	ror	r22
    2476:	b3 95       	inc	r27
    2478:	d9 f7       	brne	.-10     	; 0x2470 <__fixunssfsi+0x3c>
    247a:	3e f4       	brtc	.+14     	; 0x248a <__fixunssfsi+0x56>
    247c:	90 95       	com	r25
    247e:	80 95       	com	r24
    2480:	70 95       	com	r23
    2482:	61 95       	neg	r22
    2484:	7f 4f       	sbci	r23, 0xFF	; 255
    2486:	8f 4f       	sbci	r24, 0xFF	; 255
    2488:	9f 4f       	sbci	r25, 0xFF	; 255
    248a:	08 95       	ret

0000248c <__floatunsisf>:
    248c:	e8 94       	clt
    248e:	09 c0       	rjmp	.+18     	; 0x24a2 <__floatsisf+0x12>

00002490 <__floatsisf>:
    2490:	97 fb       	bst	r25, 7
    2492:	3e f4       	brtc	.+14     	; 0x24a2 <__floatsisf+0x12>
    2494:	90 95       	com	r25
    2496:	80 95       	com	r24
    2498:	70 95       	com	r23
    249a:	61 95       	neg	r22
    249c:	7f 4f       	sbci	r23, 0xFF	; 255
    249e:	8f 4f       	sbci	r24, 0xFF	; 255
    24a0:	9f 4f       	sbci	r25, 0xFF	; 255
    24a2:	99 23       	and	r25, r25
    24a4:	a9 f0       	breq	.+42     	; 0x24d0 <__floatsisf+0x40>
    24a6:	f9 2f       	mov	r31, r25
    24a8:	96 e9       	ldi	r25, 0x96	; 150
    24aa:	bb 27       	eor	r27, r27
    24ac:	93 95       	inc	r25
    24ae:	f6 95       	lsr	r31
    24b0:	87 95       	ror	r24
    24b2:	77 95       	ror	r23
    24b4:	67 95       	ror	r22
    24b6:	b7 95       	ror	r27
    24b8:	f1 11       	cpse	r31, r1
    24ba:	f8 cf       	rjmp	.-16     	; 0x24ac <__floatsisf+0x1c>
    24bc:	fa f4       	brpl	.+62     	; 0x24fc <__floatsisf+0x6c>
    24be:	bb 0f       	add	r27, r27
    24c0:	11 f4       	brne	.+4      	; 0x24c6 <__floatsisf+0x36>
    24c2:	60 ff       	sbrs	r22, 0
    24c4:	1b c0       	rjmp	.+54     	; 0x24fc <__floatsisf+0x6c>
    24c6:	6f 5f       	subi	r22, 0xFF	; 255
    24c8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ca:	8f 4f       	sbci	r24, 0xFF	; 255
    24cc:	9f 4f       	sbci	r25, 0xFF	; 255
    24ce:	16 c0       	rjmp	.+44     	; 0x24fc <__floatsisf+0x6c>
    24d0:	88 23       	and	r24, r24
    24d2:	11 f0       	breq	.+4      	; 0x24d8 <__floatsisf+0x48>
    24d4:	96 e9       	ldi	r25, 0x96	; 150
    24d6:	11 c0       	rjmp	.+34     	; 0x24fa <__floatsisf+0x6a>
    24d8:	77 23       	and	r23, r23
    24da:	21 f0       	breq	.+8      	; 0x24e4 <__floatsisf+0x54>
    24dc:	9e e8       	ldi	r25, 0x8E	; 142
    24de:	87 2f       	mov	r24, r23
    24e0:	76 2f       	mov	r23, r22
    24e2:	05 c0       	rjmp	.+10     	; 0x24ee <__floatsisf+0x5e>
    24e4:	66 23       	and	r22, r22
    24e6:	71 f0       	breq	.+28     	; 0x2504 <__floatsisf+0x74>
    24e8:	96 e8       	ldi	r25, 0x86	; 134
    24ea:	86 2f       	mov	r24, r22
    24ec:	70 e0       	ldi	r23, 0x00	; 0
    24ee:	60 e0       	ldi	r22, 0x00	; 0
    24f0:	2a f0       	brmi	.+10     	; 0x24fc <__floatsisf+0x6c>
    24f2:	9a 95       	dec	r25
    24f4:	66 0f       	add	r22, r22
    24f6:	77 1f       	adc	r23, r23
    24f8:	88 1f       	adc	r24, r24
    24fa:	da f7       	brpl	.-10     	; 0x24f2 <__floatsisf+0x62>
    24fc:	88 0f       	add	r24, r24
    24fe:	96 95       	lsr	r25
    2500:	87 95       	ror	r24
    2502:	97 f9       	bld	r25, 7
    2504:	08 95       	ret

00002506 <__fp_cmp>:
    2506:	99 0f       	add	r25, r25
    2508:	00 08       	sbc	r0, r0
    250a:	55 0f       	add	r21, r21
    250c:	aa 0b       	sbc	r26, r26
    250e:	e0 e8       	ldi	r30, 0x80	; 128
    2510:	fe ef       	ldi	r31, 0xFE	; 254
    2512:	16 16       	cp	r1, r22
    2514:	17 06       	cpc	r1, r23
    2516:	e8 07       	cpc	r30, r24
    2518:	f9 07       	cpc	r31, r25
    251a:	c0 f0       	brcs	.+48     	; 0x254c <__fp_cmp+0x46>
    251c:	12 16       	cp	r1, r18
    251e:	13 06       	cpc	r1, r19
    2520:	e4 07       	cpc	r30, r20
    2522:	f5 07       	cpc	r31, r21
    2524:	98 f0       	brcs	.+38     	; 0x254c <__fp_cmp+0x46>
    2526:	62 1b       	sub	r22, r18
    2528:	73 0b       	sbc	r23, r19
    252a:	84 0b       	sbc	r24, r20
    252c:	95 0b       	sbc	r25, r21
    252e:	39 f4       	brne	.+14     	; 0x253e <__fp_cmp+0x38>
    2530:	0a 26       	eor	r0, r26
    2532:	61 f0       	breq	.+24     	; 0x254c <__fp_cmp+0x46>
    2534:	23 2b       	or	r18, r19
    2536:	24 2b       	or	r18, r20
    2538:	25 2b       	or	r18, r21
    253a:	21 f4       	brne	.+8      	; 0x2544 <__fp_cmp+0x3e>
    253c:	08 95       	ret
    253e:	0a 26       	eor	r0, r26
    2540:	09 f4       	brne	.+2      	; 0x2544 <__fp_cmp+0x3e>
    2542:	a1 40       	sbci	r26, 0x01	; 1
    2544:	a6 95       	lsr	r26
    2546:	8f ef       	ldi	r24, 0xFF	; 255
    2548:	81 1d       	adc	r24, r1
    254a:	81 1d       	adc	r24, r1
    254c:	08 95       	ret

0000254e <__fp_inf>:
    254e:	97 f9       	bld	r25, 7
    2550:	9f 67       	ori	r25, 0x7F	; 127
    2552:	80 e8       	ldi	r24, 0x80	; 128
    2554:	70 e0       	ldi	r23, 0x00	; 0
    2556:	60 e0       	ldi	r22, 0x00	; 0
    2558:	08 95       	ret

0000255a <__fp_nan>:
    255a:	9f ef       	ldi	r25, 0xFF	; 255
    255c:	80 ec       	ldi	r24, 0xC0	; 192
    255e:	08 95       	ret

00002560 <__fp_pscA>:
    2560:	00 24       	eor	r0, r0
    2562:	0a 94       	dec	r0
    2564:	16 16       	cp	r1, r22
    2566:	17 06       	cpc	r1, r23
    2568:	18 06       	cpc	r1, r24
    256a:	09 06       	cpc	r0, r25
    256c:	08 95       	ret

0000256e <__fp_pscB>:
    256e:	00 24       	eor	r0, r0
    2570:	0a 94       	dec	r0
    2572:	12 16       	cp	r1, r18
    2574:	13 06       	cpc	r1, r19
    2576:	14 06       	cpc	r1, r20
    2578:	05 06       	cpc	r0, r21
    257a:	08 95       	ret

0000257c <__fp_round>:
    257c:	09 2e       	mov	r0, r25
    257e:	03 94       	inc	r0
    2580:	00 0c       	add	r0, r0
    2582:	11 f4       	brne	.+4      	; 0x2588 <__fp_round+0xc>
    2584:	88 23       	and	r24, r24
    2586:	52 f0       	brmi	.+20     	; 0x259c <__fp_round+0x20>
    2588:	bb 0f       	add	r27, r27
    258a:	40 f4       	brcc	.+16     	; 0x259c <__fp_round+0x20>
    258c:	bf 2b       	or	r27, r31
    258e:	11 f4       	brne	.+4      	; 0x2594 <__fp_round+0x18>
    2590:	60 ff       	sbrs	r22, 0
    2592:	04 c0       	rjmp	.+8      	; 0x259c <__fp_round+0x20>
    2594:	6f 5f       	subi	r22, 0xFF	; 255
    2596:	7f 4f       	sbci	r23, 0xFF	; 255
    2598:	8f 4f       	sbci	r24, 0xFF	; 255
    259a:	9f 4f       	sbci	r25, 0xFF	; 255
    259c:	08 95       	ret

0000259e <__fp_split3>:
    259e:	57 fd       	sbrc	r21, 7
    25a0:	90 58       	subi	r25, 0x80	; 128
    25a2:	44 0f       	add	r20, r20
    25a4:	55 1f       	adc	r21, r21
    25a6:	59 f0       	breq	.+22     	; 0x25be <__fp_splitA+0x10>
    25a8:	5f 3f       	cpi	r21, 0xFF	; 255
    25aa:	71 f0       	breq	.+28     	; 0x25c8 <__fp_splitA+0x1a>
    25ac:	47 95       	ror	r20

000025ae <__fp_splitA>:
    25ae:	88 0f       	add	r24, r24
    25b0:	97 fb       	bst	r25, 7
    25b2:	99 1f       	adc	r25, r25
    25b4:	61 f0       	breq	.+24     	; 0x25ce <__fp_splitA+0x20>
    25b6:	9f 3f       	cpi	r25, 0xFF	; 255
    25b8:	79 f0       	breq	.+30     	; 0x25d8 <__fp_splitA+0x2a>
    25ba:	87 95       	ror	r24
    25bc:	08 95       	ret
    25be:	12 16       	cp	r1, r18
    25c0:	13 06       	cpc	r1, r19
    25c2:	14 06       	cpc	r1, r20
    25c4:	55 1f       	adc	r21, r21
    25c6:	f2 cf       	rjmp	.-28     	; 0x25ac <__fp_split3+0xe>
    25c8:	46 95       	lsr	r20
    25ca:	f1 df       	rcall	.-30     	; 0x25ae <__fp_splitA>
    25cc:	08 c0       	rjmp	.+16     	; 0x25de <__fp_splitA+0x30>
    25ce:	16 16       	cp	r1, r22
    25d0:	17 06       	cpc	r1, r23
    25d2:	18 06       	cpc	r1, r24
    25d4:	99 1f       	adc	r25, r25
    25d6:	f1 cf       	rjmp	.-30     	; 0x25ba <__fp_splitA+0xc>
    25d8:	86 95       	lsr	r24
    25da:	71 05       	cpc	r23, r1
    25dc:	61 05       	cpc	r22, r1
    25de:	08 94       	sec
    25e0:	08 95       	ret

000025e2 <__fp_zero>:
    25e2:	e8 94       	clt

000025e4 <__fp_szero>:
    25e4:	bb 27       	eor	r27, r27
    25e6:	66 27       	eor	r22, r22
    25e8:	77 27       	eor	r23, r23
    25ea:	cb 01       	movw	r24, r22
    25ec:	97 f9       	bld	r25, 7
    25ee:	08 95       	ret

000025f0 <__gesf2>:
    25f0:	8a df       	rcall	.-236    	; 0x2506 <__fp_cmp>
    25f2:	08 f4       	brcc	.+2      	; 0x25f6 <__gesf2+0x6>
    25f4:	8f ef       	ldi	r24, 0xFF	; 255
    25f6:	08 95       	ret

000025f8 <__mulsf3>:
    25f8:	0b d0       	rcall	.+22     	; 0x2610 <__mulsf3x>
    25fa:	c0 cf       	rjmp	.-128    	; 0x257c <__fp_round>
    25fc:	b1 df       	rcall	.-158    	; 0x2560 <__fp_pscA>
    25fe:	28 f0       	brcs	.+10     	; 0x260a <__mulsf3+0x12>
    2600:	b6 df       	rcall	.-148    	; 0x256e <__fp_pscB>
    2602:	18 f0       	brcs	.+6      	; 0x260a <__mulsf3+0x12>
    2604:	95 23       	and	r25, r21
    2606:	09 f0       	breq	.+2      	; 0x260a <__mulsf3+0x12>
    2608:	a2 cf       	rjmp	.-188    	; 0x254e <__fp_inf>
    260a:	a7 cf       	rjmp	.-178    	; 0x255a <__fp_nan>
    260c:	11 24       	eor	r1, r1
    260e:	ea cf       	rjmp	.-44     	; 0x25e4 <__fp_szero>

00002610 <__mulsf3x>:
    2610:	c6 df       	rcall	.-116    	; 0x259e <__fp_split3>
    2612:	a0 f3       	brcs	.-24     	; 0x25fc <__mulsf3+0x4>

00002614 <__mulsf3_pse>:
    2614:	95 9f       	mul	r25, r21
    2616:	d1 f3       	breq	.-12     	; 0x260c <__mulsf3+0x14>
    2618:	95 0f       	add	r25, r21
    261a:	50 e0       	ldi	r21, 0x00	; 0
    261c:	55 1f       	adc	r21, r21
    261e:	62 9f       	mul	r22, r18
    2620:	f0 01       	movw	r30, r0
    2622:	72 9f       	mul	r23, r18
    2624:	bb 27       	eor	r27, r27
    2626:	f0 0d       	add	r31, r0
    2628:	b1 1d       	adc	r27, r1
    262a:	63 9f       	mul	r22, r19
    262c:	aa 27       	eor	r26, r26
    262e:	f0 0d       	add	r31, r0
    2630:	b1 1d       	adc	r27, r1
    2632:	aa 1f       	adc	r26, r26
    2634:	64 9f       	mul	r22, r20
    2636:	66 27       	eor	r22, r22
    2638:	b0 0d       	add	r27, r0
    263a:	a1 1d       	adc	r26, r1
    263c:	66 1f       	adc	r22, r22
    263e:	82 9f       	mul	r24, r18
    2640:	22 27       	eor	r18, r18
    2642:	b0 0d       	add	r27, r0
    2644:	a1 1d       	adc	r26, r1
    2646:	62 1f       	adc	r22, r18
    2648:	73 9f       	mul	r23, r19
    264a:	b0 0d       	add	r27, r0
    264c:	a1 1d       	adc	r26, r1
    264e:	62 1f       	adc	r22, r18
    2650:	83 9f       	mul	r24, r19
    2652:	a0 0d       	add	r26, r0
    2654:	61 1d       	adc	r22, r1
    2656:	22 1f       	adc	r18, r18
    2658:	74 9f       	mul	r23, r20
    265a:	33 27       	eor	r19, r19
    265c:	a0 0d       	add	r26, r0
    265e:	61 1d       	adc	r22, r1
    2660:	23 1f       	adc	r18, r19
    2662:	84 9f       	mul	r24, r20
    2664:	60 0d       	add	r22, r0
    2666:	21 1d       	adc	r18, r1
    2668:	82 2f       	mov	r24, r18
    266a:	76 2f       	mov	r23, r22
    266c:	6a 2f       	mov	r22, r26
    266e:	11 24       	eor	r1, r1
    2670:	9f 57       	subi	r25, 0x7F	; 127
    2672:	50 40       	sbci	r21, 0x00	; 0
    2674:	8a f0       	brmi	.+34     	; 0x2698 <__mulsf3_pse+0x84>
    2676:	e1 f0       	breq	.+56     	; 0x26b0 <__mulsf3_pse+0x9c>
    2678:	88 23       	and	r24, r24
    267a:	4a f0       	brmi	.+18     	; 0x268e <__mulsf3_pse+0x7a>
    267c:	ee 0f       	add	r30, r30
    267e:	ff 1f       	adc	r31, r31
    2680:	bb 1f       	adc	r27, r27
    2682:	66 1f       	adc	r22, r22
    2684:	77 1f       	adc	r23, r23
    2686:	88 1f       	adc	r24, r24
    2688:	91 50       	subi	r25, 0x01	; 1
    268a:	50 40       	sbci	r21, 0x00	; 0
    268c:	a9 f7       	brne	.-22     	; 0x2678 <__mulsf3_pse+0x64>
    268e:	9e 3f       	cpi	r25, 0xFE	; 254
    2690:	51 05       	cpc	r21, r1
    2692:	70 f0       	brcs	.+28     	; 0x26b0 <__mulsf3_pse+0x9c>
    2694:	5c cf       	rjmp	.-328    	; 0x254e <__fp_inf>
    2696:	a6 cf       	rjmp	.-180    	; 0x25e4 <__fp_szero>
    2698:	5f 3f       	cpi	r21, 0xFF	; 255
    269a:	ec f3       	brlt	.-6      	; 0x2696 <__mulsf3_pse+0x82>
    269c:	98 3e       	cpi	r25, 0xE8	; 232
    269e:	dc f3       	brlt	.-10     	; 0x2696 <__mulsf3_pse+0x82>
    26a0:	86 95       	lsr	r24
    26a2:	77 95       	ror	r23
    26a4:	67 95       	ror	r22
    26a6:	b7 95       	ror	r27
    26a8:	f7 95       	ror	r31
    26aa:	e7 95       	ror	r30
    26ac:	9f 5f       	subi	r25, 0xFF	; 255
    26ae:	c1 f7       	brne	.-16     	; 0x26a0 <__mulsf3_pse+0x8c>
    26b0:	fe 2b       	or	r31, r30
    26b2:	88 0f       	add	r24, r24
    26b4:	91 1d       	adc	r25, r1
    26b6:	96 95       	lsr	r25
    26b8:	87 95       	ror	r24
    26ba:	97 f9       	bld	r25, 7
    26bc:	08 95       	ret

000026be <__tablejump2__>:
    26be:	ee 0f       	add	r30, r30
    26c0:	ff 1f       	adc	r31, r31
    26c2:	00 24       	eor	r0, r0
    26c4:	00 1c       	adc	r0, r0
    26c6:	0b be       	out	0x3b, r0	; 59
    26c8:	07 90       	elpm	r0, Z+
    26ca:	f6 91       	elpm	r31, Z
    26cc:	e0 2d       	mov	r30, r0
    26ce:	09 94       	ijmp

000026d0 <atoi>:
    26d0:	fc 01       	movw	r30, r24
    26d2:	88 27       	eor	r24, r24
    26d4:	99 27       	eor	r25, r25
    26d6:	e8 94       	clt
    26d8:	21 91       	ld	r18, Z+
    26da:	20 32       	cpi	r18, 0x20	; 32
    26dc:	e9 f3       	breq	.-6      	; 0x26d8 <atoi+0x8>
    26de:	29 30       	cpi	r18, 0x09	; 9
    26e0:	10 f0       	brcs	.+4      	; 0x26e6 <atoi+0x16>
    26e2:	2e 30       	cpi	r18, 0x0E	; 14
    26e4:	c8 f3       	brcs	.-14     	; 0x26d8 <atoi+0x8>
    26e6:	2b 32       	cpi	r18, 0x2B	; 43
    26e8:	39 f0       	breq	.+14     	; 0x26f8 <atoi+0x28>
    26ea:	2d 32       	cpi	r18, 0x2D	; 45
    26ec:	31 f4       	brne	.+12     	; 0x26fa <atoi+0x2a>
    26ee:	68 94       	set
    26f0:	03 c0       	rjmp	.+6      	; 0x26f8 <atoi+0x28>
    26f2:	14 d0       	rcall	.+40     	; 0x271c <__mulhi_const_10>
    26f4:	82 0f       	add	r24, r18
    26f6:	91 1d       	adc	r25, r1
    26f8:	21 91       	ld	r18, Z+
    26fa:	20 53       	subi	r18, 0x30	; 48
    26fc:	2a 30       	cpi	r18, 0x0A	; 10
    26fe:	c8 f3       	brcs	.-14     	; 0x26f2 <atoi+0x22>
    2700:	1e f4       	brtc	.+6      	; 0x2708 <atoi+0x38>
    2702:	90 95       	com	r25
    2704:	81 95       	neg	r24
    2706:	9f 4f       	sbci	r25, 0xFF	; 255
    2708:	08 95       	ret

0000270a <strcmp>:
    270a:	fb 01       	movw	r30, r22
    270c:	dc 01       	movw	r26, r24
    270e:	8d 91       	ld	r24, X+
    2710:	01 90       	ld	r0, Z+
    2712:	80 19       	sub	r24, r0
    2714:	01 10       	cpse	r0, r1
    2716:	d9 f3       	breq	.-10     	; 0x270e <strcmp+0x4>
    2718:	99 0b       	sbc	r25, r25
    271a:	08 95       	ret

0000271c <__mulhi_const_10>:
    271c:	7a e0       	ldi	r23, 0x0A	; 10
    271e:	97 9f       	mul	r25, r23
    2720:	90 2d       	mov	r25, r0
    2722:	87 9f       	mul	r24, r23
    2724:	80 2d       	mov	r24, r0
    2726:	91 0d       	add	r25, r1
    2728:	11 24       	eor	r1, r1
    272a:	08 95       	ret

0000272c <printf>:
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
    2734:	ae 01       	movw	r20, r28
    2736:	4b 5f       	subi	r20, 0xFB	; 251
    2738:	5f 4f       	sbci	r21, 0xFF	; 255
    273a:	fa 01       	movw	r30, r20
    273c:	61 91       	ld	r22, Z+
    273e:	71 91       	ld	r23, Z+
    2740:	af 01       	movw	r20, r30
    2742:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <__iob+0x2>
    2746:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <__iob+0x3>
    274a:	38 d0       	rcall	.+112    	; 0x27bc <vfprintf>
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	08 95       	ret

00002752 <putchar>:
    2752:	60 91 47 04 	lds	r22, 0x0447	; 0x800447 <__iob+0x2>
    2756:	70 91 48 04 	lds	r23, 0x0448	; 0x800448 <__iob+0x3>
    275a:	43 c2       	rjmp	.+1158   	; 0x2be2 <fputc>

0000275c <puts>:
    275c:	0f 93       	push	r16
    275e:	1f 93       	push	r17
    2760:	cf 93       	push	r28
    2762:	df 93       	push	r29
    2764:	e0 91 47 04 	lds	r30, 0x0447	; 0x800447 <__iob+0x2>
    2768:	f0 91 48 04 	lds	r31, 0x0448	; 0x800448 <__iob+0x3>
    276c:	23 81       	ldd	r18, Z+3	; 0x03
    276e:	21 ff       	sbrs	r18, 1
    2770:	1b c0       	rjmp	.+54     	; 0x27a8 <puts+0x4c>
    2772:	8c 01       	movw	r16, r24
    2774:	d0 e0       	ldi	r29, 0x00	; 0
    2776:	c0 e0       	ldi	r28, 0x00	; 0
    2778:	f8 01       	movw	r30, r16
    277a:	81 91       	ld	r24, Z+
    277c:	8f 01       	movw	r16, r30
    277e:	60 91 47 04 	lds	r22, 0x0447	; 0x800447 <__iob+0x2>
    2782:	70 91 48 04 	lds	r23, 0x0448	; 0x800448 <__iob+0x3>
    2786:	db 01       	movw	r26, r22
    2788:	18 96       	adiw	r26, 0x08	; 8
    278a:	ed 91       	ld	r30, X+
    278c:	fc 91       	ld	r31, X
    278e:	19 97       	sbiw	r26, 0x09	; 9
    2790:	88 23       	and	r24, r24
    2792:	31 f0       	breq	.+12     	; 0x27a0 <puts+0x44>
    2794:	09 95       	icall
    2796:	89 2b       	or	r24, r25
    2798:	79 f3       	breq	.-34     	; 0x2778 <puts+0x1c>
    279a:	df ef       	ldi	r29, 0xFF	; 255
    279c:	cf ef       	ldi	r28, 0xFF	; 255
    279e:	ec cf       	rjmp	.-40     	; 0x2778 <puts+0x1c>
    27a0:	8a e0       	ldi	r24, 0x0A	; 10
    27a2:	09 95       	icall
    27a4:	89 2b       	or	r24, r25
    27a6:	19 f0       	breq	.+6      	; 0x27ae <puts+0x52>
    27a8:	8f ef       	ldi	r24, 0xFF	; 255
    27aa:	9f ef       	ldi	r25, 0xFF	; 255
    27ac:	02 c0       	rjmp	.+4      	; 0x27b2 <puts+0x56>
    27ae:	8d 2f       	mov	r24, r29
    27b0:	9c 2f       	mov	r25, r28
    27b2:	df 91       	pop	r29
    27b4:	cf 91       	pop	r28
    27b6:	1f 91       	pop	r17
    27b8:	0f 91       	pop	r16
    27ba:	08 95       	ret

000027bc <vfprintf>:
    27bc:	2f 92       	push	r2
    27be:	3f 92       	push	r3
    27c0:	4f 92       	push	r4
    27c2:	5f 92       	push	r5
    27c4:	6f 92       	push	r6
    27c6:	7f 92       	push	r7
    27c8:	8f 92       	push	r8
    27ca:	9f 92       	push	r9
    27cc:	af 92       	push	r10
    27ce:	bf 92       	push	r11
    27d0:	cf 92       	push	r12
    27d2:	df 92       	push	r13
    27d4:	ef 92       	push	r14
    27d6:	ff 92       	push	r15
    27d8:	0f 93       	push	r16
    27da:	1f 93       	push	r17
    27dc:	cf 93       	push	r28
    27de:	df 93       	push	r29
    27e0:	cd b7       	in	r28, 0x3d	; 61
    27e2:	de b7       	in	r29, 0x3e	; 62
    27e4:	2b 97       	sbiw	r28, 0x0b	; 11
    27e6:	0f b6       	in	r0, 0x3f	; 63
    27e8:	f8 94       	cli
    27ea:	de bf       	out	0x3e, r29	; 62
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	cd bf       	out	0x3d, r28	; 61
    27f0:	6c 01       	movw	r12, r24
    27f2:	7b 01       	movw	r14, r22
    27f4:	8a 01       	movw	r16, r20
    27f6:	fc 01       	movw	r30, r24
    27f8:	17 82       	std	Z+7, r1	; 0x07
    27fa:	16 82       	std	Z+6, r1	; 0x06
    27fc:	83 81       	ldd	r24, Z+3	; 0x03
    27fe:	81 ff       	sbrs	r24, 1
    2800:	bf c1       	rjmp	.+894    	; 0x2b80 <vfprintf+0x3c4>
    2802:	ce 01       	movw	r24, r28
    2804:	01 96       	adiw	r24, 0x01	; 1
    2806:	3c 01       	movw	r6, r24
    2808:	f6 01       	movw	r30, r12
    280a:	93 81       	ldd	r25, Z+3	; 0x03
    280c:	f7 01       	movw	r30, r14
    280e:	93 fd       	sbrc	r25, 3
    2810:	85 91       	lpm	r24, Z+
    2812:	93 ff       	sbrs	r25, 3
    2814:	81 91       	ld	r24, Z+
    2816:	7f 01       	movw	r14, r30
    2818:	88 23       	and	r24, r24
    281a:	09 f4       	brne	.+2      	; 0x281e <vfprintf+0x62>
    281c:	ad c1       	rjmp	.+858    	; 0x2b78 <vfprintf+0x3bc>
    281e:	85 32       	cpi	r24, 0x25	; 37
    2820:	39 f4       	brne	.+14     	; 0x2830 <vfprintf+0x74>
    2822:	93 fd       	sbrc	r25, 3
    2824:	85 91       	lpm	r24, Z+
    2826:	93 ff       	sbrs	r25, 3
    2828:	81 91       	ld	r24, Z+
    282a:	7f 01       	movw	r14, r30
    282c:	85 32       	cpi	r24, 0x25	; 37
    282e:	21 f4       	brne	.+8      	; 0x2838 <vfprintf+0x7c>
    2830:	b6 01       	movw	r22, r12
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	d6 d1       	rcall	.+940    	; 0x2be2 <fputc>
    2836:	e8 cf       	rjmp	.-48     	; 0x2808 <vfprintf+0x4c>
    2838:	91 2c       	mov	r9, r1
    283a:	21 2c       	mov	r2, r1
    283c:	31 2c       	mov	r3, r1
    283e:	ff e1       	ldi	r31, 0x1F	; 31
    2840:	f3 15       	cp	r31, r3
    2842:	d8 f0       	brcs	.+54     	; 0x287a <vfprintf+0xbe>
    2844:	8b 32       	cpi	r24, 0x2B	; 43
    2846:	79 f0       	breq	.+30     	; 0x2866 <vfprintf+0xaa>
    2848:	38 f4       	brcc	.+14     	; 0x2858 <vfprintf+0x9c>
    284a:	80 32       	cpi	r24, 0x20	; 32
    284c:	79 f0       	breq	.+30     	; 0x286c <vfprintf+0xb0>
    284e:	83 32       	cpi	r24, 0x23	; 35
    2850:	a1 f4       	brne	.+40     	; 0x287a <vfprintf+0xbe>
    2852:	23 2d       	mov	r18, r3
    2854:	20 61       	ori	r18, 0x10	; 16
    2856:	1d c0       	rjmp	.+58     	; 0x2892 <vfprintf+0xd6>
    2858:	8d 32       	cpi	r24, 0x2D	; 45
    285a:	61 f0       	breq	.+24     	; 0x2874 <vfprintf+0xb8>
    285c:	80 33       	cpi	r24, 0x30	; 48
    285e:	69 f4       	brne	.+26     	; 0x287a <vfprintf+0xbe>
    2860:	23 2d       	mov	r18, r3
    2862:	21 60       	ori	r18, 0x01	; 1
    2864:	16 c0       	rjmp	.+44     	; 0x2892 <vfprintf+0xd6>
    2866:	83 2d       	mov	r24, r3
    2868:	82 60       	ori	r24, 0x02	; 2
    286a:	38 2e       	mov	r3, r24
    286c:	e3 2d       	mov	r30, r3
    286e:	e4 60       	ori	r30, 0x04	; 4
    2870:	3e 2e       	mov	r3, r30
    2872:	2a c0       	rjmp	.+84     	; 0x28c8 <vfprintf+0x10c>
    2874:	f3 2d       	mov	r31, r3
    2876:	f8 60       	ori	r31, 0x08	; 8
    2878:	1d c0       	rjmp	.+58     	; 0x28b4 <vfprintf+0xf8>
    287a:	37 fc       	sbrc	r3, 7
    287c:	2d c0       	rjmp	.+90     	; 0x28d8 <vfprintf+0x11c>
    287e:	20 ed       	ldi	r18, 0xD0	; 208
    2880:	28 0f       	add	r18, r24
    2882:	2a 30       	cpi	r18, 0x0A	; 10
    2884:	40 f0       	brcs	.+16     	; 0x2896 <vfprintf+0xda>
    2886:	8e 32       	cpi	r24, 0x2E	; 46
    2888:	b9 f4       	brne	.+46     	; 0x28b8 <vfprintf+0xfc>
    288a:	36 fc       	sbrc	r3, 6
    288c:	75 c1       	rjmp	.+746    	; 0x2b78 <vfprintf+0x3bc>
    288e:	23 2d       	mov	r18, r3
    2890:	20 64       	ori	r18, 0x40	; 64
    2892:	32 2e       	mov	r3, r18
    2894:	19 c0       	rjmp	.+50     	; 0x28c8 <vfprintf+0x10c>
    2896:	36 fe       	sbrs	r3, 6
    2898:	06 c0       	rjmp	.+12     	; 0x28a6 <vfprintf+0xea>
    289a:	8a e0       	ldi	r24, 0x0A	; 10
    289c:	98 9e       	mul	r9, r24
    289e:	20 0d       	add	r18, r0
    28a0:	11 24       	eor	r1, r1
    28a2:	92 2e       	mov	r9, r18
    28a4:	11 c0       	rjmp	.+34     	; 0x28c8 <vfprintf+0x10c>
    28a6:	ea e0       	ldi	r30, 0x0A	; 10
    28a8:	2e 9e       	mul	r2, r30
    28aa:	20 0d       	add	r18, r0
    28ac:	11 24       	eor	r1, r1
    28ae:	22 2e       	mov	r2, r18
    28b0:	f3 2d       	mov	r31, r3
    28b2:	f0 62       	ori	r31, 0x20	; 32
    28b4:	3f 2e       	mov	r3, r31
    28b6:	08 c0       	rjmp	.+16     	; 0x28c8 <vfprintf+0x10c>
    28b8:	8c 36       	cpi	r24, 0x6C	; 108
    28ba:	21 f4       	brne	.+8      	; 0x28c4 <vfprintf+0x108>
    28bc:	83 2d       	mov	r24, r3
    28be:	80 68       	ori	r24, 0x80	; 128
    28c0:	38 2e       	mov	r3, r24
    28c2:	02 c0       	rjmp	.+4      	; 0x28c8 <vfprintf+0x10c>
    28c4:	88 36       	cpi	r24, 0x68	; 104
    28c6:	41 f4       	brne	.+16     	; 0x28d8 <vfprintf+0x11c>
    28c8:	f7 01       	movw	r30, r14
    28ca:	93 fd       	sbrc	r25, 3
    28cc:	85 91       	lpm	r24, Z+
    28ce:	93 ff       	sbrs	r25, 3
    28d0:	81 91       	ld	r24, Z+
    28d2:	7f 01       	movw	r14, r30
    28d4:	81 11       	cpse	r24, r1
    28d6:	b3 cf       	rjmp	.-154    	; 0x283e <vfprintf+0x82>
    28d8:	98 2f       	mov	r25, r24
    28da:	9f 7d       	andi	r25, 0xDF	; 223
    28dc:	95 54       	subi	r25, 0x45	; 69
    28de:	93 30       	cpi	r25, 0x03	; 3
    28e0:	28 f4       	brcc	.+10     	; 0x28ec <vfprintf+0x130>
    28e2:	0c 5f       	subi	r16, 0xFC	; 252
    28e4:	1f 4f       	sbci	r17, 0xFF	; 255
    28e6:	9f e3       	ldi	r25, 0x3F	; 63
    28e8:	99 83       	std	Y+1, r25	; 0x01
    28ea:	0d c0       	rjmp	.+26     	; 0x2906 <vfprintf+0x14a>
    28ec:	83 36       	cpi	r24, 0x63	; 99
    28ee:	31 f0       	breq	.+12     	; 0x28fc <vfprintf+0x140>
    28f0:	83 37       	cpi	r24, 0x73	; 115
    28f2:	71 f0       	breq	.+28     	; 0x2910 <vfprintf+0x154>
    28f4:	83 35       	cpi	r24, 0x53	; 83
    28f6:	09 f0       	breq	.+2      	; 0x28fa <vfprintf+0x13e>
    28f8:	55 c0       	rjmp	.+170    	; 0x29a4 <vfprintf+0x1e8>
    28fa:	20 c0       	rjmp	.+64     	; 0x293c <vfprintf+0x180>
    28fc:	f8 01       	movw	r30, r16
    28fe:	80 81       	ld	r24, Z
    2900:	89 83       	std	Y+1, r24	; 0x01
    2902:	0e 5f       	subi	r16, 0xFE	; 254
    2904:	1f 4f       	sbci	r17, 0xFF	; 255
    2906:	88 24       	eor	r8, r8
    2908:	83 94       	inc	r8
    290a:	91 2c       	mov	r9, r1
    290c:	53 01       	movw	r10, r6
    290e:	12 c0       	rjmp	.+36     	; 0x2934 <vfprintf+0x178>
    2910:	28 01       	movw	r4, r16
    2912:	f2 e0       	ldi	r31, 0x02	; 2
    2914:	4f 0e       	add	r4, r31
    2916:	51 1c       	adc	r5, r1
    2918:	f8 01       	movw	r30, r16
    291a:	a0 80       	ld	r10, Z
    291c:	b1 80       	ldd	r11, Z+1	; 0x01
    291e:	36 fe       	sbrs	r3, 6
    2920:	03 c0       	rjmp	.+6      	; 0x2928 <vfprintf+0x16c>
    2922:	69 2d       	mov	r22, r9
    2924:	70 e0       	ldi	r23, 0x00	; 0
    2926:	02 c0       	rjmp	.+4      	; 0x292c <vfprintf+0x170>
    2928:	6f ef       	ldi	r22, 0xFF	; 255
    292a:	7f ef       	ldi	r23, 0xFF	; 255
    292c:	c5 01       	movw	r24, r10
    292e:	4e d1       	rcall	.+668    	; 0x2bcc <strnlen>
    2930:	4c 01       	movw	r8, r24
    2932:	82 01       	movw	r16, r4
    2934:	f3 2d       	mov	r31, r3
    2936:	ff 77       	andi	r31, 0x7F	; 127
    2938:	3f 2e       	mov	r3, r31
    293a:	15 c0       	rjmp	.+42     	; 0x2966 <vfprintf+0x1aa>
    293c:	28 01       	movw	r4, r16
    293e:	22 e0       	ldi	r18, 0x02	; 2
    2940:	42 0e       	add	r4, r18
    2942:	51 1c       	adc	r5, r1
    2944:	f8 01       	movw	r30, r16
    2946:	a0 80       	ld	r10, Z
    2948:	b1 80       	ldd	r11, Z+1	; 0x01
    294a:	36 fe       	sbrs	r3, 6
    294c:	03 c0       	rjmp	.+6      	; 0x2954 <vfprintf+0x198>
    294e:	69 2d       	mov	r22, r9
    2950:	70 e0       	ldi	r23, 0x00	; 0
    2952:	02 c0       	rjmp	.+4      	; 0x2958 <vfprintf+0x19c>
    2954:	6f ef       	ldi	r22, 0xFF	; 255
    2956:	7f ef       	ldi	r23, 0xFF	; 255
    2958:	c5 01       	movw	r24, r10
    295a:	2d d1       	rcall	.+602    	; 0x2bb6 <strnlen_P>
    295c:	4c 01       	movw	r8, r24
    295e:	f3 2d       	mov	r31, r3
    2960:	f0 68       	ori	r31, 0x80	; 128
    2962:	3f 2e       	mov	r3, r31
    2964:	82 01       	movw	r16, r4
    2966:	33 fc       	sbrc	r3, 3
    2968:	19 c0       	rjmp	.+50     	; 0x299c <vfprintf+0x1e0>
    296a:	82 2d       	mov	r24, r2
    296c:	90 e0       	ldi	r25, 0x00	; 0
    296e:	88 16       	cp	r8, r24
    2970:	99 06       	cpc	r9, r25
    2972:	a0 f4       	brcc	.+40     	; 0x299c <vfprintf+0x1e0>
    2974:	b6 01       	movw	r22, r12
    2976:	80 e2       	ldi	r24, 0x20	; 32
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	33 d1       	rcall	.+614    	; 0x2be2 <fputc>
    297c:	2a 94       	dec	r2
    297e:	f5 cf       	rjmp	.-22     	; 0x296a <vfprintf+0x1ae>
    2980:	f5 01       	movw	r30, r10
    2982:	37 fc       	sbrc	r3, 7
    2984:	85 91       	lpm	r24, Z+
    2986:	37 fe       	sbrs	r3, 7
    2988:	81 91       	ld	r24, Z+
    298a:	5f 01       	movw	r10, r30
    298c:	b6 01       	movw	r22, r12
    298e:	90 e0       	ldi	r25, 0x00	; 0
    2990:	28 d1       	rcall	.+592    	; 0x2be2 <fputc>
    2992:	21 10       	cpse	r2, r1
    2994:	2a 94       	dec	r2
    2996:	21 e0       	ldi	r18, 0x01	; 1
    2998:	82 1a       	sub	r8, r18
    299a:	91 08       	sbc	r9, r1
    299c:	81 14       	cp	r8, r1
    299e:	91 04       	cpc	r9, r1
    29a0:	79 f7       	brne	.-34     	; 0x2980 <vfprintf+0x1c4>
    29a2:	e1 c0       	rjmp	.+450    	; 0x2b66 <vfprintf+0x3aa>
    29a4:	84 36       	cpi	r24, 0x64	; 100
    29a6:	11 f0       	breq	.+4      	; 0x29ac <vfprintf+0x1f0>
    29a8:	89 36       	cpi	r24, 0x69	; 105
    29aa:	39 f5       	brne	.+78     	; 0x29fa <vfprintf+0x23e>
    29ac:	f8 01       	movw	r30, r16
    29ae:	37 fe       	sbrs	r3, 7
    29b0:	07 c0       	rjmp	.+14     	; 0x29c0 <vfprintf+0x204>
    29b2:	60 81       	ld	r22, Z
    29b4:	71 81       	ldd	r23, Z+1	; 0x01
    29b6:	82 81       	ldd	r24, Z+2	; 0x02
    29b8:	93 81       	ldd	r25, Z+3	; 0x03
    29ba:	0c 5f       	subi	r16, 0xFC	; 252
    29bc:	1f 4f       	sbci	r17, 0xFF	; 255
    29be:	08 c0       	rjmp	.+16     	; 0x29d0 <vfprintf+0x214>
    29c0:	60 81       	ld	r22, Z
    29c2:	71 81       	ldd	r23, Z+1	; 0x01
    29c4:	07 2e       	mov	r0, r23
    29c6:	00 0c       	add	r0, r0
    29c8:	88 0b       	sbc	r24, r24
    29ca:	99 0b       	sbc	r25, r25
    29cc:	0e 5f       	subi	r16, 0xFE	; 254
    29ce:	1f 4f       	sbci	r17, 0xFF	; 255
    29d0:	f3 2d       	mov	r31, r3
    29d2:	ff 76       	andi	r31, 0x6F	; 111
    29d4:	3f 2e       	mov	r3, r31
    29d6:	97 ff       	sbrs	r25, 7
    29d8:	09 c0       	rjmp	.+18     	; 0x29ec <vfprintf+0x230>
    29da:	90 95       	com	r25
    29dc:	80 95       	com	r24
    29de:	70 95       	com	r23
    29e0:	61 95       	neg	r22
    29e2:	7f 4f       	sbci	r23, 0xFF	; 255
    29e4:	8f 4f       	sbci	r24, 0xFF	; 255
    29e6:	9f 4f       	sbci	r25, 0xFF	; 255
    29e8:	f0 68       	ori	r31, 0x80	; 128
    29ea:	3f 2e       	mov	r3, r31
    29ec:	2a e0       	ldi	r18, 0x0A	; 10
    29ee:	30 e0       	ldi	r19, 0x00	; 0
    29f0:	a3 01       	movw	r20, r6
    29f2:	33 d1       	rcall	.+614    	; 0x2c5a <__ultoa_invert>
    29f4:	88 2e       	mov	r8, r24
    29f6:	86 18       	sub	r8, r6
    29f8:	44 c0       	rjmp	.+136    	; 0x2a82 <vfprintf+0x2c6>
    29fa:	85 37       	cpi	r24, 0x75	; 117
    29fc:	31 f4       	brne	.+12     	; 0x2a0a <vfprintf+0x24e>
    29fe:	23 2d       	mov	r18, r3
    2a00:	2f 7e       	andi	r18, 0xEF	; 239
    2a02:	b2 2e       	mov	r11, r18
    2a04:	2a e0       	ldi	r18, 0x0A	; 10
    2a06:	30 e0       	ldi	r19, 0x00	; 0
    2a08:	25 c0       	rjmp	.+74     	; 0x2a54 <vfprintf+0x298>
    2a0a:	93 2d       	mov	r25, r3
    2a0c:	99 7f       	andi	r25, 0xF9	; 249
    2a0e:	b9 2e       	mov	r11, r25
    2a10:	8f 36       	cpi	r24, 0x6F	; 111
    2a12:	c1 f0       	breq	.+48     	; 0x2a44 <vfprintf+0x288>
    2a14:	18 f4       	brcc	.+6      	; 0x2a1c <vfprintf+0x260>
    2a16:	88 35       	cpi	r24, 0x58	; 88
    2a18:	79 f0       	breq	.+30     	; 0x2a38 <vfprintf+0x27c>
    2a1a:	ae c0       	rjmp	.+348    	; 0x2b78 <vfprintf+0x3bc>
    2a1c:	80 37       	cpi	r24, 0x70	; 112
    2a1e:	19 f0       	breq	.+6      	; 0x2a26 <vfprintf+0x26a>
    2a20:	88 37       	cpi	r24, 0x78	; 120
    2a22:	21 f0       	breq	.+8      	; 0x2a2c <vfprintf+0x270>
    2a24:	a9 c0       	rjmp	.+338    	; 0x2b78 <vfprintf+0x3bc>
    2a26:	e9 2f       	mov	r30, r25
    2a28:	e0 61       	ori	r30, 0x10	; 16
    2a2a:	be 2e       	mov	r11, r30
    2a2c:	b4 fe       	sbrs	r11, 4
    2a2e:	0d c0       	rjmp	.+26     	; 0x2a4a <vfprintf+0x28e>
    2a30:	fb 2d       	mov	r31, r11
    2a32:	f4 60       	ori	r31, 0x04	; 4
    2a34:	bf 2e       	mov	r11, r31
    2a36:	09 c0       	rjmp	.+18     	; 0x2a4a <vfprintf+0x28e>
    2a38:	34 fe       	sbrs	r3, 4
    2a3a:	0a c0       	rjmp	.+20     	; 0x2a50 <vfprintf+0x294>
    2a3c:	29 2f       	mov	r18, r25
    2a3e:	26 60       	ori	r18, 0x06	; 6
    2a40:	b2 2e       	mov	r11, r18
    2a42:	06 c0       	rjmp	.+12     	; 0x2a50 <vfprintf+0x294>
    2a44:	28 e0       	ldi	r18, 0x08	; 8
    2a46:	30 e0       	ldi	r19, 0x00	; 0
    2a48:	05 c0       	rjmp	.+10     	; 0x2a54 <vfprintf+0x298>
    2a4a:	20 e1       	ldi	r18, 0x10	; 16
    2a4c:	30 e0       	ldi	r19, 0x00	; 0
    2a4e:	02 c0       	rjmp	.+4      	; 0x2a54 <vfprintf+0x298>
    2a50:	20 e1       	ldi	r18, 0x10	; 16
    2a52:	32 e0       	ldi	r19, 0x02	; 2
    2a54:	f8 01       	movw	r30, r16
    2a56:	b7 fe       	sbrs	r11, 7
    2a58:	07 c0       	rjmp	.+14     	; 0x2a68 <vfprintf+0x2ac>
    2a5a:	60 81       	ld	r22, Z
    2a5c:	71 81       	ldd	r23, Z+1	; 0x01
    2a5e:	82 81       	ldd	r24, Z+2	; 0x02
    2a60:	93 81       	ldd	r25, Z+3	; 0x03
    2a62:	0c 5f       	subi	r16, 0xFC	; 252
    2a64:	1f 4f       	sbci	r17, 0xFF	; 255
    2a66:	06 c0       	rjmp	.+12     	; 0x2a74 <vfprintf+0x2b8>
    2a68:	60 81       	ld	r22, Z
    2a6a:	71 81       	ldd	r23, Z+1	; 0x01
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	0e 5f       	subi	r16, 0xFE	; 254
    2a72:	1f 4f       	sbci	r17, 0xFF	; 255
    2a74:	a3 01       	movw	r20, r6
    2a76:	f1 d0       	rcall	.+482    	; 0x2c5a <__ultoa_invert>
    2a78:	88 2e       	mov	r8, r24
    2a7a:	86 18       	sub	r8, r6
    2a7c:	fb 2d       	mov	r31, r11
    2a7e:	ff 77       	andi	r31, 0x7F	; 127
    2a80:	3f 2e       	mov	r3, r31
    2a82:	36 fe       	sbrs	r3, 6
    2a84:	0d c0       	rjmp	.+26     	; 0x2aa0 <vfprintf+0x2e4>
    2a86:	23 2d       	mov	r18, r3
    2a88:	2e 7f       	andi	r18, 0xFE	; 254
    2a8a:	a2 2e       	mov	r10, r18
    2a8c:	89 14       	cp	r8, r9
    2a8e:	58 f4       	brcc	.+22     	; 0x2aa6 <vfprintf+0x2ea>
    2a90:	34 fe       	sbrs	r3, 4
    2a92:	0b c0       	rjmp	.+22     	; 0x2aaa <vfprintf+0x2ee>
    2a94:	32 fc       	sbrc	r3, 2
    2a96:	09 c0       	rjmp	.+18     	; 0x2aaa <vfprintf+0x2ee>
    2a98:	83 2d       	mov	r24, r3
    2a9a:	8e 7e       	andi	r24, 0xEE	; 238
    2a9c:	a8 2e       	mov	r10, r24
    2a9e:	05 c0       	rjmp	.+10     	; 0x2aaa <vfprintf+0x2ee>
    2aa0:	b8 2c       	mov	r11, r8
    2aa2:	a3 2c       	mov	r10, r3
    2aa4:	03 c0       	rjmp	.+6      	; 0x2aac <vfprintf+0x2f0>
    2aa6:	b8 2c       	mov	r11, r8
    2aa8:	01 c0       	rjmp	.+2      	; 0x2aac <vfprintf+0x2f0>
    2aaa:	b9 2c       	mov	r11, r9
    2aac:	a4 fe       	sbrs	r10, 4
    2aae:	0f c0       	rjmp	.+30     	; 0x2ace <vfprintf+0x312>
    2ab0:	fe 01       	movw	r30, r28
    2ab2:	e8 0d       	add	r30, r8
    2ab4:	f1 1d       	adc	r31, r1
    2ab6:	80 81       	ld	r24, Z
    2ab8:	80 33       	cpi	r24, 0x30	; 48
    2aba:	21 f4       	brne	.+8      	; 0x2ac4 <vfprintf+0x308>
    2abc:	9a 2d       	mov	r25, r10
    2abe:	99 7e       	andi	r25, 0xE9	; 233
    2ac0:	a9 2e       	mov	r10, r25
    2ac2:	09 c0       	rjmp	.+18     	; 0x2ad6 <vfprintf+0x31a>
    2ac4:	a2 fe       	sbrs	r10, 2
    2ac6:	06 c0       	rjmp	.+12     	; 0x2ad4 <vfprintf+0x318>
    2ac8:	b3 94       	inc	r11
    2aca:	b3 94       	inc	r11
    2acc:	04 c0       	rjmp	.+8      	; 0x2ad6 <vfprintf+0x31a>
    2ace:	8a 2d       	mov	r24, r10
    2ad0:	86 78       	andi	r24, 0x86	; 134
    2ad2:	09 f0       	breq	.+2      	; 0x2ad6 <vfprintf+0x31a>
    2ad4:	b3 94       	inc	r11
    2ad6:	a3 fc       	sbrc	r10, 3
    2ad8:	10 c0       	rjmp	.+32     	; 0x2afa <vfprintf+0x33e>
    2ada:	a0 fe       	sbrs	r10, 0
    2adc:	06 c0       	rjmp	.+12     	; 0x2aea <vfprintf+0x32e>
    2ade:	b2 14       	cp	r11, r2
    2ae0:	80 f4       	brcc	.+32     	; 0x2b02 <vfprintf+0x346>
    2ae2:	28 0c       	add	r2, r8
    2ae4:	92 2c       	mov	r9, r2
    2ae6:	9b 18       	sub	r9, r11
    2ae8:	0d c0       	rjmp	.+26     	; 0x2b04 <vfprintf+0x348>
    2aea:	b2 14       	cp	r11, r2
    2aec:	58 f4       	brcc	.+22     	; 0x2b04 <vfprintf+0x348>
    2aee:	b6 01       	movw	r22, r12
    2af0:	80 e2       	ldi	r24, 0x20	; 32
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	76 d0       	rcall	.+236    	; 0x2be2 <fputc>
    2af6:	b3 94       	inc	r11
    2af8:	f8 cf       	rjmp	.-16     	; 0x2aea <vfprintf+0x32e>
    2afa:	b2 14       	cp	r11, r2
    2afc:	18 f4       	brcc	.+6      	; 0x2b04 <vfprintf+0x348>
    2afe:	2b 18       	sub	r2, r11
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <vfprintf+0x34a>
    2b02:	98 2c       	mov	r9, r8
    2b04:	21 2c       	mov	r2, r1
    2b06:	a4 fe       	sbrs	r10, 4
    2b08:	0f c0       	rjmp	.+30     	; 0x2b28 <vfprintf+0x36c>
    2b0a:	b6 01       	movw	r22, r12
    2b0c:	80 e3       	ldi	r24, 0x30	; 48
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	68 d0       	rcall	.+208    	; 0x2be2 <fputc>
    2b12:	a2 fe       	sbrs	r10, 2
    2b14:	16 c0       	rjmp	.+44     	; 0x2b42 <vfprintf+0x386>
    2b16:	a1 fc       	sbrc	r10, 1
    2b18:	03 c0       	rjmp	.+6      	; 0x2b20 <vfprintf+0x364>
    2b1a:	88 e7       	ldi	r24, 0x78	; 120
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	02 c0       	rjmp	.+4      	; 0x2b24 <vfprintf+0x368>
    2b20:	88 e5       	ldi	r24, 0x58	; 88
    2b22:	90 e0       	ldi	r25, 0x00	; 0
    2b24:	b6 01       	movw	r22, r12
    2b26:	0c c0       	rjmp	.+24     	; 0x2b40 <vfprintf+0x384>
    2b28:	8a 2d       	mov	r24, r10
    2b2a:	86 78       	andi	r24, 0x86	; 134
    2b2c:	51 f0       	breq	.+20     	; 0x2b42 <vfprintf+0x386>
    2b2e:	a1 fe       	sbrs	r10, 1
    2b30:	02 c0       	rjmp	.+4      	; 0x2b36 <vfprintf+0x37a>
    2b32:	8b e2       	ldi	r24, 0x2B	; 43
    2b34:	01 c0       	rjmp	.+2      	; 0x2b38 <vfprintf+0x37c>
    2b36:	80 e2       	ldi	r24, 0x20	; 32
    2b38:	a7 fc       	sbrc	r10, 7
    2b3a:	8d e2       	ldi	r24, 0x2D	; 45
    2b3c:	b6 01       	movw	r22, r12
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	50 d0       	rcall	.+160    	; 0x2be2 <fputc>
    2b42:	89 14       	cp	r8, r9
    2b44:	30 f4       	brcc	.+12     	; 0x2b52 <vfprintf+0x396>
    2b46:	b6 01       	movw	r22, r12
    2b48:	80 e3       	ldi	r24, 0x30	; 48
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	4a d0       	rcall	.+148    	; 0x2be2 <fputc>
    2b4e:	9a 94       	dec	r9
    2b50:	f8 cf       	rjmp	.-16     	; 0x2b42 <vfprintf+0x386>
    2b52:	8a 94       	dec	r8
    2b54:	f3 01       	movw	r30, r6
    2b56:	e8 0d       	add	r30, r8
    2b58:	f1 1d       	adc	r31, r1
    2b5a:	80 81       	ld	r24, Z
    2b5c:	b6 01       	movw	r22, r12
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	40 d0       	rcall	.+128    	; 0x2be2 <fputc>
    2b62:	81 10       	cpse	r8, r1
    2b64:	f6 cf       	rjmp	.-20     	; 0x2b52 <vfprintf+0x396>
    2b66:	22 20       	and	r2, r2
    2b68:	09 f4       	brne	.+2      	; 0x2b6c <vfprintf+0x3b0>
    2b6a:	4e ce       	rjmp	.-868    	; 0x2808 <vfprintf+0x4c>
    2b6c:	b6 01       	movw	r22, r12
    2b6e:	80 e2       	ldi	r24, 0x20	; 32
    2b70:	90 e0       	ldi	r25, 0x00	; 0
    2b72:	37 d0       	rcall	.+110    	; 0x2be2 <fputc>
    2b74:	2a 94       	dec	r2
    2b76:	f7 cf       	rjmp	.-18     	; 0x2b66 <vfprintf+0x3aa>
    2b78:	f6 01       	movw	r30, r12
    2b7a:	86 81       	ldd	r24, Z+6	; 0x06
    2b7c:	97 81       	ldd	r25, Z+7	; 0x07
    2b7e:	02 c0       	rjmp	.+4      	; 0x2b84 <vfprintf+0x3c8>
    2b80:	8f ef       	ldi	r24, 0xFF	; 255
    2b82:	9f ef       	ldi	r25, 0xFF	; 255
    2b84:	2b 96       	adiw	r28, 0x0b	; 11
    2b86:	0f b6       	in	r0, 0x3f	; 63
    2b88:	f8 94       	cli
    2b8a:	de bf       	out	0x3e, r29	; 62
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	cd bf       	out	0x3d, r28	; 61
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	ff 90       	pop	r15
    2b9a:	ef 90       	pop	r14
    2b9c:	df 90       	pop	r13
    2b9e:	cf 90       	pop	r12
    2ba0:	bf 90       	pop	r11
    2ba2:	af 90       	pop	r10
    2ba4:	9f 90       	pop	r9
    2ba6:	8f 90       	pop	r8
    2ba8:	7f 90       	pop	r7
    2baa:	6f 90       	pop	r6
    2bac:	5f 90       	pop	r5
    2bae:	4f 90       	pop	r4
    2bb0:	3f 90       	pop	r3
    2bb2:	2f 90       	pop	r2
    2bb4:	08 95       	ret

00002bb6 <strnlen_P>:
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	05 90       	lpm	r0, Z+
    2bba:	61 50       	subi	r22, 0x01	; 1
    2bbc:	70 40       	sbci	r23, 0x00	; 0
    2bbe:	01 10       	cpse	r0, r1
    2bc0:	d8 f7       	brcc	.-10     	; 0x2bb8 <strnlen_P+0x2>
    2bc2:	80 95       	com	r24
    2bc4:	90 95       	com	r25
    2bc6:	8e 0f       	add	r24, r30
    2bc8:	9f 1f       	adc	r25, r31
    2bca:	08 95       	ret

00002bcc <strnlen>:
    2bcc:	fc 01       	movw	r30, r24
    2bce:	61 50       	subi	r22, 0x01	; 1
    2bd0:	70 40       	sbci	r23, 0x00	; 0
    2bd2:	01 90       	ld	r0, Z+
    2bd4:	01 10       	cpse	r0, r1
    2bd6:	d8 f7       	brcc	.-10     	; 0x2bce <strnlen+0x2>
    2bd8:	80 95       	com	r24
    2bda:	90 95       	com	r25
    2bdc:	8e 0f       	add	r24, r30
    2bde:	9f 1f       	adc	r25, r31
    2be0:	08 95       	ret

00002be2 <fputc>:
    2be2:	0f 93       	push	r16
    2be4:	1f 93       	push	r17
    2be6:	cf 93       	push	r28
    2be8:	df 93       	push	r29
    2bea:	fb 01       	movw	r30, r22
    2bec:	23 81       	ldd	r18, Z+3	; 0x03
    2bee:	21 fd       	sbrc	r18, 1
    2bf0:	03 c0       	rjmp	.+6      	; 0x2bf8 <fputc+0x16>
    2bf2:	8f ef       	ldi	r24, 0xFF	; 255
    2bf4:	9f ef       	ldi	r25, 0xFF	; 255
    2bf6:	2c c0       	rjmp	.+88     	; 0x2c50 <fputc+0x6e>
    2bf8:	22 ff       	sbrs	r18, 2
    2bfa:	16 c0       	rjmp	.+44     	; 0x2c28 <fputc+0x46>
    2bfc:	46 81       	ldd	r20, Z+6	; 0x06
    2bfe:	57 81       	ldd	r21, Z+7	; 0x07
    2c00:	24 81       	ldd	r18, Z+4	; 0x04
    2c02:	35 81       	ldd	r19, Z+5	; 0x05
    2c04:	42 17       	cp	r20, r18
    2c06:	53 07       	cpc	r21, r19
    2c08:	44 f4       	brge	.+16     	; 0x2c1a <fputc+0x38>
    2c0a:	a0 81       	ld	r26, Z
    2c0c:	b1 81       	ldd	r27, Z+1	; 0x01
    2c0e:	9d 01       	movw	r18, r26
    2c10:	2f 5f       	subi	r18, 0xFF	; 255
    2c12:	3f 4f       	sbci	r19, 0xFF	; 255
    2c14:	31 83       	std	Z+1, r19	; 0x01
    2c16:	20 83       	st	Z, r18
    2c18:	8c 93       	st	X, r24
    2c1a:	26 81       	ldd	r18, Z+6	; 0x06
    2c1c:	37 81       	ldd	r19, Z+7	; 0x07
    2c1e:	2f 5f       	subi	r18, 0xFF	; 255
    2c20:	3f 4f       	sbci	r19, 0xFF	; 255
    2c22:	37 83       	std	Z+7, r19	; 0x07
    2c24:	26 83       	std	Z+6, r18	; 0x06
    2c26:	14 c0       	rjmp	.+40     	; 0x2c50 <fputc+0x6e>
    2c28:	8b 01       	movw	r16, r22
    2c2a:	ec 01       	movw	r28, r24
    2c2c:	fb 01       	movw	r30, r22
    2c2e:	00 84       	ldd	r0, Z+8	; 0x08
    2c30:	f1 85       	ldd	r31, Z+9	; 0x09
    2c32:	e0 2d       	mov	r30, r0
    2c34:	09 95       	icall
    2c36:	89 2b       	or	r24, r25
    2c38:	e1 f6       	brne	.-72     	; 0x2bf2 <fputc+0x10>
    2c3a:	d8 01       	movw	r26, r16
    2c3c:	16 96       	adiw	r26, 0x06	; 6
    2c3e:	8d 91       	ld	r24, X+
    2c40:	9c 91       	ld	r25, X
    2c42:	17 97       	sbiw	r26, 0x07	; 7
    2c44:	01 96       	adiw	r24, 0x01	; 1
    2c46:	17 96       	adiw	r26, 0x07	; 7
    2c48:	9c 93       	st	X, r25
    2c4a:	8e 93       	st	-X, r24
    2c4c:	16 97       	sbiw	r26, 0x06	; 6
    2c4e:	ce 01       	movw	r24, r28
    2c50:	df 91       	pop	r29
    2c52:	cf 91       	pop	r28
    2c54:	1f 91       	pop	r17
    2c56:	0f 91       	pop	r16
    2c58:	08 95       	ret

00002c5a <__ultoa_invert>:
    2c5a:	fa 01       	movw	r30, r20
    2c5c:	aa 27       	eor	r26, r26
    2c5e:	28 30       	cpi	r18, 0x08	; 8
    2c60:	51 f1       	breq	.+84     	; 0x2cb6 <__ultoa_invert+0x5c>
    2c62:	20 31       	cpi	r18, 0x10	; 16
    2c64:	81 f1       	breq	.+96     	; 0x2cc6 <__ultoa_invert+0x6c>
    2c66:	e8 94       	clt
    2c68:	6f 93       	push	r22
    2c6a:	6e 7f       	andi	r22, 0xFE	; 254
    2c6c:	6e 5f       	subi	r22, 0xFE	; 254
    2c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c70:	8f 4f       	sbci	r24, 0xFF	; 255
    2c72:	9f 4f       	sbci	r25, 0xFF	; 255
    2c74:	af 4f       	sbci	r26, 0xFF	; 255
    2c76:	b1 e0       	ldi	r27, 0x01	; 1
    2c78:	3e d0       	rcall	.+124    	; 0x2cf6 <__ultoa_invert+0x9c>
    2c7a:	b4 e0       	ldi	r27, 0x04	; 4
    2c7c:	3c d0       	rcall	.+120    	; 0x2cf6 <__ultoa_invert+0x9c>
    2c7e:	67 0f       	add	r22, r23
    2c80:	78 1f       	adc	r23, r24
    2c82:	89 1f       	adc	r24, r25
    2c84:	9a 1f       	adc	r25, r26
    2c86:	a1 1d       	adc	r26, r1
    2c88:	68 0f       	add	r22, r24
    2c8a:	79 1f       	adc	r23, r25
    2c8c:	8a 1f       	adc	r24, r26
    2c8e:	91 1d       	adc	r25, r1
    2c90:	a1 1d       	adc	r26, r1
    2c92:	6a 0f       	add	r22, r26
    2c94:	71 1d       	adc	r23, r1
    2c96:	81 1d       	adc	r24, r1
    2c98:	91 1d       	adc	r25, r1
    2c9a:	a1 1d       	adc	r26, r1
    2c9c:	20 d0       	rcall	.+64     	; 0x2cde <__ultoa_invert+0x84>
    2c9e:	09 f4       	brne	.+2      	; 0x2ca2 <__ultoa_invert+0x48>
    2ca0:	68 94       	set
    2ca2:	3f 91       	pop	r19
    2ca4:	2a e0       	ldi	r18, 0x0A	; 10
    2ca6:	26 9f       	mul	r18, r22
    2ca8:	11 24       	eor	r1, r1
    2caa:	30 19       	sub	r19, r0
    2cac:	30 5d       	subi	r19, 0xD0	; 208
    2cae:	31 93       	st	Z+, r19
    2cb0:	de f6       	brtc	.-74     	; 0x2c68 <__ultoa_invert+0xe>
    2cb2:	cf 01       	movw	r24, r30
    2cb4:	08 95       	ret
    2cb6:	46 2f       	mov	r20, r22
    2cb8:	47 70       	andi	r20, 0x07	; 7
    2cba:	40 5d       	subi	r20, 0xD0	; 208
    2cbc:	41 93       	st	Z+, r20
    2cbe:	b3 e0       	ldi	r27, 0x03	; 3
    2cc0:	0f d0       	rcall	.+30     	; 0x2ce0 <__ultoa_invert+0x86>
    2cc2:	c9 f7       	brne	.-14     	; 0x2cb6 <__ultoa_invert+0x5c>
    2cc4:	f6 cf       	rjmp	.-20     	; 0x2cb2 <__ultoa_invert+0x58>
    2cc6:	46 2f       	mov	r20, r22
    2cc8:	4f 70       	andi	r20, 0x0F	; 15
    2cca:	40 5d       	subi	r20, 0xD0	; 208
    2ccc:	4a 33       	cpi	r20, 0x3A	; 58
    2cce:	18 f0       	brcs	.+6      	; 0x2cd6 <__ultoa_invert+0x7c>
    2cd0:	49 5d       	subi	r20, 0xD9	; 217
    2cd2:	31 fd       	sbrc	r19, 1
    2cd4:	40 52       	subi	r20, 0x20	; 32
    2cd6:	41 93       	st	Z+, r20
    2cd8:	02 d0       	rcall	.+4      	; 0x2cde <__ultoa_invert+0x84>
    2cda:	a9 f7       	brne	.-22     	; 0x2cc6 <__ultoa_invert+0x6c>
    2cdc:	ea cf       	rjmp	.-44     	; 0x2cb2 <__ultoa_invert+0x58>
    2cde:	b4 e0       	ldi	r27, 0x04	; 4
    2ce0:	a6 95       	lsr	r26
    2ce2:	97 95       	ror	r25
    2ce4:	87 95       	ror	r24
    2ce6:	77 95       	ror	r23
    2ce8:	67 95       	ror	r22
    2cea:	ba 95       	dec	r27
    2cec:	c9 f7       	brne	.-14     	; 0x2ce0 <__ultoa_invert+0x86>
    2cee:	00 97       	sbiw	r24, 0x00	; 0
    2cf0:	61 05       	cpc	r22, r1
    2cf2:	71 05       	cpc	r23, r1
    2cf4:	08 95       	ret
    2cf6:	9b 01       	movw	r18, r22
    2cf8:	ac 01       	movw	r20, r24
    2cfa:	0a 2e       	mov	r0, r26
    2cfc:	06 94       	lsr	r0
    2cfe:	57 95       	ror	r21
    2d00:	47 95       	ror	r20
    2d02:	37 95       	ror	r19
    2d04:	27 95       	ror	r18
    2d06:	ba 95       	dec	r27
    2d08:	c9 f7       	brne	.-14     	; 0x2cfc <__ultoa_invert+0xa2>
    2d0a:	62 0f       	add	r22, r18
    2d0c:	73 1f       	adc	r23, r19
    2d0e:	84 1f       	adc	r24, r20
    2d10:	95 1f       	adc	r25, r21
    2d12:	a0 1d       	adc	r26, r0
    2d14:	08 95       	ret

00002d16 <eeprom_write_word>:
    2d16:	02 d0       	rcall	.+4      	; 0x2d1c <eeprom_write_byte>
    2d18:	27 2f       	mov	r18, r23
    2d1a:	01 c0       	rjmp	.+2      	; 0x2d1e <eeprom_write_r18>

00002d1c <eeprom_write_byte>:
    2d1c:	26 2f       	mov	r18, r22

00002d1e <eeprom_write_r18>:
    2d1e:	f9 99       	sbic	0x1f, 1	; 31
    2d20:	fe cf       	rjmp	.-4      	; 0x2d1e <eeprom_write_r18>
    2d22:	92 bd       	out	0x22, r25	; 34
    2d24:	81 bd       	out	0x21, r24	; 33
    2d26:	20 bd       	out	0x20, r18	; 32
    2d28:	0f b6       	in	r0, 0x3f	; 63
    2d2a:	f8 94       	cli
    2d2c:	fa 9a       	sbi	0x1f, 2	; 31
    2d2e:	f9 9a       	sbi	0x1f, 1	; 31
    2d30:	0f be       	out	0x3f, r0	; 63
    2d32:	01 96       	adiw	r24, 0x01	; 1
    2d34:	08 95       	ret

00002d36 <_exit>:
    2d36:	f8 94       	cli

00002d38 <__stop_program>:
    2d38:	ff cf       	rjmp	.-2      	; 0x2d38 <__stop_program>
