
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002df0  00002e84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002df0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f64  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f64  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002ff0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00003030  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000716f  00000000  00000000  000035e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001dec  00000000  00000000  0000a74f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003386  00000000  00000000  0000c53b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000109c  00000000  00000000  0000f8c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a07  00000000  00000000  00010960  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000046d5  00000000  00000000  00012367  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  00016a3c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 5f 0d 	jmp	0x1abe	; 0x1abe <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 ce 0c 	jmp	0x199c	; 0x199c <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 0f 0c 	jmp	0x181e	; 0x181e <__vector_16>
      44:	0c 94 4e 11 	jmp	0x229c	; 0x229c <__vector_17>
      48:	0c 94 ff 0e 	jmp	0x1dfe	; 0x1dfe <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 fb 0a 	jmp	0x15f6	; 0x15f6 <__vector_21>
      58:	0c 94 dd 0a 	jmp	0x15ba	; 0x15ba <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 34 0b 	jmp	0x1668	; 0x1668 <__vector_32>
      84:	0c 94 16 0b 	jmp	0x162c	; 0x162c <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	d1 0e       	add	r13, r17
      96:	d6 0e       	add	r13, r22
      98:	dc 0e       	add	r13, r28
      9a:	e2 0e       	add	r14, r18
      9c:	e8 0e       	add	r14, r24
      9e:	ed 0e       	add	r14, r29
      a0:	f3 0e       	add	r15, r19
      a2:	f9 0e       	add	r15, r25

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e0 ef       	ldi	r30, 0xF0	; 240
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 76 0b 	call	0x16ec	; 0x16ec <main>
      de:	0c 94 f6 16 	jmp	0x2dec	; 0x2dec <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	8c a9       	ldd	r24, Y+52	; 0x34
     12c:	9d a9       	ldd	r25, Y+53	; 0x35
     12e:	95 87       	std	Z+13, r25	; 0x0d
     130:	84 87       	std	Z+12, r24	; 0x0c
     132:	8e a9       	ldd	r24, Y+54	; 0x36
     134:	9f a9       	ldd	r25, Y+55	; 0x37
     136:	97 87       	std	Z+15, r25	; 0x0f
     138:	86 87       	std	Z+14, r24	; 0x0e
     13a:	88 ad       	ldd	r24, Y+56	; 0x38
     13c:	99 ad       	ldd	r25, Y+57	; 0x39
     13e:	91 8b       	std	Z+17, r25	; 0x11
     140:	80 8b       	std	Z+16, r24	; 0x10
     142:	df 91       	pop	r29
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <actuator_update>:
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
     152:	00 ee       	ldi	r16, 0xE0	; 224
     154:	11 e0       	ldi	r17, 0x01	; 1
     156:	f8 01       	movw	r30, r16
     158:	80 81       	ld	r24, Z
     15a:	91 81       	ldd	r25, Z+1	; 0x01
     15c:	8a af       	std	Y+58, r24	; 0x3a
     15e:	82 81       	ldd	r24, Z+2	; 0x02
     160:	93 81       	ldd	r25, Z+3	; 0x03
     162:	8c af       	std	Y+60, r24	; 0x3c
     164:	84 81       	ldd	r24, Z+4	; 0x04
     166:	95 81       	ldd	r25, Z+5	; 0x05
     168:	9e a3       	std	Y+38, r25	; 0x26
     16a:	8d a3       	std	Y+37, r24	; 0x25
     16c:	66 81       	ldd	r22, Z+6	; 0x06
     16e:	77 81       	ldd	r23, Z+7	; 0x07
     170:	80 85       	ldd	r24, Z+8	; 0x08
     172:	91 85       	ldd	r25, Z+9	; 0x09
     174:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     178:	79 ab       	std	Y+49, r23	; 0x31
     17a:	68 ab       	std	Y+48, r22	; 0x30
     17c:	f8 01       	movw	r30, r16
     17e:	82 85       	ldd	r24, Z+10	; 0x0a
     180:	93 85       	ldd	r25, Z+11	; 0x0b
     182:	8f a7       	std	Y+47, r24	; 0x2f
     184:	84 85       	ldd	r24, Z+12	; 0x0c
     186:	95 85       	ldd	r25, Z+13	; 0x0d
     188:	9d ab       	std	Y+53, r25	; 0x35
     18a:	8c ab       	std	Y+52, r24	; 0x34
     18c:	86 85       	ldd	r24, Z+14	; 0x0e
     18e:	97 85       	ldd	r25, Z+15	; 0x0f
     190:	9f ab       	std	Y+55, r25	; 0x37
     192:	8e ab       	std	Y+54, r24	; 0x36
     194:	80 89       	ldd	r24, Z+16	; 0x10
     196:	91 89       	ldd	r25, Z+17	; 0x11
     198:	99 af       	std	Y+57, r25	; 0x39
     19a:	88 af       	std	Y+56, r24	; 0x38
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	08 95       	ret

000001a6 <actuator_save_position>:
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	ea 01       	movw	r28, r20
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	81 f0       	breq	.+32     	; 0x1d0 <actuator_save_position+0x2a>
     1b0:	18 f0       	brcs	.+6      	; 0x1b8 <actuator_save_position+0x12>
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	d9 f0       	breq	.+54     	; 0x1ec <actuator_save_position+0x46>
     1b6:	27 c0       	rjmp	.+78     	; 0x206 <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8a e2       	ldi	r24, 0x2A	; 42
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 d6 16 	call	0x2dac	; 0x2dac <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d5 87       	std	Z+13, r29	; 0x0d
     1c8:	c4 87       	std	Z+12, r28	; 0x0c
     1ca:	11 82       	std	Z+1, r1	; 0x01
     1cc:	10 82       	st	Z, r1
     1ce:	1b c0       	rjmp	.+54     	; 0x206 <actuator_save_position+0x60>
     1d0:	ba 01       	movw	r22, r20
     1d2:	8e e2       	ldi	r24, 0x2E	; 46
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 d6 16 	call	0x2dac	; 0x2dac <eeprom_write_word>
     1da:	e0 ee       	ldi	r30, 0xE0	; 224
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	d7 87       	std	Z+15, r29	; 0x0f
     1e0:	c6 87       	std	Z+14, r28	; 0x0e
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	91 83       	std	Z+1, r25	; 0x01
     1e8:	80 83       	st	Z, r24
     1ea:	0d c0       	rjmp	.+26     	; 0x206 <actuator_save_position+0x60>
     1ec:	ba 01       	movw	r22, r20
     1ee:	8c e2       	ldi	r24, 0x2C	; 44
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	0e 94 d6 16 	call	0x2dac	; 0x2dac <eeprom_write_word>
     1f6:	e0 ee       	ldi	r30, 0xE0	; 224
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	d1 8b       	std	Z+17, r29	; 0x11
     1fc:	c0 8b       	std	Z+16, r28	; 0x10
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	91 83       	std	Z+1, r25	; 0x01
     204:	80 83       	st	Z, r24
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <actuator_pwm>:
     20c:	89 2b       	or	r24, r25
     20e:	29 f0       	breq	.+10     	; 0x21a <actuator_pwm+0xe>
     210:	81 e0       	ldi	r24, 0x01	; 1
     212:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     216:	75 9a       	sbi	0x0e, 5	; 14
     218:	08 95       	ret
     21a:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     21e:	75 98       	cbi	0x0e, 5	; 14
     220:	08 95       	ret

00000222 <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     222:	4f 92       	push	r4
     224:	5f 92       	push	r5
     226:	6f 92       	push	r6
     228:	7f 92       	push	r7
     22a:	9f 92       	push	r9
     22c:	af 92       	push	r10
     22e:	bf 92       	push	r11
     230:	cf 92       	push	r12
     232:	df 92       	push	r13
     234:	ef 92       	push	r14
     236:	ff 92       	push	r15
     238:	0f 93       	push	r16
     23a:	1f 93       	push	r17
     23c:	cf 93       	push	r28
     23e:	df 93       	push	r29
     240:	ec 01       	movw	r28, r24
     242:	96 2e       	mov	r9, r22
     244:	c6 01       	movw	r24, r12
     246:	b5 01       	movw	r22, r10
			2) Position_ERROR
			3) actuator_duty_cycle
			4) gear_status
*/
	float kp = 0.7; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value 
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     248:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     24c:	87 01       	movw	r16, r14
     24e:	06 1b       	sub	r16, r22
     250:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     252:	b8 01       	movw	r22, r16
     254:	01 2e       	mov	r0, r17
     256:	00 0c       	add	r0, r0
     258:	88 0b       	sbc	r24, r24
     25a:	99 0b       	sbc	r25, r25
     25c:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
     260:	2b 01       	movw	r4, r22
     262:	3c 01       	movw	r6, r24
     264:	23 e3       	ldi	r18, 0x33	; 51
     266:	33 e3       	ldi	r19, 0x33	; 51
     268:	43 e3       	ldi	r20, 0x33	; 51
     26a:	5f e3       	ldi	r21, 0x3F	; 63
     26c:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     270:	20 e0       	ldi	r18, 0x00	; 0
     272:	30 e0       	ldi	r19, 0x00	; 0
     274:	45 e8       	ldi	r20, 0x85	; 133
     276:	52 e4       	ldi	r21, 0x42	; 66
     278:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     27c:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     280:	6b 01       	movw	r12, r22
     282:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     284:	20 e0       	ldi	r18, 0x00	; 0
     286:	30 e0       	ldi	r19, 0x00	; 0
     288:	40 e2       	ldi	r20, 0x20	; 32
     28a:	51 e4       	ldi	r21, 0x41	; 65
     28c:	c3 01       	movw	r24, r6
     28e:	b2 01       	movw	r22, r4
     290:	0e 94 ef 11 	call	0x23de	; 0x23de <__cmpsf2>
     294:	88 23       	and	r24, r24
     296:	c4 f5       	brge	.+112    	; 0x308 <actuator_set_position+0xe6>
     298:	20 e0       	ldi	r18, 0x00	; 0
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	40 e2       	ldi	r20, 0x20	; 32
     29e:	51 ec       	ldi	r21, 0xC1	; 193
     2a0:	c3 01       	movw	r24, r6
     2a2:	b2 01       	movw	r22, r4
     2a4:	0e 94 3e 13 	call	0x267c	; 0x267c <__gesf2>
     2a8:	18 16       	cp	r1, r24
     2aa:	74 f5       	brge	.+92     	; 0x308 <actuator_set_position+0xe6>
     2ac:	30 c0       	rjmp	.+96     	; 0x30e <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     2ae:	8c 81       	ldd	r24, Y+4	; 0x04
     2b0:	9d 81       	ldd	r25, Y+5	; 0x05
     2b2:	00 97       	sbiw	r24, 0x00	; 0
     2b4:	29 f0       	breq	.+10     	; 0x2c0 <actuator_set_position+0x9e>
     2b6:	01 97       	sbiw	r24, 0x01	; 1
     2b8:	89 f4       	brne	.+34     	; 0x2dc <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2ba:	1b 82       	std	Y+3, r1	; 0x03
     2bc:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2be:	0e c0       	rjmp	.+28     	; 0x2dc <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2c0:	10 16       	cp	r1, r16
     2c2:	11 06       	cpc	r1, r17
     2c4:	2c f4       	brge	.+10     	; 0x2d0 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	9b 83       	std	Y+3, r25	; 0x03
     2cc:	8a 83       	std	Y+2, r24	; 0x02
     2ce:	06 c0       	rjmp	.+12     	; 0x2dc <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2d0:	11 23       	and	r17, r17
     2d2:	24 f4       	brge	.+8      	; 0x2dc <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2d4:	82 e0       	ldi	r24, 0x02	; 2
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	9b 83       	std	Y+3, r25	; 0x03
     2da:	8a 83       	std	Y+2, r24	; 0x02
     2dc:	c6 01       	movw	r24, r12
     2de:	83 38       	cpi	r24, 0x83	; 131
     2e0:	91 05       	cpc	r25, r1
     2e2:	14 f0       	brlt	.+4      	; 0x2e8 <actuator_set_position+0xc6>
     2e4:	82 e8       	ldi	r24, 0x82	; 130
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	6c 01       	movw	r12, r24
     2ea:	99 23       	and	r25, r25
     2ec:	14 f4       	brge	.+4      	; 0x2f2 <actuator_set_position+0xd0>
     2ee:	c1 2c       	mov	r12, r1
     2f0:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2f2:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2f6:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2fa:	db 86       	std	Y+11, r13	; 0x0b
     2fc:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2fe:	4e 82       	std	Y+6, r4	; 0x06
     300:	5f 82       	std	Y+7, r5	; 0x07
     302:	68 86       	std	Y+8, r6	; 0x08
     304:	79 86       	std	Y+9, r7	; 0x09
}
     306:	10 c0       	rjmp	.+32     	; 0x328 <actuator_set_position+0x106>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		actuator_values->actuator_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     308:	1d 82       	std	Y+5, r1	; 0x05
     30a:	1c 82       	std	Y+4, r1	; 0x04
     30c:	d0 cf       	rjmp	.-96     	; 0x2ae <actuator_set_position+0x8c>
	
	//Is the actuator with in an acceptable error
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     30e:	81 e0       	ldi	r24, 0x01	; 1
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	9d 83       	std	Y+5, r25	; 0x05
     314:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     316:	89 2d       	mov	r24, r9
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	99 83       	std	Y+1, r25	; 0x01
     31c:	88 83       	st	Y, r24
		actuator_values->actuator_duty_cycle = 50;
     31e:	82 e3       	ldi	r24, 0x32	; 50
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9b 87       	std	Y+11, r25	; 0x0b
     324:	8a 87       	std	Y+10, r24	; 0x0a
     326:	c3 cf       	rjmp	.-122    	; 0x2ae <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     328:	df 91       	pop	r29
     32a:	cf 91       	pop	r28
     32c:	1f 91       	pop	r17
     32e:	0f 91       	pop	r16
     330:	ff 90       	pop	r15
     332:	ef 90       	pop	r14
     334:	df 90       	pop	r13
     336:	cf 90       	pop	r12
     338:	bf 90       	pop	r11
     33a:	af 90       	pop	r10
     33c:	9f 90       	pop	r9
     33e:	7f 90       	pop	r7
     340:	6f 90       	pop	r6
     342:	5f 90       	pop	r5
     344:	4f 90       	pop	r4
     346:	08 95       	ret

00000348 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     348:	af 92       	push	r10
     34a:	bf 92       	push	r11
     34c:	cf 92       	push	r12
     34e:	df 92       	push	r13
     350:	ef 92       	push	r14
     352:	ff 92       	push	r15
     354:	0f 93       	push	r16
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     35e:	8b a1       	ldd	r24, Y+35	; 0x23
     360:	9c a1       	ldd	r25, Y+36	; 0x24
     362:	89 2b       	or	r24, r25
     364:	61 f1       	breq	.+88     	; 0x3be <actuator_p_controller+0x76>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     366:	8b ad       	ldd	r24, Y+59	; 0x3b
     368:	81 30       	cpi	r24, 0x01	; 1
     36a:	39 f0       	breq	.+14     	; 0x37a <actuator_p_controller+0x32>
     36c:	18 f0       	brcs	.+6      	; 0x374 <actuator_p_controller+0x2c>
     36e:	82 30       	cpi	r24, 0x02	; 2
     370:	39 f0       	breq	.+14     	; 0x380 <actuator_p_controller+0x38>
     372:	09 c0       	rjmp	.+18     	; 0x386 <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     374:	ec a8       	ldd	r14, Y+52	; 0x34
     376:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     378:	08 c0       	rjmp	.+16     	; 0x38a <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     37a:	ee a8       	ldd	r14, Y+54	; 0x36
     37c:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     37e:	05 c0       	rjmp	.+10     	; 0x38a <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     380:	e8 ac       	ldd	r14, Y+56	; 0x38
     382:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     384:	02 c0       	rjmp	.+4      	; 0x38a <actuator_p_controller+0x42>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     386:	e1 2c       	mov	r14, r1
     388:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     38a:	ab a4       	ldd	r10, Y+43	; 0x2b
     38c:	bc a4       	ldd	r11, Y+44	; 0x2c
     38e:	cd a4       	ldd	r12, Y+45	; 0x2d
     390:	de a4       	ldd	r13, Y+46	; 0x2e
     392:	0f a5       	ldd	r16, Y+47	; 0x2f
     394:	2f a1       	ldd	r18, Y+39	; 0x27
     396:	38 a5       	ldd	r19, Y+40	; 0x28
     398:	49 a5       	ldd	r20, Y+41	; 0x29
     39a:	5a a5       	ldd	r21, Y+42	; 0x2a
     39c:	6b ad       	ldd	r22, Y+59	; 0x3b
     39e:	10 e0       	ldi	r17, 0x00	; 0
     3a0:	80 ee       	ldi	r24, 0xE0	; 224
     3a2:	91 e0       	ldi	r25, 0x01	; 1
     3a4:	3e df       	rcall	.-388    	; 0x222 <actuator_set_position>
		//vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
		//vals->actuator_direction = ActuatorComValues.actuator_direction;
		//vals->gear_status = ActuatorComValues.clutch_state;
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
		
		if (ActuatorComValues.actuator_in_position)
     3a6:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <__data_end+0x4>
     3aa:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <__data_end+0x5>
     3ae:	89 2b       	or	r24, r25
     3b0:	b1 f0       	breq	.+44     	; 0x3de <actuator_p_controller+0x96>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     3b2:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     3b6:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     3ba:	8a af       	std	Y+58, r24	; 0x3a
     3bc:	10 c0       	rjmp	.+32     	; 0x3de <actuator_p_controller+0x96>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     3be:	ea a8       	ldd	r14, Y+50	; 0x32
     3c0:	fb a8       	ldd	r15, Y+51	; 0x33
		//vals->uart_debug = target_position;
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     3c2:	ab a4       	ldd	r10, Y+43	; 0x2b
     3c4:	bc a4       	ldd	r11, Y+44	; 0x2c
     3c6:	cd a4       	ldd	r12, Y+45	; 0x2d
     3c8:	de a4       	ldd	r13, Y+46	; 0x2e
     3ca:	0f a5       	ldd	r16, Y+47	; 0x2f
     3cc:	2f a1       	ldd	r18, Y+39	; 0x27
     3ce:	38 a5       	ldd	r19, Y+40	; 0x28
     3d0:	49 a5       	ldd	r20, Y+41	; 0x29
     3d2:	5a a5       	ldd	r21, Y+42	; 0x2a
     3d4:	6b ad       	ldd	r22, Y+59	; 0x3b
     3d6:	10 e0       	ldi	r17, 0x00	; 0
     3d8:	80 ee       	ldi	r24, 0xE0	; 224
     3da:	91 e0       	ldi	r25, 0x01	; 1
     3dc:	22 df       	rcall	.-444    	; 0x222 <actuator_set_position>
		//vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
		//vals->actuator_direction = ActuatorComValues.actuator_direction;
		//vals->gear_status = ActuatorComValues.clutch_state;
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
	}
}
     3de:	df 91       	pop	r29
     3e0:	cf 91       	pop	r28
     3e2:	1f 91       	pop	r17
     3e4:	0f 91       	pop	r16
     3e6:	ff 90       	pop	r15
     3e8:	ef 90       	pop	r14
     3ea:	df 90       	pop	r13
     3ec:	cf 90       	pop	r12
     3ee:	bf 90       	pop	r11
     3f0:	af 90       	pop	r10
     3f2:	08 95       	ret

000003f4 <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3f4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3f8:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3fc:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     400:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     404:	08 95       	ret

00000406 <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     406:	68 2f       	mov	r22, r24
     408:	70 e0       	ldi	r23, 0x00	; 0
     40a:	80 e0       	ldi	r24, 0x00	; 0
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
     412:	20 e0       	ldi	r18, 0x00	; 0
     414:	30 e0       	ldi	r19, 0x00	; 0
     416:	48 e4       	ldi	r20, 0x48	; 72
     418:	52 e4       	ldi	r21, 0x42	; 66
     41a:	0e 94 8a 11 	call	0x2314	; 0x2314 <__subsf3>
     41e:	27 ed       	ldi	r18, 0xD7	; 215
     420:	33 ea       	ldi	r19, 0xA3	; 163
     422:	48 e8       	ldi	r20, 0x88	; 136
     424:	51 e4       	ldi	r21, 0x41	; 65
     426:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
     42a:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     42e:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     432:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     436:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     43a:	08 95       	ret

0000043c <controller>:
}

void controller(volatile ModuleValues_t *vals){
     43c:	8f 92       	push	r8
     43e:	9f 92       	push	r9
     440:	af 92       	push	r10
     442:	bf 92       	push	r11
     444:	cf 92       	push	r12
     446:	df 92       	push	r13
     448:	ef 92       	push	r14
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     456:	8e 8d       	ldd	r24, Y+30	; 0x1e
     458:	82 30       	cpi	r24, 0x02	; 2
     45a:	21 f4       	brne	.+8      	; 0x464 <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     45c:	68 8d       	ldd	r22, Y+24	; 0x18
     45e:	16 2f       	mov	r17, r22
     460:	11 95       	neg	r17
     462:	01 c0       	rjmp	.+2      	; 0x466 <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     464:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     466:	8e 8d       	ldd	r24, Y+30	; 0x1e
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	09 f4       	brne	.+2      	; 0x46e <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     46c:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     46e:	89 a1       	ldd	r24, Y+33	; 0x21
     470:	81 11       	cpse	r24, r1
     472:	7b c0       	rjmp	.+246    	; 0x56a <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     474:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     478:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     47c:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     480:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	30 e0       	ldi	r19, 0x00	; 0
     488:	4e eb       	ldi	r20, 0xBE	; 190
     48a:	52 e4       	ldi	r21, 0x42	; 66
     48c:	c7 01       	movw	r24, r14
     48e:	b6 01       	movw	r22, r12
     490:	0e 94 3e 13 	call	0x267c	; 0x267c <__gesf2>
     494:	88 23       	and	r24, r24
     496:	54 f4       	brge	.+20     	; 0x4ac <controller+0x70>
     498:	20 e0       	ldi	r18, 0x00	; 0
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	48 e4       	ldi	r20, 0x48	; 72
     49e:	52 e4       	ldi	r21, 0x42	; 66
     4a0:	c7 01       	movw	r24, r14
     4a2:	b6 01       	movw	r22, r12
     4a4:	0e 94 ef 11 	call	0x23de	; 0x23de <__cmpsf2>
     4a8:	18 16       	cp	r1, r24
     4aa:	6c f0       	brlt	.+26     	; 0x4c6 <controller+0x8a>
		{
			b_saturation = 1 ;
     4ac:	81 e0       	ldi	r24, 0x01	; 1
     4ae:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4b2:	61 2f       	mov	r22, r17
     4b4:	11 0f       	add	r17, r17
     4b6:	77 0b       	sbc	r23, r23
     4b8:	88 0b       	sbc	r24, r24
     4ba:	99 0b       	sbc	r25, r25
     4bc:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
     4c0:	6b 01       	movw	r12, r22
     4c2:	7c 01       	movw	r14, r24
     4c4:	25 c0       	rjmp	.+74     	; 0x510 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     4c6:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4ca:	61 2f       	mov	r22, r17
     4cc:	11 0f       	add	r17, r17
     4ce:	77 0b       	sbc	r23, r23
     4d0:	88 0b       	sbc	r24, r24
     4d2:	99 0b       	sbc	r25, r25
     4d4:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
     4d8:	6b 01       	movw	r12, r22
     4da:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4dc:	2a e0       	ldi	r18, 0x0A	; 10
     4de:	37 ed       	ldi	r19, 0xD7	; 215
     4e0:	43 ea       	ldi	r20, 0xA3	; 163
     4e2:	5b e3       	ldi	r21, 0x3B	; 59
     4e4:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     4e8:	9b 01       	movw	r18, r22
     4ea:	ac 01       	movw	r20, r24
     4ec:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4f0:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4f4:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4f8:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4fc:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     500:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     504:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     508:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     50c:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     510:	27 ed       	ldi	r18, 0xD7	; 215
     512:	33 ea       	ldi	r19, 0xA3	; 163
     514:	48 e8       	ldi	r20, 0x88	; 136
     516:	51 e4       	ldi	r21, 0x41	; 65
     518:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     51c:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     520:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     524:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     528:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     52c:	4b 01       	movw	r8, r22
     52e:	5c 01       	movw	r10, r24
     530:	27 e8       	ldi	r18, 0x87	; 135
     532:	3f eb       	ldi	r19, 0xBF	; 191
     534:	46 e2       	ldi	r20, 0x26	; 38
     536:	5e e3       	ldi	r21, 0x3E	; 62
     538:	c7 01       	movw	r24, r14
     53a:	b6 01       	movw	r22, r12
     53c:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     540:	9b 01       	movw	r18, r22
     542:	ac 01       	movw	r20, r24
     544:	c5 01       	movw	r24, r10
     546:	b4 01       	movw	r22, r8
     548:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     54c:	20 e0       	ldi	r18, 0x00	; 0
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	48 e4       	ldi	r20, 0x48	; 72
     552:	52 e4       	ldi	r21, 0x42	; 66
     554:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     558:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     55c:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     560:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     564:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     568:	11 c0       	rjmp	.+34     	; 0x58c <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     56a:	89 a1       	ldd	r24, Y+33	; 0x21
     56c:	81 30       	cpi	r24, 0x01	; 1
     56e:	71 f4       	brne	.+28     	; 0x58c <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     570:	69 8d       	ldd	r22, Y+25	; 0x19
     572:	70 e0       	ldi	r23, 0x00	; 0
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     57c:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     580:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     584:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     588:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     58c:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     590:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     594:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     598:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     59c:	20 e0       	ldi	r18, 0x00	; 0
     59e:	30 e0       	ldi	r19, 0x00	; 0
     5a0:	4e eb       	ldi	r20, 0xBE	; 190
     5a2:	52 e4       	ldi	r21, 0x42	; 66
     5a4:	c7 01       	movw	r24, r14
     5a6:	b6 01       	movw	r22, r12
     5a8:	0e 94 3e 13 	call	0x267c	; 0x267c <__gesf2>
     5ac:	18 16       	cp	r1, r24
     5ae:	6c f4       	brge	.+26     	; 0x5ca <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	ae eb       	ldi	r26, 0xBE	; 190
     5b6:	b2 e4       	ldi	r27, 0x42	; 66
     5b8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5bc:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5c0:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5c4:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     5c8:	16 c0       	rjmp	.+44     	; 0x5f6 <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	48 e4       	ldi	r20, 0x48	; 72
     5d0:	52 e4       	ldi	r21, 0x42	; 66
     5d2:	c7 01       	movw	r24, r14
     5d4:	b6 01       	movw	r22, r12
     5d6:	0e 94 ef 11 	call	0x23de	; 0x23de <__cmpsf2>
     5da:	88 23       	and	r24, r24
     5dc:	64 f4       	brge	.+24     	; 0x5f6 <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	a8 e4       	ldi	r26, 0x48	; 72
     5e4:	b2 e4       	ldi	r27, 0x42	; 66
     5e6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5ea:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5ee:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5f2:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5f6:	06 e9       	ldi	r16, 0x96	; 150
     5f8:	10 e0       	ldi	r17, 0x00	; 0
     5fa:	f8 01       	movw	r30, r16
     5fc:	e0 80       	ld	r14, Z
     5fe:	f1 80       	ldd	r15, Z+1	; 0x01
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	30 e0       	ldi	r19, 0x00	; 0
     604:	48 ec       	ldi	r20, 0xC8	; 200
     606:	52 e4       	ldi	r21, 0x42	; 66
     608:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     60c:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     610:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     614:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     618:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
     61c:	4b 01       	movw	r8, r22
     61e:	5c 01       	movw	r10, r24
     620:	b7 01       	movw	r22, r14
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     62a:	9b 01       	movw	r18, r22
     62c:	ac 01       	movw	r20, r24
     62e:	c5 01       	movw	r24, r10
     630:	b4 01       	movw	r22, r8
     632:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     636:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     63a:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     63e:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     642:	f8 01       	movw	r30, r16
     644:	60 81       	ld	r22, Z
     646:	71 81       	ldd	r23, Z+1	; 0x01
     648:	00 81       	ld	r16, Z
     64a:	11 81       	ldd	r17, Z+1	; 0x01
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     654:	6b 01       	movw	r12, r22
     656:	7c 01       	movw	r14, r24
     658:	20 e0       	ldi	r18, 0x00	; 0
     65a:	30 e0       	ldi	r19, 0x00	; 0
     65c:	48 ec       	ldi	r20, 0xC8	; 200
     65e:	52 e4       	ldi	r21, 0x42	; 66
     660:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     664:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     668:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     66c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     670:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
     674:	4b 01       	movw	r8, r22
     676:	5c 01       	movw	r10, r24
     678:	b8 01       	movw	r22, r16
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     682:	9b 01       	movw	r18, r22
     684:	ac 01       	movw	r20, r24
     686:	c5 01       	movw	r24, r10
     688:	b4 01       	movw	r22, r8
     68a:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     68e:	9b 01       	movw	r18, r22
     690:	ac 01       	movw	r20, r24
     692:	c7 01       	movw	r24, r14
     694:	b6 01       	movw	r22, r12
     696:	0e 94 8a 11 	call	0x2314	; 0x2314 <__subsf3>
     69a:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     69e:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     6a2:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     6a6:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     6aa:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     6ae:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     6b2:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     6b6:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
     6ba:	69 8f       	std	Y+25, r22	; 0x19

}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	1f 91       	pop	r17
     6c2:	0f 91       	pop	r16
     6c4:	ff 90       	pop	r15
     6c6:	ef 90       	pop	r14
     6c8:	df 90       	pop	r13
     6ca:	cf 90       	pop	r12
     6cc:	bf 90       	pop	r11
     6ce:	af 90       	pop	r10
     6d0:	9f 90       	pop	r9
     6d2:	8f 90       	pop	r8
     6d4:	08 95       	ret

000006d6 <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6d6:	53 9a       	sbi	0x0a, 3	; 10
     6d8:	08 95       	ret

000006da <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6da:	81 30       	cpi	r24, 0x01	; 1
     6dc:	11 f4       	brne	.+4      	; 0x6e2 <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6de:	5b 9a       	sbi	0x0b, 3	; 11
     6e0:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6e2:	5b 98       	cbi	0x0b, 3	; 11
     6e4:	08 95       	ret

000006e6 <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6e6:	cf 93       	push	r28
     6e8:	df 93       	push	r29
     6ea:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6ec:	6a ef       	ldi	r22, 0xFA	; 250
     6ee:	71 e0       	ldi	r23, 0x01	; 1
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6f6:	21 e0       	ldi	r18, 0x01	; 1
     6f8:	43 e0       	ldi	r20, 0x03	; 3
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	67 ef       	ldi	r22, 0xF7	; 247
     6fe:	71 e0       	ldi	r23, 0x01	; 1
     700:	8a ef       	ldi	r24, 0xFA	; 250
     702:	91 e0       	ldi	r25, 0x01	; 1
     704:	0e 94 2a 11 	call	0x2254	; 0x2254 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     708:	e7 ef       	ldi	r30, 0xF7	; 247
     70a:	f1 e0       	ldi	r31, 0x01	; 1
     70c:	61 81       	ldd	r22, Z+1	; 0x01
     70e:	6f 71       	andi	r22, 0x1F	; 31
     710:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     712:	70 e0       	ldi	r23, 0x00	; 0
     714:	76 2f       	mov	r23, r22
     716:	66 27       	eor	r22, r22
     718:	82 81       	ldd	r24, Z+2	; 0x02
     71a:	68 2b       	or	r22, r24
     71c:	80 e0       	ldi	r24, 0x00	; 0
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     724:	20 e0       	ldi	r18, 0x00	; 0
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	49 e8       	ldi	r20, 0x89	; 137
     72a:	52 e4       	ldi	r21, 0x42	; 66
     72c:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
     730:	20 e0       	ldi	r18, 0x00	; 0
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	40 e2       	ldi	r20, 0x20	; 32
     736:	51 e4       	ldi	r21, 0x41	; 65
     738:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     73c:	20 e0       	ldi	r18, 0x00	; 0
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	48 e8       	ldi	r20, 0x88	; 136
     742:	51 e4       	ldi	r21, 0x41	; 65
     744:	0e 94 8a 11 	call	0x2314	; 0x2314 <__subsf3>
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	a9 01       	movw	r20, r18
     74e:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     752:	68 83       	st	Y, r22
     754:	79 83       	std	Y+1, r23	; 0x01
     756:	8a 83       	std	Y+2, r24	; 0x02
     758:	9b 83       	std	Y+3, r25	; 0x03
}
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     766:	6a ef       	ldi	r22, 0xFA	; 250
     768:	71 e0       	ldi	r23, 0x01	; 1
     76a:	81 e0       	ldi	r24, 0x01	; 1
     76c:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     770:	21 e0       	ldi	r18, 0x01	; 1
     772:	43 e0       	ldi	r20, 0x03	; 3
     774:	50 e0       	ldi	r21, 0x00	; 0
     776:	67 ef       	ldi	r22, 0xF7	; 247
     778:	71 e0       	ldi	r23, 0x01	; 1
     77a:	8a ef       	ldi	r24, 0xFA	; 250
     77c:	91 e0       	ldi	r25, 0x01	; 1
     77e:	0e 94 2a 11 	call	0x2254	; 0x2254 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     782:	e7 ef       	ldi	r30, 0xF7	; 247
     784:	f1 e0       	ldi	r31, 0x01	; 1
     786:	61 81       	ldd	r22, Z+1	; 0x01
     788:	6f 71       	andi	r22, 0x1F	; 31
     78a:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	76 2f       	mov	r23, r22
     790:	66 27       	eor	r22, r22
     792:	82 81       	ldd	r24, Z+2	; 0x02
     794:	68 2b       	or	r22, r24
     796:	41 e0       	ldi	r20, 0x01	; 1
     798:	ce 01       	movw	r24, r28
     79a:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <handle_current_sensor>
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     7aa:	6a ef       	ldi	r22, 0xFA	; 250
     7ac:	71 e0       	ldi	r23, 0x01	; 1
     7ae:	84 e0       	ldi	r24, 0x04	; 4
     7b0:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7b4:	21 e0       	ldi	r18, 0x01	; 1
     7b6:	43 e0       	ldi	r20, 0x03	; 3
     7b8:	50 e0       	ldi	r21, 0x00	; 0
     7ba:	67 ef       	ldi	r22, 0xF7	; 247
     7bc:	71 e0       	ldi	r23, 0x01	; 1
     7be:	8a ef       	ldi	r24, 0xFA	; 250
     7c0:	91 e0       	ldi	r25, 0x01	; 1
     7c2:	0e 94 2a 11 	call	0x2254	; 0x2254 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7c6:	e7 ef       	ldi	r30, 0xF7	; 247
     7c8:	f1 e0       	ldi	r31, 0x01	; 1
     7ca:	61 81       	ldd	r22, Z+1	; 0x01
     7cc:	6f 71       	andi	r22, 0x1F	; 31
     7ce:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7d0:	70 e0       	ldi	r23, 0x00	; 0
     7d2:	76 2f       	mov	r23, r22
     7d4:	66 27       	eor	r22, r22
     7d6:	82 81       	ldd	r24, Z+2	; 0x02
     7d8:	68 2b       	or	r22, r24
     7da:	ce 01       	movw	r24, r28
     7dc:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <handle_temp_sensor>
}
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	08 95       	ret

000007e6 <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7e6:	0f 93       	push	r16
     7e8:	1f 93       	push	r17
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	00 d0       	rcall	.+0      	; 0x7f0 <SPI_handler_6+0xa>
     7f0:	00 d0       	rcall	.+0      	; 0x7f2 <SPI_handler_6+0xc>
     7f2:	cd b7       	in	r28, 0x3d	; 61
     7f4:	de b7       	in	r29, 0x3e	; 62
     7f6:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7f8:	6a ef       	ldi	r22, 0xFA	; 250
     7fa:	71 e0       	ldi	r23, 0x01	; 1
     7fc:	86 e0       	ldi	r24, 0x06	; 6
     7fe:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     802:	21 e0       	ldi	r18, 0x01	; 1
     804:	43 e0       	ldi	r20, 0x03	; 3
     806:	50 e0       	ldi	r21, 0x00	; 0
     808:	67 ef       	ldi	r22, 0xF7	; 247
     80a:	71 e0       	ldi	r23, 0x01	; 1
     80c:	8a ef       	ldi	r24, 0xFA	; 250
     80e:	91 e0       	ldi	r25, 0x01	; 1
     810:	0e 94 2a 11 	call	0x2254	; 0x2254 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     814:	e7 ef       	ldi	r30, 0xF7	; 247
     816:	f1 e0       	ldi	r31, 0x01	; 1
     818:	61 81       	ldd	r22, Z+1	; 0x01
     81a:	6f 71       	andi	r22, 0x1F	; 31
     81c:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     81e:	70 e0       	ldi	r23, 0x00	; 0
     820:	76 2f       	mov	r23, r22
     822:	66 27       	eor	r22, r22
     824:	82 81       	ldd	r24, Z+2	; 0x02
     826:	68 2b       	or	r22, r24
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     830:	20 e0       	ldi	r18, 0x00	; 0
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	40 ea       	ldi	r20, 0xA0	; 160
     836:	50 e4       	ldi	r21, 0x40	; 64
     838:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     83c:	20 e0       	ldi	r18, 0x00	; 0
     83e:	30 e0       	ldi	r19, 0x00	; 0
     840:	40 e8       	ldi	r20, 0x80	; 128
     842:	59 e3       	ldi	r21, 0x39	; 57
     844:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     848:	69 83       	std	Y+1, r22	; 0x01
     84a:	7a 83       	std	Y+2, r23	; 0x02
     84c:	8b 83       	std	Y+3, r24	; 0x03
     84e:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     850:	69 81       	ldd	r22, Y+1	; 0x01
     852:	7a 81       	ldd	r23, Y+2	; 0x02
     854:	8b 81       	ldd	r24, Y+3	; 0x03
     856:	9c 81       	ldd	r25, Y+4	; 0x04
     858:	20 e0       	ldi	r18, 0x00	; 0
     85a:	30 e0       	ldi	r19, 0x00	; 0
     85c:	48 ec       	ldi	r20, 0xC8	; 200
     85e:	52 e4       	ldi	r21, 0x42	; 66
     860:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     864:	20 e0       	ldi	r18, 0x00	; 0
     866:	30 e0       	ldi	r19, 0x00	; 0
     868:	48 ec       	ldi	r20, 0xC8	; 200
     86a:	51 e4       	ldi	r21, 0x41	; 65
     86c:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
     870:	f8 01       	movw	r30, r16
     872:	60 83       	st	Z, r22
     874:	71 83       	std	Z+1, r23	; 0x01
     876:	82 83       	std	Z+2, r24	; 0x02
     878:	93 83       	std	Z+3, r25	; 0x03
}
     87a:	0f 90       	pop	r0
     87c:	0f 90       	pop	r0
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	08 95       	ret

0000088c <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     88c:	cf 93       	push	r28
     88e:	df 93       	push	r29
     890:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     892:	6a ef       	ldi	r22, 0xFA	; 250
     894:	71 e0       	ldi	r23, 0x01	; 1
     896:	87 e0       	ldi	r24, 0x07	; 7
     898:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     89c:	21 e0       	ldi	r18, 0x01	; 1
     89e:	43 e0       	ldi	r20, 0x03	; 3
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	67 ef       	ldi	r22, 0xF7	; 247
     8a4:	71 e0       	ldi	r23, 0x01	; 1
     8a6:	8a ef       	ldi	r24, 0xFA	; 250
     8a8:	91 e0       	ldi	r25, 0x01	; 1
     8aa:	0e 94 2a 11 	call	0x2254	; 0x2254 <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     8ae:	e7 ef       	ldi	r30, 0xF7	; 247
     8b0:	f1 e0       	ldi	r31, 0x01	; 1
     8b2:	61 81       	ldd	r22, Z+1	; 0x01
     8b4:	6f 71       	andi	r22, 0x1F	; 31
     8b6:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     8b8:	70 e0       	ldi	r23, 0x00	; 0
     8ba:	76 2f       	mov	r23, r22
     8bc:	66 27       	eor	r22, r22
     8be:	82 81       	ldd	r24, Z+2	; 0x02
     8c0:	68 2b       	or	r22, r24
     8c2:	40 e0       	ldi	r20, 0x00	; 0
     8c4:	ce 01       	movw	r24, r28
     8c6:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <handle_current_sensor>
}
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	cf 93       	push	r28
     8d6:	df 93       	push	r29
     8d8:	8c 01       	movw	r16, r24
     8da:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8dc:	cb 01       	movw	r24, r22
     8de:	0e 94 45 10 	call	0x208a	; 0x208a <can_read_message_if_new>
     8e2:	88 23       	and	r24, r24
     8e4:	09 f4       	brne	.+2      	; 0x8e8 <handle_can+0x18>
     8e6:	46 c0       	rjmp	.+140    	; 0x974 <handle_can+0xa4>
     8e8:	f8 01       	movw	r30, r16
     8ea:	86 8d       	ldd	r24, Z+30	; 0x1e
     8ec:	84 30       	cpi	r24, 0x04	; 4
     8ee:	09 f4       	brne	.+2      	; 0x8f2 <handle_can+0x22>
     8f0:	41 c0       	rjmp	.+130    	; 0x974 <handle_can+0xa4>
		switch (rx->id){
     8f2:	88 81       	ld	r24, Y
     8f4:	99 81       	ldd	r25, Y+1	; 0x01
     8f6:	80 32       	cpi	r24, 0x20	; 32
     8f8:	f1 e0       	ldi	r31, 0x01	; 1
     8fa:	9f 07       	cpc	r25, r31
     8fc:	91 f1       	breq	.+100    	; 0x962 <handle_can+0x92>
     8fe:	80 33       	cpi	r24, 0x30	; 48
     900:	92 40       	sbci	r25, 0x02	; 2
     902:	c1 f5       	brne	.+112    	; 0x974 <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	f8 01       	movw	r30, r16
     908:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     90a:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     90c:	82 e3       	ldi	r24, 0x32	; 50
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	93 8f       	std	Z+27, r25	; 0x1b
     912:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     914:	8e 81       	ldd	r24, Y+6	; 0x06
     916:	89 30       	cpi	r24, 0x09	; 9
     918:	40 f0       	brcs	.+16     	; 0x92a <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     91a:	86 95       	lsr	r24
     91c:	86 95       	lsr	r24
     91e:	86 95       	lsr	r24
     920:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     922:	8e e1       	ldi	r24, 0x1E	; 30
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	95 8f       	std	Z+29, r25	; 0x1d
     928:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     92a:	8f 81       	ldd	r24, Y+7	; 0x07
     92c:	89 30       	cpi	r24, 0x09	; 9
     92e:	88 f0       	brcs	.+34     	; 0x952 <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     930:	8d 81       	ldd	r24, Y+5	; 0x05
     932:	9d ec       	ldi	r25, 0xCD	; 205
     934:	89 9f       	mul	r24, r25
     936:	81 2d       	mov	r24, r1
     938:	11 24       	eor	r1, r1
     93a:	86 95       	lsr	r24
     93c:	86 95       	lsr	r24
     93e:	86 95       	lsr	r24
     940:	f8 01       	movw	r30, r16
     942:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     944:	8e e1       	ldi	r24, 0x1E	; 30
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	95 8f       	std	Z+29, r25	; 0x1d
     94a:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     94c:	8f 81       	ldd	r24, Y+7	; 0x07
     94e:	89 30       	cpi	r24, 0x09	; 9
     950:	10 f4       	brcc	.+4      	; 0x956 <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     952:	f8 01       	movw	r30, r16
     954:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     956:	8e 81       	ldd	r24, Y+6	; 0x06
     958:	89 30       	cpi	r24, 0x09	; 9
     95a:	60 f4       	brcc	.+24     	; 0x974 <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     95c:	f8 01       	movw	r30, r16
     95e:	17 8a       	std	Z+23, r1	; 0x17
     960:	09 c0       	rjmp	.+18     	; 0x974 <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	f8 01       	movw	r30, r16
     966:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     968:	8b 81       	ldd	r24, Y+3	; 0x03
     96a:	9c 81       	ldd	r25, Y+4	; 0x04
     96c:	96 8b       	std	Z+22, r25	; 0x16
     96e:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     970:	8d 81       	ldd	r24, Y+5	; 0x05
     972:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	08 95       	ret

0000097e <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     97e:	0f 93       	push	r16
     980:	1f 93       	push	r17
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	cd b7       	in	r28, 0x3d	; 61
     988:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     98a:	08 eb       	ldi	r16, 0xB8	; 184
     98c:	13 e0       	ldi	r17, 0x03	; 3
     98e:	80 e5       	ldi	r24, 0x50	; 80
     990:	92 e0       	ldi	r25, 0x02	; 2
     992:	f8 01       	movw	r30, r16
     994:	91 83       	std	Z+1, r25	; 0x01
     996:	80 83       	st	Z, r24
	txFrame.length = 8;
     998:	88 e0       	ldi	r24, 0x08	; 8
     99a:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     99c:	8d a1       	ldd	r24, Y+37	; 0x25
     99e:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     9a0:	69 85       	ldd	r22, Y+9	; 0x09
     9a2:	7a 85       	ldd	r23, Y+10	; 0x0a
     9a4:	8b 85       	ldd	r24, Y+11	; 0x0b
     9a6:	9c 85       	ldd	r25, Y+12	; 0x0c
     9a8:	20 e0       	ldi	r18, 0x00	; 0
     9aa:	30 e0       	ldi	r19, 0x00	; 0
     9ac:	40 e2       	ldi	r20, 0x20	; 32
     9ae:	51 e4       	ldi	r21, 0x41	; 65
     9b0:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     9b4:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     9b8:	f8 01       	movw	r30, r16
     9ba:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     9bc:	69 89       	ldd	r22, Y+17	; 0x11
     9be:	7a 89       	ldd	r23, Y+18	; 0x12
     9c0:	8b 89       	ldd	r24, Y+19	; 0x13
     9c2:	9c 89       	ldd	r25, Y+20	; 0x14
     9c4:	20 e0       	ldi	r18, 0x00	; 0
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	40 e2       	ldi	r20, 0x20	; 32
     9ca:	51 e4       	ldi	r21, 0x41	; 65
     9cc:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     9d0:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
     9d4:	f8 01       	movw	r30, r16
     9d6:	76 83       	std	Z+6, r23	; 0x06
     9d8:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9da:	6d 89       	ldd	r22, Y+21	; 0x15
     9dc:	7e 89       	ldd	r23, Y+22	; 0x16
     9de:	8f 89       	ldd	r24, Y+23	; 0x17
     9e0:	98 8d       	ldd	r25, Y+24	; 0x18
     9e2:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     9e6:	07 2e       	mov	r0, r23
     9e8:	00 0c       	add	r0, r0
     9ea:	88 0b       	sbc	r24, r24
     9ec:	99 0b       	sbc	r25, r25
     9ee:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
     9f2:	20 e0       	ldi	r18, 0x00	; 0
     9f4:	30 e0       	ldi	r19, 0x00	; 0
     9f6:	48 ec       	ldi	r20, 0xC8	; 200
     9f8:	52 e4       	ldi	r21, 0x42	; 66
     9fa:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
     9fe:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     a02:	9b 01       	movw	r18, r22
     a04:	77 23       	and	r23, r23
     a06:	24 f4       	brge	.+8      	; 0xa10 <handle_motor_status_can_msg+0x92>
     a08:	22 27       	eor	r18, r18
     a0a:	33 27       	eor	r19, r19
     a0c:	26 1b       	sub	r18, r22
     a0e:	37 0b       	sbc	r19, r23
     a10:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     a14:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     a18:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a1a:	7b 8d       	ldd	r23, Y+27	; 0x1b
     a1c:	08 eb       	ldi	r16, 0xB8	; 184
     a1e:	13 e0       	ldi	r17, 0x03	; 3
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
     a28:	26 e6       	ldi	r18, 0x66	; 102
     a2a:	36 e6       	ldi	r19, 0x66	; 102
     a2c:	46 e6       	ldi	r20, 0x66	; 102
     a2e:	50 e4       	ldi	r21, 0x40	; 64
     a30:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     a34:	20 e0       	ldi	r18, 0x00	; 0
     a36:	30 e0       	ldi	r19, 0x00	; 0
     a38:	40 e0       	ldi	r20, 0x00	; 0
     a3a:	5f e3       	ldi	r21, 0x3F	; 63
     a3c:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
     a40:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
     a44:	f8 01       	movw	r30, r16
     a46:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a48:	89 8d       	ldd	r24, Y+25	; 0x19
     a4a:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a4c:	c8 01       	movw	r24, r16
     a4e:	0e 94 88 10 	call	0x2110	; 0x2110 <can_send_message>
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	08 95       	ret

00000a5c <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a5c:	cf 93       	push	r28
     a5e:	df 93       	push	r29
     a60:	cd b7       	in	r28, 0x3d	; 61
     a62:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a64:	ed ea       	ldi	r30, 0xAD	; 173
     a66:	f3 e0       	ldi	r31, 0x03	; 3
     a68:	81 e5       	ldi	r24, 0x51	; 81
     a6a:	92 e0       	ldi	r25, 0x02	; 2
     a6c:	91 83       	std	Z+1, r25	; 0x01
     a6e:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a74:	21 96       	adiw	r28, 0x01	; 1
     a76:	8f ad       	ldd	r24, Y+63	; 0x3f
     a78:	21 97       	sbiw	r28, 0x01	; 1
     a7a:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a7c:	cf 01       	movw	r24, r30
     a7e:	0e 94 88 10 	call	0x2110	; 0x2110 <can_send_message>
}
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a88:	af 92       	push	r10
     a8a:	bf 92       	push	r11
     a8c:	cf 92       	push	r12
     a8e:	df 92       	push	r13
     a90:	ef 92       	push	r14
     a92:	ff 92       	push	r15
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	66 97       	sbiw	r28, 0x16	; 22
     aa2:	0f b6       	in	r0, 0x3f	; 63
     aa4:	f8 94       	cli
     aa6:	de bf       	out	0x3e, r29	; 62
     aa8:	0f be       	out	0x3f, r0	; 63
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     aae:	fe 01       	movw	r30, r28
     ab0:	31 96       	adiw	r30, 0x01	; 1
     ab2:	96 e1       	ldi	r25, 0x16	; 22
     ab4:	df 01       	movw	r26, r30
     ab6:	1d 92       	st	X+, r1
     ab8:	9a 95       	dec	r25
     aba:	e9 f7       	brne	.-6      	; 0xab6 <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     abc:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     ac0:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     ac4:	92 1b       	sub	r25, r18
     ac6:	9f 71       	andi	r25, 0x1F	; 31
     ac8:	09 f4       	brne	.+2      	; 0xacc <receive_uart+0x44>
     aca:	4e c1       	rjmp	.+668    	; 0xd68 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     acc:	f6 01       	movw	r30, r12
     ace:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     ad0:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     ad2:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     ad4:	66 e1       	ldi	r22, 0x16	; 22
     ad6:	ce 01       	movw	r24, r28
     ad8:	01 96       	adiw	r24, 0x01	; 1
     ada:	08 d5       	rcall	.+2576   	; 0x14ec <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     adc:	ce 01       	movw	r24, r28
     ade:	01 96       	adiw	r24, 0x01	; 1
     ae0:	0e 94 ae 13 	call	0x275c	; 0x275c <atoi>
     ae4:	5c 01       	movw	r10, r24
     ae6:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ae8:	d6 01       	movw	r26, r12
     aea:	8d 91       	ld	r24, X+
     aec:	9c 91       	ld	r25, X
     aee:	89 2b       	or	r24, r25
     af0:	71 f4       	brne	.+28     	; 0xb0e <receive_uart+0x86>
     af2:	6f e4       	ldi	r22, 0x4F	; 79
     af4:	71 e0       	ldi	r23, 0x01	; 1
     af6:	ce 01       	movw	r24, r28
     af8:	01 96       	adiw	r24, 0x01	; 1
     afa:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     afe:	89 2b       	or	r24, r25
     b00:	31 f4       	brne	.+12     	; 0xb0e <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     b02:	f6 01       	movw	r30, r12
     b04:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	91 83       	std	Z+1, r25	; 0x01
     b0c:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     b0e:	d6 01       	movw	r26, r12
     b10:	8d 91       	ld	r24, X+
     b12:	9c 91       	ld	r25, X
     b14:	89 2b       	or	r24, r25
     b16:	71 f0       	breq	.+28     	; 0xb34 <receive_uart+0xac>
     b18:	61 e6       	ldi	r22, 0x61	; 97
     b1a:	71 e0       	ldi	r23, 0x01	; 1
     b1c:	ce 01       	movw	r24, r28
     b1e:	01 96       	adiw	r24, 0x01	; 1
     b20:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     b24:	89 2b       	or	r24, r25
     b26:	31 f4       	brne	.+12     	; 0xb34 <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     b28:	f6 01       	movw	r30, r12
     b2a:	11 82       	std	Z+1, r1	; 0x01
     b2c:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     b2e:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b30:	15 8e       	std	Z+29, r1	; 0x1d
     b32:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b34:	62 e7       	ldi	r22, 0x72	; 114
     b36:	71 e0       	ldi	r23, 0x01	; 1
     b38:	ce 01       	movw	r24, r28
     b3a:	01 96       	adiw	r24, 0x01	; 1
     b3c:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     b40:	89 2b       	or	r24, r25
     b42:	11 f5       	brne	.+68     	; 0xb88 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b44:	d6 01       	movw	r26, r12
     b46:	94 96       	adiw	r26, 0x24	; 36
     b48:	1c 92       	st	X, r1
     b4a:	1e 92       	st	-X, r1
     b4c:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b4e:	da 96       	adiw	r26, 0x3a	; 58
     b50:	8c 91       	ld	r24, X
     b52:	81 30       	cpi	r24, 0x01	; 1
     b54:	51 f0       	breq	.+20     	; 0xb6a <receive_uart+0xe2>
     b56:	18 f0       	brcs	.+6      	; 0xb5e <receive_uart+0xd6>
     b58:	82 30       	cpi	r24, 0x02	; 2
     b5a:	89 f0       	breq	.+34     	; 0xb7e <receive_uart+0xf6>
     b5c:	15 c0       	rjmp	.+42     	; 0xb88 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b5e:	f6 01       	movw	r30, r12
     b60:	84 a9       	ldd	r24, Z+52	; 0x34
     b62:	95 a9       	ldd	r25, Z+53	; 0x35
     b64:	93 ab       	std	Z+51, r25	; 0x33
     b66:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b68:	0f c0       	rjmp	.+30     	; 0xb88 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b6a:	d6 01       	movw	r26, r12
     b6c:	d6 96       	adiw	r26, 0x36	; 54
     b6e:	8d 91       	ld	r24, X+
     b70:	9c 91       	ld	r25, X
     b72:	d7 97       	sbiw	r26, 0x37	; 55
     b74:	d3 96       	adiw	r26, 0x33	; 51
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b7c:	05 c0       	rjmp	.+10     	; 0xb88 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b7e:	f6 01       	movw	r30, r12
     b80:	80 ad       	ldd	r24, Z+56	; 0x38
     b82:	91 ad       	ldd	r25, Z+57	; 0x39
     b84:	93 ab       	std	Z+51, r25	; 0x33
     b86:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b88:	65 e8       	ldi	r22, 0x85	; 133
     b8a:	71 e0       	ldi	r23, 0x01	; 1
     b8c:	ce 01       	movw	r24, r28
     b8e:	01 96       	adiw	r24, 0x01	; 1
     b90:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     b94:	89 2b       	or	r24, r25
     b96:	39 f4       	brne	.+14     	; 0xba6 <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	d6 01       	movw	r26, r12
     b9e:	94 96       	adiw	r26, 0x24	; 36
     ba0:	9c 93       	st	X, r25
     ba2:	8e 93       	st	-X, r24
     ba4:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     ba6:	f6 01       	movw	r30, r12
     ba8:	80 81       	ld	r24, Z
     baa:	91 81       	ldd	r25, Z+1	; 0x01
     bac:	89 2b       	or	r24, r25
     bae:	39 f0       	breq	.+14     	; 0xbbe <receive_uart+0x136>
     bb0:	c5 01       	movw	r24, r10
     bb2:	0b 97       	sbiw	r24, 0x0b	; 11
     bb4:	0a 97       	sbiw	r24, 0x0a	; 10
     bb6:	18 f4       	brcc	.+6      	; 0xbbe <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     bb8:	86 ef       	ldi	r24, 0xF6	; 246
     bba:	8a 0d       	add	r24, r10
     bbc:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     bbe:	d6 01       	movw	r26, r12
     bc0:	8d 91       	ld	r24, X+
     bc2:	9c 91       	ld	r25, X
     bc4:	11 97       	sbiw	r26, 0x01	; 1
     bc6:	89 2b       	or	r24, r25
     bc8:	39 f0       	breq	.+14     	; 0xbd8 <receive_uart+0x150>
     bca:	0a 30       	cpi	r16, 0x0A	; 10
     bcc:	11 05       	cpc	r17, r1
     bce:	20 f4       	brcc	.+8      	; 0xbd8 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     bd0:	8a e0       	ldi	r24, 0x0A	; 10
     bd2:	8a 19       	sub	r24, r10
     bd4:	58 96       	adiw	r26, 0x18	; 24
     bd6:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     bd8:	f6 01       	movw	r30, r12
     bda:	80 81       	ld	r24, Z
     bdc:	91 81       	ldd	r25, Z+1	; 0x01
     bde:	89 2b       	or	r24, r25
     be0:	31 f0       	breq	.+12     	; 0xbee <receive_uart+0x166>
     be2:	01 2b       	or	r16, r17
     be4:	21 f4       	brne	.+8      	; 0xbee <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     be6:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     be8:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bea:	82 e3       	ldi	r24, 0x32	; 50
     bec:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bee:	d6 01       	movw	r26, r12
     bf0:	93 96       	adiw	r26, 0x23	; 35
     bf2:	8d 91       	ld	r24, X+
     bf4:	9c 91       	ld	r25, X
     bf6:	94 97       	sbiw	r26, 0x24	; 36
     bf8:	01 97       	sbiw	r24, 0x01	; 1
     bfa:	51 f4       	brne	.+20     	; 0xc10 <receive_uart+0x188>
     bfc:	67 e9       	ldi	r22, 0x97	; 151
     bfe:	71 e0       	ldi	r23, 0x01	; 1
     c00:	ce 01       	movw	r24, r28
     c02:	01 96       	adiw	r24, 0x01	; 1
     c04:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     c08:	89 2b       	or	r24, r25
     c0a:	11 f4       	brne	.+4      	; 0xc10 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     c0c:	f6 01       	movw	r30, r12
     c0e:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     c10:	d6 01       	movw	r26, r12
     c12:	93 96       	adiw	r26, 0x23	; 35
     c14:	8d 91       	ld	r24, X+
     c16:	9c 91       	ld	r25, X
     c18:	94 97       	sbiw	r26, 0x24	; 36
     c1a:	01 97       	sbiw	r24, 0x01	; 1
     c1c:	59 f4       	brne	.+22     	; 0xc34 <receive_uart+0x1ac>
     c1e:	69 e9       	ldi	r22, 0x99	; 153
     c20:	71 e0       	ldi	r23, 0x01	; 1
     c22:	ce 01       	movw	r24, r28
     c24:	01 96       	adiw	r24, 0x01	; 1
     c26:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     c2a:	89 2b       	or	r24, r25
     c2c:	19 f4       	brne	.+6      	; 0xc34 <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	f6 01       	movw	r30, r12
     c32:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c34:	d6 01       	movw	r26, r12
     c36:	93 96       	adiw	r26, 0x23	; 35
     c38:	8d 91       	ld	r24, X+
     c3a:	9c 91       	ld	r25, X
     c3c:	94 97       	sbiw	r26, 0x24	; 36
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	59 f4       	brne	.+22     	; 0xc58 <receive_uart+0x1d0>
     c42:	65 eb       	ldi	r22, 0xB5	; 181
     c44:	71 e0       	ldi	r23, 0x01	; 1
     c46:	ce 01       	movw	r24, r28
     c48:	01 96       	adiw	r24, 0x01	; 1
     c4a:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     c4e:	89 2b       	or	r24, r25
     c50:	19 f4       	brne	.+6      	; 0xc58 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c52:	82 e0       	ldi	r24, 0x02	; 2
     c54:	f6 01       	movw	r30, r12
     c56:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c58:	d6 01       	movw	r26, r12
     c5a:	93 96       	adiw	r26, 0x23	; 35
     c5c:	8d 91       	ld	r24, X+
     c5e:	9c 91       	ld	r25, X
     c60:	94 97       	sbiw	r26, 0x24	; 36
     c62:	89 2b       	or	r24, r25
     c64:	59 f4       	brne	.+22     	; 0xc7c <receive_uart+0x1f4>
     c66:	6b e9       	ldi	r22, 0x9B	; 155
     c68:	71 e0       	ldi	r23, 0x01	; 1
     c6a:	ce 01       	movw	r24, r28
     c6c:	01 96       	adiw	r24, 0x01	; 1
     c6e:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     c72:	89 2b       	or	r24, r25
     c74:	19 f4       	brne	.+6      	; 0xc7c <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	c8 da       	rcall	.-2672   	; 0x20c <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c7c:	f6 01       	movw	r30, r12
     c7e:	83 a1       	ldd	r24, Z+35	; 0x23
     c80:	94 a1       	ldd	r25, Z+36	; 0x24
     c82:	89 2b       	or	r24, r25
     c84:	59 f4       	brne	.+22     	; 0xc9c <receive_uart+0x214>
     c86:	63 ea       	ldi	r22, 0xA3	; 163
     c88:	71 e0       	ldi	r23, 0x01	; 1
     c8a:	ce 01       	movw	r24, r28
     c8c:	01 96       	adiw	r24, 0x01	; 1
     c8e:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     c92:	89 2b       	or	r24, r25
     c94:	19 f4       	brne	.+6      	; 0xc9c <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	b8 da       	rcall	.-2704   	; 0x20c <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c9c:	d6 01       	movw	r26, r12
     c9e:	93 96       	adiw	r26, 0x23	; 35
     ca0:	8d 91       	ld	r24, X+
     ca2:	9c 91       	ld	r25, X
     ca4:	94 97       	sbiw	r26, 0x24	; 36
     ca6:	89 2b       	or	r24, r25
     ca8:	a9 f4       	brne	.+42     	; 0xcd4 <receive_uart+0x24c>
     caa:	69 ea       	ldi	r22, 0xA9	; 169
     cac:	71 e0       	ldi	r23, 0x01	; 1
     cae:	ce 01       	movw	r24, r28
     cb0:	01 96       	adiw	r24, 0x01	; 1
     cb2:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     cb6:	89 2b       	or	r24, r25
     cb8:	69 f4       	brne	.+26     	; 0xcd4 <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     cba:	f6 01       	movw	r30, r12
     cbc:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cbe:	e0 ac       	ldd	r14, Z+56	; 0x38
     cc0:	f1 ac       	ldd	r15, Z+57	; 0x39
     cc2:	06 a9       	ldd	r16, Z+54	; 0x36
     cc4:	17 a9       	ldd	r17, Z+55	; 0x37
     cc6:	24 a9       	ldd	r18, Z+52	; 0x34
     cc8:	35 a9       	ldd	r19, Z+53	; 0x35
     cca:	42 a9       	ldd	r20, Z+50	; 0x32
     ccc:	53 a9       	ldd	r21, Z+51	; 0x33
     cce:	62 ad       	ldd	r22, Z+58	; 0x3a
     cd0:	83 ad       	ldd	r24, Z+59	; 0x3b
     cd2:	69 da       	rcall	.-2862   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     cd4:	d6 01       	movw	r26, r12
     cd6:	93 96       	adiw	r26, 0x23	; 35
     cd8:	8d 91       	ld	r24, X+
     cda:	9c 91       	ld	r25, X
     cdc:	94 97       	sbiw	r26, 0x24	; 36
     cde:	89 2b       	or	r24, r25
     ce0:	b1 f4       	brne	.+44     	; 0xd0e <receive_uart+0x286>
     ce2:	67 eb       	ldi	r22, 0xB7	; 183
     ce4:	71 e0       	ldi	r23, 0x01	; 1
     ce6:	ce 01       	movw	r24, r28
     ce8:	01 96       	adiw	r24, 0x01	; 1
     cea:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     cee:	89 2b       	or	r24, r25
     cf0:	71 f4       	brne	.+28     	; 0xd0e <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	f6 01       	movw	r30, r12
     cf6:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     cf8:	e0 ac       	ldd	r14, Z+56	; 0x38
     cfa:	f1 ac       	ldd	r15, Z+57	; 0x39
     cfc:	06 a9       	ldd	r16, Z+54	; 0x36
     cfe:	17 a9       	ldd	r17, Z+55	; 0x37
     d00:	24 a9       	ldd	r18, Z+52	; 0x34
     d02:	35 a9       	ldd	r19, Z+53	; 0x35
     d04:	42 a9       	ldd	r20, Z+50	; 0x32
     d06:	53 a9       	ldd	r21, Z+51	; 0x33
     d08:	62 ad       	ldd	r22, Z+58	; 0x3a
     d0a:	83 ad       	ldd	r24, Z+59	; 0x3b
     d0c:	4c da       	rcall	.-2920   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     d0e:	d6 01       	movw	r26, r12
     d10:	93 96       	adiw	r26, 0x23	; 35
     d12:	8d 91       	ld	r24, X+
     d14:	9c 91       	ld	r25, X
     d16:	94 97       	sbiw	r26, 0x24	; 36
     d18:	89 2b       	or	r24, r25
     d1a:	b1 f4       	brne	.+44     	; 0xd48 <receive_uart+0x2c0>
     d1c:	67 ec       	ldi	r22, 0xC7	; 199
     d1e:	71 e0       	ldi	r23, 0x01	; 1
     d20:	ce 01       	movw	r24, r28
     d22:	01 96       	adiw	r24, 0x01	; 1
     d24:	0e 94 cb 13 	call	0x2796	; 0x2796 <strcmp>
     d28:	89 2b       	or	r24, r25
     d2a:	71 f4       	brne	.+28     	; 0xd48 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     d2c:	82 e0       	ldi	r24, 0x02	; 2
     d2e:	f6 01       	movw	r30, r12
     d30:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d32:	e0 ac       	ldd	r14, Z+56	; 0x38
     d34:	f1 ac       	ldd	r15, Z+57	; 0x39
     d36:	06 a9       	ldd	r16, Z+54	; 0x36
     d38:	17 a9       	ldd	r17, Z+55	; 0x37
     d3a:	24 a9       	ldd	r18, Z+52	; 0x34
     d3c:	35 a9       	ldd	r19, Z+53	; 0x35
     d3e:	42 a9       	ldd	r20, Z+50	; 0x32
     d40:	53 a9       	ldd	r21, Z+51	; 0x33
     d42:	62 ad       	ldd	r22, Z+58	; 0x3a
     d44:	83 ad       	ldd	r24, Z+59	; 0x3b
     d46:	2f da       	rcall	.-2978   	; 0x1a6 <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d48:	d6 01       	movw	r26, r12
     d4a:	93 96       	adiw	r26, 0x23	; 35
     d4c:	8d 91       	ld	r24, X+
     d4e:	9c 91       	ld	r25, X
     d50:	94 97       	sbiw	r26, 0x24	; 36
     d52:	89 2b       	or	r24, r25
     d54:	41 f4       	brne	.+16     	; 0xd66 <receive_uart+0x2de>
     d56:	c5 01       	movw	r24, r10
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	87 3e       	cpi	r24, 0xE7	; 231
     d5c:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d5e:	18 f4       	brcc	.+6      	; 0xd66 <receive_uart+0x2de>
     d60:	f6 01       	movw	r30, r12
     d62:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d64:	a2 aa       	std	Z+50, r10	; 0x32
     d66:	78 d3       	rcall	.+1776   	; 0x1458 <uart0_flush>
	}
}
     d68:	66 96       	adiw	r28, 0x16	; 22
     d6a:	0f b6       	in	r0, 0x3f	; 63
     d6c:	f8 94       	cli
     d6e:	de bf       	out	0x3e, r29	; 62
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	cd bf       	out	0x3d, r28	; 61
     d74:	df 91       	pop	r29
     d76:	cf 91       	pop	r28
     d78:	1f 91       	pop	r17
     d7a:	0f 91       	pop	r16
     d7c:	ff 90       	pop	r15
     d7e:	ef 90       	pop	r14
     d80:	df 90       	pop	r13
     d82:	cf 90       	pop	r12
     d84:	bf 90       	pop	r11
     d86:	af 90       	pop	r10
     d88:	08 95       	ret

00000d8a <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d8a:	ef 92       	push	r14
     d8c:	ff 92       	push	r15
     d8e:	0f 93       	push	r16
     d90:	1f 93       	push	r17
     d92:	cf 93       	push	r28
     d94:	df 93       	push	r29
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d9a:	88 ed       	ldi	r24, 0xD8	; 216
     d9c:	91 e0       	ldi	r25, 0x01	; 1
     d9e:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <puts>
	printf("%i", (int16_t)vals.actuator_in_position);
     da2:	8e a5       	ldd	r24, Y+46	; 0x2e
     da4:	9f a5       	ldd	r25, Y+47	; 0x2f
     da6:	9f 93       	push	r25
     da8:	8f 93       	push	r24
     daa:	0f 2e       	mov	r0, r31
     dac:	fa ed       	ldi	r31, 0xDA	; 218
     dae:	ef 2e       	mov	r14, r31
     db0:	f1 e0       	ldi	r31, 0x01	; 1
     db2:	ff 2e       	mov	r15, r31
     db4:	f0 2d       	mov	r31, r0
     db6:	ff 92       	push	r15
     db8:	ef 92       	push	r14
     dba:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     dbe:	8c e2       	ldi	r24, 0x2C	; 44
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u", vals.gear_required);
     dc6:	25 96       	adiw	r28, 0x05	; 5
     dc8:	8f ad       	ldd	r24, Y+63	; 0x3f
     dca:	25 97       	sbiw	r28, 0x05	; 5
     dcc:	1f 92       	push	r1
     dce:	8f 93       	push	r24
     dd0:	0d ed       	ldi	r16, 0xDD	; 221
     dd2:	11 e0       	ldi	r17, 0x01	; 1
     dd4:	1f 93       	push	r17
     dd6:	0f 93       	push	r16
     dd8:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     ddc:	8c e2       	ldi	r24, 0x2C	; 44
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.gear_status);
     de4:	24 96       	adiw	r28, 0x04	; 4
     de6:	8f ad       	ldd	r24, Y+63	; 0x3f
     de8:	24 97       	sbiw	r28, 0x04	; 4
     dea:	1f 92       	push	r1
     dec:	8f 93       	push	r24
     dee:	1f 93       	push	r17
     df0:	0f 93       	push	r16
     df2:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     df6:	8c e2       	ldi	r24, 0x2C	; 44
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u", vals.motor_status);
     dfe:	8f a1       	ldd	r24, Y+39	; 0x27
     e00:	1f 92       	push	r1
     e02:	8f 93       	push	r24
     e04:	1f 93       	push	r17
     e06:	0f 93       	push	r16
     e08:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e0c:	8c e2       	ldi	r24, 0x2C	; 44
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.message_mode);
     e14:	88 a5       	ldd	r24, Y+40	; 0x28
     e16:	1f 92       	push	r1
     e18:	8f 93       	push	r24
     e1a:	1f 93       	push	r17
     e1c:	0f 93       	push	r16
     e1e:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e22:	8c e2       	ldi	r24, 0x2C	; 44
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.u8_duty_cycle);
     e2a:	8a a1       	ldd	r24, Y+34	; 0x22
     e2c:	1f 92       	push	r1
     e2e:	8f 93       	push	r24
     e30:	1f 93       	push	r17
     e32:	0f 93       	push	r16
     e34:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e38:	8c e2       	ldi	r24, 0x2C	; 44
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e40:	6b 89       	ldd	r22, Y+19	; 0x13
     e42:	7c 89       	ldd	r23, Y+20	; 0x14
     e44:	8d 89       	ldd	r24, Y+21	; 0x15
     e46:	9e 89       	ldd	r25, Y+22	; 0x16
     e48:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     e4c:	7f 93       	push	r23
     e4e:	6f 93       	push	r22
     e50:	ff 92       	push	r15
     e52:	ef 92       	push	r14
     e54:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e58:	8c e2       	ldi	r24, 0x2C	; 44
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e60:	6c a9       	ldd	r22, Y+52	; 0x34
     e62:	7d a9       	ldd	r23, Y+53	; 0x35
     e64:	8e a9       	ldd	r24, Y+54	; 0x36
     e66:	9f a9       	ldd	r25, Y+55	; 0x37
     e68:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     e6c:	7f 93       	push	r23
     e6e:	6f 93       	push	r22
     e70:	ff 92       	push	r15
     e72:	ef 92       	push	r14
     e74:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	8c e2       	ldi	r24, 0x2C	; 44
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e8a:	89 85       	ldd	r24, Y+9	; 0x09
     e8c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e8e:	9f 93       	push	r25
     e90:	8f 93       	push	r24
     e92:	ff 92       	push	r15
     e94:	ef 92       	push	r14
     e96:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     e9a:	8c e2       	ldi	r24, 0x2C	; 44
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%i",vals.clutch_enabled);
     ea2:	8c a5       	ldd	r24, Y+44	; 0x2c
     ea4:	9d a5       	ldd	r25, Y+45	; 0x2d
     ea6:	9f 93       	push	r25
     ea8:	8f 93       	push	r24
     eaa:	ff 92       	push	r15
     eac:	ef 92       	push	r14
     eae:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     eb2:	8c e2       	ldi	r24, 0x2C	; 44
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.position_neutral);
     eba:	8d ad       	ldd	r24, Y+61	; 0x3d
     ebc:	9e ad       	ldd	r25, Y+62	; 0x3e
     ebe:	9f 93       	push	r25
     ec0:	8f 93       	push	r24
     ec2:	1f 93       	push	r17
     ec4:	0f 93       	push	r16
     ec6:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     eca:	8c e2       	ldi	r24, 0x2C	; 44
     ecc:	90 e0       	ldi	r25, 0x00	; 0
     ece:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.position_gear_1);
     ed2:	21 96       	adiw	r28, 0x01	; 1
     ed4:	8e ad       	ldd	r24, Y+62	; 0x3e
     ed6:	9f ad       	ldd	r25, Y+63	; 0x3f
     ed8:	21 97       	sbiw	r28, 0x01	; 1
     eda:	9f 93       	push	r25
     edc:	8f 93       	push	r24
     ede:	1f 93       	push	r17
     ee0:	0f 93       	push	r16
     ee2:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     ee6:	8c e2       	ldi	r24, 0x2C	; 44
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%u",vals.position_gear_2);	
     eee:	23 96       	adiw	r28, 0x03	; 3
     ef0:	8e ad       	ldd	r24, Y+62	; 0x3e
     ef2:	9f ad       	ldd	r25, Y+63	; 0x3f
     ef4:	23 97       	sbiw	r28, 0x03	; 3
     ef6:	9f 93       	push	r25
     ef8:	8f 93       	push	r24
     efa:	1f 93       	push	r17
     efc:	0f 93       	push	r16
     efe:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     f02:	8c e2       	ldi	r24, 0x2C	; 44
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     f0a:	88 ad       	ldd	r24, Y+56	; 0x38
     f0c:	1f 92       	push	r1
     f0e:	8f 93       	push	r24
     f10:	ff 92       	push	r15
     f12:	ef 92       	push	r14
     f14:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	printf(",");
     f18:	8c e2       	ldi	r24, 0x2C	; 44
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	0e 94 ef 13 	call	0x27de	; 0x27de <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     f20:	68 a9       	ldd	r22, Y+48	; 0x30
     f22:	79 a9       	ldd	r23, Y+49	; 0x31
     f24:	8a a9       	ldd	r24, Y+50	; 0x32
     f26:	9b a9       	ldd	r25, Y+51	; 0x33
     f28:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
     f2c:	7f 93       	push	r23
     f2e:	6f 93       	push	r22
     f30:	ff 92       	push	r15
     f32:	ef 92       	push	r14
     f34:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <printf>
	
}
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	1f 91       	pop	r17
     f48:	0f 91       	pop	r16
     f4a:	ff 90       	pop	r15
     f4c:	ef 90       	pop	r14
     f4e:	08 95       	ret

00000f50 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f58:	8b a1       	ldd	r24, Y+35	; 0x23
     f5a:	82 30       	cpi	r24, 0x02	; 2
     f5c:	91 f1       	breq	.+100    	; 0xfc2 <manage_LEDs+0x72>
     f5e:	28 f4       	brcc	.+10     	; 0xf6a <manage_LEDs+0x1a>
     f60:	88 23       	and	r24, r24
     f62:	49 f0       	breq	.+18     	; 0xf76 <manage_LEDs+0x26>
     f64:	81 30       	cpi	r24, 0x01	; 1
     f66:	19 f1       	breq	.+70     	; 0xfae <manage_LEDs+0x5e>
     f68:	49 c0       	rjmp	.+146    	; 0xffc <manage_LEDs+0xac>
     f6a:	84 30       	cpi	r24, 0x04	; 4
     f6c:	f1 f1       	breq	.+124    	; 0xfea <manage_LEDs+0x9a>
     f6e:	98 f1       	brcs	.+102    	; 0xfd6 <manage_LEDs+0x86>
     f70:	85 30       	cpi	r24, 0x05	; 5
     f72:	99 f0       	breq	.+38     	; 0xf9a <manage_LEDs+0x4a>
     f74:	43 c0       	rjmp	.+134    	; 0xffc <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f76:	80 e4       	ldi	r24, 0x40	; 64
     f78:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f7c:	80 e8       	ldi	r24, 0x80	; 128
     f7e:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f82:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f84:	98 a1       	ldd	r25, Y+32	; 0x20
     f86:	89 2b       	or	r24, r25
     f88:	21 f4       	brne	.+8      	; 0xf92 <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f8a:	80 e2       	ldi	r24, 0x20	; 32
     f8c:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
     f90:	35 c0       	rjmp	.+106    	; 0xffc <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f92:	80 e2       	ldi	r24, 0x20	; 32
     f94:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
     f98:	31 c0       	rjmp	.+98     	; 0xffc <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f9a:	80 e2       	ldi	r24, 0x20	; 32
     f9c:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fa0:	80 e4       	ldi	r24, 0x40	; 64
     fa2:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     fa6:	80 e8       	ldi	r24, 0x80	; 128
     fa8:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
		break ;
     fac:	27 c0       	rjmp	.+78     	; 0xffc <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     fae:	80 e2       	ldi	r24, 0x20	; 32
     fb0:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fb4:	80 e8       	ldi	r24, 0x80	; 128
     fb6:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fba:	80 e4       	ldi	r24, 0x40	; 64
     fbc:	0e 94 15 11 	call	0x222a	; 0x222a <rgbled_toggle>
		break;
     fc0:	1d c0       	rjmp	.+58     	; 0xffc <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     fc2:	80 e8       	ldi	r24, 0x80	; 128
     fc4:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fc8:	80 e4       	ldi	r24, 0x40	; 64
     fca:	0e 94 15 11 	call	0x222a	; 0x222a <rgbled_toggle>
			rgbled_toggle(LED_RED);
     fce:	80 e2       	ldi	r24, 0x20	; 32
     fd0:	0e 94 15 11 	call	0x222a	; 0x222a <rgbled_toggle>
		break;
     fd4:	13 c0       	rjmp	.+38     	; 0xffc <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     fd6:	80 e2       	ldi	r24, 0x20	; 32
     fd8:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fdc:	80 e8       	ldi	r24, 0x80	; 128
     fde:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fe2:	80 e4       	ldi	r24, 0x40	; 64
     fe4:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
		break;
     fe8:	09 c0       	rjmp	.+18     	; 0xffc <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     fea:	80 e4       	ldi	r24, 0x40	; 64
     fec:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     ff0:	80 e8       	ldi	r24, 0x80	; 128
     ff2:	0e 94 06 11 	call	0x220c	; 0x220c <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     ff6:	80 e2       	ldi	r24, 0x20	; 32
     ff8:	0e 94 10 11 	call	0x2220	; 0x2220 <rgbled_turn_on>
		break;
	}
     ffc:	df 91       	pop	r29
     ffe:	cf 91       	pop	r28
    1000:	08 95       	ret

00001002 <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
    1002:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
    1004:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
    1006:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
    1008:	e9 e6       	ldi	r30, 0x69	; 105
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 81       	ld	r24, Z
    100e:	84 60       	ori	r24, 0x04	; 4
    1010:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
    1012:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
    1014:	e9 9a       	sbi	0x1d, 1	; 29
    1016:	08 95       	ret

00001018 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
	
	if (*u16_counter > 70)
    1020:	fb 01       	movw	r30, r22
    1022:	20 81       	ld	r18, Z
    1024:	31 81       	ldd	r19, Z+1	; 0x01
    1026:	27 34       	cpi	r18, 0x47	; 71
    1028:	31 05       	cpc	r19, r1
    102a:	b8 f0       	brcs	.+46     	; 0x105a <handle_speed_sensor+0x42>
    102c:	eb 01       	movw	r28, r22
    102e:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    1030:	60 81       	ld	r22, Z
    1032:	71 81       	ldd	r23, Z+1	; 0x01
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
    103c:	9b 01       	movw	r18, r22
    103e:	ac 01       	movw	r20, r24
    1040:	60 e0       	ldi	r22, 0x00	; 0
    1042:	76 e7       	ldi	r23, 0x76	; 118
    1044:	88 e8       	ldi	r24, 0x88	; 136
    1046:	96 e4       	ldi	r25, 0x46	; 70
    1048:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
    104c:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
    1050:	f8 01       	movw	r30, r16
    1052:	71 83       	std	Z+1, r23	; 0x01
    1054:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    1056:	19 82       	std	Y+1, r1	; 0x01
    1058:	18 82       	st	Y, r1
	}	
}
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	1f 91       	pop	r17
    1060:	0f 91       	pop	r16
    1062:	08 95       	ret

00001064 <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    1064:	cf 92       	push	r12
    1066:	df 92       	push	r13
    1068:	ef 92       	push	r14
    106a:	ff 92       	push	r15
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	1f 92       	push	r1
    1072:	cd b7       	in	r28, 0x3d	; 61
    1074:	de b7       	in	r29, 0x3e	; 62
    1076:	89 83       	std	Y+1, r24	; 0x01
    1078:	69 01       	movw	r12, r18
    107a:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    107c:	61 30       	cpi	r22, 0x01	; 1
    107e:	19 f5       	brne	.+70     	; 0x10c6 <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    1080:	69 81       	ldd	r22, Y+1	; 0x01
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	80 e0       	ldi	r24, 0x00	; 0
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
    108c:	22 e1       	ldi	r18, 0x12	; 18
    108e:	35 e8       	ldi	r19, 0x85	; 133
    1090:	41 e6       	ldi	r20, 0x61	; 97
    1092:	5e e3       	ldi	r21, 0x3E	; 62
    1094:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    1098:	a7 01       	movw	r20, r14
    109a:	96 01       	movw	r18, r12
    109c:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
    10a0:	20 e0       	ldi	r18, 0x00	; 0
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	48 ec       	ldi	r20, 0xC8	; 200
    10a6:	52 e4       	ldi	r21, 0x42	; 66
    10a8:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    10ac:	20 e0       	ldi	r18, 0x00	; 0
    10ae:	30 e0       	ldi	r19, 0x00	; 0
    10b0:	48 e4       	ldi	r20, 0x48	; 72
    10b2:	52 e4       	ldi	r21, 0x42	; 66
    10b4:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
    10b8:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
    10bc:	86 2f       	mov	r24, r22
		if (Duty == 50)
    10be:	62 33       	cpi	r22, 0x32	; 50
    10c0:	29 f5       	brne	.+74     	; 0x110c <__stack+0xd>
		{
			Duty = 52 ;
    10c2:	84 e3       	ldi	r24, 0x34	; 52
    10c4:	23 c0       	rjmp	.+70     	; 0x110c <__stack+0xd>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    10c6:	62 30       	cpi	r22, 0x02	; 2
    10c8:	01 f5       	brne	.+64     	; 0x110a <__stack+0xb>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    10ca:	69 81       	ldd	r22, Y+1	; 0x01
    10cc:	70 e0       	ldi	r23, 0x00	; 0
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	0e 94 8e 12 	call	0x251c	; 0x251c <__floatsisf>
    10d6:	23 ee       	ldi	r18, 0xE3	; 227
    10d8:	3e ee       	ldi	r19, 0xEE	; 238
    10da:	4b e3       	ldi	r20, 0x3B	; 59
    10dc:	5e e3       	ldi	r21, 0x3E	; 62
    10de:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    10e2:	a7 01       	movw	r20, r14
    10e4:	96 01       	movw	r18, r12
    10e6:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__divsf3>
    10ea:	20 e0       	ldi	r18, 0x00	; 0
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	48 ec       	ldi	r20, 0xC8	; 200
    10f0:	52 e4       	ldi	r21, 0x42	; 66
    10f2:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    10f6:	20 e0       	ldi	r18, 0x00	; 0
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	48 e4       	ldi	r20, 0x48	; 72
    10fc:	52 e4       	ldi	r21, 0x42	; 66
    10fe:	0e 94 8b 11 	call	0x2316	; 0x2316 <__addsf3>
    1102:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__fixunssfsi>
    1106:	86 2f       	mov	r24, r22
    1108:	01 c0       	rjmp	.+2      	; 0x110c <__stack+0xd>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    110a:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    110c:	0f 90       	pop	r0
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	ff 90       	pop	r15
    1114:	ef 90       	pop	r14
    1116:	df 90       	pop	r13
    1118:	cf 90       	pop	r12
    111a:	08 95       	ret

0000111c <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
    1120:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    1122:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1124:	81 11       	cpse	r24, r1
    1126:	08 c0       	rjmp	.+16     	; 0x1138 <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    1128:	82 e3       	ldi	r24, 0x32	; 50
    112a:	90 e0       	ldi	r25, 0x00	; 0
    112c:	9b 8f       	std	Y+27, r25	; 0x1b
    112e:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    1130:	8e e1       	ldi	r24, 0x1E	; 30
    1132:	90 e0       	ldi	r25, 0x00	; 0
    1134:	9d 8f       	std	Y+29, r25	; 0x1d
    1136:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1138:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    113c:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    1140:	00 97       	sbiw	r24, 0x00	; 0
    1142:	31 f0       	breq	.+12     	; 0x1150 <state_handler+0x34>
	{
		fault_timeout -- ;
    1144:	01 97       	sbiw	r24, 0x01	; 1
    1146:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    114a:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    114e:	05 c0       	rjmp	.+10     	; 0x115a <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    1150:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1154:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    1156:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    115a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    115c:	82 30       	cpi	r24, 0x02	; 2
    115e:	09 f4       	brne	.+2      	; 0x1162 <state_handler+0x46>
    1160:	b7 c0       	rjmp	.+366    	; 0x12d0 <state_handler+0x1b4>
    1162:	30 f4       	brcc	.+12     	; 0x1170 <state_handler+0x54>
    1164:	88 23       	and	r24, r24
    1166:	61 f0       	breq	.+24     	; 0x1180 <state_handler+0x64>
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	09 f4       	brne	.+2      	; 0x116e <state_handler+0x52>
    116c:	8f c0       	rjmp	.+286    	; 0x128c <state_handler+0x170>
    116e:	e1 c0       	rjmp	.+450    	; 0x1332 <state_handler+0x216>
    1170:	84 30       	cpi	r24, 0x04	; 4
    1172:	09 f4       	brne	.+2      	; 0x1176 <state_handler+0x5a>
    1174:	cf c0       	rjmp	.+414    	; 0x1314 <state_handler+0x1f8>
    1176:	a0 f0       	brcs	.+40     	; 0x11a0 <state_handler+0x84>
    1178:	85 30       	cpi	r24, 0x05	; 5
    117a:	09 f4       	brne	.+2      	; 0x117e <state_handler+0x62>
    117c:	51 c0       	rjmp	.+162    	; 0x1220 <state_handler+0x104>
    117e:	d9 c0       	rjmp	.+434    	; 0x1332 <state_handler+0x216>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    1180:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1182:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1184:	89 2b       	or	r24, r25
    1186:	11 f0       	breq	.+4      	; 0x118c <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    1188:	83 e0       	ldi	r24, 0x03	; 3
    118a:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	a5 da       	rcall	.-2742   	; 0x6da <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    1190:	18 a2       	std	Y+32, r1	; 0x20
    1192:	30 d9       	rcall	.-3488   	; 0x3f4 <reset_I>
			vals->u8_brake_cmd = 0;
    1194:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    1196:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    1198:	82 e3       	ldi	r24, 0x32	; 50
    119a:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    119c:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    119e:	c9 c0       	rjmp	.+402    	; 0x1332 <state_handler+0x216>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    11a0:	8a a1       	ldd	r24, Y+34	; 0x22
    11a2:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    11a4:	24 c0       	rjmp	.+72     	; 0x11ee <state_handler+0xd2>
    11a6:	99 da       	rcall	.-2766   	; 0x6da <drivers>
				reset_I();
    11a8:	25 d9       	rcall	.-3510   	; 0x3f4 <reset_I>
    11aa:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    11ac:	89 8f       	std	Y+25, r24	; 0x19
    11ae:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    11b0:	88 23       	and	r24, r24
    11b2:	69 f0       	breq	.+26     	; 0x11ce <state_handler+0xb2>
    11b4:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11b6:	3b 85       	ldd	r19, Y+11	; 0x0b
    11b8:	4c 85       	ldd	r20, Y+12	; 0x0c
    11ba:	5d 85       	ldd	r21, Y+13	; 0x0d
    11bc:	8b 89       	ldd	r24, Y+19	; 0x13
    11be:	9c 89       	ldd	r25, Y+20	; 0x14
    11c0:	62 e0       	ldi	r22, 0x02	; 2
    11c2:	50 df       	rcall	.-352    	; 0x1064 <compute_synch_duty>
    11c4:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11c6:	89 8d       	ldd	r24, Y+25	; 0x19
    11c8:	1e d9       	rcall	.-3524   	; 0x406 <set_I>
    11ca:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    11cc:	8e 8f       	std	Y+30, r24	; 0x1e
    11ce:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11d0:	88 23       	and	r24, r24
    11d2:	69 f0       	breq	.+26     	; 0x11ee <state_handler+0xd2>
    11d4:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11d6:	3b 85       	ldd	r19, Y+11	; 0x0b
    11d8:	4c 85       	ldd	r20, Y+12	; 0x0c
    11da:	5d 85       	ldd	r21, Y+13	; 0x0d
    11dc:	8b 89       	ldd	r24, Y+19	; 0x13
    11de:	9c 89       	ldd	r25, Y+20	; 0x14
    11e0:	62 e0       	ldi	r22, 0x02	; 2
    11e2:	40 df       	rcall	.-384    	; 0x1064 <compute_synch_duty>
    11e4:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11e6:	89 8d       	ldd	r24, Y+25	; 0x19
    11e8:	0e d9       	rcall	.-3556   	; 0x406 <set_I>
    11ea:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    11ec:	8e 8f       	std	Y+30, r24	; 0x1e
    11ee:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    11f0:	81 30       	cpi	r24, 0x01	; 1
    11f2:	09 f0       	breq	.+2      	; 0x11f6 <state_handler+0xda>
    11f4:	9e c0       	rjmp	.+316    	; 0x1332 <state_handler+0x216>
    11f6:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    11f8:	81 11       	cpse	r24, r1
    11fa:	03 c0       	rjmp	.+6      	; 0x1202 <state_handler+0xe6>
    11fc:	88 8d       	ldd	r24, Y+24	; 0x18
    11fe:	88 23       	and	r24, r24
    1200:	41 f0       	breq	.+16     	; 0x1212 <state_handler+0xf6>
    1202:	8a ad       	ldd	r24, Y+58	; 0x3a
    1204:	81 11       	cpse	r24, r1
    1206:	05 c0       	rjmp	.+10     	; 0x1212 <state_handler+0xf6>
				{
					vals->motor_status = ENGAGE;
    1208:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    120a:	8e 8f       	std	Y+30, r24	; 0x1e
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	62 da       	rcall	.-2876   	; 0x6da <drivers>
				vals->gear_required = NEUTRAL ;
    1216:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    1218:	ed d8       	rcall	.-3622   	; 0x3f4 <reset_I>
    121a:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    121c:	89 8f       	std	Y+25, r24	; 0x19
    121e:	89 c0       	rjmp	.+274    	; 0x1332 <state_handler+0x216>
    1220:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    1222:	8b af       	std	Y+59, r24	; 0x3b
    1224:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    1228:	88 23       	and	r24, r24
    122a:	69 f0       	breq	.+26     	; 0x1246 <state_handler+0x12a>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    122c:	2a 85       	ldd	r18, Y+10	; 0x0a
    122e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1230:	4c 85       	ldd	r20, Y+12	; 0x0c
    1232:	5d 85       	ldd	r21, Y+13	; 0x0d
    1234:	6b ad       	ldd	r22, Y+59	; 0x3b
    1236:	8b 89       	ldd	r24, Y+19	; 0x13
    1238:	9c 89       	ldd	r25, Y+20	; 0x14
    123a:	14 df       	rcall	.-472    	; 0x1064 <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    123c:	89 8f       	std	Y+25, r24	; 0x19
    123e:	89 8d       	ldd	r24, Y+25	; 0x19
    1240:	e2 d8       	rcall	.-3644   	; 0x406 <set_I>
				starting_engage = 0;
    1242:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    124a:	ce 01       	movw	r24, r28
    124c:	f7 d8       	rcall	.-3602   	; 0x43c <controller>
    124e:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1250:	44 da       	rcall	.-2936   	; 0x6da <drivers>
    1252:	88 8d       	ldd	r24, Y+24	; 0x18
    1254:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    1256:	29 f0       	breq	.+10     	; 0x1262 <state_handler+0x146>
    1258:	8a ad       	ldd	r24, Y+58	; 0x3a
    125a:	81 30       	cpi	r24, 0x01	; 1
    125c:	11 f4       	brne	.+4      	; 0x1262 <state_handler+0x146>
    125e:	82 e0       	ldi	r24, 0x02	; 2
    1260:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    1262:	8f 89       	ldd	r24, Y+23	; 0x17
    1264:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    1266:	21 f0       	breq	.+8      	; 0x1270 <state_handler+0x154>
    1268:	8a ad       	ldd	r24, Y+58	; 0x3a
    126a:	81 30       	cpi	r24, 0x01	; 1
    126c:	09 f4       	brne	.+2      	; 0x1270 <state_handler+0x154>
    126e:	8e 8f       	std	Y+30, r24	; 0x1e
    1270:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    1272:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1274:	5e c0       	rjmp	.+188    	; 0x1332 <state_handler+0x216>
    1276:	88 8d       	ldd	r24, Y+24	; 0x18
    1278:	81 11       	cpse	r24, r1
    127a:	5b c0       	rjmp	.+182    	; 0x1332 <state_handler+0x216>
    127c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    127e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1280:	89 2b       	or	r24, r25
    1282:	09 f0       	breq	.+2      	; 0x1286 <state_handler+0x16a>
    1284:	56 c0       	rjmp	.+172    	; 0x1332 <state_handler+0x216>
			{
				vals->motor_status = IDLE;
    1286:	83 e0       	ldi	r24, 0x03	; 3
    1288:	8e 8f       	std	Y+30, r24	; 0x1e
    128a:	53 c0       	rjmp	.+166    	; 0x1332 <state_handler+0x216>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    128c:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    128e:	ce 01       	movw	r24, r28
    1290:	d5 d8       	rcall	.-3670   	; 0x43c <controller>
    1292:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1294:	22 da       	rcall	.-3004   	; 0x6da <drivers>
    1296:	8f 89       	ldd	r24, Y+23	; 0x17
    1298:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    129a:	06 c0       	rjmp	.+12     	; 0x12a8 <state_handler+0x18c>
    129c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    129e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12a0:	89 2b       	or	r24, r25
    12a2:	11 f4       	brne	.+4      	; 0x12a8 <state_handler+0x18c>
    12a4:	83 e0       	ldi	r24, 0x03	; 3
    12a6:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12a8:	8a a1       	ldd	r24, Y+34	; 0x22
    12aa:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12ac:	41 f4       	brne	.+16     	; 0x12be <state_handler+0x1a2>
    12ae:	8a ad       	ldd	r24, Y+58	; 0x3a
    12b0:	81 11       	cpse	r24, r1
    12b2:	05 c0       	rjmp	.+10     	; 0x12be <state_handler+0x1a2>
    12b4:	85 e0       	ldi	r24, 0x05	; 5
    12b6:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12b8:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    12ba:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    12be:	88 8d       	ldd	r24, Y+24	; 0x18
    12c0:	88 23       	and	r24, r24
    12c2:	b9 f1       	breq	.+110    	; 0x1332 <state_handler+0x216>
    12c4:	8f 89       	ldd	r24, Y+23	; 0x17
    12c6:	81 11       	cpse	r24, r1
    12c8:	34 c0       	rjmp	.+104    	; 0x1332 <state_handler+0x216>
			{
				vals->motor_status = BRAKE;
    12ca:	82 e0       	ldi	r24, 0x02	; 2
    12cc:	8e 8f       	std	Y+30, r24	; 0x1e
    12ce:	31 c0       	rjmp	.+98     	; 0x1332 <state_handler+0x216>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12d0:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12d2:	ce 01       	movw	r24, r28
    12d4:	b3 d8       	rcall	.-3738   	; 0x43c <controller>
    12d6:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12d8:	00 da       	rcall	.-3072   	; 0x6da <drivers>
    12da:	88 8d       	ldd	r24, Y+24	; 0x18
    12dc:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12de:	06 c0       	rjmp	.+12     	; 0x12ec <state_handler+0x1d0>
    12e0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12e2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12e4:	89 2b       	or	r24, r25
    12e6:	11 f4       	brne	.+4      	; 0x12ec <state_handler+0x1d0>
    12e8:	83 e0       	ldi	r24, 0x03	; 3
    12ea:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12ec:	8a a1       	ldd	r24, Y+34	; 0x22
    12ee:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12f0:	41 f4       	brne	.+16     	; 0x1302 <state_handler+0x1e6>
    12f2:	8a ad       	ldd	r24, Y+58	; 0x3a
    12f4:	81 11       	cpse	r24, r1
    12f6:	05 c0       	rjmp	.+10     	; 0x1302 <state_handler+0x1e6>
    12f8:	85 e0       	ldi	r24, 0x05	; 5
    12fa:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    1302:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    1304:	81 11       	cpse	r24, r1
    1306:	15 c0       	rjmp	.+42     	; 0x1332 <state_handler+0x216>
    1308:	8f 89       	ldd	r24, Y+23	; 0x17
    130a:	88 23       	and	r24, r24
    130c:	91 f0       	breq	.+36     	; 0x1332 <state_handler+0x216>
			{
				vals->motor_status = ACCEL;
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	8e 8f       	std	Y+30, r24	; 0x1e
    1312:	0f c0       	rjmp	.+30     	; 0x1332 <state_handler+0x216>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    1314:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1318:	81 11       	cpse	r24, r1
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <state_handler+0x204>
			{
				vals->motor_status = IDLE;
    131c:	83 e0       	ldi	r24, 0x03	; 3
    131e:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    1320:	80 e0       	ldi	r24, 0x00	; 0
    1322:	db d9       	rcall	.-3146   	; 0x6da <drivers>
    1324:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    1326:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    1328:	65 d8       	rcall	.-3894   	; 0x3f4 <reset_I>
			reset_I(); //reset integrator
    132a:	18 8e       	std	Y+24, r1	; 0x18
    132c:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    132e:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    1330:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    1332:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1334:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    1336:	49 f0       	breq	.+18     	; 0x134a <state_handler+0x22e>
    1338:	8e 8d       	ldd	r24, Y+30	; 0x1e
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	31 f0       	breq	.+12     	; 0x134a <state_handler+0x22e>
    133e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1340:	82 30       	cpi	r24, 0x02	; 2
    1342:	19 f0       	breq	.+6      	; 0x134a <state_handler+0x22e>
    1344:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1346:	85 30       	cpi	r24, 0x05	; 5
    1348:	29 f4       	brne	.+10     	; 0x1354 <state_handler+0x238>
    134a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    134c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    134e:	89 2b       	or	r24, r25
    1350:	09 f4       	brne	.+2      	; 0x1354 <state_handler+0x238>
    1352:	1e 8e       	std	Y+30, r1	; 0x1e
    1354:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    1356:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1358:	08 95       	ret

0000135a <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    135e:	8e b1       	in	r24, 0x0e	; 14
    1360:	87 7c       	andi	r24, 0xC7	; 199
    1362:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    1364:	8d b1       	in	r24, 0x0d	; 13
    1366:	88 63       	ori	r24, 0x38	; 56
    1368:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    136a:	a1 e9       	ldi	r26, 0x91	; 145
    136c:	b0 e0       	ldi	r27, 0x00	; 0
    136e:	8c 91       	ld	r24, X
    1370:	80 61       	ori	r24, 0x10	; 16
    1372:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    1374:	8c 91       	ld	r24, X
    1376:	87 7f       	andi	r24, 0xF7	; 247
    1378:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    137a:	e0 e9       	ldi	r30, 0x90	; 144
    137c:	f0 e0       	ldi	r31, 0x00	; 0
    137e:	80 81       	ld	r24, Z
    1380:	82 60       	ori	r24, 0x02	; 2
    1382:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    1384:	80 81       	ld	r24, Z
    1386:	8e 7f       	andi	r24, 0xFE	; 254
    1388:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    138a:	80 81       	ld	r24, Z
    138c:	80 68       	ori	r24, 0x80	; 128
    138e:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    1390:	80 81       	ld	r24, Z
    1392:	8f 7b       	andi	r24, 0xBF	; 191
    1394:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    1396:	80 81       	ld	r24, Z
    1398:	80 62       	ori	r24, 0x20	; 32
    139a:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    139c:	80 81       	ld	r24, Z
    139e:	8f 7e       	andi	r24, 0xEF	; 239
    13a0:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    13a2:	80 81       	ld	r24, Z
    13a4:	88 60       	ori	r24, 0x08	; 8
    13a6:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    13a8:	80 81       	ld	r24, Z
    13aa:	8b 7f       	andi	r24, 0xFB	; 251
    13ac:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    13ae:	8c 91       	ld	r24, X
    13b0:	81 60       	ori	r24, 0x01	; 1
    13b2:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    13b4:	8c 91       	ld	r24, X
    13b6:	89 7f       	andi	r24, 0xF9	; 249
    13b8:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    13ba:	c6 e9       	ldi	r28, 0x96	; 150
    13bc:	d0 e0       	ldi	r29, 0x00	; 0
    13be:	85 e8       	ldi	r24, 0x85	; 133
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	99 83       	std	Y+1, r25	; 0x01
    13c4:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    13c6:	68 81       	ld	r22, Y
    13c8:	79 81       	ldd	r23, Y+1	; 0x01
    13ca:	80 e0       	ldi	r24, 0x00	; 0
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
    13d2:	20 e0       	ldi	r18, 0x00	; 0
    13d4:	30 e0       	ldi	r19, 0x00	; 0
    13d6:	40 e0       	ldi	r20, 0x00	; 0
    13d8:	5f e3       	ldi	r21, 0x3F	; 63
    13da:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    13de:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
    13e2:	e8 e9       	ldi	r30, 0x98	; 152
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	71 83       	std	Z+1, r23	; 0x01
    13e8:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    13ea:	88 81       	ld	r24, Y
    13ec:	99 81       	ldd	r25, Y+1	; 0x01
    13ee:	20 81       	ld	r18, Z
    13f0:	31 81       	ldd	r19, Z+1	; 0x01
    13f2:	82 1b       	sub	r24, r18
    13f4:	93 0b       	sbc	r25, r19
    13f6:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    13fa:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    13fe:	68 81       	ld	r22, Y
    1400:	79 81       	ldd	r23, Y+1	; 0x01
    1402:	80 e0       	ldi	r24, 0x00	; 0
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	0e 94 8c 12 	call	0x2518	; 0x2518 <__floatunsisf>
    140a:	20 e0       	ldi	r18, 0x00	; 0
    140c:	30 e0       	ldi	r19, 0x00	; 0
    140e:	40 e0       	ldi	r20, 0x00	; 0
    1410:	5f e3       	ldi	r21, 0x3F	; 63
    1412:	0e 94 42 13 	call	0x2684	; 0x2684 <__mulsf3>
    1416:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <__fixsfsi>
    141a:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    141e:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    1422:	df 91       	pop	r29
    1424:	cf 91       	pop	r28
    1426:	08 95       	ret

00001428 <uart0_putc>:
    1428:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    142c:	9f 5f       	subi	r25, 0xFF	; 255
    142e:	9f 71       	andi	r25, 0x1F	; 31
    1430:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    1434:	92 17       	cp	r25, r18
    1436:	e1 f3       	breq	.-8      	; 0x1430 <uart0_putc+0x8>
    1438:	e9 2f       	mov	r30, r25
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	e5 5d       	subi	r30, 0xD5	; 213
    143e:	fb 4f       	sbci	r31, 0xFB	; 251
    1440:	80 83       	st	Z, r24
    1442:	2f b7       	in	r18, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    144a:	e1 ec       	ldi	r30, 0xC1	; 193
    144c:	f0 e0       	ldi	r31, 0x00	; 0
    144e:	80 81       	ld	r24, Z
    1450:	80 62       	ori	r24, 0x20	; 32
    1452:	80 83       	st	Z, r24
    1454:	2f bf       	out	0x3f, r18	; 63
    1456:	08 95       	ret

00001458 <uart0_flush>:
    1458:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    145c:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    1460:	98 13       	cpse	r25, r24
    1462:	fa cf       	rjmp	.-12     	; 0x1458 <uart0_flush>
    1464:	08 95       	ret

00001466 <uart1_putc>:
    1466:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    146a:	9f 5f       	subi	r25, 0xFF	; 255
    146c:	9f 71       	andi	r25, 0x1F	; 31
    146e:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    1472:	92 17       	cp	r25, r18
    1474:	e1 f3       	breq	.-8      	; 0x146e <uart1_putc+0x8>
    1476:	e9 2f       	mov	r30, r25
    1478:	f0 e0       	ldi	r31, 0x00	; 0
    147a:	ea 51       	subi	r30, 0x1A	; 26
    147c:	fc 4f       	sbci	r31, 0xFC	; 252
    147e:	80 83       	st	Z, r24
    1480:	2f b7       	in	r18, 0x3f	; 63
    1482:	f8 94       	cli
    1484:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    1488:	e9 ec       	ldi	r30, 0xC9	; 201
    148a:	f0 e0       	ldi	r31, 0x00	; 0
    148c:	80 81       	ld	r24, Z
    148e:	80 62       	ori	r24, 0x20	; 32
    1490:	80 83       	st	Z, r24
    1492:	2f bf       	out	0x3f, r18	; 63
    1494:	08 95       	ret

00001496 <uart_putchar>:
    1496:	cf 93       	push	r28
    1498:	c8 2f       	mov	r28, r24
    149a:	fb 01       	movw	r30, r22
    149c:	84 85       	ldd	r24, Z+12	; 0x0c
    149e:	95 85       	ldd	r25, Z+13	; 0x0d
    14a0:	01 97       	sbiw	r24, 0x01	; 1
    14a2:	39 f0       	breq	.+14     	; 0x14b2 <uart_putchar+0x1c>
    14a4:	ca 30       	cpi	r28, 0x0A	; 10
    14a6:	11 f4       	brne	.+4      	; 0x14ac <uart_putchar+0x16>
    14a8:	8d e0       	ldi	r24, 0x0D	; 13
    14aa:	be df       	rcall	.-132    	; 0x1428 <uart0_putc>
    14ac:	8c 2f       	mov	r24, r28
    14ae:	bc df       	rcall	.-136    	; 0x1428 <uart0_putc>
    14b0:	06 c0       	rjmp	.+12     	; 0x14be <uart_putchar+0x28>
    14b2:	ca 30       	cpi	r28, 0x0A	; 10
    14b4:	11 f4       	brne	.+4      	; 0x14ba <uart_putchar+0x24>
    14b6:	8d e0       	ldi	r24, 0x0D	; 13
    14b8:	d6 df       	rcall	.-84     	; 0x1466 <uart1_putc>
    14ba:	8c 2f       	mov	r24, r28
    14bc:	d4 df       	rcall	.-88     	; 0x1466 <uart1_putc>
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	cf 91       	pop	r28
    14c4:	08 95       	ret

000014c6 <uart0_getc>:
    14c6:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    14ca:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    14ce:	89 17       	cp	r24, r25
    14d0:	59 f0       	breq	.+22     	; 0x14e8 <uart0_getc+0x22>
    14d2:	8f 5f       	subi	r24, 0xFF	; 255
    14d4:	98 2f       	mov	r25, r24
    14d6:	9f 71       	andi	r25, 0x1F	; 31
    14d8:	e9 2f       	mov	r30, r25
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	ed 53       	subi	r30, 0x3D	; 61
    14de:	fc 4f       	sbci	r31, 0xFC	; 252
    14e0:	80 81       	ld	r24, Z
    14e2:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    14e6:	08 95       	ret
    14e8:	80 e0       	ldi	r24, 0x00	; 0
    14ea:	08 95       	ret

000014ec <uart0_getln>:
    14ec:	0f 93       	push	r16
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	ec 01       	movw	r28, r24
    14f6:	61 30       	cpi	r22, 0x01	; 1
    14f8:	b1 f0       	breq	.+44     	; 0x1526 <uart0_getln+0x3a>
    14fa:	62 50       	subi	r22, 0x02	; 2
    14fc:	06 2f       	mov	r16, r22
    14fe:	10 e0       	ldi	r17, 0x00	; 0
    1500:	0f 5f       	subi	r16, 0xFF	; 255
    1502:	1f 4f       	sbci	r17, 0xFF	; 255
    1504:	08 0f       	add	r16, r24
    1506:	19 1f       	adc	r17, r25
    1508:	de df       	rcall	.-68     	; 0x14c6 <uart0_getc>
    150a:	88 83       	st	Y, r24
    150c:	88 23       	and	r24, r24
    150e:	e1 f3       	breq	.-8      	; 0x1508 <uart0_getln+0x1c>
    1510:	8d 30       	cpi	r24, 0x0D	; 13
    1512:	21 f4       	brne	.+8      	; 0x151c <uart0_getln+0x30>
    1514:	d8 df       	rcall	.-80     	; 0x14c6 <uart0_getc>
    1516:	88 23       	and	r24, r24
    1518:	e9 f3       	breq	.-6      	; 0x1514 <uart0_getln+0x28>
    151a:	05 c0       	rjmp	.+10     	; 0x1526 <uart0_getln+0x3a>
    151c:	21 96       	adiw	r28, 0x01	; 1
    151e:	c0 17       	cp	r28, r16
    1520:	d1 07       	cpc	r29, r17
    1522:	91 f7       	brne	.-28     	; 0x1508 <uart0_getln+0x1c>
    1524:	e8 01       	movw	r28, r16
    1526:	18 82       	st	Y, r1
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	08 95       	ret

00001532 <uart0_getData>:
    1532:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    1536:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    153a:	89 17       	cp	r24, r25
    153c:	61 f0       	breq	.+24     	; 0x1556 <uart0_getData+0x24>
    153e:	8f 5f       	subi	r24, 0xFF	; 255
    1540:	8f 71       	andi	r24, 0x1F	; 31
    1542:	e8 2f       	mov	r30, r24
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	ed 53       	subi	r30, 0x3D	; 61
    1548:	fc 4f       	sbci	r31, 0xFC	; 252
    154a:	90 81       	ld	r25, Z
    154c:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    1550:	89 2f       	mov	r24, r25
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	08 95       	ret
    1556:	8f ef       	ldi	r24, 0xFF	; 255
    1558:	9f ef       	ldi	r25, 0xFF	; 255
    155a:	08 95       	ret

0000155c <uart1_getData>:
    155c:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    1560:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    1564:	89 17       	cp	r24, r25
    1566:	61 f0       	breq	.+24     	; 0x1580 <uart1_getData+0x24>
    1568:	8f 5f       	subi	r24, 0xFF	; 255
    156a:	8f 71       	andi	r24, 0x1F	; 31
    156c:	e8 2f       	mov	r30, r24
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	e9 5f       	subi	r30, 0xF9	; 249
    1572:	fb 4f       	sbci	r31, 0xFB	; 251
    1574:	90 81       	ld	r25, Z
    1576:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    157a:	89 2f       	mov	r24, r25
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	08 95       	ret
    1580:	8f ef       	ldi	r24, 0xFF	; 255
    1582:	9f ef       	ldi	r25, 0xFF	; 255
    1584:	08 95       	ret

00001586 <uart_getchar>:
    1586:	cf 93       	push	r28
    1588:	df 93       	push	r29
    158a:	fc 01       	movw	r30, r24
    158c:	84 85       	ldd	r24, Z+12	; 0x0c
    158e:	95 85       	ldd	r25, Z+13	; 0x0d
    1590:	01 97       	sbiw	r24, 0x01	; 1
    1592:	41 f0       	breq	.+16     	; 0x15a4 <uart_getchar+0x1e>
    1594:	ce df       	rcall	.-100    	; 0x1532 <uart0_getData>
    1596:	ec 01       	movw	r28, r24
    1598:	99 23       	and	r25, r25
    159a:	e4 f3       	brlt	.-8      	; 0x1594 <uart_getchar+0xe>
    159c:	45 df       	rcall	.-374    	; 0x1428 <uart0_putc>
    159e:	ce 01       	movw	r24, r28
    15a0:	99 27       	eor	r25, r25
    15a2:	07 c0       	rjmp	.+14     	; 0x15b2 <uart_getchar+0x2c>
    15a4:	db df       	rcall	.-74     	; 0x155c <uart1_getData>
    15a6:	ec 01       	movw	r28, r24
    15a8:	99 23       	and	r25, r25
    15aa:	e4 f3       	brlt	.-8      	; 0x15a4 <uart_getchar+0x1e>
    15ac:	5c df       	rcall	.-328    	; 0x1466 <uart1_putc>
    15ae:	ce 01       	movw	r24, r28
    15b0:	99 27       	eor	r25, r25
    15b2:	99 27       	eor	r25, r25
    15b4:	df 91       	pop	r29
    15b6:	cf 91       	pop	r28
    15b8:	08 95       	ret

000015ba <__vector_22>:
    15ba:	0f 93       	push	r16
    15bc:	0f b7       	in	r16, 0x3f	; 63
    15be:	ef 93       	push	r30
    15c0:	ff 93       	push	r31
    15c2:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    15c6:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    15ca:	e3 95       	inc	r30
    15cc:	ef 71       	andi	r30, 0x1F	; 31
    15ce:	ef 13       	cpse	r30, r31
    15d0:	05 c0       	rjmp	.+10     	; 0x15dc <USART0_TX_CONTINUE>
    15d2:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15d6:	ff 7d       	andi	r31, 0xDF	; 223
    15d8:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015dc <USART0_TX_CONTINUE>:
    15dc:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    15e0:	f0 e0       	ldi	r31, 0x00	; 0
    15e2:	e5 5d       	subi	r30, 0xD5	; 213
    15e4:	fb 4f       	sbci	r31, 0xFB	; 251
    15e6:	e0 81       	ld	r30, Z
    15e8:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

000015ec <USART0_TX_EXIT>:
    15ec:	ff 91       	pop	r31
    15ee:	ef 91       	pop	r30
    15f0:	0f bf       	out	0x3f, r16	; 63
    15f2:	0f 91       	pop	r16
    15f4:	18 95       	reti

000015f6 <__vector_21>:
    15f6:	0f 93       	push	r16
    15f8:	0f b7       	in	r16, 0x3f	; 63
    15fa:	9f 93       	push	r25
    15fc:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1600:	ef 93       	push	r30
    1602:	ff 93       	push	r31
    1604:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    1608:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    160c:	e3 95       	inc	r30
    160e:	ef 71       	andi	r30, 0x1F	; 31
    1610:	fe 17       	cp	r31, r30
    1612:	31 f0       	breq	.+12     	; 0x1620 <USART0_RX_EXIT>
    1614:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    1618:	f0 e0       	ldi	r31, 0x00	; 0
    161a:	ed 53       	subi	r30, 0x3D	; 61
    161c:	fc 4f       	sbci	r31, 0xFC	; 252
    161e:	90 83       	st	Z, r25

00001620 <USART0_RX_EXIT>:
    1620:	ff 91       	pop	r31
    1622:	ef 91       	pop	r30
    1624:	9f 91       	pop	r25
    1626:	0f bf       	out	0x3f, r16	; 63
    1628:	0f 91       	pop	r16
    162a:	18 95       	reti

0000162c <__vector_33>:
    162c:	0f 93       	push	r16
    162e:	0f b7       	in	r16, 0x3f	; 63
    1630:	ef 93       	push	r30
    1632:	ff 93       	push	r31
    1634:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1638:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    163c:	e3 95       	inc	r30
    163e:	ef 71       	andi	r30, 0x1F	; 31
    1640:	ef 13       	cpse	r30, r31
    1642:	05 c0       	rjmp	.+10     	; 0x164e <USART1_TX_CONTINUE>
    1644:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1648:	ff 7d       	andi	r31, 0xDF	; 223
    164a:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

0000164e <USART1_TX_CONTINUE>:
    164e:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    1652:	f0 e0       	ldi	r31, 0x00	; 0
    1654:	ea 51       	subi	r30, 0x1A	; 26
    1656:	fc 4f       	sbci	r31, 0xFC	; 252
    1658:	e0 81       	ld	r30, Z
    165a:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

0000165e <USART1_TX_EXIT>:
    165e:	ff 91       	pop	r31
    1660:	ef 91       	pop	r30
    1662:	0f bf       	out	0x3f, r16	; 63
    1664:	0f 91       	pop	r16
    1666:	18 95       	reti

00001668 <__vector_32>:
    1668:	0f 93       	push	r16
    166a:	0f b7       	in	r16, 0x3f	; 63
    166c:	9f 93       	push	r25
    166e:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1672:	ef 93       	push	r30
    1674:	ff 93       	push	r31
    1676:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    167a:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    167e:	e3 95       	inc	r30
    1680:	ef 71       	andi	r30, 0x1F	; 31
    1682:	fe 17       	cp	r31, r30
    1684:	31 f0       	breq	.+12     	; 0x1692 <USART1_RX_EXIT>
    1686:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    168a:	f0 e0       	ldi	r31, 0x00	; 0
    168c:	e9 5f       	subi	r30, 0xF9	; 249
    168e:	fb 4f       	sbci	r31, 0xFB	; 251
    1690:	90 83       	st	Z, r25

00001692 <USART1_RX_EXIT>:
    1692:	ff 91       	pop	r31
    1694:	ef 91       	pop	r30
    1696:	9f 91       	pop	r25
    1698:	0f bf       	out	0x3f, r16	; 63
    169a:	0f 91       	pop	r16
    169c:	18 95       	reti

0000169e <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    169e:	e1 e8       	ldi	r30, 0x81	; 129
    16a0:	f0 e0       	ldi	r31, 0x00	; 0
    16a2:	80 81       	ld	r24, Z
    16a4:	83 60       	ori	r24, 0x03	; 3
    16a6:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    16a8:	80 81       	ld	r24, Z
    16aa:	88 60       	ori	r24, 0x08	; 8
    16ac:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    16ae:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    16b2:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    16b6:	ef e6       	ldi	r30, 0x6F	; 111
    16b8:	f0 e0       	ldi	r31, 0x00	; 0
    16ba:	80 81       	ld	r24, Z
    16bc:	82 60       	ori	r24, 0x02	; 2
    16be:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    16c0:	8d e7       	ldi	r24, 0x7D	; 125
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16c8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16cc:	08 95       	ret

000016ce <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    16ce:	84 b5       	in	r24, 0x24	; 36
    16d0:	85 60       	ori	r24, 0x05	; 5
    16d2:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16d4:	84 b5       	in	r24, 0x24	; 36
    16d6:	88 60       	ori	r24, 0x08	; 8
    16d8:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16da:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16dc:	ee e6       	ldi	r30, 0x6E	; 110
    16de:	f0 e0       	ldi	r31, 0x00	; 0
    16e0:	80 81       	ld	r24, Z
    16e2:	82 60       	ori	r24, 0x02	; 2
    16e4:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    16e6:	87 e2       	ldi	r24, 0x27	; 39
    16e8:	87 bd       	out	0x27, r24	; 39
    16ea:	08 95       	ret

000016ec <main>:
};


int main(void)	
{
	cli();
    16ec:	f8 94       	cli
	rgbled_init();
    16ee:	92 d5       	rcall	.+2852   	; 0x2214 <rgbled_init>
	DWC_init();
    16f0:	11 d2       	rcall	.+1058   	; 0x1b14 <DWC_init>
	pwm_init();
    16f2:	33 de       	rcall	.-922    	; 0x135a <pwm_init>
    16f4:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    16f6:	70 e0       	ldi	r23, 0x00	; 0
    16f8:	80 e0       	ldi	r24, 0x00	; 0
    16fa:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    16fc:	71 d4       	rcall	.+2274   	; 0x1fe0 <can_init>
	timer0_init_ts();
    16fe:	cf df       	rcall	.-98     	; 0x169e <timer1_init_ts>
    1700:	e6 df       	rcall	.-52     	; 0x16ce <timer0_init_ts>
	speed_init();
    1702:	7f dc       	rcall	.-1794   	; 0x1002 <speed_init>
    1704:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    1706:	95 d5       	rcall	.+2858   	; 0x2232 <spi_init>
    1708:	82 e1       	ldi	r24, 0x12	; 18
    170a:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    170c:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    1710:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    1714:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1718:	88 e9       	ldi	r24, 0x98	; 152
    171a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    171e:	eb e4       	ldi	r30, 0x4B	; 75
    1720:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    1722:	84 e0       	ldi	r24, 0x04	; 4
    1724:	91 e0       	ldi	r25, 0x01	; 1
    1726:	93 83       	std	Z+3, r25	; 0x03
    1728:	82 83       	std	Z+2, r24	; 0x02
    172a:	91 83       	std	Z+1, r25	; 0x01
    172c:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    172e:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <drivers_init>
	drivers_init();
    1732:	80 e0       	ldi	r24, 0x00	; 0
    1734:	0e 94 6d 03 	call	0x6da	; 0x6da <drivers>
	drivers(0);
    1738:	78 94       	sei
	sei();
    173a:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    173c:	67 e9       	ldi	r22, 0x97	; 151
    173e:	73 e0       	ldi	r23, 0x03	; 3
    1740:	82 e1       	ldi	r24, 0x12	; 18
    1742:	91 e0       	ldi	r25, 0x01	; 1
    1744:	c5 d8       	rcall	.-3702   	; 0x8d0 <handle_can>
    1746:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1748:	91 e0       	ldi	r25, 0x01	; 1
    174a:	9e d9       	rcall	.-3268   	; 0xa88 <receive_uart>
    174c:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1750:	88 23       	and	r24, r24
    1752:	09 f4       	brne	.+2      	; 0x1756 <main+0x6a>
    1754:	41 c0       	rjmp	.+130    	; 0x17d8 <main+0xec>
    1756:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    175a:	88 23       	and	r24, r24
    175c:	f1 f0       	breq	.+60     	; 0x179a <main+0xae>
    175e:	8d b7       	in	r24, 0x3d	; 61
    1760:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    1762:	cd 97       	sbiw	r24, 0x3d	; 61
    1764:	0f b6       	in	r0, 0x3f	; 63
    1766:	f8 94       	cli
    1768:	9e bf       	out	0x3e, r25	; 62
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	8d bf       	out	0x3d, r24	; 61
    176e:	ad b7       	in	r26, 0x3d	; 61
    1770:	be b7       	in	r27, 0x3e	; 62
    1772:	11 96       	adiw	r26, 0x01	; 1
    1774:	8d e3       	ldi	r24, 0x3D	; 61
    1776:	e2 e1       	ldi	r30, 0x12	; 18
    1778:	f1 e0       	ldi	r31, 0x01	; 1
    177a:	01 90       	ld	r0, Z+
    177c:	0d 92       	st	X+, r0
    177e:	8a 95       	dec	r24
    1780:	e1 f7       	brne	.-8      	; 0x177a <main+0x8e>
    1782:	fd d8       	rcall	.-3590   	; 0x97e <handle_motor_status_can_msg>
    1784:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    1788:	8d b7       	in	r24, 0x3d	; 61
    178a:	9e b7       	in	r25, 0x3e	; 62
    178c:	cd 96       	adiw	r24, 0x3d	; 61
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	9e bf       	out	0x3e, r25	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	8d bf       	out	0x3d, r24	; 61
    1798:	1d c0       	rjmp	.+58     	; 0x17d4 <main+0xe8>
    179a:	8d b7       	in	r24, 0x3d	; 61
    179c:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    179e:	cd 97       	sbiw	r24, 0x3d	; 61
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	f8 94       	cli
    17a4:	9e bf       	out	0x3e, r25	; 62
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	8d bf       	out	0x3d, r24	; 61
    17aa:	ad b7       	in	r26, 0x3d	; 61
    17ac:	be b7       	in	r27, 0x3e	; 62
    17ae:	11 96       	adiw	r26, 0x01	; 1
    17b0:	8d e3       	ldi	r24, 0x3D	; 61
    17b2:	e2 e1       	ldi	r30, 0x12	; 18
    17b4:	f1 e0       	ldi	r31, 0x01	; 1
    17b6:	01 90       	ld	r0, Z+
    17b8:	0d 92       	st	X+, r0
    17ba:	8a 95       	dec	r24
    17bc:	e1 f7       	brne	.-8      	; 0x17b6 <main+0xca>
    17be:	4e d9       	rcall	.-3428   	; 0xa5c <handle_clutch_cmd_can_msg>
    17c0:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    17c4:	8d b7       	in	r24, 0x3d	; 61
    17c6:	9e b7       	in	r25, 0x3e	; 62
    17c8:	cd 96       	adiw	r24, 0x3d	; 61
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	f8 94       	cli
    17ce:	9e bf       	out	0x3e, r25	; 62
    17d0:	0f be       	out	0x3f, r0	; 63
    17d2:	8d bf       	out	0x3d, r24	; 61
    17d4:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17d8:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17dc:	88 23       	and	r24, r24
    17de:	09 f4       	brne	.+2      	; 0x17e2 <main+0xf6>
    17e0:	ad cf       	rjmp	.-166    	; 0x173c <main+0x50>
    17e2:	8d b7       	in	r24, 0x3d	; 61
    17e4:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    17e6:	cd 97       	sbiw	r24, 0x3d	; 61
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	9e bf       	out	0x3e, r25	; 62
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	8d bf       	out	0x3d, r24	; 61
    17f2:	ad b7       	in	r26, 0x3d	; 61
    17f4:	be b7       	in	r27, 0x3e	; 62
    17f6:	11 96       	adiw	r26, 0x01	; 1
    17f8:	8d e3       	ldi	r24, 0x3D	; 61
    17fa:	e2 e1       	ldi	r30, 0x12	; 18
    17fc:	f1 e0       	ldi	r31, 0x01	; 1
    17fe:	01 90       	ld	r0, Z+
    1800:	0d 92       	st	X+, r0
    1802:	8a 95       	dec	r24
    1804:	e1 f7       	brne	.-8      	; 0x17fe <main+0x112>
    1806:	c1 da       	rcall	.-2686   	; 0xd8a <send_uart>
    1808:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    180c:	8d b7       	in	r24, 0x3d	; 61
    180e:	9e b7       	in	r25, 0x3e	; 62
    1810:	cd 96       	adiw	r24, 0x3d	; 61
    1812:	0f b6       	in	r0, 0x3f	; 63
    1814:	f8 94       	cli
    1816:	9e bf       	out	0x3e, r25	; 62
    1818:	0f be       	out	0x3f, r0	; 63
    181a:	8d bf       	out	0x3d, r24	; 61
    181c:	8f cf       	rjmp	.-226    	; 0x173c <main+0x50>

0000181e <__vector_16>:
    181e:	1f 92       	push	r1
    1820:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	0f 92       	push	r0
    1826:	11 24       	eor	r1, r1
    1828:	0b b6       	in	r0, 0x3b	; 59
    182a:	0f 92       	push	r0
    182c:	ef 92       	push	r14
    182e:	0f 93       	push	r16
    1830:	1f 93       	push	r17
    1832:	2f 93       	push	r18
    1834:	3f 93       	push	r19
    1836:	4f 93       	push	r20
    1838:	5f 93       	push	r21
    183a:	6f 93       	push	r22
    183c:	7f 93       	push	r23
    183e:	8f 93       	push	r24
    1840:	9f 93       	push	r25
    1842:	af 93       	push	r26
    1844:	bf 93       	push	r27
    1846:	ef 93       	push	r30
    1848:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    184a:	82 e1       	ldi	r24, 0x12	; 18
    184c:	91 e0       	ldi	r25, 0x01	; 1
    184e:	63 d1       	rcall	.+710    	; 0x1b16 <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1850:	82 e1       	ldi	r24, 0x12	; 18
    1852:	91 e0       	ldi	r25, 0x01	; 1
    1854:	63 dc       	rcall	.-1850   	; 0x111c <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    1856:	82 e1       	ldi	r24, 0x12	; 18
    1858:	91 e0       	ldi	r25, 0x01	; 1
    185a:	0e 94 a4 01 	call	0x348	; 0x348 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    185e:	82 e1       	ldi	r24, 0x12	; 18
    1860:	91 e0       	ldi	r25, 0x01	; 1
    1862:	0e 94 a4 00 	call	0x148	; 0x148 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    1866:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    186a:	87 30       	cpi	r24, 0x07	; 7
    186c:	09 f0       	breq	.+2      	; 0x1870 <__vector_16+0x52>
    186e:	51 c0       	rjmp	.+162    	; 0x1912 <__vector_16+0xf4>
	{
		b_send_can = 1;
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    1876:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    187a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    187e:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    1882:	89 2b       	or	r24, r25
    1884:	b1 f0       	breq	.+44     	; 0x18b2 <__vector_16+0x94>
    1886:	e2 e1       	ldi	r30, 0x12	; 18
    1888:	f1 e0       	ldi	r31, 0x01	; 1
    188a:	97 8d       	ldd	r25, Z+31	; 0x1f
    188c:	27 8d       	ldd	r18, Z+31	; 0x1f
    188e:	81 e0       	ldi	r24, 0x01	; 1
    1890:	91 30       	cpi	r25, 0x01	; 1
    1892:	09 f0       	breq	.+2      	; 0x1896 <__vector_16+0x78>
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	81 11       	cpse	r24, r1
    1898:	05 c0       	rjmp	.+10     	; 0x18a4 <__vector_16+0x86>
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	21 11       	cpse	r18, r1
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	88 23       	and	r24, r24
    18a2:	39 f0       	breq	.+14     	; 0x18b2 <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    18a4:	e2 e1       	ldi	r30, 0x12	; 18
    18a6:	f1 e0       	ldi	r31, 0x01	; 1
    18a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18aa:	93 8d       	ldd	r25, Z+27	; 0x1b
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	93 8f       	std	Z+27, r25	; 0x1b
    18b0:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    18b2:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    18b6:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    18ba:	89 2b       	or	r24, r25
    18bc:	b1 f0       	breq	.+44     	; 0x18ea <__vector_16+0xcc>
    18be:	e2 e1       	ldi	r30, 0x12	; 18
    18c0:	f1 e0       	ldi	r31, 0x01	; 1
    18c2:	97 8d       	ldd	r25, Z+31	; 0x1f
    18c4:	27 8d       	ldd	r18, Z+31	; 0x1f
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	91 30       	cpi	r25, 0x01	; 1
    18ca:	09 f0       	breq	.+2      	; 0x18ce <__vector_16+0xb0>
    18cc:	80 e0       	ldi	r24, 0x00	; 0
    18ce:	81 11       	cpse	r24, r1
    18d0:	05 c0       	rjmp	.+10     	; 0x18dc <__vector_16+0xbe>
    18d2:	81 e0       	ldi	r24, 0x01	; 1
    18d4:	21 11       	cpse	r18, r1
    18d6:	80 e0       	ldi	r24, 0x00	; 0
    18d8:	88 23       	and	r24, r24
    18da:	39 f0       	breq	.+14     	; 0x18ea <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18dc:	e2 e1       	ldi	r30, 0x12	; 18
    18de:	f1 e0       	ldi	r31, 0x01	; 1
    18e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    18e2:	95 8d       	ldd	r25, Z+29	; 0x1d
    18e4:	01 97       	sbiw	r24, 0x01	; 1
    18e6:	95 8f       	std	Z+29, r25	; 0x1d
    18e8:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    18ea:	e2 e1       	ldi	r30, 0x12	; 18
    18ec:	f1 e0       	ldi	r31, 0x01	; 1
    18ee:	02 85       	ldd	r16, Z+10	; 0x0a
    18f0:	13 85       	ldd	r17, Z+11	; 0x0b
    18f2:	24 85       	ldd	r18, Z+12	; 0x0c
    18f4:	35 85       	ldd	r19, Z+13	; 0x0d
    18f6:	46 81       	ldd	r20, Z+6	; 0x06
    18f8:	57 81       	ldd	r21, Z+7	; 0x07
    18fa:	60 85       	ldd	r22, Z+8	; 0x08
    18fc:	71 85       	ldd	r23, Z+9	; 0x09
    18fe:	0f 2e       	mov	r0, r31
    1900:	f9 e2       	ldi	r31, 0x29	; 41
    1902:	ef 2e       	mov	r14, r31
    1904:	f0 2d       	mov	r31, r0
    1906:	80 e2       	ldi	r24, 0x20	; 32
    1908:	91 e0       	ldi	r25, 0x01	; 1
    190a:	e6 d1       	rcall	.+972    	; 0x1cd8 <handle_joulemeter>
		systic_counter_fast = 0;
    190c:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    1910:	03 c0       	rjmp	.+6      	; 0x1918 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    1912:	8f 5f       	subi	r24, 0xFF	; 255
    1914:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1918:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    191c:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    1920:	84 36       	cpi	r24, 0x64	; 100
    1922:	91 05       	cpc	r25, r1
    1924:	01 f5       	brne	.+64     	; 0x1966 <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    1926:	8d b7       	in	r24, 0x3d	; 61
    1928:	9e b7       	in	r25, 0x3e	; 62
    192a:	cd 97       	sbiw	r24, 0x3d	; 61
    192c:	0f b6       	in	r0, 0x3f	; 63
    192e:	f8 94       	cli
    1930:	9e bf       	out	0x3e, r25	; 62
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	8d bf       	out	0x3d, r24	; 61
    1936:	ad b7       	in	r26, 0x3d	; 61
    1938:	be b7       	in	r27, 0x3e	; 62
    193a:	11 96       	adiw	r26, 0x01	; 1
    193c:	8d e3       	ldi	r24, 0x3D	; 61
    193e:	e2 e1       	ldi	r30, 0x12	; 18
    1940:	f1 e0       	ldi	r31, 0x01	; 1
    1942:	01 90       	ld	r0, Z+
    1944:	0d 92       	st	X+, r0
    1946:	8a 95       	dec	r24
    1948:	e1 f7       	brne	.-8      	; 0x1942 <__vector_16+0x124>
    194a:	02 db       	rcall	.-2556   	; 0xf50 <manage_LEDs>
		systic_counter_slow = 0;
    194c:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1950:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    1954:	8d b7       	in	r24, 0x3d	; 61
    1956:	9e b7       	in	r25, 0x3e	; 62
    1958:	cd 96       	adiw	r24, 0x3d	; 61
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	9e bf       	out	0x3e, r25	; 62
    1960:	0f be       	out	0x3f, r0	; 63
    1962:	8d bf       	out	0x3d, r24	; 61
    1964:	05 c0       	rjmp	.+10     	; 0x1970 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    1966:	01 96       	adiw	r24, 0x01	; 1
    1968:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    196c:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1970:	ff 91       	pop	r31
    1972:	ef 91       	pop	r30
    1974:	bf 91       	pop	r27
    1976:	af 91       	pop	r26
    1978:	9f 91       	pop	r25
    197a:	8f 91       	pop	r24
    197c:	7f 91       	pop	r23
    197e:	6f 91       	pop	r22
    1980:	5f 91       	pop	r21
    1982:	4f 91       	pop	r20
    1984:	3f 91       	pop	r19
    1986:	2f 91       	pop	r18
    1988:	1f 91       	pop	r17
    198a:	0f 91       	pop	r16
    198c:	ef 90       	pop	r14
    198e:	0f 90       	pop	r0
    1990:	0b be       	out	0x3b, r0	; 59
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	0f 90       	pop	r0
    1998:	1f 90       	pop	r1
    199a:	18 95       	reti

0000199c <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    199c:	1f 92       	push	r1
    199e:	0f 92       	push	r0
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	0f 92       	push	r0
    19a4:	11 24       	eor	r1, r1
    19a6:	0b b6       	in	r0, 0x3b	; 59
    19a8:	0f 92       	push	r0
    19aa:	2f 93       	push	r18
    19ac:	3f 93       	push	r19
    19ae:	4f 93       	push	r20
    19b0:	5f 93       	push	r21
    19b2:	6f 93       	push	r22
    19b4:	7f 93       	push	r23
    19b6:	8f 93       	push	r24
    19b8:	9f 93       	push	r25
    19ba:	af 93       	push	r26
    19bc:	bf 93       	push	r27
    19be:	ef 93       	push	r30
    19c0:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    19c2:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19c6:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19ca:	80 3d       	cpi	r24, 0xD0	; 208
    19cc:	97 40       	sbci	r25, 0x07	; 7
    19ce:	50 f4       	brcc	.+20     	; 0x19e4 <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19d0:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19d4:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19d8:	01 96       	adiw	r24, 0x01	; 1
    19da:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19de:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19e2:	08 c0       	rjmp	.+16     	; 0x19f4 <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19e4:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    19e8:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    19ec:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    19f0:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    19f4:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19f8:	87 30       	cpi	r24, 0x07	; 7
    19fa:	41 f4       	brne	.+16     	; 0x1a0c <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    19fc:	84 e1       	ldi	r24, 0x14	; 20
    19fe:	91 e0       	ldi	r25, 0x01	; 1
    1a00:	0e 94 46 04 	call	0x88c	; 0x88c <SPI_handler_7>
		u8_SPI_count = 0 ;
    1a04:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	13 c0       	rjmp	.+38     	; 0x1a32 <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    1a0c:	86 30       	cpi	r24, 0x06	; 6
    1a0e:	49 f4       	brne	.+18     	; 0x1a22 <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    1a10:	8d e3       	ldi	r24, 0x3D	; 61
    1a12:	91 e0       	ldi	r25, 0x01	; 1
    1a14:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPI_handler_6>
		u8_SPI_count ++ ;
    1a18:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a1c:	8f 5f       	subi	r24, 0xFF	; 255
    1a1e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1a22:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a26:	85 30       	cpi	r24, 0x05	; 5
    1a28:	21 f4       	brne	.+8      	; 0x1a32 <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1a2a:	86 e0       	ldi	r24, 0x06	; 6
    1a2c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a30:	13 c0       	rjmp	.+38     	; 0x1a58 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a32:	84 30       	cpi	r24, 0x04	; 4
    1a34:	49 f4       	brne	.+18     	; 0x1a48 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a36:	84 e2       	ldi	r24, 0x24	; 36
    1a38:	91 e0       	ldi	r25, 0x01	; 1
    1a3a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <SPI_handler_4>
		u8_SPI_count ++ ;
    1a3e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a42:	8f 5f       	subi	r24, 0xFF	; 255
    1a44:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a48:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a4c:	83 30       	cpi	r24, 0x03	; 3
    1a4e:	21 f4       	brne	.+8      	; 0x1a58 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a50:	84 e0       	ldi	r24, 0x04	; 4
    1a52:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a56:	13 c0       	rjmp	.+38     	; 0x1a7e <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a58:	82 30       	cpi	r24, 0x02	; 2
    1a5a:	21 f4       	brne	.+8      	; 0x1a64 <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a5c:	83 e0       	ldi	r24, 0x03	; 3
    1a5e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a62:	1a c0       	rjmp	.+52     	; 0x1a98 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a64:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a68:	81 30       	cpi	r24, 0x01	; 1
    1a6a:	49 f4       	brne	.+18     	; 0x1a7e <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a6c:	88 e1       	ldi	r24, 0x18	; 24
    1a6e:	91 e0       	ldi	r25, 0x01	; 1
    1a70:	0e 94 b0 03 	call	0x760	; 0x760 <SPI_handler_1>
		u8_SPI_count ++ ;
    1a74:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a78:	8f 5f       	subi	r24, 0xFF	; 255
    1a7a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a7e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a82:	81 11       	cpse	r24, r1
    1a84:	09 c0       	rjmp	.+18     	; 0x1a98 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1a86:	8c e1       	ldi	r24, 0x1C	; 28
    1a88:	91 e0       	ldi	r25, 0x01	; 1
    1a8a:	0e 94 73 03 	call	0x6e6	; 0x6e6 <SPI_handler_0>
		u8_SPI_count ++ ;
    1a8e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a92:	8f 5f       	subi	r24, 0xFF	; 255
    1a94:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1a98:	ff 91       	pop	r31
    1a9a:	ef 91       	pop	r30
    1a9c:	bf 91       	pop	r27
    1a9e:	af 91       	pop	r26
    1aa0:	9f 91       	pop	r25
    1aa2:	8f 91       	pop	r24
    1aa4:	7f 91       	pop	r23
    1aa6:	6f 91       	pop	r22
    1aa8:	5f 91       	pop	r21
    1aaa:	4f 91       	pop	r20
    1aac:	3f 91       	pop	r19
    1aae:	2f 91       	pop	r18
    1ab0:	0f 90       	pop	r0
    1ab2:	0b be       	out	0x3b, r0	; 59
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	0f 90       	pop	r0
    1aba:	1f 90       	pop	r1
    1abc:	18 95       	reti

00001abe <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1abe:	1f 92       	push	r1
    1ac0:	0f 92       	push	r0
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	0f 92       	push	r0
    1ac6:	11 24       	eor	r1, r1
    1ac8:	0b b6       	in	r0, 0x3b	; 59
    1aca:	0f 92       	push	r0
    1acc:	2f 93       	push	r18
    1ace:	3f 93       	push	r19
    1ad0:	4f 93       	push	r20
    1ad2:	5f 93       	push	r21
    1ad4:	6f 93       	push	r22
    1ad6:	7f 93       	push	r23
    1ad8:	8f 93       	push	r24
    1ada:	9f 93       	push	r25
    1adc:	af 93       	push	r26
    1ade:	bf 93       	push	r27
    1ae0:	ef 93       	push	r30
    1ae2:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1ae4:	60 e0       	ldi	r22, 0x00	; 0
    1ae6:	72 e0       	ldi	r23, 0x02	; 2
    1ae8:	85 e2       	ldi	r24, 0x25	; 37
    1aea:	91 e0       	ldi	r25, 0x01	; 1
    1aec:	95 da       	rcall	.-2774   	; 0x1018 <handle_speed_sensor>
}
    1aee:	ff 91       	pop	r31
    1af0:	ef 91       	pop	r30
    1af2:	bf 91       	pop	r27
    1af4:	af 91       	pop	r26
    1af6:	9f 91       	pop	r25
    1af8:	8f 91       	pop	r24
    1afa:	7f 91       	pop	r23
    1afc:	6f 91       	pop	r22
    1afe:	5f 91       	pop	r21
    1b00:	4f 91       	pop	r20
    1b02:	3f 91       	pop	r19
    1b04:	2f 91       	pop	r18
    1b06:	0f 90       	pop	r0
    1b08:	0b be       	out	0x3b, r0	; 59
    1b0a:	0f 90       	pop	r0
    1b0c:	0f be       	out	0x3f, r0	; 63
    1b0e:	0f 90       	pop	r0
    1b10:	1f 90       	pop	r1
    1b12:	18 95       	reti

00001b14 <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1b14:	08 95       	ret

00001b16 <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1b16:	7a 99       	sbic	0x0f, 2	; 15
    1b18:	03 c0       	rjmp	.+6      	; 0x1b20 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1b1e:	10 8e       	std	Z+24, r1	; 0x18
    1b20:	08 95       	ret

00001b22 <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1b22:	8f 92       	push	r8
    1b24:	9f 92       	push	r9
    1b26:	af 92       	push	r10
    1b28:	bf 92       	push	r11
    1b2a:	cf 92       	push	r12
    1b2c:	df 92       	push	r13
    1b2e:	ef 92       	push	r14
    1b30:	ff 92       	push	r15
    1b32:	0f 93       	push	r16
    1b34:	1f 93       	push	r17
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	00 d0       	rcall	.+0      	; 0x1b3c <handle_current_sensor+0x1a>
    1b3c:	00 d0       	rcall	.+0      	; 0x1b3e <handle_current_sensor+0x1c>
    1b3e:	cd b7       	in	r28, 0x3d	; 61
    1b40:	de b7       	in	r29, 0x3e	; 62
    1b42:	8c 01       	movw	r16, r24
    1b44:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b46:	80 e0       	ldi	r24, 0x00	; 0
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	e6 d4       	rcall	.+2508   	; 0x2518 <__floatunsisf>
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	40 ea       	ldi	r20, 0xA0	; 160
    1b52:	50 e4       	ldi	r21, 0x40	; 64
    1b54:	97 d5       	rcall	.+2862   	; 0x2684 <__mulsf3>
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e8       	ldi	r20, 0x80	; 128
    1b5c:	59 e3       	ldi	r21, 0x39	; 57
    1b5e:	92 d5       	rcall	.+2852   	; 0x2684 <__mulsf3>
    1b60:	20 e0       	ldi	r18, 0x00	; 0
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	40 e0       	ldi	r20, 0x00	; 0
    1b66:	51 e4       	ldi	r21, 0x41	; 65
    1b68:	8d d5       	rcall	.+2842   	; 0x2684 <__mulsf3>
    1b6a:	20 e0       	ldi	r18, 0x00	; 0
    1b6c:	30 e0       	ldi	r19, 0x00	; 0
    1b6e:	40 ea       	ldi	r20, 0xA0	; 160
    1b70:	51 e4       	ldi	r21, 0x41	; 65
    1b72:	d0 d3       	rcall	.+1952   	; 0x2314 <__subsf3>
    1b74:	69 83       	std	Y+1, r22	; 0x01
    1b76:	7a 83       	std	Y+2, r23	; 0x02
    1b78:	8b 83       	std	Y+3, r24	; 0x03
    1b7a:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b7c:	ff 20       	and	r15, r15
    1b7e:	49 f0       	breq	.+18     	; 0x1b92 <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b80:	89 81       	ldd	r24, Y+1	; 0x01
    1b82:	9a 81       	ldd	r25, Y+2	; 0x02
    1b84:	ab 81       	ldd	r26, Y+3	; 0x03
    1b86:	bc 81       	ldd	r27, Y+4	; 0x04
    1b88:	89 83       	std	Y+1, r24	; 0x01
    1b8a:	9a 83       	std	Y+2, r25	; 0x02
    1b8c:	ab 83       	std	Y+3, r26	; 0x03
    1b8e:	bc 83       	std	Y+4, r27	; 0x04
    1b90:	08 c0       	rjmp	.+16     	; 0x1ba2 <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	9a 81       	ldd	r25, Y+2	; 0x02
    1b96:	ab 81       	ldd	r26, Y+3	; 0x03
    1b98:	bc 81       	ldd	r27, Y+4	; 0x04
    1b9a:	89 83       	std	Y+1, r24	; 0x01
    1b9c:	9a 83       	std	Y+2, r25	; 0x02
    1b9e:	ab 83       	std	Y+3, r26	; 0x03
    1ba0:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1ba2:	f8 01       	movw	r30, r16
    1ba4:	60 81       	ld	r22, Z
    1ba6:	71 81       	ldd	r23, Z+1	; 0x01
    1ba8:	82 81       	ldd	r24, Z+2	; 0x02
    1baa:	93 81       	ldd	r25, Z+3	; 0x03
    1bac:	89 80       	ldd	r8, Y+1	; 0x01
    1bae:	9a 80       	ldd	r9, Y+2	; 0x02
    1bb0:	ab 80       	ldd	r10, Y+3	; 0x03
    1bb2:	bc 80       	ldd	r11, Y+4	; 0x04
    1bb4:	26 e6       	ldi	r18, 0x66	; 102
    1bb6:	36 e6       	ldi	r19, 0x66	; 102
    1bb8:	46 e6       	ldi	r20, 0x66	; 102
    1bba:	5f e3       	ldi	r21, 0x3F	; 63
    1bbc:	63 d5       	rcall	.+2758   	; 0x2684 <__mulsf3>
    1bbe:	6b 01       	movw	r12, r22
    1bc0:	7c 01       	movw	r14, r24
    1bc2:	2d ec       	ldi	r18, 0xCD	; 205
    1bc4:	3c ec       	ldi	r19, 0xCC	; 204
    1bc6:	4c ec       	ldi	r20, 0xCC	; 204
    1bc8:	5d e3       	ldi	r21, 0x3D	; 61
    1bca:	c5 01       	movw	r24, r10
    1bcc:	b4 01       	movw	r22, r8
    1bce:	5a d5       	rcall	.+2740   	; 0x2684 <__mulsf3>
    1bd0:	9b 01       	movw	r18, r22
    1bd2:	ac 01       	movw	r20, r24
    1bd4:	c7 01       	movw	r24, r14
    1bd6:	b6 01       	movw	r22, r12
    1bd8:	9e d3       	rcall	.+1852   	; 0x2316 <__addsf3>
    1bda:	f8 01       	movw	r30, r16
    1bdc:	60 83       	st	Z, r22
    1bde:	71 83       	std	Z+1, r23	; 0x01
    1be0:	82 83       	std	Z+2, r24	; 0x02
    1be2:	93 83       	std	Z+3, r25	; 0x03
}
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	1f 91       	pop	r17
    1bf2:	0f 91       	pop	r16
    1bf4:	ff 90       	pop	r15
    1bf6:	ef 90       	pop	r14
    1bf8:	df 90       	pop	r13
    1bfa:	cf 90       	pop	r12
    1bfc:	bf 90       	pop	r11
    1bfe:	af 90       	pop	r10
    1c00:	9f 90       	pop	r9
    1c02:	8f 90       	pop	r8
    1c04:	08 95       	ret

00001c06 <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1c06:	cf 92       	push	r12
    1c08:	df 92       	push	r13
    1c0a:	ef 92       	push	r14
    1c0c:	ff 92       	push	r15
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
    1c12:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1c14:	80 e0       	ldi	r24, 0x00	; 0
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	7f d4       	rcall	.+2302   	; 0x2518 <__floatunsisf>
    1c1a:	20 e0       	ldi	r18, 0x00	; 0
    1c1c:	30 e0       	ldi	r19, 0x00	; 0
    1c1e:	40 ea       	ldi	r20, 0xA0	; 160
    1c20:	50 e4       	ldi	r21, 0x40	; 64
    1c22:	30 d5       	rcall	.+2656   	; 0x2684 <__mulsf3>
    1c24:	20 e0       	ldi	r18, 0x00	; 0
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	40 e8       	ldi	r20, 0x80	; 128
    1c2a:	59 e3       	ldi	r21, 0x39	; 57
    1c2c:	2b d5       	rcall	.+2646   	; 0x2684 <__mulsf3>
    1c2e:	6b 01       	movw	r12, r22
    1c30:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c32:	2d ec       	ldi	r18, 0xCD	; 205
    1c34:	3c ec       	ldi	r19, 0xCC	; 204
    1c36:	4c e6       	ldi	r20, 0x6C	; 108
    1c38:	50 e4       	ldi	r21, 0x40	; 64
    1c3a:	d1 d3       	rcall	.+1954   	; 0x23de <__cmpsf2>
    1c3c:	18 16       	cp	r1, r24
    1c3e:	74 f0       	brlt	.+28     	; 0x1c5c <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c40:	20 e0       	ldi	r18, 0x00	; 0
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	40 ea       	ldi	r20, 0xA0	; 160
    1c46:	51 e4       	ldi	r21, 0x41	; 65
    1c48:	c7 01       	movw	r24, r14
    1c4a:	b6 01       	movw	r22, r12
    1c4c:	1b d5       	rcall	.+2614   	; 0x2684 <__mulsf3>
    1c4e:	20 e0       	ldi	r18, 0x00	; 0
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	40 eb       	ldi	r20, 0xB0	; 176
    1c54:	51 e4       	ldi	r21, 0x41	; 65
    1c56:	5e d3       	rcall	.+1724   	; 0x2314 <__subsf3>
    1c58:	33 d4       	rcall	.+2150   	; 0x24c0 <__fixunssfsi>
    1c5a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c5c:	26 e6       	ldi	r18, 0x66	; 102
    1c5e:	36 e6       	ldi	r19, 0x66	; 102
    1c60:	46 e9       	ldi	r20, 0x96	; 150
    1c62:	50 e4       	ldi	r21, 0x40	; 64
    1c64:	c7 01       	movw	r24, r14
    1c66:	b6 01       	movw	r22, r12
    1c68:	ba d3       	rcall	.+1908   	; 0x23de <__cmpsf2>
    1c6a:	18 16       	cp	r1, r24
    1c6c:	bc f0       	brlt	.+46     	; 0x1c9c <handle_temp_sensor+0x96>
    1c6e:	2d ec       	ldi	r18, 0xCD	; 205
    1c70:	3c ec       	ldi	r19, 0xCC	; 204
    1c72:	4c e6       	ldi	r20, 0x6C	; 108
    1c74:	50 e4       	ldi	r21, 0x40	; 64
    1c76:	c7 01       	movw	r24, r14
    1c78:	b6 01       	movw	r22, r12
    1c7a:	00 d5       	rcall	.+2560   	; 0x267c <__gesf2>
    1c7c:	18 16       	cp	r1, r24
    1c7e:	74 f4       	brge	.+28     	; 0x1c9c <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c80:	20 e0       	ldi	r18, 0x00	; 0
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	4e e5       	ldi	r20, 0x5E	; 94
    1c86:	52 e4       	ldi	r21, 0x42	; 66
    1c88:	c7 01       	movw	r24, r14
    1c8a:	b6 01       	movw	r22, r12
    1c8c:	fb d4       	rcall	.+2550   	; 0x2684 <__mulsf3>
    1c8e:	20 e0       	ldi	r18, 0x00	; 0
    1c90:	30 e8       	ldi	r19, 0x80	; 128
    1c92:	4b e1       	ldi	r20, 0x1B	; 27
    1c94:	53 e4       	ldi	r21, 0x43	; 67
    1c96:	3e d3       	rcall	.+1660   	; 0x2314 <__subsf3>
    1c98:	13 d4       	rcall	.+2086   	; 0x24c0 <__fixunssfsi>
    1c9a:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c9c:	26 e6       	ldi	r18, 0x66	; 102
    1c9e:	36 e6       	ldi	r19, 0x66	; 102
    1ca0:	46 e9       	ldi	r20, 0x96	; 150
    1ca2:	50 e4       	ldi	r21, 0x40	; 64
    1ca4:	c7 01       	movw	r24, r14
    1ca6:	b6 01       	movw	r22, r12
    1ca8:	e9 d4       	rcall	.+2514   	; 0x267c <__gesf2>
    1caa:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1cac:	74 f4       	brge	.+28     	; 0x1cca <handle_temp_sensor+0xc4>
    1cae:	20 e0       	ldi	r18, 0x00	; 0
    1cb0:	30 e0       	ldi	r19, 0x00	; 0
    1cb2:	48 e4       	ldi	r20, 0x48	; 72
    1cb4:	53 e4       	ldi	r21, 0x43	; 67
    1cb6:	c7 01       	movw	r24, r14
    1cb8:	b6 01       	movw	r22, r12
    1cba:	e4 d4       	rcall	.+2504   	; 0x2684 <__mulsf3>
    1cbc:	20 e0       	ldi	r18, 0x00	; 0
    1cbe:	30 e0       	ldi	r19, 0x00	; 0
    1cc0:	42 e5       	ldi	r20, 0x52	; 82
    1cc2:	54 e4       	ldi	r21, 0x44	; 68
    1cc4:	27 d3       	rcall	.+1614   	; 0x2314 <__subsf3>
    1cc6:	fc d3       	rcall	.+2040   	; 0x24c0 <__fixunssfsi>
    1cc8:	68 83       	st	Y, r22
    1cca:	df 91       	pop	r29
    1ccc:	cf 91       	pop	r28
	}
}
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	df 90       	pop	r13
    1cd4:	cf 90       	pop	r12
    1cd6:	08 95       	ret

00001cd8 <handle_joulemeter>:
    1cd8:	4f 92       	push	r4
    1cda:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cdc:	6f 92       	push	r6
    1cde:	7f 92       	push	r7
    1ce0:	8f 92       	push	r8
    1ce2:	9f 92       	push	r9
    1ce4:	af 92       	push	r10
    1ce6:	bf 92       	push	r11
    1ce8:	cf 92       	push	r12
    1cea:	df 92       	push	r13
    1cec:	ef 92       	push	r14
    1cee:	0f 93       	push	r16
    1cf0:	1f 93       	push	r17
    1cf2:	cf 93       	push	r28
    1cf4:	df 93       	push	r29
    1cf6:	cd b7       	in	r28, 0x3d	; 61
    1cf8:	de b7       	in	r29, 0x3e	; 62
    1cfa:	28 97       	sbiw	r28, 0x08	; 8
    1cfc:	0f b6       	in	r0, 0x3f	; 63
    1cfe:	f8 94       	cli
    1d00:	de bf       	out	0x3e, r29	; 62
    1d02:	0f be       	out	0x3f, r0	; 63
    1d04:	cd bf       	out	0x3d, r28	; 61
    1d06:	6c 01       	movw	r12, r24
    1d08:	49 83       	std	Y+1, r20	; 0x01
    1d0a:	5a 83       	std	Y+2, r21	; 0x02
    1d0c:	6b 83       	std	Y+3, r22	; 0x03
    1d0e:	7c 83       	std	Y+4, r23	; 0x04
    1d10:	0d 83       	std	Y+5, r16	; 0x05
    1d12:	1e 83       	std	Y+6, r17	; 0x06
    1d14:	2f 83       	std	Y+7, r18	; 0x07
    1d16:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1d18:	6d 81       	ldd	r22, Y+5	; 0x05
    1d1a:	7e 81       	ldd	r23, Y+6	; 0x06
    1d1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d1e:	98 85       	ldd	r25, Y+8	; 0x08
    1d20:	29 81       	ldd	r18, Y+1	; 0x01
    1d22:	3a 81       	ldd	r19, Y+2	; 0x02
    1d24:	4b 81       	ldd	r20, Y+3	; 0x03
    1d26:	5c 81       	ldd	r21, Y+4	; 0x04
    1d28:	f6 01       	movw	r30, r12
    1d2a:	80 80       	ld	r8, Z
    1d2c:	91 80       	ldd	r9, Z+1	; 0x01
    1d2e:	a2 80       	ldd	r10, Z+2	; 0x02
    1d30:	b3 80       	ldd	r11, Z+3	; 0x03
    1d32:	a8 d4       	rcall	.+2384   	; 0x2684 <__mulsf3>
    1d34:	2b 01       	movw	r4, r22
    1d36:	3c 01       	movw	r6, r24
    1d38:	6e 2d       	mov	r22, r14
    1d3a:	70 e0       	ldi	r23, 0x00	; 0
    1d3c:	80 e0       	ldi	r24, 0x00	; 0
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	eb d3       	rcall	.+2006   	; 0x2518 <__floatunsisf>
    1d42:	9b 01       	movw	r18, r22
    1d44:	ac 01       	movw	r20, r24
    1d46:	c3 01       	movw	r24, r6
    1d48:	b2 01       	movw	r22, r4
    1d4a:	9c d4       	rcall	.+2360   	; 0x2684 <__mulsf3>
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	30 e0       	ldi	r19, 0x00	; 0
    1d50:	4a e7       	ldi	r20, 0x7A	; 122
    1d52:	54 e4       	ldi	r21, 0x44	; 68
    1d54:	48 d3       	rcall	.+1680   	; 0x23e6 <__divsf3>
    1d56:	a5 01       	movw	r20, r10
    1d58:	94 01       	movw	r18, r8
    1d5a:	dd d2       	rcall	.+1466   	; 0x2316 <__addsf3>
    1d5c:	f6 01       	movw	r30, r12
    1d5e:	60 83       	st	Z, r22
    1d60:	71 83       	std	Z+1, r23	; 0x01
    1d62:	82 83       	std	Z+2, r24	; 0x02
    1d64:	93 83       	std	Z+3, r25	; 0x03
}
    1d66:	28 96       	adiw	r28, 0x08	; 8
    1d68:	0f b6       	in	r0, 0x3f	; 63
    1d6a:	f8 94       	cli
    1d6c:	de bf       	out	0x3e, r29	; 62
    1d6e:	0f be       	out	0x3f, r0	; 63
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	ef 90       	pop	r14
    1d7c:	df 90       	pop	r13
    1d7e:	cf 90       	pop	r12
    1d80:	bf 90       	pop	r11
    1d82:	af 90       	pop	r10
    1d84:	9f 90       	pop	r9
    1d86:	8f 90       	pop	r8
    1d88:	7f 90       	pop	r7
    1d8a:	6f 90       	pop	r6
    1d8c:	5f 90       	pop	r5
    1d8e:	4f 90       	pop	r4
    1d90:	08 95       	ret

00001d92 <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d92:	90 e0       	ldi	r25, 0x00	; 0
    1d94:	88 30       	cpi	r24, 0x08	; 8
    1d96:	91 05       	cpc	r25, r1
    1d98:	88 f5       	brcc	.+98     	; 0x1dfc <Set_ADC_Channel_ext+0x6a>
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	e6 5b       	subi	r30, 0xB6	; 182
    1d9e:	ff 4f       	sbci	r31, 0xFF	; 255
    1da0:	d4 c4       	rjmp	.+2472   	; 0x274a <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1da2:	86 e0       	ldi	r24, 0x06	; 6
    1da4:	fb 01       	movw	r30, r22
    1da6:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1da8:	11 82       	std	Z+1, r1	; 0x01
		break;
    1daa:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1dac:	86 e0       	ldi	r24, 0x06	; 6
    1dae:	fb 01       	movw	r30, r22
    1db0:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1db2:	80 e4       	ldi	r24, 0x40	; 64
    1db4:	81 83       	std	Z+1, r24	; 0x01
		break;
    1db6:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1db8:	86 e0       	ldi	r24, 0x06	; 6
    1dba:	fb 01       	movw	r30, r22
    1dbc:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1dbe:	80 e8       	ldi	r24, 0x80	; 128
    1dc0:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dc2:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1dc4:	86 e0       	ldi	r24, 0x06	; 6
    1dc6:	fb 01       	movw	r30, r22
    1dc8:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1dca:	80 ec       	ldi	r24, 0xC0	; 192
    1dcc:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dce:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dd0:	87 e0       	ldi	r24, 0x07	; 7
    1dd2:	fb 01       	movw	r30, r22
    1dd4:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1dd6:	11 82       	std	Z+1, r1	; 0x01
		break;
    1dd8:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dda:	87 e0       	ldi	r24, 0x07	; 7
    1ddc:	fb 01       	movw	r30, r22
    1dde:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1de0:	80 e4       	ldi	r24, 0x40	; 64
    1de2:	81 83       	std	Z+1, r24	; 0x01
		break;
    1de4:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1de6:	87 e0       	ldi	r24, 0x07	; 7
    1de8:	fb 01       	movw	r30, r22
    1dea:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1dec:	80 e8       	ldi	r24, 0x80	; 128
    1dee:	81 83       	std	Z+1, r24	; 0x01
		break;
    1df0:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1df2:	87 e0       	ldi	r24, 0x07	; 7
    1df4:	fb 01       	movw	r30, r22
    1df6:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1df8:	80 ec       	ldi	r24, 0xC0	; 192
    1dfa:	81 83       	std	Z+1, r24	; 0x01
    1dfc:	08 95       	ret

00001dfe <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1dfe:	1f 92       	push	r1
    1e00:	0f 92       	push	r0
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	0f 92       	push	r0
    1e06:	11 24       	eor	r1, r1
    1e08:	0b b6       	in	r0, 0x3b	; 59
    1e0a:	0f 92       	push	r0
    1e0c:	2f 93       	push	r18
    1e0e:	3f 93       	push	r19
    1e10:	4f 93       	push	r20
    1e12:	5f 93       	push	r21
    1e14:	6f 93       	push	r22
    1e16:	8f 93       	push	r24
    1e18:	9f 93       	push	r25
    1e1a:	af 93       	push	r26
    1e1c:	bf 93       	push	r27
    1e1e:	ef 93       	push	r30
    1e20:	ff 93       	push	r31
    1e22:	cf 93       	push	r28
    1e24:	df 93       	push	r29
    1e26:	1f 92       	push	r1
    1e28:	cd b7       	in	r28, 0x3d	; 61
    1e2a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1e2c:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e30:	80 ff       	sbrs	r24, 0
    1e32:	47 c0       	rjmp	.+142    	; 0x1ec2 <__vector_18+0xc4>
    1e34:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e38:	90 ff       	sbrs	r25, 0
    1e3a:	43 c0       	rjmp	.+134    	; 0x1ec2 <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e3c:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e40:	ee ee       	ldi	r30, 0xEE	; 238
    1e42:	f0 e0       	ldi	r31, 0x00	; 0
    1e44:	80 81       	ld	r24, Z
    1e46:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e48:	80 81       	ld	r24, Z
    1e4a:	8f 7b       	andi	r24, 0xBF	; 191
    1e4c:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e4e:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e52:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e56:	98 17       	cp	r25, r24
    1e58:	89 f1       	breq	.+98     	; 0x1ebc <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e5a:	8f 70       	andi	r24, 0x0F	; 15
    1e5c:	2b e0       	ldi	r18, 0x0B	; 11
    1e5e:	82 9f       	mul	r24, r18
    1e60:	c0 01       	movw	r24, r0
    1e62:	11 24       	eor	r1, r1
    1e64:	fc 01       	movw	r30, r24
    1e66:	e1 54       	subi	r30, 0x41	; 65
    1e68:	fd 4f       	sbci	r31, 0xFD	; 253
    1e6a:	20 81       	ld	r18, Z
    1e6c:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e70:	20 81       	ld	r18, Z
    1e72:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e76:	21 81       	ldd	r18, Z+1	; 0x01
    1e78:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e7c:	23 81       	ldd	r18, Z+3	; 0x03
    1e7e:	aa ef       	ldi	r26, 0xFA	; 250
    1e80:	b0 e0       	ldi	r27, 0x00	; 0
    1e82:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e84:	24 81       	ldd	r18, Z+4	; 0x04
    1e86:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1e88:	25 81       	ldd	r18, Z+5	; 0x05
    1e8a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e8c:	26 81       	ldd	r18, Z+6	; 0x06
    1e8e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e90:	27 81       	ldd	r18, Z+7	; 0x07
    1e92:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e94:	20 85       	ldd	r18, Z+8	; 0x08
    1e96:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e98:	21 85       	ldd	r18, Z+9	; 0x09
    1e9a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e9c:	22 85       	ldd	r18, Z+10	; 0x0a
    1e9e:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1ea0:	fc 01       	movw	r30, r24
    1ea2:	ef 53       	subi	r30, 0x3F	; 63
    1ea4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ea6:	80 81       	ld	r24, Z
    1ea8:	8f 70       	andi	r24, 0x0F	; 15
    1eaa:	80 64       	ori	r24, 0x40	; 64
    1eac:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1eb0:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1eb4:	8f 5f       	subi	r24, 0xFF	; 255
    1eb6:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1eba:	7d c0       	rjmp	.+250    	; 0x1fb6 <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1ebc:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1ec0:	7a c0       	rjmp	.+244    	; 0x1fb6 <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1ec2:	81 ff       	sbrs	r24, 1
    1ec4:	78 c0       	rjmp	.+240    	; 0x1fb6 <__vector_18+0x1b8>
    1ec6:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1eca:	81 ff       	sbrs	r24, 1
    1ecc:	74 c0       	rjmp	.+232    	; 0x1fb6 <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1ece:	80 e1       	ldi	r24, 0x10	; 16
    1ed0:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1ed4:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ed8:	28 2f       	mov	r18, r24
    1eda:	30 e0       	ldi	r19, 0x00	; 0
    1edc:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1ee0:	29 1b       	sub	r18, r25
    1ee2:	31 09       	sbc	r19, r1
    1ee4:	2f 77       	andi	r18, 0x7F	; 127
    1ee6:	33 27       	eor	r19, r19
    1ee8:	20 31       	cpi	r18, 0x10	; 16
    1eea:	31 05       	cpc	r19, r1
    1eec:	0c f0       	brlt	.+2      	; 0x1ef0 <__vector_18+0xf2>
    1eee:	58 c0       	rjmp	.+176    	; 0x1fa0 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1ef0:	e8 2f       	mov	r30, r24
    1ef2:	ef 70       	andi	r30, 0x0F	; 15
    1ef4:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1ef8:	2e 2f       	mov	r18, r30
    1efa:	30 e0       	ldi	r19, 0x00	; 0
    1efc:	4b e0       	ldi	r20, 0x0B	; 11
    1efe:	e4 9f       	mul	r30, r20
    1f00:	f0 01       	movw	r30, r0
    1f02:	11 24       	eor	r1, r1
    1f04:	e1 5f       	subi	r30, 0xF1	; 241
    1f06:	fd 4f       	sbci	r31, 0xFD	; 253
    1f08:	9f 70       	andi	r25, 0x0F	; 15
    1f0a:	42 81       	ldd	r20, Z+2	; 0x02
    1f0c:	40 7f       	andi	r20, 0xF0	; 240
    1f0e:	94 2b       	or	r25, r20
    1f10:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1f12:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1f16:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f1a:	40 7e       	andi	r20, 0xE0	; 224
    1f1c:	97 70       	andi	r25, 0x07	; 7
    1f1e:	94 2b       	or	r25, r20
    1f20:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1f22:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1f26:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1f28:	aa ef       	ldi	r26, 0xFA	; 250
    1f2a:	b0 e0       	ldi	r27, 0x00	; 0
    1f2c:	9c 91       	ld	r25, X
    1f2e:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f30:	9c 91       	ld	r25, X
    1f32:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f34:	9c 91       	ld	r25, X
    1f36:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f38:	9c 91       	ld	r25, X
    1f3a:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f3c:	9c 91       	ld	r25, X
    1f3e:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f40:	9c 91       	ld	r25, X
    1f42:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f44:	9c 91       	ld	r25, X
    1f46:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f48:	9c 91       	ld	r25, X
    1f4a:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f4c:	8f 5f       	subi	r24, 0xFF	; 255
    1f4e:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f52:	40 81       	ld	r20, Z
    1f54:	42 95       	swap	r20
    1f56:	46 95       	lsr	r20
    1f58:	47 70       	andi	r20, 0x07	; 7
    1f5a:	51 81       	ldd	r21, Z+1	; 0x01
    1f5c:	65 2f       	mov	r22, r21
    1f5e:	66 0f       	add	r22, r22
    1f60:	66 0f       	add	r22, r22
    1f62:	66 0f       	add	r22, r22
    1f64:	86 2f       	mov	r24, r22
    1f66:	84 2b       	or	r24, r20
    1f68:	95 2f       	mov	r25, r21
    1f6a:	92 95       	swap	r25
    1f6c:	96 95       	lsr	r25
    1f6e:	97 70       	andi	r25, 0x07	; 7
    1f70:	89 2b       	or	r24, r25
    1f72:	b1 f4       	brne	.+44     	; 0x1fa0 <__vector_18+0x1a2>
    1f74:	8b e0       	ldi	r24, 0x0B	; 11
    1f76:	82 9f       	mul	r24, r18
    1f78:	f0 01       	movw	r30, r0
    1f7a:	83 9f       	mul	r24, r19
    1f7c:	f0 0d       	add	r31, r0
    1f7e:	11 24       	eor	r1, r1
    1f80:	e1 5f       	subi	r30, 0xF1	; 241
    1f82:	fd 4f       	sbci	r31, 0xFD	; 253
    1f84:	83 81       	ldd	r24, Z+3	; 0x03
    1f86:	83 30       	cpi	r24, 0x03	; 3
    1f88:	59 f4       	brne	.+22     	; 0x1fa0 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1f8a:	98 e0       	ldi	r25, 0x08	; 8
    1f8c:	88 e1       	ldi	r24, 0x18	; 24
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	a8 95       	wdr
    1f94:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f98:	0f be       	out	0x3f, r0	; 63
    1f9a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f9e:	ff cf       	rjmp	.-2      	; 0x1f9e <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1fa0:	ee ee       	ldi	r30, 0xEE	; 238
    1fa2:	f0 e0       	ldi	r31, 0x00	; 0
    1fa4:	80 81       	ld	r24, Z
    1fa6:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1fa8:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1faa:	80 81       	ld	r24, Z
    1fac:	8f 7d       	andi	r24, 0xDF	; 223
    1fae:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1fb0:	80 e8       	ldi	r24, 0x80	; 128
    1fb2:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1fb6:	0f 90       	pop	r0
    1fb8:	df 91       	pop	r29
    1fba:	cf 91       	pop	r28
    1fbc:	ff 91       	pop	r31
    1fbe:	ef 91       	pop	r30
    1fc0:	bf 91       	pop	r27
    1fc2:	af 91       	pop	r26
    1fc4:	9f 91       	pop	r25
    1fc6:	8f 91       	pop	r24
    1fc8:	6f 91       	pop	r22
    1fca:	5f 91       	pop	r21
    1fcc:	4f 91       	pop	r20
    1fce:	3f 91       	pop	r19
    1fd0:	2f 91       	pop	r18
    1fd2:	0f 90       	pop	r0
    1fd4:	0b be       	out	0x3b, r0	; 59
    1fd6:	0f 90       	pop	r0
    1fd8:	0f be       	out	0x3f, r0	; 63
    1fda:	0f 90       	pop	r0
    1fdc:	1f 90       	pop	r1
    1fde:	18 95       	reti

00001fe0 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1fe0:	cf 93       	push	r28
    1fe2:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1fe4:	e8 ed       	ldi	r30, 0xD8	; 216
    1fe6:	f0 e0       	ldi	r31, 0x00	; 0
    1fe8:	21 e0       	ldi	r18, 0x01	; 1
    1fea:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1fec:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1ff0:	2c e0       	ldi	r18, 0x0C	; 12
    1ff2:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1ff6:	27 e3       	ldi	r18, 0x37	; 55
    1ff8:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1ffc:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    2000:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    2004:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2008:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    200c:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    2010:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    2014:	cd ee       	ldi	r28, 0xED	; 237
    2016:	d0 e0       	ldi	r29, 0x00	; 0
    2018:	18 82       	st	Y, r1
	CANSTMOB = 0;
    201a:	ae ee       	ldi	r26, 0xEE	; 238
    201c:	b0 e0       	ldi	r27, 0x00	; 0
    201e:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    2020:	20 e1       	ldi	r18, 0x10	; 16
    2022:	28 83       	st	Y, r18
	CANSTMOB = 0;
    2024:	1c 92       	st	X, r1
	CANIDM4 = 0;
    2026:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    202a:	28 2f       	mov	r18, r24
    202c:	22 95       	swap	r18
    202e:	22 0f       	add	r18, r18
    2030:	20 7e       	andi	r18, 0xE0	; 224
    2032:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    2036:	96 95       	lsr	r25
    2038:	87 95       	ror	r24
    203a:	96 95       	lsr	r25
    203c:	87 95       	ror	r24
    203e:	96 95       	lsr	r25
    2040:	87 95       	ror	r24
    2042:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    2046:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    204a:	86 2f       	mov	r24, r22
    204c:	82 95       	swap	r24
    204e:	88 0f       	add	r24, r24
    2050:	80 7e       	andi	r24, 0xE0	; 224
    2052:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    2056:	76 95       	lsr	r23
    2058:	67 95       	ror	r22
    205a:	76 95       	lsr	r23
    205c:	67 95       	ror	r22
    205e:	76 95       	lsr	r23
    2060:	67 95       	ror	r22
    2062:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    2066:	80 e8       	ldi	r24, 0x80	; 128
    2068:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    206c:	83 e0       	ldi	r24, 0x03	; 3
    206e:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    2072:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    2076:	80 eb       	ldi	r24, 0xB0	; 176
    2078:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    207c:	82 e0       	ldi	r24, 0x02	; 2
    207e:	80 83       	st	Z, r24

	reset = 0;
    2080:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	08 95       	ret

0000208a <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    208a:	cf 93       	push	r28
    208c:	df 93       	push	r29
    208e:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    2090:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    2094:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    2098:	24 17       	cp	r18, r20
    209a:	89 f1       	breq	.+98     	; 0x20fe <can_read_message_if_new+0x74>
    209c:	a4 2f       	mov	r26, r20
    209e:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    20a0:	8b e0       	ldi	r24, 0x0B	; 11
    20a2:	a8 9f       	mul	r26, r24
    20a4:	b0 01       	movw	r22, r0
    20a6:	11 24       	eor	r1, r1
    20a8:	fb 01       	movw	r30, r22
    20aa:	e1 5f       	subi	r30, 0xF1	; 241
    20ac:	fd 4f       	sbci	r31, 0xFD	; 253
    20ae:	20 81       	ld	r18, Z
    20b0:	22 95       	swap	r18
    20b2:	26 95       	lsr	r18
    20b4:	27 70       	andi	r18, 0x07	; 7
    20b6:	31 81       	ldd	r19, Z+1	; 0x01
    20b8:	53 2f       	mov	r21, r19
    20ba:	55 0f       	add	r21, r21
    20bc:	55 0f       	add	r21, r21
    20be:	55 0f       	add	r21, r21
    20c0:	25 2b       	or	r18, r21
    20c2:	32 95       	swap	r19
    20c4:	36 95       	lsr	r19
    20c6:	37 70       	andi	r19, 0x07	; 7
    20c8:	28 83       	st	Y, r18
    20ca:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    20cc:	fb 01       	movw	r30, r22
    20ce:	ef 5e       	subi	r30, 0xEF	; 239
    20d0:	fd 4f       	sbci	r31, 0xFD	; 253
    20d2:	20 81       	ld	r18, Z
    20d4:	2f 70       	andi	r18, 0x0F	; 15
    20d6:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20d8:	22 23       	and	r18, r18
    20da:	99 f0       	breq	.+38     	; 0x2102 <can_read_message_if_new+0x78>
    20dc:	db 01       	movw	r26, r22
    20de:	ae 5e       	subi	r26, 0xEE	; 238
    20e0:	bd 4f       	sbci	r27, 0xFD	; 253
    20e2:	fe 01       	movw	r30, r28
    20e4:	33 96       	adiw	r30, 0x03	; 3
    20e6:	30 e0       	ldi	r19, 0x00	; 0
    20e8:	2d 5f       	subi	r18, 0xFD	; 253
    20ea:	3f 4f       	sbci	r19, 0xFF	; 255
    20ec:	ce 01       	movw	r24, r28
    20ee:	82 0f       	add	r24, r18
    20f0:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    20f2:	2d 91       	ld	r18, X+
    20f4:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    20f6:	e8 17       	cp	r30, r24
    20f8:	f9 07       	cpc	r31, r25
    20fa:	d9 f7       	brne	.-10     	; 0x20f2 <can_read_message_if_new+0x68>
    20fc:	02 c0       	rjmp	.+4      	; 0x2102 <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	04 c0       	rjmp	.+8      	; 0x210a <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    2102:	4f 5f       	subi	r20, 0xFF	; 255
    2104:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    2108:	81 e0       	ldi	r24, 0x01	; 1
}
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	08 95       	ret

00002110 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    2110:	cf 93       	push	r28
    2112:	df 93       	push	r29
    2114:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    2116:	ab ed       	ldi	r26, 0xDB	; 219
    2118:	b0 e0       	ldi	r27, 0x00	; 0
    211a:	8c 91       	ld	r24, X
    211c:	8f 77       	andi	r24, 0x7F	; 127
    211e:	8c 93       	st	X, r24

	if (!tx_busy) {
    2120:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    2124:	81 11       	cpse	r24, r1
    2126:	27 c0       	rjmp	.+78     	; 0x2176 <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2128:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    212c:	80 81       	ld	r24, Z
    212e:	82 95       	swap	r24
    2130:	88 0f       	add	r24, r24
    2132:	80 7e       	andi	r24, 0xE0	; 224
    2134:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2138:	80 81       	ld	r24, Z
    213a:	91 81       	ldd	r25, Z+1	; 0x01
    213c:	96 95       	lsr	r25
    213e:	87 95       	ror	r24
    2140:	96 95       	lsr	r25
    2142:	87 95       	ror	r24
    2144:	96 95       	lsr	r25
    2146:	87 95       	ror	r24
    2148:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    214c:	df 01       	movw	r26, r30
    214e:	13 96       	adiw	r26, 0x03	; 3
    2150:	9f 01       	movw	r18, r30
    2152:	25 5f       	subi	r18, 0xF5	; 245
    2154:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    2156:	ca ef       	ldi	r28, 0xFA	; 250
    2158:	d0 e0       	ldi	r29, 0x00	; 0
    215a:	9d 91       	ld	r25, X+
    215c:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    215e:	a2 17       	cp	r26, r18
    2160:	b3 07       	cpc	r27, r19
    2162:	d9 f7       	brne	.-10     	; 0x215a <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    2164:	81 e0       	ldi	r24, 0x01	; 1
    2166:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    216a:	82 81       	ldd	r24, Z+2	; 0x02
    216c:	80 64       	ori	r24, 0x40	; 64
    216e:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	43 c0       	rjmp	.+134    	; 0x21fc <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    2176:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    217a:	82 2f       	mov	r24, r18
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    2182:	83 1b       	sub	r24, r19
    2184:	91 09       	sbc	r25, r1
    2186:	8f 77       	andi	r24, 0x7F	; 127
    2188:	99 27       	eor	r25, r25
    218a:	40 97       	sbiw	r24, 0x10	; 16
    218c:	b1 f1       	breq	.+108    	; 0x21fa <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    218e:	a2 2f       	mov	r26, r18
    2190:	af 70       	andi	r26, 0x0F	; 15
    2192:	8b e0       	ldi	r24, 0x0B	; 11
    2194:	a8 9f       	mul	r26, r24
    2196:	d0 01       	movw	r26, r0
    2198:	11 24       	eor	r1, r1
    219a:	ed 01       	movw	r28, r26
    219c:	c1 54       	subi	r28, 0x41	; 65
    219e:	dd 4f       	sbci	r29, 0xFD	; 253
    21a0:	80 81       	ld	r24, Z
    21a2:	98 2f       	mov	r25, r24
    21a4:	92 95       	swap	r25
    21a6:	99 0f       	add	r25, r25
    21a8:	90 7e       	andi	r25, 0xE0	; 224
    21aa:	88 81       	ld	r24, Y
    21ac:	8f 71       	andi	r24, 0x1F	; 31
    21ae:	89 2b       	or	r24, r25
    21b0:	88 83       	st	Y, r24
    21b2:	80 81       	ld	r24, Z
    21b4:	98 2f       	mov	r25, r24
    21b6:	96 95       	lsr	r25
    21b8:	96 95       	lsr	r25
    21ba:	96 95       	lsr	r25
    21bc:	89 81       	ldd	r24, Y+1	; 0x01
    21be:	80 7e       	andi	r24, 0xE0	; 224
    21c0:	89 2b       	or	r24, r25
    21c2:	89 83       	std	Y+1, r24	; 0x01
    21c4:	91 81       	ldd	r25, Z+1	; 0x01
    21c6:	92 95       	swap	r25
    21c8:	99 0f       	add	r25, r25
    21ca:	90 7e       	andi	r25, 0xE0	; 224
    21cc:	8f 71       	andi	r24, 0x1F	; 31
    21ce:	89 2b       	or	r24, r25
    21d0:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21d2:	82 81       	ldd	r24, Z+2	; 0x02
    21d4:	98 2f       	mov	r25, r24
    21d6:	9f 70       	andi	r25, 0x0F	; 15
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	80 7f       	andi	r24, 0xF0	; 240
    21dc:	89 2b       	or	r24, r25
    21de:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21e0:	ae 53       	subi	r26, 0x3E	; 62
    21e2:	bd 4f       	sbci	r27, 0xFD	; 253
    21e4:	33 96       	adiw	r30, 0x03	; 3
    21e6:	88 e0       	ldi	r24, 0x08	; 8
    21e8:	01 90       	ld	r0, Z+
    21ea:	0d 92       	st	X+, r0
    21ec:	8a 95       	dec	r24
    21ee:	e1 f7       	brne	.-8      	; 0x21e8 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    21f0:	2f 5f       	subi	r18, 0xFF	; 255
    21f2:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	01 c0       	rjmp	.+2      	; 0x21fc <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    21fa:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    21fc:	eb ed       	ldi	r30, 0xDB	; 219
    21fe:	f0 e0       	ldi	r31, 0x00	; 0
    2200:	90 81       	ld	r25, Z
    2202:	90 68       	ori	r25, 0x80	; 128
    2204:	90 83       	st	Z, r25

	return result;
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	08 95       	ret

0000220c <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    220c:	95 b1       	in	r25, 0x05	; 5
    220e:	89 2b       	or	r24, r25
    2210:	85 b9       	out	0x05, r24	; 5
    2212:	08 95       	ret

00002214 <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    2214:	84 b1       	in	r24, 0x04	; 4
    2216:	80 6e       	ori	r24, 0xE0	; 224
    2218:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    221a:	80 ee       	ldi	r24, 0xE0	; 224
    221c:	f7 cf       	rjmp	.-18     	; 0x220c <rgbled_turn_off>
    221e:	08 95       	ret

00002220 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2220:	95 b1       	in	r25, 0x05	; 5
    2222:	80 95       	com	r24
    2224:	98 23       	and	r25, r24
    2226:	95 b9       	out	0x05, r25	; 5
    2228:	08 95       	ret

0000222a <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    222a:	95 b1       	in	r25, 0x05	; 5
    222c:	89 27       	eor	r24, r25
    222e:	85 b9       	out	0x05, r24	; 5
    2230:	08 95       	ret

00002232 <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    2232:	94 b1       	in	r25, 0x04	; 4
    2234:	97 60       	ori	r25, 0x07	; 7
    2236:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2238:	82 fb       	bst	r24, 2
    223a:	99 27       	eor	r25, r25
    223c:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    223e:	28 2f       	mov	r18, r24
    2240:	22 70       	andi	r18, 0x02	; 2
    2242:	81 70       	andi	r24, 0x01	; 1
    2244:	80 65       	ori	r24, 0x50	; 80
    2246:	82 2b       	or	r24, r18
    2248:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    224a:	8c b5       	in	r24, 0x2c	; 44
    224c:	83 7f       	andi	r24, 0xF3	; 243
    224e:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2250:	9d bd       	out	0x2d, r25	; 45
    2252:	08 95       	ret

00002254 <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    2254:	cf 93       	push	r28
    2256:	df 93       	push	r29
    2258:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    225a:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    225c:	41 15       	cp	r20, r1
    225e:	51 05       	cpc	r21, r1
    2260:	c1 f0       	breq	.+48     	; 0x2292 <spi_trancieve+0x3e>
    2262:	fb 01       	movw	r30, r22
    2264:	dc 01       	movw	r26, r24
    2266:	46 0f       	add	r20, r22
    2268:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    226a:	8f ef       	ldi	r24, 0xFF	; 255
    226c:	20 97       	sbiw	r28, 0x00	; 0
    226e:	11 f0       	breq	.+4      	; 0x2274 <spi_trancieve+0x20>
    2270:	9c 91       	ld	r25, X
    2272:	01 c0       	rjmp	.+2      	; 0x2276 <spi_trancieve+0x22>
    2274:	98 2f       	mov	r25, r24
    2276:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2278:	0d b4       	in	r0, 0x2d	; 45
    227a:	07 fe       	sbrs	r0, 7
    227c:	fd cf       	rjmp	.-6      	; 0x2278 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    227e:	61 15       	cp	r22, r1
    2280:	71 05       	cpc	r23, r1
    2282:	11 f0       	breq	.+4      	; 0x2288 <spi_trancieve+0x34>
    2284:	9e b5       	in	r25, 0x2e	; 46
    2286:	90 83       	st	Z, r25
    2288:	31 96       	adiw	r30, 0x01	; 1
    228a:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    228c:	e4 17       	cp	r30, r20
    228e:	f5 07       	cpc	r31, r21
    2290:	69 f7       	brne	.-38     	; 0x226c <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    2292:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    2294:	28 9a       	sbi	0x05, 0	; 5
	}
}
    2296:	df 91       	pop	r29
    2298:	cf 91       	pop	r28
    229a:	08 95       	ret

0000229c <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    229c:	1f 92       	push	r1
    229e:	0f 92       	push	r0
    22a0:	0f b6       	in	r0, 0x3f	; 63
    22a2:	0f 92       	push	r0
    22a4:	11 24       	eor	r1, r1
    22a6:	0b b6       	in	r0, 0x3b	; 59
    22a8:	0f 92       	push	r0
    22aa:	2f 93       	push	r18
    22ac:	3f 93       	push	r19
    22ae:	4f 93       	push	r20
    22b0:	5f 93       	push	r21
    22b2:	6f 93       	push	r22
    22b4:	7f 93       	push	r23
    22b6:	8f 93       	push	r24
    22b8:	af 93       	push	r26
    22ba:	bf 93       	push	r27
    22bc:	ef 93       	push	r30
    22be:	ff 93       	push	r31
    22c0:	af e8       	ldi	r26, 0x8F	; 143
    22c2:	b3 e0       	ldi	r27, 0x03	; 3
    22c4:	ef e6       	ldi	r30, 0x6F	; 111
    22c6:	f3 e0       	ldi	r31, 0x03	; 3
    22c8:	2f e8       	ldi	r18, 0x8F	; 143
    22ca:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    22cc:	8d 91       	ld	r24, X+
    22ce:	88 23       	and	r24, r24
    22d0:	59 f0       	breq	.+22     	; 0x22e8 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22d2:	40 81       	ld	r20, Z
    22d4:	51 81       	ldd	r21, Z+1	; 0x01
    22d6:	62 81       	ldd	r22, Z+2	; 0x02
    22d8:	73 81       	ldd	r23, Z+3	; 0x03
    22da:	50 5e       	subi	r21, 0xE0	; 224
    22dc:	6f 4f       	sbci	r22, 0xFF	; 255
    22de:	7f 4f       	sbci	r23, 0xFF	; 255
    22e0:	40 83       	st	Z, r20
    22e2:	51 83       	std	Z+1, r21	; 0x01
    22e4:	62 83       	std	Z+2, r22	; 0x02
    22e6:	73 83       	std	Z+3, r23	; 0x03
    22e8:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    22ea:	e2 17       	cp	r30, r18
    22ec:	f3 07       	cpc	r31, r19
    22ee:	71 f7       	brne	.-36     	; 0x22cc <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    22f0:	ff 91       	pop	r31
    22f2:	ef 91       	pop	r30
    22f4:	bf 91       	pop	r27
    22f6:	af 91       	pop	r26
    22f8:	8f 91       	pop	r24
    22fa:	7f 91       	pop	r23
    22fc:	6f 91       	pop	r22
    22fe:	5f 91       	pop	r21
    2300:	4f 91       	pop	r20
    2302:	3f 91       	pop	r19
    2304:	2f 91       	pop	r18
    2306:	0f 90       	pop	r0
    2308:	0b be       	out	0x3b, r0	; 59
    230a:	0f 90       	pop	r0
    230c:	0f be       	out	0x3f, r0	; 63
    230e:	0f 90       	pop	r0
    2310:	1f 90       	pop	r1
    2312:	18 95       	reti

00002314 <__subsf3>:
    2314:	50 58       	subi	r21, 0x80	; 128

00002316 <__addsf3>:
    2316:	bb 27       	eor	r27, r27
    2318:	aa 27       	eor	r26, r26
    231a:	0e d0       	rcall	.+28     	; 0x2338 <__addsf3x>
    231c:	75 c1       	rjmp	.+746    	; 0x2608 <__fp_round>
    231e:	66 d1       	rcall	.+716    	; 0x25ec <__fp_pscA>
    2320:	30 f0       	brcs	.+12     	; 0x232e <__addsf3+0x18>
    2322:	6b d1       	rcall	.+726    	; 0x25fa <__fp_pscB>
    2324:	20 f0       	brcs	.+8      	; 0x232e <__addsf3+0x18>
    2326:	31 f4       	brne	.+12     	; 0x2334 <__addsf3+0x1e>
    2328:	9f 3f       	cpi	r25, 0xFF	; 255
    232a:	11 f4       	brne	.+4      	; 0x2330 <__addsf3+0x1a>
    232c:	1e f4       	brtc	.+6      	; 0x2334 <__addsf3+0x1e>
    232e:	5b c1       	rjmp	.+694    	; 0x25e6 <__fp_nan>
    2330:	0e f4       	brtc	.+2      	; 0x2334 <__addsf3+0x1e>
    2332:	e0 95       	com	r30
    2334:	e7 fb       	bst	r30, 7
    2336:	51 c1       	rjmp	.+674    	; 0x25da <__fp_inf>

00002338 <__addsf3x>:
    2338:	e9 2f       	mov	r30, r25
    233a:	77 d1       	rcall	.+750    	; 0x262a <__fp_split3>
    233c:	80 f3       	brcs	.-32     	; 0x231e <__addsf3+0x8>
    233e:	ba 17       	cp	r27, r26
    2340:	62 07       	cpc	r22, r18
    2342:	73 07       	cpc	r23, r19
    2344:	84 07       	cpc	r24, r20
    2346:	95 07       	cpc	r25, r21
    2348:	18 f0       	brcs	.+6      	; 0x2350 <__addsf3x+0x18>
    234a:	71 f4       	brne	.+28     	; 0x2368 <__addsf3x+0x30>
    234c:	9e f5       	brtc	.+102    	; 0x23b4 <__addsf3x+0x7c>
    234e:	8f c1       	rjmp	.+798    	; 0x266e <__fp_zero>
    2350:	0e f4       	brtc	.+2      	; 0x2354 <__addsf3x+0x1c>
    2352:	e0 95       	com	r30
    2354:	0b 2e       	mov	r0, r27
    2356:	ba 2f       	mov	r27, r26
    2358:	a0 2d       	mov	r26, r0
    235a:	0b 01       	movw	r0, r22
    235c:	b9 01       	movw	r22, r18
    235e:	90 01       	movw	r18, r0
    2360:	0c 01       	movw	r0, r24
    2362:	ca 01       	movw	r24, r20
    2364:	a0 01       	movw	r20, r0
    2366:	11 24       	eor	r1, r1
    2368:	ff 27       	eor	r31, r31
    236a:	59 1b       	sub	r21, r25
    236c:	99 f0       	breq	.+38     	; 0x2394 <__addsf3x+0x5c>
    236e:	59 3f       	cpi	r21, 0xF9	; 249
    2370:	50 f4       	brcc	.+20     	; 0x2386 <__addsf3x+0x4e>
    2372:	50 3e       	cpi	r21, 0xE0	; 224
    2374:	68 f1       	brcs	.+90     	; 0x23d0 <__addsf3x+0x98>
    2376:	1a 16       	cp	r1, r26
    2378:	f0 40       	sbci	r31, 0x00	; 0
    237a:	a2 2f       	mov	r26, r18
    237c:	23 2f       	mov	r18, r19
    237e:	34 2f       	mov	r19, r20
    2380:	44 27       	eor	r20, r20
    2382:	58 5f       	subi	r21, 0xF8	; 248
    2384:	f3 cf       	rjmp	.-26     	; 0x236c <__addsf3x+0x34>
    2386:	46 95       	lsr	r20
    2388:	37 95       	ror	r19
    238a:	27 95       	ror	r18
    238c:	a7 95       	ror	r26
    238e:	f0 40       	sbci	r31, 0x00	; 0
    2390:	53 95       	inc	r21
    2392:	c9 f7       	brne	.-14     	; 0x2386 <__addsf3x+0x4e>
    2394:	7e f4       	brtc	.+30     	; 0x23b4 <__addsf3x+0x7c>
    2396:	1f 16       	cp	r1, r31
    2398:	ba 0b       	sbc	r27, r26
    239a:	62 0b       	sbc	r22, r18
    239c:	73 0b       	sbc	r23, r19
    239e:	84 0b       	sbc	r24, r20
    23a0:	ba f0       	brmi	.+46     	; 0x23d0 <__addsf3x+0x98>
    23a2:	91 50       	subi	r25, 0x01	; 1
    23a4:	a1 f0       	breq	.+40     	; 0x23ce <__addsf3x+0x96>
    23a6:	ff 0f       	add	r31, r31
    23a8:	bb 1f       	adc	r27, r27
    23aa:	66 1f       	adc	r22, r22
    23ac:	77 1f       	adc	r23, r23
    23ae:	88 1f       	adc	r24, r24
    23b0:	c2 f7       	brpl	.-16     	; 0x23a2 <__addsf3x+0x6a>
    23b2:	0e c0       	rjmp	.+28     	; 0x23d0 <__addsf3x+0x98>
    23b4:	ba 0f       	add	r27, r26
    23b6:	62 1f       	adc	r22, r18
    23b8:	73 1f       	adc	r23, r19
    23ba:	84 1f       	adc	r24, r20
    23bc:	48 f4       	brcc	.+18     	; 0x23d0 <__addsf3x+0x98>
    23be:	87 95       	ror	r24
    23c0:	77 95       	ror	r23
    23c2:	67 95       	ror	r22
    23c4:	b7 95       	ror	r27
    23c6:	f7 95       	ror	r31
    23c8:	9e 3f       	cpi	r25, 0xFE	; 254
    23ca:	08 f0       	brcs	.+2      	; 0x23ce <__addsf3x+0x96>
    23cc:	b3 cf       	rjmp	.-154    	; 0x2334 <__addsf3+0x1e>
    23ce:	93 95       	inc	r25
    23d0:	88 0f       	add	r24, r24
    23d2:	08 f0       	brcs	.+2      	; 0x23d6 <__addsf3x+0x9e>
    23d4:	99 27       	eor	r25, r25
    23d6:	ee 0f       	add	r30, r30
    23d8:	97 95       	ror	r25
    23da:	87 95       	ror	r24
    23dc:	08 95       	ret

000023de <__cmpsf2>:
    23de:	d9 d0       	rcall	.+434    	; 0x2592 <__fp_cmp>
    23e0:	08 f4       	brcc	.+2      	; 0x23e4 <__cmpsf2+0x6>
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	08 95       	ret

000023e6 <__divsf3>:
    23e6:	0c d0       	rcall	.+24     	; 0x2400 <__divsf3x>
    23e8:	0f c1       	rjmp	.+542    	; 0x2608 <__fp_round>
    23ea:	07 d1       	rcall	.+526    	; 0x25fa <__fp_pscB>
    23ec:	40 f0       	brcs	.+16     	; 0x23fe <__divsf3+0x18>
    23ee:	fe d0       	rcall	.+508    	; 0x25ec <__fp_pscA>
    23f0:	30 f0       	brcs	.+12     	; 0x23fe <__divsf3+0x18>
    23f2:	21 f4       	brne	.+8      	; 0x23fc <__divsf3+0x16>
    23f4:	5f 3f       	cpi	r21, 0xFF	; 255
    23f6:	19 f0       	breq	.+6      	; 0x23fe <__divsf3+0x18>
    23f8:	f0 c0       	rjmp	.+480    	; 0x25da <__fp_inf>
    23fa:	51 11       	cpse	r21, r1
    23fc:	39 c1       	rjmp	.+626    	; 0x2670 <__fp_szero>
    23fe:	f3 c0       	rjmp	.+486    	; 0x25e6 <__fp_nan>

00002400 <__divsf3x>:
    2400:	14 d1       	rcall	.+552    	; 0x262a <__fp_split3>
    2402:	98 f3       	brcs	.-26     	; 0x23ea <__divsf3+0x4>

00002404 <__divsf3_pse>:
    2404:	99 23       	and	r25, r25
    2406:	c9 f3       	breq	.-14     	; 0x23fa <__divsf3+0x14>
    2408:	55 23       	and	r21, r21
    240a:	b1 f3       	breq	.-20     	; 0x23f8 <__divsf3+0x12>
    240c:	95 1b       	sub	r25, r21
    240e:	55 0b       	sbc	r21, r21
    2410:	bb 27       	eor	r27, r27
    2412:	aa 27       	eor	r26, r26
    2414:	62 17       	cp	r22, r18
    2416:	73 07       	cpc	r23, r19
    2418:	84 07       	cpc	r24, r20
    241a:	38 f0       	brcs	.+14     	; 0x242a <__divsf3_pse+0x26>
    241c:	9f 5f       	subi	r25, 0xFF	; 255
    241e:	5f 4f       	sbci	r21, 0xFF	; 255
    2420:	22 0f       	add	r18, r18
    2422:	33 1f       	adc	r19, r19
    2424:	44 1f       	adc	r20, r20
    2426:	aa 1f       	adc	r26, r26
    2428:	a9 f3       	breq	.-22     	; 0x2414 <__divsf3_pse+0x10>
    242a:	33 d0       	rcall	.+102    	; 0x2492 <__divsf3_pse+0x8e>
    242c:	0e 2e       	mov	r0, r30
    242e:	3a f0       	brmi	.+14     	; 0x243e <__divsf3_pse+0x3a>
    2430:	e0 e8       	ldi	r30, 0x80	; 128
    2432:	30 d0       	rcall	.+96     	; 0x2494 <__divsf3_pse+0x90>
    2434:	91 50       	subi	r25, 0x01	; 1
    2436:	50 40       	sbci	r21, 0x00	; 0
    2438:	e6 95       	lsr	r30
    243a:	00 1c       	adc	r0, r0
    243c:	ca f7       	brpl	.-14     	; 0x2430 <__divsf3_pse+0x2c>
    243e:	29 d0       	rcall	.+82     	; 0x2492 <__divsf3_pse+0x8e>
    2440:	fe 2f       	mov	r31, r30
    2442:	27 d0       	rcall	.+78     	; 0x2492 <__divsf3_pse+0x8e>
    2444:	66 0f       	add	r22, r22
    2446:	77 1f       	adc	r23, r23
    2448:	88 1f       	adc	r24, r24
    244a:	bb 1f       	adc	r27, r27
    244c:	26 17       	cp	r18, r22
    244e:	37 07       	cpc	r19, r23
    2450:	48 07       	cpc	r20, r24
    2452:	ab 07       	cpc	r26, r27
    2454:	b0 e8       	ldi	r27, 0x80	; 128
    2456:	09 f0       	breq	.+2      	; 0x245a <__divsf3_pse+0x56>
    2458:	bb 0b       	sbc	r27, r27
    245a:	80 2d       	mov	r24, r0
    245c:	bf 01       	movw	r22, r30
    245e:	ff 27       	eor	r31, r31
    2460:	93 58       	subi	r25, 0x83	; 131
    2462:	5f 4f       	sbci	r21, 0xFF	; 255
    2464:	2a f0       	brmi	.+10     	; 0x2470 <__divsf3_pse+0x6c>
    2466:	9e 3f       	cpi	r25, 0xFE	; 254
    2468:	51 05       	cpc	r21, r1
    246a:	68 f0       	brcs	.+26     	; 0x2486 <__divsf3_pse+0x82>
    246c:	b6 c0       	rjmp	.+364    	; 0x25da <__fp_inf>
    246e:	00 c1       	rjmp	.+512    	; 0x2670 <__fp_szero>
    2470:	5f 3f       	cpi	r21, 0xFF	; 255
    2472:	ec f3       	brlt	.-6      	; 0x246e <__divsf3_pse+0x6a>
    2474:	98 3e       	cpi	r25, 0xE8	; 232
    2476:	dc f3       	brlt	.-10     	; 0x246e <__divsf3_pse+0x6a>
    2478:	86 95       	lsr	r24
    247a:	77 95       	ror	r23
    247c:	67 95       	ror	r22
    247e:	b7 95       	ror	r27
    2480:	f7 95       	ror	r31
    2482:	9f 5f       	subi	r25, 0xFF	; 255
    2484:	c9 f7       	brne	.-14     	; 0x2478 <__divsf3_pse+0x74>
    2486:	88 0f       	add	r24, r24
    2488:	91 1d       	adc	r25, r1
    248a:	96 95       	lsr	r25
    248c:	87 95       	ror	r24
    248e:	97 f9       	bld	r25, 7
    2490:	08 95       	ret
    2492:	e1 e0       	ldi	r30, 0x01	; 1
    2494:	66 0f       	add	r22, r22
    2496:	77 1f       	adc	r23, r23
    2498:	88 1f       	adc	r24, r24
    249a:	bb 1f       	adc	r27, r27
    249c:	62 17       	cp	r22, r18
    249e:	73 07       	cpc	r23, r19
    24a0:	84 07       	cpc	r24, r20
    24a2:	ba 07       	cpc	r27, r26
    24a4:	20 f0       	brcs	.+8      	; 0x24ae <__divsf3_pse+0xaa>
    24a6:	62 1b       	sub	r22, r18
    24a8:	73 0b       	sbc	r23, r19
    24aa:	84 0b       	sbc	r24, r20
    24ac:	ba 0b       	sbc	r27, r26
    24ae:	ee 1f       	adc	r30, r30
    24b0:	88 f7       	brcc	.-30     	; 0x2494 <__divsf3_pse+0x90>
    24b2:	e0 95       	com	r30
    24b4:	08 95       	ret

000024b6 <__fixsfsi>:
    24b6:	04 d0       	rcall	.+8      	; 0x24c0 <__fixunssfsi>
    24b8:	68 94       	set
    24ba:	b1 11       	cpse	r27, r1
    24bc:	d9 c0       	rjmp	.+434    	; 0x2670 <__fp_szero>
    24be:	08 95       	ret

000024c0 <__fixunssfsi>:
    24c0:	bc d0       	rcall	.+376    	; 0x263a <__fp_splitA>
    24c2:	88 f0       	brcs	.+34     	; 0x24e6 <__fixunssfsi+0x26>
    24c4:	9f 57       	subi	r25, 0x7F	; 127
    24c6:	90 f0       	brcs	.+36     	; 0x24ec <__fixunssfsi+0x2c>
    24c8:	b9 2f       	mov	r27, r25
    24ca:	99 27       	eor	r25, r25
    24cc:	b7 51       	subi	r27, 0x17	; 23
    24ce:	a0 f0       	brcs	.+40     	; 0x24f8 <__fixunssfsi+0x38>
    24d0:	d1 f0       	breq	.+52     	; 0x2506 <__fixunssfsi+0x46>
    24d2:	66 0f       	add	r22, r22
    24d4:	77 1f       	adc	r23, r23
    24d6:	88 1f       	adc	r24, r24
    24d8:	99 1f       	adc	r25, r25
    24da:	1a f0       	brmi	.+6      	; 0x24e2 <__fixunssfsi+0x22>
    24dc:	ba 95       	dec	r27
    24de:	c9 f7       	brne	.-14     	; 0x24d2 <__fixunssfsi+0x12>
    24e0:	12 c0       	rjmp	.+36     	; 0x2506 <__fixunssfsi+0x46>
    24e2:	b1 30       	cpi	r27, 0x01	; 1
    24e4:	81 f0       	breq	.+32     	; 0x2506 <__fixunssfsi+0x46>
    24e6:	c3 d0       	rcall	.+390    	; 0x266e <__fp_zero>
    24e8:	b1 e0       	ldi	r27, 0x01	; 1
    24ea:	08 95       	ret
    24ec:	c0 c0       	rjmp	.+384    	; 0x266e <__fp_zero>
    24ee:	67 2f       	mov	r22, r23
    24f0:	78 2f       	mov	r23, r24
    24f2:	88 27       	eor	r24, r24
    24f4:	b8 5f       	subi	r27, 0xF8	; 248
    24f6:	39 f0       	breq	.+14     	; 0x2506 <__fixunssfsi+0x46>
    24f8:	b9 3f       	cpi	r27, 0xF9	; 249
    24fa:	cc f3       	brlt	.-14     	; 0x24ee <__fixunssfsi+0x2e>
    24fc:	86 95       	lsr	r24
    24fe:	77 95       	ror	r23
    2500:	67 95       	ror	r22
    2502:	b3 95       	inc	r27
    2504:	d9 f7       	brne	.-10     	; 0x24fc <__fixunssfsi+0x3c>
    2506:	3e f4       	brtc	.+14     	; 0x2516 <__fixunssfsi+0x56>
    2508:	90 95       	com	r25
    250a:	80 95       	com	r24
    250c:	70 95       	com	r23
    250e:	61 95       	neg	r22
    2510:	7f 4f       	sbci	r23, 0xFF	; 255
    2512:	8f 4f       	sbci	r24, 0xFF	; 255
    2514:	9f 4f       	sbci	r25, 0xFF	; 255
    2516:	08 95       	ret

00002518 <__floatunsisf>:
    2518:	e8 94       	clt
    251a:	09 c0       	rjmp	.+18     	; 0x252e <__floatsisf+0x12>

0000251c <__floatsisf>:
    251c:	97 fb       	bst	r25, 7
    251e:	3e f4       	brtc	.+14     	; 0x252e <__floatsisf+0x12>
    2520:	90 95       	com	r25
    2522:	80 95       	com	r24
    2524:	70 95       	com	r23
    2526:	61 95       	neg	r22
    2528:	7f 4f       	sbci	r23, 0xFF	; 255
    252a:	8f 4f       	sbci	r24, 0xFF	; 255
    252c:	9f 4f       	sbci	r25, 0xFF	; 255
    252e:	99 23       	and	r25, r25
    2530:	a9 f0       	breq	.+42     	; 0x255c <__floatsisf+0x40>
    2532:	f9 2f       	mov	r31, r25
    2534:	96 e9       	ldi	r25, 0x96	; 150
    2536:	bb 27       	eor	r27, r27
    2538:	93 95       	inc	r25
    253a:	f6 95       	lsr	r31
    253c:	87 95       	ror	r24
    253e:	77 95       	ror	r23
    2540:	67 95       	ror	r22
    2542:	b7 95       	ror	r27
    2544:	f1 11       	cpse	r31, r1
    2546:	f8 cf       	rjmp	.-16     	; 0x2538 <__floatsisf+0x1c>
    2548:	fa f4       	brpl	.+62     	; 0x2588 <__floatsisf+0x6c>
    254a:	bb 0f       	add	r27, r27
    254c:	11 f4       	brne	.+4      	; 0x2552 <__floatsisf+0x36>
    254e:	60 ff       	sbrs	r22, 0
    2550:	1b c0       	rjmp	.+54     	; 0x2588 <__floatsisf+0x6c>
    2552:	6f 5f       	subi	r22, 0xFF	; 255
    2554:	7f 4f       	sbci	r23, 0xFF	; 255
    2556:	8f 4f       	sbci	r24, 0xFF	; 255
    2558:	9f 4f       	sbci	r25, 0xFF	; 255
    255a:	16 c0       	rjmp	.+44     	; 0x2588 <__floatsisf+0x6c>
    255c:	88 23       	and	r24, r24
    255e:	11 f0       	breq	.+4      	; 0x2564 <__floatsisf+0x48>
    2560:	96 e9       	ldi	r25, 0x96	; 150
    2562:	11 c0       	rjmp	.+34     	; 0x2586 <__floatsisf+0x6a>
    2564:	77 23       	and	r23, r23
    2566:	21 f0       	breq	.+8      	; 0x2570 <__floatsisf+0x54>
    2568:	9e e8       	ldi	r25, 0x8E	; 142
    256a:	87 2f       	mov	r24, r23
    256c:	76 2f       	mov	r23, r22
    256e:	05 c0       	rjmp	.+10     	; 0x257a <__floatsisf+0x5e>
    2570:	66 23       	and	r22, r22
    2572:	71 f0       	breq	.+28     	; 0x2590 <__floatsisf+0x74>
    2574:	96 e8       	ldi	r25, 0x86	; 134
    2576:	86 2f       	mov	r24, r22
    2578:	70 e0       	ldi	r23, 0x00	; 0
    257a:	60 e0       	ldi	r22, 0x00	; 0
    257c:	2a f0       	brmi	.+10     	; 0x2588 <__floatsisf+0x6c>
    257e:	9a 95       	dec	r25
    2580:	66 0f       	add	r22, r22
    2582:	77 1f       	adc	r23, r23
    2584:	88 1f       	adc	r24, r24
    2586:	da f7       	brpl	.-10     	; 0x257e <__floatsisf+0x62>
    2588:	88 0f       	add	r24, r24
    258a:	96 95       	lsr	r25
    258c:	87 95       	ror	r24
    258e:	97 f9       	bld	r25, 7
    2590:	08 95       	ret

00002592 <__fp_cmp>:
    2592:	99 0f       	add	r25, r25
    2594:	00 08       	sbc	r0, r0
    2596:	55 0f       	add	r21, r21
    2598:	aa 0b       	sbc	r26, r26
    259a:	e0 e8       	ldi	r30, 0x80	; 128
    259c:	fe ef       	ldi	r31, 0xFE	; 254
    259e:	16 16       	cp	r1, r22
    25a0:	17 06       	cpc	r1, r23
    25a2:	e8 07       	cpc	r30, r24
    25a4:	f9 07       	cpc	r31, r25
    25a6:	c0 f0       	brcs	.+48     	; 0x25d8 <__fp_cmp+0x46>
    25a8:	12 16       	cp	r1, r18
    25aa:	13 06       	cpc	r1, r19
    25ac:	e4 07       	cpc	r30, r20
    25ae:	f5 07       	cpc	r31, r21
    25b0:	98 f0       	brcs	.+38     	; 0x25d8 <__fp_cmp+0x46>
    25b2:	62 1b       	sub	r22, r18
    25b4:	73 0b       	sbc	r23, r19
    25b6:	84 0b       	sbc	r24, r20
    25b8:	95 0b       	sbc	r25, r21
    25ba:	39 f4       	brne	.+14     	; 0x25ca <__fp_cmp+0x38>
    25bc:	0a 26       	eor	r0, r26
    25be:	61 f0       	breq	.+24     	; 0x25d8 <__fp_cmp+0x46>
    25c0:	23 2b       	or	r18, r19
    25c2:	24 2b       	or	r18, r20
    25c4:	25 2b       	or	r18, r21
    25c6:	21 f4       	brne	.+8      	; 0x25d0 <__fp_cmp+0x3e>
    25c8:	08 95       	ret
    25ca:	0a 26       	eor	r0, r26
    25cc:	09 f4       	brne	.+2      	; 0x25d0 <__fp_cmp+0x3e>
    25ce:	a1 40       	sbci	r26, 0x01	; 1
    25d0:	a6 95       	lsr	r26
    25d2:	8f ef       	ldi	r24, 0xFF	; 255
    25d4:	81 1d       	adc	r24, r1
    25d6:	81 1d       	adc	r24, r1
    25d8:	08 95       	ret

000025da <__fp_inf>:
    25da:	97 f9       	bld	r25, 7
    25dc:	9f 67       	ori	r25, 0x7F	; 127
    25de:	80 e8       	ldi	r24, 0x80	; 128
    25e0:	70 e0       	ldi	r23, 0x00	; 0
    25e2:	60 e0       	ldi	r22, 0x00	; 0
    25e4:	08 95       	ret

000025e6 <__fp_nan>:
    25e6:	9f ef       	ldi	r25, 0xFF	; 255
    25e8:	80 ec       	ldi	r24, 0xC0	; 192
    25ea:	08 95       	ret

000025ec <__fp_pscA>:
    25ec:	00 24       	eor	r0, r0
    25ee:	0a 94       	dec	r0
    25f0:	16 16       	cp	r1, r22
    25f2:	17 06       	cpc	r1, r23
    25f4:	18 06       	cpc	r1, r24
    25f6:	09 06       	cpc	r0, r25
    25f8:	08 95       	ret

000025fa <__fp_pscB>:
    25fa:	00 24       	eor	r0, r0
    25fc:	0a 94       	dec	r0
    25fe:	12 16       	cp	r1, r18
    2600:	13 06       	cpc	r1, r19
    2602:	14 06       	cpc	r1, r20
    2604:	05 06       	cpc	r0, r21
    2606:	08 95       	ret

00002608 <__fp_round>:
    2608:	09 2e       	mov	r0, r25
    260a:	03 94       	inc	r0
    260c:	00 0c       	add	r0, r0
    260e:	11 f4       	brne	.+4      	; 0x2614 <__fp_round+0xc>
    2610:	88 23       	and	r24, r24
    2612:	52 f0       	brmi	.+20     	; 0x2628 <__fp_round+0x20>
    2614:	bb 0f       	add	r27, r27
    2616:	40 f4       	brcc	.+16     	; 0x2628 <__fp_round+0x20>
    2618:	bf 2b       	or	r27, r31
    261a:	11 f4       	brne	.+4      	; 0x2620 <__fp_round+0x18>
    261c:	60 ff       	sbrs	r22, 0
    261e:	04 c0       	rjmp	.+8      	; 0x2628 <__fp_round+0x20>
    2620:	6f 5f       	subi	r22, 0xFF	; 255
    2622:	7f 4f       	sbci	r23, 0xFF	; 255
    2624:	8f 4f       	sbci	r24, 0xFF	; 255
    2626:	9f 4f       	sbci	r25, 0xFF	; 255
    2628:	08 95       	ret

0000262a <__fp_split3>:
    262a:	57 fd       	sbrc	r21, 7
    262c:	90 58       	subi	r25, 0x80	; 128
    262e:	44 0f       	add	r20, r20
    2630:	55 1f       	adc	r21, r21
    2632:	59 f0       	breq	.+22     	; 0x264a <__fp_splitA+0x10>
    2634:	5f 3f       	cpi	r21, 0xFF	; 255
    2636:	71 f0       	breq	.+28     	; 0x2654 <__fp_splitA+0x1a>
    2638:	47 95       	ror	r20

0000263a <__fp_splitA>:
    263a:	88 0f       	add	r24, r24
    263c:	97 fb       	bst	r25, 7
    263e:	99 1f       	adc	r25, r25
    2640:	61 f0       	breq	.+24     	; 0x265a <__fp_splitA+0x20>
    2642:	9f 3f       	cpi	r25, 0xFF	; 255
    2644:	79 f0       	breq	.+30     	; 0x2664 <__fp_splitA+0x2a>
    2646:	87 95       	ror	r24
    2648:	08 95       	ret
    264a:	12 16       	cp	r1, r18
    264c:	13 06       	cpc	r1, r19
    264e:	14 06       	cpc	r1, r20
    2650:	55 1f       	adc	r21, r21
    2652:	f2 cf       	rjmp	.-28     	; 0x2638 <__fp_split3+0xe>
    2654:	46 95       	lsr	r20
    2656:	f1 df       	rcall	.-30     	; 0x263a <__fp_splitA>
    2658:	08 c0       	rjmp	.+16     	; 0x266a <__fp_splitA+0x30>
    265a:	16 16       	cp	r1, r22
    265c:	17 06       	cpc	r1, r23
    265e:	18 06       	cpc	r1, r24
    2660:	99 1f       	adc	r25, r25
    2662:	f1 cf       	rjmp	.-30     	; 0x2646 <__fp_splitA+0xc>
    2664:	86 95       	lsr	r24
    2666:	71 05       	cpc	r23, r1
    2668:	61 05       	cpc	r22, r1
    266a:	08 94       	sec
    266c:	08 95       	ret

0000266e <__fp_zero>:
    266e:	e8 94       	clt

00002670 <__fp_szero>:
    2670:	bb 27       	eor	r27, r27
    2672:	66 27       	eor	r22, r22
    2674:	77 27       	eor	r23, r23
    2676:	cb 01       	movw	r24, r22
    2678:	97 f9       	bld	r25, 7
    267a:	08 95       	ret

0000267c <__gesf2>:
    267c:	8a df       	rcall	.-236    	; 0x2592 <__fp_cmp>
    267e:	08 f4       	brcc	.+2      	; 0x2682 <__gesf2+0x6>
    2680:	8f ef       	ldi	r24, 0xFF	; 255
    2682:	08 95       	ret

00002684 <__mulsf3>:
    2684:	0b d0       	rcall	.+22     	; 0x269c <__mulsf3x>
    2686:	c0 cf       	rjmp	.-128    	; 0x2608 <__fp_round>
    2688:	b1 df       	rcall	.-158    	; 0x25ec <__fp_pscA>
    268a:	28 f0       	brcs	.+10     	; 0x2696 <__mulsf3+0x12>
    268c:	b6 df       	rcall	.-148    	; 0x25fa <__fp_pscB>
    268e:	18 f0       	brcs	.+6      	; 0x2696 <__mulsf3+0x12>
    2690:	95 23       	and	r25, r21
    2692:	09 f0       	breq	.+2      	; 0x2696 <__mulsf3+0x12>
    2694:	a2 cf       	rjmp	.-188    	; 0x25da <__fp_inf>
    2696:	a7 cf       	rjmp	.-178    	; 0x25e6 <__fp_nan>
    2698:	11 24       	eor	r1, r1
    269a:	ea cf       	rjmp	.-44     	; 0x2670 <__fp_szero>

0000269c <__mulsf3x>:
    269c:	c6 df       	rcall	.-116    	; 0x262a <__fp_split3>
    269e:	a0 f3       	brcs	.-24     	; 0x2688 <__mulsf3+0x4>

000026a0 <__mulsf3_pse>:
    26a0:	95 9f       	mul	r25, r21
    26a2:	d1 f3       	breq	.-12     	; 0x2698 <__mulsf3+0x14>
    26a4:	95 0f       	add	r25, r21
    26a6:	50 e0       	ldi	r21, 0x00	; 0
    26a8:	55 1f       	adc	r21, r21
    26aa:	62 9f       	mul	r22, r18
    26ac:	f0 01       	movw	r30, r0
    26ae:	72 9f       	mul	r23, r18
    26b0:	bb 27       	eor	r27, r27
    26b2:	f0 0d       	add	r31, r0
    26b4:	b1 1d       	adc	r27, r1
    26b6:	63 9f       	mul	r22, r19
    26b8:	aa 27       	eor	r26, r26
    26ba:	f0 0d       	add	r31, r0
    26bc:	b1 1d       	adc	r27, r1
    26be:	aa 1f       	adc	r26, r26
    26c0:	64 9f       	mul	r22, r20
    26c2:	66 27       	eor	r22, r22
    26c4:	b0 0d       	add	r27, r0
    26c6:	a1 1d       	adc	r26, r1
    26c8:	66 1f       	adc	r22, r22
    26ca:	82 9f       	mul	r24, r18
    26cc:	22 27       	eor	r18, r18
    26ce:	b0 0d       	add	r27, r0
    26d0:	a1 1d       	adc	r26, r1
    26d2:	62 1f       	adc	r22, r18
    26d4:	73 9f       	mul	r23, r19
    26d6:	b0 0d       	add	r27, r0
    26d8:	a1 1d       	adc	r26, r1
    26da:	62 1f       	adc	r22, r18
    26dc:	83 9f       	mul	r24, r19
    26de:	a0 0d       	add	r26, r0
    26e0:	61 1d       	adc	r22, r1
    26e2:	22 1f       	adc	r18, r18
    26e4:	74 9f       	mul	r23, r20
    26e6:	33 27       	eor	r19, r19
    26e8:	a0 0d       	add	r26, r0
    26ea:	61 1d       	adc	r22, r1
    26ec:	23 1f       	adc	r18, r19
    26ee:	84 9f       	mul	r24, r20
    26f0:	60 0d       	add	r22, r0
    26f2:	21 1d       	adc	r18, r1
    26f4:	82 2f       	mov	r24, r18
    26f6:	76 2f       	mov	r23, r22
    26f8:	6a 2f       	mov	r22, r26
    26fa:	11 24       	eor	r1, r1
    26fc:	9f 57       	subi	r25, 0x7F	; 127
    26fe:	50 40       	sbci	r21, 0x00	; 0
    2700:	8a f0       	brmi	.+34     	; 0x2724 <__mulsf3_pse+0x84>
    2702:	e1 f0       	breq	.+56     	; 0x273c <__mulsf3_pse+0x9c>
    2704:	88 23       	and	r24, r24
    2706:	4a f0       	brmi	.+18     	; 0x271a <__mulsf3_pse+0x7a>
    2708:	ee 0f       	add	r30, r30
    270a:	ff 1f       	adc	r31, r31
    270c:	bb 1f       	adc	r27, r27
    270e:	66 1f       	adc	r22, r22
    2710:	77 1f       	adc	r23, r23
    2712:	88 1f       	adc	r24, r24
    2714:	91 50       	subi	r25, 0x01	; 1
    2716:	50 40       	sbci	r21, 0x00	; 0
    2718:	a9 f7       	brne	.-22     	; 0x2704 <__mulsf3_pse+0x64>
    271a:	9e 3f       	cpi	r25, 0xFE	; 254
    271c:	51 05       	cpc	r21, r1
    271e:	70 f0       	brcs	.+28     	; 0x273c <__mulsf3_pse+0x9c>
    2720:	5c cf       	rjmp	.-328    	; 0x25da <__fp_inf>
    2722:	a6 cf       	rjmp	.-180    	; 0x2670 <__fp_szero>
    2724:	5f 3f       	cpi	r21, 0xFF	; 255
    2726:	ec f3       	brlt	.-6      	; 0x2722 <__mulsf3_pse+0x82>
    2728:	98 3e       	cpi	r25, 0xE8	; 232
    272a:	dc f3       	brlt	.-10     	; 0x2722 <__mulsf3_pse+0x82>
    272c:	86 95       	lsr	r24
    272e:	77 95       	ror	r23
    2730:	67 95       	ror	r22
    2732:	b7 95       	ror	r27
    2734:	f7 95       	ror	r31
    2736:	e7 95       	ror	r30
    2738:	9f 5f       	subi	r25, 0xFF	; 255
    273a:	c1 f7       	brne	.-16     	; 0x272c <__mulsf3_pse+0x8c>
    273c:	fe 2b       	or	r31, r30
    273e:	88 0f       	add	r24, r24
    2740:	91 1d       	adc	r25, r1
    2742:	96 95       	lsr	r25
    2744:	87 95       	ror	r24
    2746:	97 f9       	bld	r25, 7
    2748:	08 95       	ret

0000274a <__tablejump2__>:
    274a:	ee 0f       	add	r30, r30
    274c:	ff 1f       	adc	r31, r31
    274e:	00 24       	eor	r0, r0
    2750:	00 1c       	adc	r0, r0
    2752:	0b be       	out	0x3b, r0	; 59
    2754:	07 90       	elpm	r0, Z+
    2756:	f6 91       	elpm	r31, Z
    2758:	e0 2d       	mov	r30, r0
    275a:	09 94       	ijmp

0000275c <atoi>:
    275c:	fc 01       	movw	r30, r24
    275e:	88 27       	eor	r24, r24
    2760:	99 27       	eor	r25, r25
    2762:	e8 94       	clt
    2764:	21 91       	ld	r18, Z+
    2766:	20 32       	cpi	r18, 0x20	; 32
    2768:	e9 f3       	breq	.-6      	; 0x2764 <atoi+0x8>
    276a:	29 30       	cpi	r18, 0x09	; 9
    276c:	10 f0       	brcs	.+4      	; 0x2772 <atoi+0x16>
    276e:	2e 30       	cpi	r18, 0x0E	; 14
    2770:	c8 f3       	brcs	.-14     	; 0x2764 <atoi+0x8>
    2772:	2b 32       	cpi	r18, 0x2B	; 43
    2774:	39 f0       	breq	.+14     	; 0x2784 <atoi+0x28>
    2776:	2d 32       	cpi	r18, 0x2D	; 45
    2778:	31 f4       	brne	.+12     	; 0x2786 <atoi+0x2a>
    277a:	68 94       	set
    277c:	03 c0       	rjmp	.+6      	; 0x2784 <atoi+0x28>
    277e:	14 d0       	rcall	.+40     	; 0x27a8 <__mulhi_const_10>
    2780:	82 0f       	add	r24, r18
    2782:	91 1d       	adc	r25, r1
    2784:	21 91       	ld	r18, Z+
    2786:	20 53       	subi	r18, 0x30	; 48
    2788:	2a 30       	cpi	r18, 0x0A	; 10
    278a:	c8 f3       	brcs	.-14     	; 0x277e <atoi+0x22>
    278c:	1e f4       	brtc	.+6      	; 0x2794 <atoi+0x38>
    278e:	90 95       	com	r25
    2790:	81 95       	neg	r24
    2792:	9f 4f       	sbci	r25, 0xFF	; 255
    2794:	08 95       	ret

00002796 <strcmp>:
    2796:	fb 01       	movw	r30, r22
    2798:	dc 01       	movw	r26, r24
    279a:	8d 91       	ld	r24, X+
    279c:	01 90       	ld	r0, Z+
    279e:	80 19       	sub	r24, r0
    27a0:	01 10       	cpse	r0, r1
    27a2:	d9 f3       	breq	.-10     	; 0x279a <strcmp+0x4>
    27a4:	99 0b       	sbc	r25, r25
    27a6:	08 95       	ret

000027a8 <__mulhi_const_10>:
    27a8:	7a e0       	ldi	r23, 0x0A	; 10
    27aa:	97 9f       	mul	r25, r23
    27ac:	90 2d       	mov	r25, r0
    27ae:	87 9f       	mul	r24, r23
    27b0:	80 2d       	mov	r24, r0
    27b2:	91 0d       	add	r25, r1
    27b4:	11 24       	eor	r1, r1
    27b6:	08 95       	ret

000027b8 <printf>:
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
    27c0:	ae 01       	movw	r20, r28
    27c2:	4b 5f       	subi	r20, 0xFB	; 251
    27c4:	5f 4f       	sbci	r21, 0xFF	; 255
    27c6:	fa 01       	movw	r30, r20
    27c8:	61 91       	ld	r22, Z+
    27ca:	71 91       	ld	r23, Z+
    27cc:	af 01       	movw	r20, r30
    27ce:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27d2:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27d6:	38 d0       	rcall	.+112    	; 0x2848 <vfprintf>
    27d8:	df 91       	pop	r29
    27da:	cf 91       	pop	r28
    27dc:	08 95       	ret

000027de <putchar>:
    27de:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27e2:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27e6:	43 c2       	rjmp	.+1158   	; 0x2c6e <fputc>

000027e8 <puts>:
    27e8:	0f 93       	push	r16
    27ea:	1f 93       	push	r17
    27ec:	cf 93       	push	r28
    27ee:	df 93       	push	r29
    27f0:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    27f4:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    27f8:	23 81       	ldd	r18, Z+3	; 0x03
    27fa:	21 ff       	sbrs	r18, 1
    27fc:	1b c0       	rjmp	.+54     	; 0x2834 <puts+0x4c>
    27fe:	8c 01       	movw	r16, r24
    2800:	d0 e0       	ldi	r29, 0x00	; 0
    2802:	c0 e0       	ldi	r28, 0x00	; 0
    2804:	f8 01       	movw	r30, r16
    2806:	81 91       	ld	r24, Z+
    2808:	8f 01       	movw	r16, r30
    280a:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    280e:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    2812:	db 01       	movw	r26, r22
    2814:	18 96       	adiw	r26, 0x08	; 8
    2816:	ed 91       	ld	r30, X+
    2818:	fc 91       	ld	r31, X
    281a:	19 97       	sbiw	r26, 0x09	; 9
    281c:	88 23       	and	r24, r24
    281e:	31 f0       	breq	.+12     	; 0x282c <puts+0x44>
    2820:	09 95       	icall
    2822:	89 2b       	or	r24, r25
    2824:	79 f3       	breq	.-34     	; 0x2804 <puts+0x1c>
    2826:	df ef       	ldi	r29, 0xFF	; 255
    2828:	cf ef       	ldi	r28, 0xFF	; 255
    282a:	ec cf       	rjmp	.-40     	; 0x2804 <puts+0x1c>
    282c:	8a e0       	ldi	r24, 0x0A	; 10
    282e:	09 95       	icall
    2830:	89 2b       	or	r24, r25
    2832:	19 f0       	breq	.+6      	; 0x283a <puts+0x52>
    2834:	8f ef       	ldi	r24, 0xFF	; 255
    2836:	9f ef       	ldi	r25, 0xFF	; 255
    2838:	02 c0       	rjmp	.+4      	; 0x283e <puts+0x56>
    283a:	8d 2f       	mov	r24, r29
    283c:	9c 2f       	mov	r25, r28
    283e:	df 91       	pop	r29
    2840:	cf 91       	pop	r28
    2842:	1f 91       	pop	r17
    2844:	0f 91       	pop	r16
    2846:	08 95       	ret

00002848 <vfprintf>:
    2848:	2f 92       	push	r2
    284a:	3f 92       	push	r3
    284c:	4f 92       	push	r4
    284e:	5f 92       	push	r5
    2850:	6f 92       	push	r6
    2852:	7f 92       	push	r7
    2854:	8f 92       	push	r8
    2856:	9f 92       	push	r9
    2858:	af 92       	push	r10
    285a:	bf 92       	push	r11
    285c:	cf 92       	push	r12
    285e:	df 92       	push	r13
    2860:	ef 92       	push	r14
    2862:	ff 92       	push	r15
    2864:	0f 93       	push	r16
    2866:	1f 93       	push	r17
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	2b 97       	sbiw	r28, 0x0b	; 11
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	6c 01       	movw	r12, r24
    287e:	7b 01       	movw	r14, r22
    2880:	8a 01       	movw	r16, r20
    2882:	fc 01       	movw	r30, r24
    2884:	17 82       	std	Z+7, r1	; 0x07
    2886:	16 82       	std	Z+6, r1	; 0x06
    2888:	83 81       	ldd	r24, Z+3	; 0x03
    288a:	81 ff       	sbrs	r24, 1
    288c:	bf c1       	rjmp	.+894    	; 0x2c0c <vfprintf+0x3c4>
    288e:	ce 01       	movw	r24, r28
    2890:	01 96       	adiw	r24, 0x01	; 1
    2892:	3c 01       	movw	r6, r24
    2894:	f6 01       	movw	r30, r12
    2896:	93 81       	ldd	r25, Z+3	; 0x03
    2898:	f7 01       	movw	r30, r14
    289a:	93 fd       	sbrc	r25, 3
    289c:	85 91       	lpm	r24, Z+
    289e:	93 ff       	sbrs	r25, 3
    28a0:	81 91       	ld	r24, Z+
    28a2:	7f 01       	movw	r14, r30
    28a4:	88 23       	and	r24, r24
    28a6:	09 f4       	brne	.+2      	; 0x28aa <vfprintf+0x62>
    28a8:	ad c1       	rjmp	.+858    	; 0x2c04 <vfprintf+0x3bc>
    28aa:	85 32       	cpi	r24, 0x25	; 37
    28ac:	39 f4       	brne	.+14     	; 0x28bc <vfprintf+0x74>
    28ae:	93 fd       	sbrc	r25, 3
    28b0:	85 91       	lpm	r24, Z+
    28b2:	93 ff       	sbrs	r25, 3
    28b4:	81 91       	ld	r24, Z+
    28b6:	7f 01       	movw	r14, r30
    28b8:	85 32       	cpi	r24, 0x25	; 37
    28ba:	21 f4       	brne	.+8      	; 0x28c4 <vfprintf+0x7c>
    28bc:	b6 01       	movw	r22, r12
    28be:	90 e0       	ldi	r25, 0x00	; 0
    28c0:	d6 d1       	rcall	.+940    	; 0x2c6e <fputc>
    28c2:	e8 cf       	rjmp	.-48     	; 0x2894 <vfprintf+0x4c>
    28c4:	91 2c       	mov	r9, r1
    28c6:	21 2c       	mov	r2, r1
    28c8:	31 2c       	mov	r3, r1
    28ca:	ff e1       	ldi	r31, 0x1F	; 31
    28cc:	f3 15       	cp	r31, r3
    28ce:	d8 f0       	brcs	.+54     	; 0x2906 <vfprintf+0xbe>
    28d0:	8b 32       	cpi	r24, 0x2B	; 43
    28d2:	79 f0       	breq	.+30     	; 0x28f2 <vfprintf+0xaa>
    28d4:	38 f4       	brcc	.+14     	; 0x28e4 <vfprintf+0x9c>
    28d6:	80 32       	cpi	r24, 0x20	; 32
    28d8:	79 f0       	breq	.+30     	; 0x28f8 <vfprintf+0xb0>
    28da:	83 32       	cpi	r24, 0x23	; 35
    28dc:	a1 f4       	brne	.+40     	; 0x2906 <vfprintf+0xbe>
    28de:	23 2d       	mov	r18, r3
    28e0:	20 61       	ori	r18, 0x10	; 16
    28e2:	1d c0       	rjmp	.+58     	; 0x291e <vfprintf+0xd6>
    28e4:	8d 32       	cpi	r24, 0x2D	; 45
    28e6:	61 f0       	breq	.+24     	; 0x2900 <vfprintf+0xb8>
    28e8:	80 33       	cpi	r24, 0x30	; 48
    28ea:	69 f4       	brne	.+26     	; 0x2906 <vfprintf+0xbe>
    28ec:	23 2d       	mov	r18, r3
    28ee:	21 60       	ori	r18, 0x01	; 1
    28f0:	16 c0       	rjmp	.+44     	; 0x291e <vfprintf+0xd6>
    28f2:	83 2d       	mov	r24, r3
    28f4:	82 60       	ori	r24, 0x02	; 2
    28f6:	38 2e       	mov	r3, r24
    28f8:	e3 2d       	mov	r30, r3
    28fa:	e4 60       	ori	r30, 0x04	; 4
    28fc:	3e 2e       	mov	r3, r30
    28fe:	2a c0       	rjmp	.+84     	; 0x2954 <vfprintf+0x10c>
    2900:	f3 2d       	mov	r31, r3
    2902:	f8 60       	ori	r31, 0x08	; 8
    2904:	1d c0       	rjmp	.+58     	; 0x2940 <vfprintf+0xf8>
    2906:	37 fc       	sbrc	r3, 7
    2908:	2d c0       	rjmp	.+90     	; 0x2964 <vfprintf+0x11c>
    290a:	20 ed       	ldi	r18, 0xD0	; 208
    290c:	28 0f       	add	r18, r24
    290e:	2a 30       	cpi	r18, 0x0A	; 10
    2910:	40 f0       	brcs	.+16     	; 0x2922 <vfprintf+0xda>
    2912:	8e 32       	cpi	r24, 0x2E	; 46
    2914:	b9 f4       	brne	.+46     	; 0x2944 <vfprintf+0xfc>
    2916:	36 fc       	sbrc	r3, 6
    2918:	75 c1       	rjmp	.+746    	; 0x2c04 <vfprintf+0x3bc>
    291a:	23 2d       	mov	r18, r3
    291c:	20 64       	ori	r18, 0x40	; 64
    291e:	32 2e       	mov	r3, r18
    2920:	19 c0       	rjmp	.+50     	; 0x2954 <vfprintf+0x10c>
    2922:	36 fe       	sbrs	r3, 6
    2924:	06 c0       	rjmp	.+12     	; 0x2932 <vfprintf+0xea>
    2926:	8a e0       	ldi	r24, 0x0A	; 10
    2928:	98 9e       	mul	r9, r24
    292a:	20 0d       	add	r18, r0
    292c:	11 24       	eor	r1, r1
    292e:	92 2e       	mov	r9, r18
    2930:	11 c0       	rjmp	.+34     	; 0x2954 <vfprintf+0x10c>
    2932:	ea e0       	ldi	r30, 0x0A	; 10
    2934:	2e 9e       	mul	r2, r30
    2936:	20 0d       	add	r18, r0
    2938:	11 24       	eor	r1, r1
    293a:	22 2e       	mov	r2, r18
    293c:	f3 2d       	mov	r31, r3
    293e:	f0 62       	ori	r31, 0x20	; 32
    2940:	3f 2e       	mov	r3, r31
    2942:	08 c0       	rjmp	.+16     	; 0x2954 <vfprintf+0x10c>
    2944:	8c 36       	cpi	r24, 0x6C	; 108
    2946:	21 f4       	brne	.+8      	; 0x2950 <vfprintf+0x108>
    2948:	83 2d       	mov	r24, r3
    294a:	80 68       	ori	r24, 0x80	; 128
    294c:	38 2e       	mov	r3, r24
    294e:	02 c0       	rjmp	.+4      	; 0x2954 <vfprintf+0x10c>
    2950:	88 36       	cpi	r24, 0x68	; 104
    2952:	41 f4       	brne	.+16     	; 0x2964 <vfprintf+0x11c>
    2954:	f7 01       	movw	r30, r14
    2956:	93 fd       	sbrc	r25, 3
    2958:	85 91       	lpm	r24, Z+
    295a:	93 ff       	sbrs	r25, 3
    295c:	81 91       	ld	r24, Z+
    295e:	7f 01       	movw	r14, r30
    2960:	81 11       	cpse	r24, r1
    2962:	b3 cf       	rjmp	.-154    	; 0x28ca <vfprintf+0x82>
    2964:	98 2f       	mov	r25, r24
    2966:	9f 7d       	andi	r25, 0xDF	; 223
    2968:	95 54       	subi	r25, 0x45	; 69
    296a:	93 30       	cpi	r25, 0x03	; 3
    296c:	28 f4       	brcc	.+10     	; 0x2978 <vfprintf+0x130>
    296e:	0c 5f       	subi	r16, 0xFC	; 252
    2970:	1f 4f       	sbci	r17, 0xFF	; 255
    2972:	9f e3       	ldi	r25, 0x3F	; 63
    2974:	99 83       	std	Y+1, r25	; 0x01
    2976:	0d c0       	rjmp	.+26     	; 0x2992 <vfprintf+0x14a>
    2978:	83 36       	cpi	r24, 0x63	; 99
    297a:	31 f0       	breq	.+12     	; 0x2988 <vfprintf+0x140>
    297c:	83 37       	cpi	r24, 0x73	; 115
    297e:	71 f0       	breq	.+28     	; 0x299c <vfprintf+0x154>
    2980:	83 35       	cpi	r24, 0x53	; 83
    2982:	09 f0       	breq	.+2      	; 0x2986 <vfprintf+0x13e>
    2984:	55 c0       	rjmp	.+170    	; 0x2a30 <vfprintf+0x1e8>
    2986:	20 c0       	rjmp	.+64     	; 0x29c8 <vfprintf+0x180>
    2988:	f8 01       	movw	r30, r16
    298a:	80 81       	ld	r24, Z
    298c:	89 83       	std	Y+1, r24	; 0x01
    298e:	0e 5f       	subi	r16, 0xFE	; 254
    2990:	1f 4f       	sbci	r17, 0xFF	; 255
    2992:	88 24       	eor	r8, r8
    2994:	83 94       	inc	r8
    2996:	91 2c       	mov	r9, r1
    2998:	53 01       	movw	r10, r6
    299a:	12 c0       	rjmp	.+36     	; 0x29c0 <vfprintf+0x178>
    299c:	28 01       	movw	r4, r16
    299e:	f2 e0       	ldi	r31, 0x02	; 2
    29a0:	4f 0e       	add	r4, r31
    29a2:	51 1c       	adc	r5, r1
    29a4:	f8 01       	movw	r30, r16
    29a6:	a0 80       	ld	r10, Z
    29a8:	b1 80       	ldd	r11, Z+1	; 0x01
    29aa:	36 fe       	sbrs	r3, 6
    29ac:	03 c0       	rjmp	.+6      	; 0x29b4 <vfprintf+0x16c>
    29ae:	69 2d       	mov	r22, r9
    29b0:	70 e0       	ldi	r23, 0x00	; 0
    29b2:	02 c0       	rjmp	.+4      	; 0x29b8 <vfprintf+0x170>
    29b4:	6f ef       	ldi	r22, 0xFF	; 255
    29b6:	7f ef       	ldi	r23, 0xFF	; 255
    29b8:	c5 01       	movw	r24, r10
    29ba:	4e d1       	rcall	.+668    	; 0x2c58 <strnlen>
    29bc:	4c 01       	movw	r8, r24
    29be:	82 01       	movw	r16, r4
    29c0:	f3 2d       	mov	r31, r3
    29c2:	ff 77       	andi	r31, 0x7F	; 127
    29c4:	3f 2e       	mov	r3, r31
    29c6:	15 c0       	rjmp	.+42     	; 0x29f2 <vfprintf+0x1aa>
    29c8:	28 01       	movw	r4, r16
    29ca:	22 e0       	ldi	r18, 0x02	; 2
    29cc:	42 0e       	add	r4, r18
    29ce:	51 1c       	adc	r5, r1
    29d0:	f8 01       	movw	r30, r16
    29d2:	a0 80       	ld	r10, Z
    29d4:	b1 80       	ldd	r11, Z+1	; 0x01
    29d6:	36 fe       	sbrs	r3, 6
    29d8:	03 c0       	rjmp	.+6      	; 0x29e0 <vfprintf+0x198>
    29da:	69 2d       	mov	r22, r9
    29dc:	70 e0       	ldi	r23, 0x00	; 0
    29de:	02 c0       	rjmp	.+4      	; 0x29e4 <vfprintf+0x19c>
    29e0:	6f ef       	ldi	r22, 0xFF	; 255
    29e2:	7f ef       	ldi	r23, 0xFF	; 255
    29e4:	c5 01       	movw	r24, r10
    29e6:	2d d1       	rcall	.+602    	; 0x2c42 <strnlen_P>
    29e8:	4c 01       	movw	r8, r24
    29ea:	f3 2d       	mov	r31, r3
    29ec:	f0 68       	ori	r31, 0x80	; 128
    29ee:	3f 2e       	mov	r3, r31
    29f0:	82 01       	movw	r16, r4
    29f2:	33 fc       	sbrc	r3, 3
    29f4:	19 c0       	rjmp	.+50     	; 0x2a28 <vfprintf+0x1e0>
    29f6:	82 2d       	mov	r24, r2
    29f8:	90 e0       	ldi	r25, 0x00	; 0
    29fa:	88 16       	cp	r8, r24
    29fc:	99 06       	cpc	r9, r25
    29fe:	a0 f4       	brcc	.+40     	; 0x2a28 <vfprintf+0x1e0>
    2a00:	b6 01       	movw	r22, r12
    2a02:	80 e2       	ldi	r24, 0x20	; 32
    2a04:	90 e0       	ldi	r25, 0x00	; 0
    2a06:	33 d1       	rcall	.+614    	; 0x2c6e <fputc>
    2a08:	2a 94       	dec	r2
    2a0a:	f5 cf       	rjmp	.-22     	; 0x29f6 <vfprintf+0x1ae>
    2a0c:	f5 01       	movw	r30, r10
    2a0e:	37 fc       	sbrc	r3, 7
    2a10:	85 91       	lpm	r24, Z+
    2a12:	37 fe       	sbrs	r3, 7
    2a14:	81 91       	ld	r24, Z+
    2a16:	5f 01       	movw	r10, r30
    2a18:	b6 01       	movw	r22, r12
    2a1a:	90 e0       	ldi	r25, 0x00	; 0
    2a1c:	28 d1       	rcall	.+592    	; 0x2c6e <fputc>
    2a1e:	21 10       	cpse	r2, r1
    2a20:	2a 94       	dec	r2
    2a22:	21 e0       	ldi	r18, 0x01	; 1
    2a24:	82 1a       	sub	r8, r18
    2a26:	91 08       	sbc	r9, r1
    2a28:	81 14       	cp	r8, r1
    2a2a:	91 04       	cpc	r9, r1
    2a2c:	79 f7       	brne	.-34     	; 0x2a0c <vfprintf+0x1c4>
    2a2e:	e1 c0       	rjmp	.+450    	; 0x2bf2 <vfprintf+0x3aa>
    2a30:	84 36       	cpi	r24, 0x64	; 100
    2a32:	11 f0       	breq	.+4      	; 0x2a38 <vfprintf+0x1f0>
    2a34:	89 36       	cpi	r24, 0x69	; 105
    2a36:	39 f5       	brne	.+78     	; 0x2a86 <vfprintf+0x23e>
    2a38:	f8 01       	movw	r30, r16
    2a3a:	37 fe       	sbrs	r3, 7
    2a3c:	07 c0       	rjmp	.+14     	; 0x2a4c <vfprintf+0x204>
    2a3e:	60 81       	ld	r22, Z
    2a40:	71 81       	ldd	r23, Z+1	; 0x01
    2a42:	82 81       	ldd	r24, Z+2	; 0x02
    2a44:	93 81       	ldd	r25, Z+3	; 0x03
    2a46:	0c 5f       	subi	r16, 0xFC	; 252
    2a48:	1f 4f       	sbci	r17, 0xFF	; 255
    2a4a:	08 c0       	rjmp	.+16     	; 0x2a5c <vfprintf+0x214>
    2a4c:	60 81       	ld	r22, Z
    2a4e:	71 81       	ldd	r23, Z+1	; 0x01
    2a50:	07 2e       	mov	r0, r23
    2a52:	00 0c       	add	r0, r0
    2a54:	88 0b       	sbc	r24, r24
    2a56:	99 0b       	sbc	r25, r25
    2a58:	0e 5f       	subi	r16, 0xFE	; 254
    2a5a:	1f 4f       	sbci	r17, 0xFF	; 255
    2a5c:	f3 2d       	mov	r31, r3
    2a5e:	ff 76       	andi	r31, 0x6F	; 111
    2a60:	3f 2e       	mov	r3, r31
    2a62:	97 ff       	sbrs	r25, 7
    2a64:	09 c0       	rjmp	.+18     	; 0x2a78 <vfprintf+0x230>
    2a66:	90 95       	com	r25
    2a68:	80 95       	com	r24
    2a6a:	70 95       	com	r23
    2a6c:	61 95       	neg	r22
    2a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a70:	8f 4f       	sbci	r24, 0xFF	; 255
    2a72:	9f 4f       	sbci	r25, 0xFF	; 255
    2a74:	f0 68       	ori	r31, 0x80	; 128
    2a76:	3f 2e       	mov	r3, r31
    2a78:	2a e0       	ldi	r18, 0x0A	; 10
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	a3 01       	movw	r20, r6
    2a7e:	33 d1       	rcall	.+614    	; 0x2ce6 <__ultoa_invert>
    2a80:	88 2e       	mov	r8, r24
    2a82:	86 18       	sub	r8, r6
    2a84:	44 c0       	rjmp	.+136    	; 0x2b0e <vfprintf+0x2c6>
    2a86:	85 37       	cpi	r24, 0x75	; 117
    2a88:	31 f4       	brne	.+12     	; 0x2a96 <vfprintf+0x24e>
    2a8a:	23 2d       	mov	r18, r3
    2a8c:	2f 7e       	andi	r18, 0xEF	; 239
    2a8e:	b2 2e       	mov	r11, r18
    2a90:	2a e0       	ldi	r18, 0x0A	; 10
    2a92:	30 e0       	ldi	r19, 0x00	; 0
    2a94:	25 c0       	rjmp	.+74     	; 0x2ae0 <vfprintf+0x298>
    2a96:	93 2d       	mov	r25, r3
    2a98:	99 7f       	andi	r25, 0xF9	; 249
    2a9a:	b9 2e       	mov	r11, r25
    2a9c:	8f 36       	cpi	r24, 0x6F	; 111
    2a9e:	c1 f0       	breq	.+48     	; 0x2ad0 <vfprintf+0x288>
    2aa0:	18 f4       	brcc	.+6      	; 0x2aa8 <vfprintf+0x260>
    2aa2:	88 35       	cpi	r24, 0x58	; 88
    2aa4:	79 f0       	breq	.+30     	; 0x2ac4 <vfprintf+0x27c>
    2aa6:	ae c0       	rjmp	.+348    	; 0x2c04 <vfprintf+0x3bc>
    2aa8:	80 37       	cpi	r24, 0x70	; 112
    2aaa:	19 f0       	breq	.+6      	; 0x2ab2 <vfprintf+0x26a>
    2aac:	88 37       	cpi	r24, 0x78	; 120
    2aae:	21 f0       	breq	.+8      	; 0x2ab8 <vfprintf+0x270>
    2ab0:	a9 c0       	rjmp	.+338    	; 0x2c04 <vfprintf+0x3bc>
    2ab2:	e9 2f       	mov	r30, r25
    2ab4:	e0 61       	ori	r30, 0x10	; 16
    2ab6:	be 2e       	mov	r11, r30
    2ab8:	b4 fe       	sbrs	r11, 4
    2aba:	0d c0       	rjmp	.+26     	; 0x2ad6 <vfprintf+0x28e>
    2abc:	fb 2d       	mov	r31, r11
    2abe:	f4 60       	ori	r31, 0x04	; 4
    2ac0:	bf 2e       	mov	r11, r31
    2ac2:	09 c0       	rjmp	.+18     	; 0x2ad6 <vfprintf+0x28e>
    2ac4:	34 fe       	sbrs	r3, 4
    2ac6:	0a c0       	rjmp	.+20     	; 0x2adc <vfprintf+0x294>
    2ac8:	29 2f       	mov	r18, r25
    2aca:	26 60       	ori	r18, 0x06	; 6
    2acc:	b2 2e       	mov	r11, r18
    2ace:	06 c0       	rjmp	.+12     	; 0x2adc <vfprintf+0x294>
    2ad0:	28 e0       	ldi	r18, 0x08	; 8
    2ad2:	30 e0       	ldi	r19, 0x00	; 0
    2ad4:	05 c0       	rjmp	.+10     	; 0x2ae0 <vfprintf+0x298>
    2ad6:	20 e1       	ldi	r18, 0x10	; 16
    2ad8:	30 e0       	ldi	r19, 0x00	; 0
    2ada:	02 c0       	rjmp	.+4      	; 0x2ae0 <vfprintf+0x298>
    2adc:	20 e1       	ldi	r18, 0x10	; 16
    2ade:	32 e0       	ldi	r19, 0x02	; 2
    2ae0:	f8 01       	movw	r30, r16
    2ae2:	b7 fe       	sbrs	r11, 7
    2ae4:	07 c0       	rjmp	.+14     	; 0x2af4 <vfprintf+0x2ac>
    2ae6:	60 81       	ld	r22, Z
    2ae8:	71 81       	ldd	r23, Z+1	; 0x01
    2aea:	82 81       	ldd	r24, Z+2	; 0x02
    2aec:	93 81       	ldd	r25, Z+3	; 0x03
    2aee:	0c 5f       	subi	r16, 0xFC	; 252
    2af0:	1f 4f       	sbci	r17, 0xFF	; 255
    2af2:	06 c0       	rjmp	.+12     	; 0x2b00 <vfprintf+0x2b8>
    2af4:	60 81       	ld	r22, Z
    2af6:	71 81       	ldd	r23, Z+1	; 0x01
    2af8:	80 e0       	ldi	r24, 0x00	; 0
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	0e 5f       	subi	r16, 0xFE	; 254
    2afe:	1f 4f       	sbci	r17, 0xFF	; 255
    2b00:	a3 01       	movw	r20, r6
    2b02:	f1 d0       	rcall	.+482    	; 0x2ce6 <__ultoa_invert>
    2b04:	88 2e       	mov	r8, r24
    2b06:	86 18       	sub	r8, r6
    2b08:	fb 2d       	mov	r31, r11
    2b0a:	ff 77       	andi	r31, 0x7F	; 127
    2b0c:	3f 2e       	mov	r3, r31
    2b0e:	36 fe       	sbrs	r3, 6
    2b10:	0d c0       	rjmp	.+26     	; 0x2b2c <vfprintf+0x2e4>
    2b12:	23 2d       	mov	r18, r3
    2b14:	2e 7f       	andi	r18, 0xFE	; 254
    2b16:	a2 2e       	mov	r10, r18
    2b18:	89 14       	cp	r8, r9
    2b1a:	58 f4       	brcc	.+22     	; 0x2b32 <vfprintf+0x2ea>
    2b1c:	34 fe       	sbrs	r3, 4
    2b1e:	0b c0       	rjmp	.+22     	; 0x2b36 <vfprintf+0x2ee>
    2b20:	32 fc       	sbrc	r3, 2
    2b22:	09 c0       	rjmp	.+18     	; 0x2b36 <vfprintf+0x2ee>
    2b24:	83 2d       	mov	r24, r3
    2b26:	8e 7e       	andi	r24, 0xEE	; 238
    2b28:	a8 2e       	mov	r10, r24
    2b2a:	05 c0       	rjmp	.+10     	; 0x2b36 <vfprintf+0x2ee>
    2b2c:	b8 2c       	mov	r11, r8
    2b2e:	a3 2c       	mov	r10, r3
    2b30:	03 c0       	rjmp	.+6      	; 0x2b38 <vfprintf+0x2f0>
    2b32:	b8 2c       	mov	r11, r8
    2b34:	01 c0       	rjmp	.+2      	; 0x2b38 <vfprintf+0x2f0>
    2b36:	b9 2c       	mov	r11, r9
    2b38:	a4 fe       	sbrs	r10, 4
    2b3a:	0f c0       	rjmp	.+30     	; 0x2b5a <vfprintf+0x312>
    2b3c:	fe 01       	movw	r30, r28
    2b3e:	e8 0d       	add	r30, r8
    2b40:	f1 1d       	adc	r31, r1
    2b42:	80 81       	ld	r24, Z
    2b44:	80 33       	cpi	r24, 0x30	; 48
    2b46:	21 f4       	brne	.+8      	; 0x2b50 <vfprintf+0x308>
    2b48:	9a 2d       	mov	r25, r10
    2b4a:	99 7e       	andi	r25, 0xE9	; 233
    2b4c:	a9 2e       	mov	r10, r25
    2b4e:	09 c0       	rjmp	.+18     	; 0x2b62 <vfprintf+0x31a>
    2b50:	a2 fe       	sbrs	r10, 2
    2b52:	06 c0       	rjmp	.+12     	; 0x2b60 <vfprintf+0x318>
    2b54:	b3 94       	inc	r11
    2b56:	b3 94       	inc	r11
    2b58:	04 c0       	rjmp	.+8      	; 0x2b62 <vfprintf+0x31a>
    2b5a:	8a 2d       	mov	r24, r10
    2b5c:	86 78       	andi	r24, 0x86	; 134
    2b5e:	09 f0       	breq	.+2      	; 0x2b62 <vfprintf+0x31a>
    2b60:	b3 94       	inc	r11
    2b62:	a3 fc       	sbrc	r10, 3
    2b64:	10 c0       	rjmp	.+32     	; 0x2b86 <vfprintf+0x33e>
    2b66:	a0 fe       	sbrs	r10, 0
    2b68:	06 c0       	rjmp	.+12     	; 0x2b76 <vfprintf+0x32e>
    2b6a:	b2 14       	cp	r11, r2
    2b6c:	80 f4       	brcc	.+32     	; 0x2b8e <vfprintf+0x346>
    2b6e:	28 0c       	add	r2, r8
    2b70:	92 2c       	mov	r9, r2
    2b72:	9b 18       	sub	r9, r11
    2b74:	0d c0       	rjmp	.+26     	; 0x2b90 <vfprintf+0x348>
    2b76:	b2 14       	cp	r11, r2
    2b78:	58 f4       	brcc	.+22     	; 0x2b90 <vfprintf+0x348>
    2b7a:	b6 01       	movw	r22, r12
    2b7c:	80 e2       	ldi	r24, 0x20	; 32
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	76 d0       	rcall	.+236    	; 0x2c6e <fputc>
    2b82:	b3 94       	inc	r11
    2b84:	f8 cf       	rjmp	.-16     	; 0x2b76 <vfprintf+0x32e>
    2b86:	b2 14       	cp	r11, r2
    2b88:	18 f4       	brcc	.+6      	; 0x2b90 <vfprintf+0x348>
    2b8a:	2b 18       	sub	r2, r11
    2b8c:	02 c0       	rjmp	.+4      	; 0x2b92 <vfprintf+0x34a>
    2b8e:	98 2c       	mov	r9, r8
    2b90:	21 2c       	mov	r2, r1
    2b92:	a4 fe       	sbrs	r10, 4
    2b94:	0f c0       	rjmp	.+30     	; 0x2bb4 <vfprintf+0x36c>
    2b96:	b6 01       	movw	r22, r12
    2b98:	80 e3       	ldi	r24, 0x30	; 48
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	68 d0       	rcall	.+208    	; 0x2c6e <fputc>
    2b9e:	a2 fe       	sbrs	r10, 2
    2ba0:	16 c0       	rjmp	.+44     	; 0x2bce <vfprintf+0x386>
    2ba2:	a1 fc       	sbrc	r10, 1
    2ba4:	03 c0       	rjmp	.+6      	; 0x2bac <vfprintf+0x364>
    2ba6:	88 e7       	ldi	r24, 0x78	; 120
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	02 c0       	rjmp	.+4      	; 0x2bb0 <vfprintf+0x368>
    2bac:	88 e5       	ldi	r24, 0x58	; 88
    2bae:	90 e0       	ldi	r25, 0x00	; 0
    2bb0:	b6 01       	movw	r22, r12
    2bb2:	0c c0       	rjmp	.+24     	; 0x2bcc <vfprintf+0x384>
    2bb4:	8a 2d       	mov	r24, r10
    2bb6:	86 78       	andi	r24, 0x86	; 134
    2bb8:	51 f0       	breq	.+20     	; 0x2bce <vfprintf+0x386>
    2bba:	a1 fe       	sbrs	r10, 1
    2bbc:	02 c0       	rjmp	.+4      	; 0x2bc2 <vfprintf+0x37a>
    2bbe:	8b e2       	ldi	r24, 0x2B	; 43
    2bc0:	01 c0       	rjmp	.+2      	; 0x2bc4 <vfprintf+0x37c>
    2bc2:	80 e2       	ldi	r24, 0x20	; 32
    2bc4:	a7 fc       	sbrc	r10, 7
    2bc6:	8d e2       	ldi	r24, 0x2D	; 45
    2bc8:	b6 01       	movw	r22, r12
    2bca:	90 e0       	ldi	r25, 0x00	; 0
    2bcc:	50 d0       	rcall	.+160    	; 0x2c6e <fputc>
    2bce:	89 14       	cp	r8, r9
    2bd0:	30 f4       	brcc	.+12     	; 0x2bde <vfprintf+0x396>
    2bd2:	b6 01       	movw	r22, r12
    2bd4:	80 e3       	ldi	r24, 0x30	; 48
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	4a d0       	rcall	.+148    	; 0x2c6e <fputc>
    2bda:	9a 94       	dec	r9
    2bdc:	f8 cf       	rjmp	.-16     	; 0x2bce <vfprintf+0x386>
    2bde:	8a 94       	dec	r8
    2be0:	f3 01       	movw	r30, r6
    2be2:	e8 0d       	add	r30, r8
    2be4:	f1 1d       	adc	r31, r1
    2be6:	80 81       	ld	r24, Z
    2be8:	b6 01       	movw	r22, r12
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	40 d0       	rcall	.+128    	; 0x2c6e <fputc>
    2bee:	81 10       	cpse	r8, r1
    2bf0:	f6 cf       	rjmp	.-20     	; 0x2bde <vfprintf+0x396>
    2bf2:	22 20       	and	r2, r2
    2bf4:	09 f4       	brne	.+2      	; 0x2bf8 <vfprintf+0x3b0>
    2bf6:	4e ce       	rjmp	.-868    	; 0x2894 <vfprintf+0x4c>
    2bf8:	b6 01       	movw	r22, r12
    2bfa:	80 e2       	ldi	r24, 0x20	; 32
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
    2bfe:	37 d0       	rcall	.+110    	; 0x2c6e <fputc>
    2c00:	2a 94       	dec	r2
    2c02:	f7 cf       	rjmp	.-18     	; 0x2bf2 <vfprintf+0x3aa>
    2c04:	f6 01       	movw	r30, r12
    2c06:	86 81       	ldd	r24, Z+6	; 0x06
    2c08:	97 81       	ldd	r25, Z+7	; 0x07
    2c0a:	02 c0       	rjmp	.+4      	; 0x2c10 <vfprintf+0x3c8>
    2c0c:	8f ef       	ldi	r24, 0xFF	; 255
    2c0e:	9f ef       	ldi	r25, 0xFF	; 255
    2c10:	2b 96       	adiw	r28, 0x0b	; 11
    2c12:	0f b6       	in	r0, 0x3f	; 63
    2c14:	f8 94       	cli
    2c16:	de bf       	out	0x3e, r29	; 62
    2c18:	0f be       	out	0x3f, r0	; 63
    2c1a:	cd bf       	out	0x3d, r28	; 61
    2c1c:	df 91       	pop	r29
    2c1e:	cf 91       	pop	r28
    2c20:	1f 91       	pop	r17
    2c22:	0f 91       	pop	r16
    2c24:	ff 90       	pop	r15
    2c26:	ef 90       	pop	r14
    2c28:	df 90       	pop	r13
    2c2a:	cf 90       	pop	r12
    2c2c:	bf 90       	pop	r11
    2c2e:	af 90       	pop	r10
    2c30:	9f 90       	pop	r9
    2c32:	8f 90       	pop	r8
    2c34:	7f 90       	pop	r7
    2c36:	6f 90       	pop	r6
    2c38:	5f 90       	pop	r5
    2c3a:	4f 90       	pop	r4
    2c3c:	3f 90       	pop	r3
    2c3e:	2f 90       	pop	r2
    2c40:	08 95       	ret

00002c42 <strnlen_P>:
    2c42:	fc 01       	movw	r30, r24
    2c44:	05 90       	lpm	r0, Z+
    2c46:	61 50       	subi	r22, 0x01	; 1
    2c48:	70 40       	sbci	r23, 0x00	; 0
    2c4a:	01 10       	cpse	r0, r1
    2c4c:	d8 f7       	brcc	.-10     	; 0x2c44 <strnlen_P+0x2>
    2c4e:	80 95       	com	r24
    2c50:	90 95       	com	r25
    2c52:	8e 0f       	add	r24, r30
    2c54:	9f 1f       	adc	r25, r31
    2c56:	08 95       	ret

00002c58 <strnlen>:
    2c58:	fc 01       	movw	r30, r24
    2c5a:	61 50       	subi	r22, 0x01	; 1
    2c5c:	70 40       	sbci	r23, 0x00	; 0
    2c5e:	01 90       	ld	r0, Z+
    2c60:	01 10       	cpse	r0, r1
    2c62:	d8 f7       	brcc	.-10     	; 0x2c5a <strnlen+0x2>
    2c64:	80 95       	com	r24
    2c66:	90 95       	com	r25
    2c68:	8e 0f       	add	r24, r30
    2c6a:	9f 1f       	adc	r25, r31
    2c6c:	08 95       	ret

00002c6e <fputc>:
    2c6e:	0f 93       	push	r16
    2c70:	1f 93       	push	r17
    2c72:	cf 93       	push	r28
    2c74:	df 93       	push	r29
    2c76:	fb 01       	movw	r30, r22
    2c78:	23 81       	ldd	r18, Z+3	; 0x03
    2c7a:	21 fd       	sbrc	r18, 1
    2c7c:	03 c0       	rjmp	.+6      	; 0x2c84 <fputc+0x16>
    2c7e:	8f ef       	ldi	r24, 0xFF	; 255
    2c80:	9f ef       	ldi	r25, 0xFF	; 255
    2c82:	2c c0       	rjmp	.+88     	; 0x2cdc <fputc+0x6e>
    2c84:	22 ff       	sbrs	r18, 2
    2c86:	16 c0       	rjmp	.+44     	; 0x2cb4 <fputc+0x46>
    2c88:	46 81       	ldd	r20, Z+6	; 0x06
    2c8a:	57 81       	ldd	r21, Z+7	; 0x07
    2c8c:	24 81       	ldd	r18, Z+4	; 0x04
    2c8e:	35 81       	ldd	r19, Z+5	; 0x05
    2c90:	42 17       	cp	r20, r18
    2c92:	53 07       	cpc	r21, r19
    2c94:	44 f4       	brge	.+16     	; 0x2ca6 <fputc+0x38>
    2c96:	a0 81       	ld	r26, Z
    2c98:	b1 81       	ldd	r27, Z+1	; 0x01
    2c9a:	9d 01       	movw	r18, r26
    2c9c:	2f 5f       	subi	r18, 0xFF	; 255
    2c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    2ca0:	31 83       	std	Z+1, r19	; 0x01
    2ca2:	20 83       	st	Z, r18
    2ca4:	8c 93       	st	X, r24
    2ca6:	26 81       	ldd	r18, Z+6	; 0x06
    2ca8:	37 81       	ldd	r19, Z+7	; 0x07
    2caa:	2f 5f       	subi	r18, 0xFF	; 255
    2cac:	3f 4f       	sbci	r19, 0xFF	; 255
    2cae:	37 83       	std	Z+7, r19	; 0x07
    2cb0:	26 83       	std	Z+6, r18	; 0x06
    2cb2:	14 c0       	rjmp	.+40     	; 0x2cdc <fputc+0x6e>
    2cb4:	8b 01       	movw	r16, r22
    2cb6:	ec 01       	movw	r28, r24
    2cb8:	fb 01       	movw	r30, r22
    2cba:	00 84       	ldd	r0, Z+8	; 0x08
    2cbc:	f1 85       	ldd	r31, Z+9	; 0x09
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	09 95       	icall
    2cc2:	89 2b       	or	r24, r25
    2cc4:	e1 f6       	brne	.-72     	; 0x2c7e <fputc+0x10>
    2cc6:	d8 01       	movw	r26, r16
    2cc8:	16 96       	adiw	r26, 0x06	; 6
    2cca:	8d 91       	ld	r24, X+
    2ccc:	9c 91       	ld	r25, X
    2cce:	17 97       	sbiw	r26, 0x07	; 7
    2cd0:	01 96       	adiw	r24, 0x01	; 1
    2cd2:	17 96       	adiw	r26, 0x07	; 7
    2cd4:	9c 93       	st	X, r25
    2cd6:	8e 93       	st	-X, r24
    2cd8:	16 97       	sbiw	r26, 0x06	; 6
    2cda:	ce 01       	movw	r24, r28
    2cdc:	df 91       	pop	r29
    2cde:	cf 91       	pop	r28
    2ce0:	1f 91       	pop	r17
    2ce2:	0f 91       	pop	r16
    2ce4:	08 95       	ret

00002ce6 <__ultoa_invert>:
    2ce6:	fa 01       	movw	r30, r20
    2ce8:	aa 27       	eor	r26, r26
    2cea:	28 30       	cpi	r18, 0x08	; 8
    2cec:	51 f1       	breq	.+84     	; 0x2d42 <__ultoa_invert+0x5c>
    2cee:	20 31       	cpi	r18, 0x10	; 16
    2cf0:	81 f1       	breq	.+96     	; 0x2d52 <__ultoa_invert+0x6c>
    2cf2:	e8 94       	clt
    2cf4:	6f 93       	push	r22
    2cf6:	6e 7f       	andi	r22, 0xFE	; 254
    2cf8:	6e 5f       	subi	r22, 0xFE	; 254
    2cfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2cfc:	8f 4f       	sbci	r24, 0xFF	; 255
    2cfe:	9f 4f       	sbci	r25, 0xFF	; 255
    2d00:	af 4f       	sbci	r26, 0xFF	; 255
    2d02:	b1 e0       	ldi	r27, 0x01	; 1
    2d04:	3e d0       	rcall	.+124    	; 0x2d82 <__ultoa_invert+0x9c>
    2d06:	b4 e0       	ldi	r27, 0x04	; 4
    2d08:	3c d0       	rcall	.+120    	; 0x2d82 <__ultoa_invert+0x9c>
    2d0a:	67 0f       	add	r22, r23
    2d0c:	78 1f       	adc	r23, r24
    2d0e:	89 1f       	adc	r24, r25
    2d10:	9a 1f       	adc	r25, r26
    2d12:	a1 1d       	adc	r26, r1
    2d14:	68 0f       	add	r22, r24
    2d16:	79 1f       	adc	r23, r25
    2d18:	8a 1f       	adc	r24, r26
    2d1a:	91 1d       	adc	r25, r1
    2d1c:	a1 1d       	adc	r26, r1
    2d1e:	6a 0f       	add	r22, r26
    2d20:	71 1d       	adc	r23, r1
    2d22:	81 1d       	adc	r24, r1
    2d24:	91 1d       	adc	r25, r1
    2d26:	a1 1d       	adc	r26, r1
    2d28:	20 d0       	rcall	.+64     	; 0x2d6a <__ultoa_invert+0x84>
    2d2a:	09 f4       	brne	.+2      	; 0x2d2e <__ultoa_invert+0x48>
    2d2c:	68 94       	set
    2d2e:	3f 91       	pop	r19
    2d30:	2a e0       	ldi	r18, 0x0A	; 10
    2d32:	26 9f       	mul	r18, r22
    2d34:	11 24       	eor	r1, r1
    2d36:	30 19       	sub	r19, r0
    2d38:	30 5d       	subi	r19, 0xD0	; 208
    2d3a:	31 93       	st	Z+, r19
    2d3c:	de f6       	brtc	.-74     	; 0x2cf4 <__ultoa_invert+0xe>
    2d3e:	cf 01       	movw	r24, r30
    2d40:	08 95       	ret
    2d42:	46 2f       	mov	r20, r22
    2d44:	47 70       	andi	r20, 0x07	; 7
    2d46:	40 5d       	subi	r20, 0xD0	; 208
    2d48:	41 93       	st	Z+, r20
    2d4a:	b3 e0       	ldi	r27, 0x03	; 3
    2d4c:	0f d0       	rcall	.+30     	; 0x2d6c <__ultoa_invert+0x86>
    2d4e:	c9 f7       	brne	.-14     	; 0x2d42 <__ultoa_invert+0x5c>
    2d50:	f6 cf       	rjmp	.-20     	; 0x2d3e <__ultoa_invert+0x58>
    2d52:	46 2f       	mov	r20, r22
    2d54:	4f 70       	andi	r20, 0x0F	; 15
    2d56:	40 5d       	subi	r20, 0xD0	; 208
    2d58:	4a 33       	cpi	r20, 0x3A	; 58
    2d5a:	18 f0       	brcs	.+6      	; 0x2d62 <__ultoa_invert+0x7c>
    2d5c:	49 5d       	subi	r20, 0xD9	; 217
    2d5e:	31 fd       	sbrc	r19, 1
    2d60:	40 52       	subi	r20, 0x20	; 32
    2d62:	41 93       	st	Z+, r20
    2d64:	02 d0       	rcall	.+4      	; 0x2d6a <__ultoa_invert+0x84>
    2d66:	a9 f7       	brne	.-22     	; 0x2d52 <__ultoa_invert+0x6c>
    2d68:	ea cf       	rjmp	.-44     	; 0x2d3e <__ultoa_invert+0x58>
    2d6a:	b4 e0       	ldi	r27, 0x04	; 4
    2d6c:	a6 95       	lsr	r26
    2d6e:	97 95       	ror	r25
    2d70:	87 95       	ror	r24
    2d72:	77 95       	ror	r23
    2d74:	67 95       	ror	r22
    2d76:	ba 95       	dec	r27
    2d78:	c9 f7       	brne	.-14     	; 0x2d6c <__ultoa_invert+0x86>
    2d7a:	00 97       	sbiw	r24, 0x00	; 0
    2d7c:	61 05       	cpc	r22, r1
    2d7e:	71 05       	cpc	r23, r1
    2d80:	08 95       	ret
    2d82:	9b 01       	movw	r18, r22
    2d84:	ac 01       	movw	r20, r24
    2d86:	0a 2e       	mov	r0, r26
    2d88:	06 94       	lsr	r0
    2d8a:	57 95       	ror	r21
    2d8c:	47 95       	ror	r20
    2d8e:	37 95       	ror	r19
    2d90:	27 95       	ror	r18
    2d92:	ba 95       	dec	r27
    2d94:	c9 f7       	brne	.-14     	; 0x2d88 <__ultoa_invert+0xa2>
    2d96:	62 0f       	add	r22, r18
    2d98:	73 1f       	adc	r23, r19
    2d9a:	84 1f       	adc	r24, r20
    2d9c:	95 1f       	adc	r25, r21
    2d9e:	a0 1d       	adc	r26, r0
    2da0:	08 95       	ret

00002da2 <eeprom_read_word>:
    2da2:	a8 e1       	ldi	r26, 0x18	; 24
    2da4:	b0 e0       	ldi	r27, 0x00	; 0
    2da6:	42 e0       	ldi	r20, 0x02	; 2
    2da8:	50 e0       	ldi	r21, 0x00	; 0
    2daa:	05 c0       	rjmp	.+10     	; 0x2db6 <eeprom_read_blraw>

00002dac <eeprom_write_word>:
    2dac:	12 d0       	rcall	.+36     	; 0x2dd2 <eeprom_write_byte>
    2dae:	27 2f       	mov	r18, r23
    2db0:	11 c0       	rjmp	.+34     	; 0x2dd4 <eeprom_write_r18>

00002db2 <eeprom_read_block>:
    2db2:	dc 01       	movw	r26, r24
    2db4:	cb 01       	movw	r24, r22

00002db6 <eeprom_read_blraw>:
    2db6:	fc 01       	movw	r30, r24
    2db8:	f9 99       	sbic	0x1f, 1	; 31
    2dba:	fe cf       	rjmp	.-4      	; 0x2db8 <eeprom_read_blraw+0x2>
    2dbc:	06 c0       	rjmp	.+12     	; 0x2dca <eeprom_read_blraw+0x14>
    2dbe:	f2 bd       	out	0x22, r31	; 34
    2dc0:	e1 bd       	out	0x21, r30	; 33
    2dc2:	f8 9a       	sbi	0x1f, 0	; 31
    2dc4:	31 96       	adiw	r30, 0x01	; 1
    2dc6:	00 b4       	in	r0, 0x20	; 32
    2dc8:	0d 92       	st	X+, r0
    2dca:	41 50       	subi	r20, 0x01	; 1
    2dcc:	50 40       	sbci	r21, 0x00	; 0
    2dce:	b8 f7       	brcc	.-18     	; 0x2dbe <eeprom_read_blraw+0x8>
    2dd0:	08 95       	ret

00002dd2 <eeprom_write_byte>:
    2dd2:	26 2f       	mov	r18, r22

00002dd4 <eeprom_write_r18>:
    2dd4:	f9 99       	sbic	0x1f, 1	; 31
    2dd6:	fe cf       	rjmp	.-4      	; 0x2dd4 <eeprom_write_r18>
    2dd8:	92 bd       	out	0x22, r25	; 34
    2dda:	81 bd       	out	0x21, r24	; 33
    2ddc:	20 bd       	out	0x20, r18	; 32
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	fa 9a       	sbi	0x1f, 2	; 31
    2de4:	f9 9a       	sbi	0x1f, 1	; 31
    2de6:	0f be       	out	0x3f, r0	; 63
    2de8:	01 96       	adiw	r24, 0x01	; 1
    2dea:	08 95       	ret

00002dec <_exit>:
    2dec:	f8 94       	cli

00002dee <__stop_program>:
    2dee:	ff cf       	rjmp	.-2      	; 0x2dee <__stop_program>
