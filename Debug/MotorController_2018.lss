
MotorController_2018.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00002dd8  00002e6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dd8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000271  008001e0  008001e0  00002f4c  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00002f4c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fd8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00003018  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000716f  00000000  00000000  000035c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001dec  00000000  00000000  0000a737  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003374  00000000  00000000  0000c523  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000109c  00000000  00000000  0000f898  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a07  00000000  00000000  00010934  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000046d5  00000000  00000000  0001233b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  00016a10  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	51 c0       	rjmp	.+162    	; 0xa4 <__ctors_end>
       2:	00 00       	nop
       4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
       6:	00 00       	nop
       8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
       a:	00 00       	nop
       c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
       e:	00 00       	nop
      10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
      12:	00 00       	nop
      14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
      16:	00 00       	nop
      18:	0c 94 53 0d 	jmp	0x1aa6	; 0x1aa6 <__vector_6>
      1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
      22:	00 00       	nop
      24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
      26:	00 00       	nop
      28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 c2 0c 	jmp	0x1984	; 0x1984 <__vector_12>
      34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
      36:	00 00       	nop
      38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 03 0c 	jmp	0x1806	; 0x1806 <__vector_16>
      44:	0c 94 42 11 	jmp	0x2284	; 0x2284 <__vector_17>
      48:	0c 94 f3 0e 	jmp	0x1de6	; 0x1de6 <__vector_18>
      4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 ef 0a 	jmp	0x15de	; 0x15de <__vector_21>
      58:	0c 94 d1 0a 	jmp	0x15a2	; 0x15a2 <__vector_22>
      5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
      62:	00 00       	nop
      64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
      66:	00 00       	nop
      68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
      72:	00 00       	nop
      74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
      76:	00 00       	nop
      78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 28 0b 	jmp	0x1650	; 0x1650 <__vector_32>
      84:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <__vector_33>
      88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
      92:	00 00       	nop
      94:	c5 0e       	add	r12, r21
      96:	ca 0e       	add	r12, r26
      98:	d0 0e       	add	r13, r16
      9a:	d6 0e       	add	r13, r22
      9c:	dc 0e       	add	r13, r28
      9e:	e1 0e       	add	r14, r17
      a0:	e7 0e       	add	r14, r23
      a2:	ed 0e       	add	r14, r29

000000a4 <__ctors_end>:
      a4:	11 24       	eor	r1, r1
      a6:	1f be       	out	0x3f, r1	; 63
      a8:	cf ef       	ldi	r28, 0xFF	; 255
      aa:	d0 e1       	ldi	r29, 0x10	; 16
      ac:	de bf       	out	0x3e, r29	; 62
      ae:	cd bf       	out	0x3d, r28	; 61

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e8 ed       	ldi	r30, 0xD8	; 216
      b8:	fd e2       	ldi	r31, 0x2D	; 45
      ba:	00 e0       	ldi	r16, 0x00	; 0
      bc:	0b bf       	out	0x3b, r16	; 59
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x14>
      c0:	07 90       	elpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	a0 3e       	cpi	r26, 0xE0	; 224
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0x10>

000000ca <__do_clear_bss>:
      ca:	24 e0       	ldi	r18, 0x04	; 4
      cc:	a0 ee       	ldi	r26, 0xE0	; 224
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a1 35       	cpi	r26, 0x51	; 81
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <main>
      de:	0c 94 ea 16 	jmp	0x2dd4	; 0x2dd4 <_exit>

000000e2 <__bad_interrupt>:
      e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <actuator_init>:
		return 1;	
	}else
	{
		return 0;
	}	
} 
      e4:	cf 93       	push	r28
      e6:	df 93       	push	r29
      e8:	ec 01       	movw	r28, r24
      ea:	8a e2       	ldi	r24, 0x2A	; 42
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <eeprom_read_word>
      f2:	9d ab       	std	Y+53, r25	; 0x35
      f4:	8c ab       	std	Y+52, r24	; 0x34
      f6:	8e e2       	ldi	r24, 0x2E	; 46
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <eeprom_read_word>
      fe:	9f ab       	std	Y+55, r25	; 0x37
     100:	8e ab       	std	Y+54, r24	; 0x36
     102:	8c e2       	ldi	r24, 0x2C	; 44
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <eeprom_read_word>
     10a:	99 af       	std	Y+57, r25	; 0x39
     10c:	88 af       	std	Y+56, r24	; 0x38
     10e:	8a ad       	ldd	r24, Y+58	; 0x3a
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	e0 ee       	ldi	r30, 0xE0	; 224
     114:	f1 e0       	ldi	r31, 0x01	; 1
     116:	91 83       	std	Z+1, r25	; 0x01
     118:	80 83       	st	Z, r24
     11a:	8c ad       	ldd	r24, Y+60	; 0x3c
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	93 83       	std	Z+3, r25	; 0x03
     120:	82 83       	std	Z+2, r24	; 0x02
     122:	8f a5       	ldd	r24, Y+47	; 0x2f
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	93 87       	std	Z+11, r25	; 0x0b
     128:	82 87       	std	Z+10, r24	; 0x0a
     12a:	df 91       	pop	r29
     12c:	cf 91       	pop	r28
     12e:	08 95       	ret

00000130 <actuator_update>:
     130:	0f 93       	push	r16
     132:	1f 93       	push	r17
     134:	cf 93       	push	r28
     136:	df 93       	push	r29
     138:	ec 01       	movw	r28, r24
     13a:	00 ee       	ldi	r16, 0xE0	; 224
     13c:	11 e0       	ldi	r17, 0x01	; 1
     13e:	f8 01       	movw	r30, r16
     140:	80 81       	ld	r24, Z
     142:	91 81       	ldd	r25, Z+1	; 0x01
     144:	8a af       	std	Y+58, r24	; 0x3a
     146:	82 81       	ldd	r24, Z+2	; 0x02
     148:	93 81       	ldd	r25, Z+3	; 0x03
     14a:	8c af       	std	Y+60, r24	; 0x3c
     14c:	84 81       	ldd	r24, Z+4	; 0x04
     14e:	95 81       	ldd	r25, Z+5	; 0x05
     150:	9e a3       	std	Y+38, r25	; 0x26
     152:	8d a3       	std	Y+37, r24	; 0x25
     154:	66 81       	ldd	r22, Z+6	; 0x06
     156:	77 81       	ldd	r23, Z+7	; 0x07
     158:	80 85       	ldd	r24, Z+8	; 0x08
     15a:	91 85       	ldd	r25, Z+9	; 0x09
     15c:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     160:	79 ab       	std	Y+49, r23	; 0x31
     162:	68 ab       	std	Y+48, r22	; 0x30
     164:	f8 01       	movw	r30, r16
     166:	82 85       	ldd	r24, Z+10	; 0x0a
     168:	93 85       	ldd	r25, Z+11	; 0x0b
     16a:	8f a7       	std	Y+47, r24	; 0x2f
     16c:	84 85       	ldd	r24, Z+12	; 0x0c
     16e:	95 85       	ldd	r25, Z+13	; 0x0d
     170:	9d ab       	std	Y+53, r25	; 0x35
     172:	8c ab       	std	Y+52, r24	; 0x34
     174:	86 85       	ldd	r24, Z+14	; 0x0e
     176:	97 85       	ldd	r25, Z+15	; 0x0f
     178:	9f ab       	std	Y+55, r25	; 0x37
     17a:	8e ab       	std	Y+54, r24	; 0x36
     17c:	80 89       	ldd	r24, Z+16	; 0x10
     17e:	91 89       	ldd	r25, Z+17	; 0x11
     180:	99 af       	std	Y+57, r25	; 0x39
     182:	88 af       	std	Y+56, r24	; 0x38
     184:	df 91       	pop	r29
     186:	cf 91       	pop	r28
     188:	1f 91       	pop	r17
     18a:	0f 91       	pop	r16
     18c:	08 95       	ret

0000018e <actuator_save_position>:
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	ea 01       	movw	r28, r20
     194:	81 30       	cpi	r24, 0x01	; 1
     196:	81 f0       	breq	.+32     	; 0x1b8 <actuator_save_position+0x2a>
     198:	18 f0       	brcs	.+6      	; 0x1a0 <actuator_save_position+0x12>
     19a:	82 30       	cpi	r24, 0x02	; 2
     19c:	d9 f0       	breq	.+54     	; 0x1d4 <actuator_save_position+0x46>
     19e:	27 c0       	rjmp	.+78     	; 0x1ee <actuator_save_position+0x60>
     1a0:	ba 01       	movw	r22, r20
     1a2:	8a e2       	ldi	r24, 0x2A	; 42
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <eeprom_write_word>
     1aa:	e0 ee       	ldi	r30, 0xE0	; 224
     1ac:	f1 e0       	ldi	r31, 0x01	; 1
     1ae:	d5 87       	std	Z+13, r29	; 0x0d
     1b0:	c4 87       	std	Z+12, r28	; 0x0c
     1b2:	11 82       	std	Z+1, r1	; 0x01
     1b4:	10 82       	st	Z, r1
     1b6:	1b c0       	rjmp	.+54     	; 0x1ee <actuator_save_position+0x60>
     1b8:	ba 01       	movw	r22, r20
     1ba:	8e e2       	ldi	r24, 0x2E	; 46
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <eeprom_write_word>
     1c2:	e0 ee       	ldi	r30, 0xE0	; 224
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	d7 87       	std	Z+15, r29	; 0x0f
     1c8:	c6 87       	std	Z+14, r28	; 0x0e
     1ca:	81 e0       	ldi	r24, 0x01	; 1
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	91 83       	std	Z+1, r25	; 0x01
     1d0:	80 83       	st	Z, r24
     1d2:	0d c0       	rjmp	.+26     	; 0x1ee <actuator_save_position+0x60>
     1d4:	ba 01       	movw	r22, r20
     1d6:	8c e2       	ldi	r24, 0x2C	; 44
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <eeprom_write_word>
     1de:	e0 ee       	ldi	r30, 0xE0	; 224
     1e0:	f1 e0       	ldi	r31, 0x01	; 1
     1e2:	d1 8b       	std	Z+17, r29	; 0x11
     1e4:	c0 8b       	std	Z+16, r28	; 0x10
     1e6:	82 e0       	ldi	r24, 0x02	; 2
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	91 83       	std	Z+1, r25	; 0x01
     1ec:	80 83       	st	Z, r24
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <actuator_pwm>:
     1f4:	89 2b       	or	r24, r25
     1f6:	29 f0       	breq	.+10     	; 0x202 <actuator_pwm+0xe>
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     1fe:	75 9a       	sbi	0x0e, 5	; 14
     200:	08 95       	ret
     202:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <__TEXT_REGION_LENGTH__+0x7e0092>
     206:	75 98       	cbi	0x0e, 5	; 14
     208:	08 95       	ret

0000020a <actuator_set_position>:


void actuator_set_position(volatile ActuatorModuleValues_t *actuator_values, ClutchState_t gear_required, float uart_debug, int16_t actuator_duty_cycle, uint16_t target_position, float f32_actuator_feedback)
{
     20a:	4f 92       	push	r4
     20c:	5f 92       	push	r5
     20e:	6f 92       	push	r6
     210:	7f 92       	push	r7
     212:	9f 92       	push	r9
     214:	af 92       	push	r10
     216:	bf 92       	push	r11
     218:	cf 92       	push	r12
     21a:	df 92       	push	r13
     21c:	ef 92       	push	r14
     21e:	ff 92       	push	r15
     220:	0f 93       	push	r16
     222:	1f 93       	push	r17
     224:	cf 93       	push	r28
     226:	df 93       	push	r29
     228:	ec 01       	movw	r28, r24
     22a:	96 2e       	mov	r9, r22
     22c:	c6 01       	movw	r24, r12
     22e:	b5 01       	movw	r22, r10
			2) Position_ERROR
			3) actuator_duty_cycle
			4) gear_status
*/
	float kp = 0.7; //ATTENTION: Change kp to produce a bigger duty cycle for a given error value 
	int16_t position_error = ((int16_t)target_position - (int16_t)f32_actuator_feedback);
     230:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     234:	87 01       	movw	r16, r14
     236:	06 1b       	sub	r16, r22
     238:	17 0b       	sbc	r17, r23
	int16_t new_duty_cycle = 0;
	new_duty_cycle = kp*position_error + 66.5;
     23a:	b8 01       	movw	r22, r16
     23c:	01 2e       	mov	r0, r17
     23e:	00 0c       	add	r0, r0
     240:	88 0b       	sbc	r24, r24
     242:	99 0b       	sbc	r25, r25
     244:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     248:	2b 01       	movw	r4, r22
     24a:	3c 01       	movw	r6, r24
     24c:	23 e3       	ldi	r18, 0x33	; 51
     24e:	33 e3       	ldi	r19, 0x33	; 51
     250:	43 e3       	ldi	r20, 0x33	; 51
     252:	5f e3       	ldi	r21, 0x3F	; 63
     254:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     258:	20 e0       	ldi	r18, 0x00	; 0
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	45 e8       	ldi	r20, 0x85	; 133
     25e:	52 e4       	ldi	r21, 0x42	; 66
     260:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     264:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     268:	6b 01       	movw	r12, r22
     26a:	7c 01       	movw	r14, r24
	}
}

int actuator_position_tolerance(float position_error)
{
	if((position_error < POSITION_TOLERANCE) && (-position_error < POSITION_TOLERANCE))
     26c:	20 e0       	ldi	r18, 0x00	; 0
     26e:	30 e0       	ldi	r19, 0x00	; 0
     270:	40 e2       	ldi	r20, 0x20	; 32
     272:	51 e4       	ldi	r21, 0x41	; 65
     274:	c3 01       	movw	r24, r6
     276:	b2 01       	movw	r22, r4
     278:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <__cmpsf2>
     27c:	88 23       	and	r24, r24
     27e:	c4 f5       	brge	.+112    	; 0x2f0 <actuator_set_position+0xe6>
     280:	20 e0       	ldi	r18, 0x00	; 0
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	40 e2       	ldi	r20, 0x20	; 32
     286:	51 ec       	ldi	r21, 0xC1	; 193
     288:	c3 01       	movw	r24, r6
     28a:	b2 01       	movw	r22, r4
     28c:	0e 94 32 13 	call	0x2664	; 0x2664 <__gesf2>
     290:	18 16       	cp	r1, r24
     292:	74 f5       	brge	.+92     	; 0x2f0 <actuator_set_position+0xe6>
     294:	30 c0       	rjmp	.+96     	; 0x2f6 <actuator_set_position+0xec>
	{
		actuator_values->actuator_in_position = 0;
	}
	
	//Check actuator state
	switch (actuator_values->actuator_in_position) {
     296:	8c 81       	ldd	r24, Y+4	; 0x04
     298:	9d 81       	ldd	r25, Y+5	; 0x05
     29a:	00 97       	sbiw	r24, 0x00	; 0
     29c:	29 f0       	breq	.+10     	; 0x2a8 <actuator_set_position+0x9e>
     29e:	01 97       	sbiw	r24, 0x01	; 1
     2a0:	89 f4       	brne	.+34     	; 0x2c4 <actuator_set_position+0xba>
		case (1):
			actuator_values->actuator_direction = STATIONARY;
     2a2:	1b 82       	std	Y+3, r1	; 0x03
     2a4:	1a 82       	std	Y+2, r1	; 0x02
		break;
     2a6:	0e c0       	rjmp	.+28     	; 0x2c4 <actuator_set_position+0xba>
		
		case (0):
			if (position_error > 0) 
     2a8:	10 16       	cp	r1, r16
     2aa:	11 06       	cpc	r1, r17
     2ac:	2c f4       	brge	.+10     	; 0x2b8 <actuator_set_position+0xae>
			{
				//target is bigger than the actuators current position
				actuator_values->actuator_direction = EXTEND;
     2ae:	81 e0       	ldi	r24, 0x01	; 1
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	9b 83       	std	Y+3, r25	; 0x03
     2b4:	8a 83       	std	Y+2, r24	; 0x02
     2b6:	06 c0       	rjmp	.+12     	; 0x2c4 <actuator_set_position+0xba>
			} 
			else if (position_error < 0)
     2b8:	11 23       	and	r17, r17
     2ba:	24 f4       	brge	.+8      	; 0x2c4 <actuator_set_position+0xba>
			{
				actuator_values->actuator_direction = RETRACT;
     2bc:	82 e0       	ldi	r24, 0x02	; 2
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	9b 83       	std	Y+3, r25	; 0x03
     2c2:	8a 83       	std	Y+2, r24	; 0x02
     2c4:	c6 01       	movw	r24, r12
     2c6:	83 38       	cpi	r24, 0x83	; 131
     2c8:	91 05       	cpc	r25, r1
     2ca:	14 f0       	brlt	.+4      	; 0x2d0 <actuator_set_position+0xc6>
     2cc:	82 e8       	ldi	r24, 0x82	; 130
     2ce:	90 e0       	ldi	r25, 0x00	; 0
     2d0:	6c 01       	movw	r12, r24
     2d2:	99 23       	and	r25, r25
     2d4:	14 f4       	brge	.+4      	; 0x2da <actuator_set_position+0xd0>
     2d6:	c1 2c       	mov	r12, r1
     2d8:	d1 2c       	mov	r13, r1
	if (new_duty_cycle < 0)
	{
		new_duty_cycle = 0;
	}
	
	OCR3C = new_duty_cycle;
     2da:	d0 92 9d 00 	sts	0x009D, r13	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     2de:	c0 92 9c 00 	sts	0x009C, r12	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
     2e2:	db 86       	std	Y+11, r13	; 0x0b
     2e4:	ca 86       	std	Y+10, r12	; 0x0a
	actuator_values->actuator_position_error = position_error;
     2e6:	4e 82       	std	Y+6, r4	; 0x06
     2e8:	5f 82       	std	Y+7, r5	; 0x07
     2ea:	68 86       	std	Y+8, r6	; 0x08
     2ec:	79 86       	std	Y+9, r7	; 0x09
}
     2ee:	10 c0       	rjmp	.+32     	; 0x310 <actuator_set_position+0x106>
		actuator_values->actuator_in_position = 1;
		actuator_values->clutch_state = gear_required;
		actuator_values->actuator_duty_cycle = 50;
	} else
	{
		actuator_values->actuator_in_position = 0;
     2f0:	1d 82       	std	Y+5, r1	; 0x05
     2f2:	1c 82       	std	Y+4, r1	; 0x04
     2f4:	d0 cf       	rjmp	.-96     	; 0x296 <actuator_set_position+0x8c>
	
	//Is the actuator with in an acceptable error
	
	if (actuator_position_tolerance(position_error)) 
	{
		actuator_values->actuator_in_position = 1;
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	9d 83       	std	Y+5, r25	; 0x05
     2fc:	8c 83       	std	Y+4, r24	; 0x04
		actuator_values->clutch_state = gear_required;
     2fe:	89 2d       	mov	r24, r9
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	99 83       	std	Y+1, r25	; 0x01
     304:	88 83       	st	Y, r24
		actuator_values->actuator_duty_cycle = 50;
     306:	82 e3       	ldi	r24, 0x32	; 50
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	9b 87       	std	Y+11, r25	; 0x0b
     30c:	8a 87       	std	Y+10, r24	; 0x0a
     30e:	c3 cf       	rjmp	.-122    	; 0x296 <actuator_set_position+0x8c>
	
	OCR3C = new_duty_cycle;
	
	actuator_values->actuator_duty_cycle = new_duty_cycle;
	actuator_values->actuator_position_error = position_error;
}
     310:	df 91       	pop	r29
     312:	cf 91       	pop	r28
     314:	1f 91       	pop	r17
     316:	0f 91       	pop	r16
     318:	ff 90       	pop	r15
     31a:	ef 90       	pop	r14
     31c:	df 90       	pop	r13
     31e:	cf 90       	pop	r12
     320:	bf 90       	pop	r11
     322:	af 90       	pop	r10
     324:	9f 90       	pop	r9
     326:	7f 90       	pop	r7
     328:	6f 90       	pop	r6
     32a:	5f 90       	pop	r5
     32c:	4f 90       	pop	r4
     32e:	08 95       	ret

00000330 <actuator_p_controller>:

void actuator_p_controller(volatile ModuleValues_t * vals)
{
     330:	af 92       	push	r10
     332:	bf 92       	push	r11
     334:	cf 92       	push	r12
     336:	df 92       	push	r13
     338:	ef 92       	push	r14
     33a:	ff 92       	push	r15
     33c:	0f 93       	push	r16
     33e:	1f 93       	push	r17
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	ec 01       	movw	r28, r24
	uint16_t target_position = 0;
	
	//vals->uart_debug = (int16_t)vals->uart_debug;
	
	if(vals->clutch_enabled)
     346:	8b a1       	ldd	r24, Y+35	; 0x23
     348:	9c a1       	ldd	r25, Y+36	; 0x24
     34a:	89 2b       	or	r24, r25
     34c:	61 f1       	breq	.+88     	; 0x3a6 <actuator_p_controller+0x76>
	{
		//ACTUATOR: set actuator position based off current state
		//ATTENTION: maybe make the gear_required as the switch case and then change to gear_status 
		switch(vals->gear_required)
     34e:	8b ad       	ldd	r24, Y+59	; 0x3b
     350:	81 30       	cpi	r24, 0x01	; 1
     352:	39 f0       	breq	.+14     	; 0x362 <actuator_p_controller+0x32>
     354:	18 f0       	brcs	.+6      	; 0x35c <actuator_p_controller+0x2c>
     356:	82 30       	cpi	r24, 0x02	; 2
     358:	39 f0       	breq	.+14     	; 0x368 <actuator_p_controller+0x38>
     35a:	09 c0       	rjmp	.+18     	; 0x36e <actuator_p_controller+0x3e>
		{
			case NEUTRAL:
					target_position = vals->position_neutral;
     35c:	ec a8       	ldd	r14, Y+52	; 0x34
     35e:	fd a8       	ldd	r15, Y+53	; 0x35
				break;
     360:	08 c0       	rjmp	.+16     	; 0x372 <actuator_p_controller+0x42>
				
			case GEAR1:
					target_position = vals->position_gear_1;
     362:	ee a8       	ldd	r14, Y+54	; 0x36
     364:	ff a8       	ldd	r15, Y+55	; 0x37
				break;
     366:	05 c0       	rjmp	.+10     	; 0x372 <actuator_p_controller+0x42>
				
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
     368:	e8 ac       	ldd	r14, Y+56	; 0x38
     36a:	f9 ac       	ldd	r15, Y+57	; 0x39
				break;
     36c:	02 c0       	rjmp	.+4      	; 0x372 <actuator_p_controller+0x42>
	actuator_values->actuator_position_error = position_error;
}

void actuator_p_controller(volatile ModuleValues_t * vals)
{
	uint16_t target_position = 0;
     36e:	e1 2c       	mov	r14, r1
     370:	f1 2c       	mov	r15, r1
			case GEAR2: //ATTENTION: this is belt mode... as currently implemented
					target_position = vals->position_gear_2;
				break;
		}
	
		actuator_set_position(&ActuatorComValues, vals->gear_required, vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     372:	ab a4       	ldd	r10, Y+43	; 0x2b
     374:	bc a4       	ldd	r11, Y+44	; 0x2c
     376:	cd a4       	ldd	r12, Y+45	; 0x2d
     378:	de a4       	ldd	r13, Y+46	; 0x2e
     37a:	0f a5       	ldd	r16, Y+47	; 0x2f
     37c:	2f a1       	ldd	r18, Y+39	; 0x27
     37e:	38 a5       	ldd	r19, Y+40	; 0x28
     380:	49 a5       	ldd	r20, Y+41	; 0x29
     382:	5a a5       	ldd	r21, Y+42	; 0x2a
     384:	6b ad       	ldd	r22, Y+59	; 0x3b
     386:	10 e0       	ldi	r17, 0x00	; 0
     388:	80 ee       	ldi	r24, 0xE0	; 224
     38a:	91 e0       	ldi	r25, 0x01	; 1
     38c:	3e df       	rcall	.-388    	; 0x20a <actuator_set_position>
		//vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
		//vals->actuator_direction = ActuatorComValues.actuator_direction;
		//vals->gear_status = ActuatorComValues.clutch_state;
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
		
		if (ActuatorComValues.actuator_in_position)
     38e:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <__data_end+0x4>
     392:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <__data_end+0x5>
     396:	89 2b       	or	r24, r25
     398:	b1 f0       	breq	.+44     	; 0x3c6 <actuator_p_controller+0x96>
		{
			vals->gear_status = ActuatorComValues.clutch_state;
     39a:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <__data_end>
     39e:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <__data_end+0x1>
     3a2:	8a af       	std	Y+58, r24	; 0x3a
     3a4:	10 c0       	rjmp	.+32     	; 0x3c6 <actuator_p_controller+0x96>
		}
		
	}else
	{
		//moving actuator through uart
		target_position = vals->position_uart_instruction;
     3a6:	ea a8       	ldd	r14, Y+50	; 0x32
     3a8:	fb a8       	ldd	r15, Y+51	; 0x33
		//vals->uart_debug = target_position;
		actuator_set_position(&ActuatorComValues, vals->gear_required,  vals->uart_debug, vals->u8_actuator_duty_cycle, target_position, vals->f32_actuator_feedback);
     3aa:	ab a4       	ldd	r10, Y+43	; 0x2b
     3ac:	bc a4       	ldd	r11, Y+44	; 0x2c
     3ae:	cd a4       	ldd	r12, Y+45	; 0x2d
     3b0:	de a4       	ldd	r13, Y+46	; 0x2e
     3b2:	0f a5       	ldd	r16, Y+47	; 0x2f
     3b4:	2f a1       	ldd	r18, Y+39	; 0x27
     3b6:	38 a5       	ldd	r19, Y+40	; 0x28
     3b8:	49 a5       	ldd	r20, Y+41	; 0x29
     3ba:	5a a5       	ldd	r21, Y+42	; 0x2a
     3bc:	6b ad       	ldd	r22, Y+59	; 0x3b
     3be:	10 e0       	ldi	r17, 0x00	; 0
     3c0:	80 ee       	ldi	r24, 0xE0	; 224
     3c2:	91 e0       	ldi	r25, 0x01	; 1
     3c4:	22 df       	rcall	.-444    	; 0x20a <actuator_set_position>
		//vals->u8_actuator_duty_cycle = ActuatorComValues.actuator_duty_cycle;
		//vals->actuator_direction = ActuatorComValues.actuator_direction;
		//vals->gear_status = ActuatorComValues.clutch_state;
		//vals->uart_debug = ActuatorComValues.actuator_in_position;
	}
}
     3c6:	df 91       	pop	r29
     3c8:	cf 91       	pop	r28
     3ca:	1f 91       	pop	r17
     3cc:	0f 91       	pop	r16
     3ce:	ff 90       	pop	r15
     3d0:	ef 90       	pop	r14
     3d2:	df 90       	pop	r13
     3d4:	cf 90       	pop	r12
     3d6:	bf 90       	pop	r11
     3d8:	af 90       	pop	r10
     3da:	08 95       	ret

000003dc <reset_I>:

static float f32_Integrator = 0.0 ;

void reset_I(void)
{
	f32_Integrator = 0;
     3dc:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <f32_Integrator>
     3e0:	10 92 f4 01 	sts	0x01F4, r1	; 0x8001f4 <f32_Integrator+0x1>
     3e4:	10 92 f5 01 	sts	0x01F5, r1	; 0x8001f5 <f32_Integrator+0x2>
     3e8:	10 92 f6 01 	sts	0x01F6, r1	; 0x8001f6 <f32_Integrator+0x3>
     3ec:	08 95       	ret

000003ee <set_I>:
}

void set_I(uint8_t duty)
{
	f32_Integrator = (duty-50.0)/Ki;
     3ee:	68 2f       	mov	r22, r24
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     3fa:	20 e0       	ldi	r18, 0x00	; 0
     3fc:	30 e0       	ldi	r19, 0x00	; 0
     3fe:	48 e4       	ldi	r20, 0x48	; 72
     400:	52 e4       	ldi	r21, 0x42	; 66
     402:	0e 94 7e 11 	call	0x22fc	; 0x22fc <__subsf3>
     406:	27 ed       	ldi	r18, 0xD7	; 215
     408:	33 ea       	ldi	r19, 0xA3	; 163
     40a:	48 e8       	ldi	r20, 0x88	; 136
     40c:	51 e4       	ldi	r21, 0x41	; 65
     40e:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
     412:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     416:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     41a:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     41e:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
     422:	08 95       	ret

00000424 <controller>:
}

void controller(volatile ModuleValues_t *vals){
     424:	8f 92       	push	r8
     426:	9f 92       	push	r9
     428:	af 92       	push	r10
     42a:	bf 92       	push	r11
     42c:	cf 92       	push	r12
     42e:	df 92       	push	r13
     430:	ef 92       	push	r14
     432:	ff 92       	push	r15
     434:	0f 93       	push	r16
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
     43c:	ec 01       	movw	r28, r24
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
	
	if (vals->motor_status == BRAKE)
     43e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     440:	82 30       	cpi	r24, 0x02	; 2
     442:	21 f4       	brne	.+8      	; 0x44c <controller+0x28>
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
     444:	68 8d       	ldd	r22, Y+24	; 0x18
     446:	16 2f       	mov	r17, r22
     448:	11 95       	neg	r17
     44a:	01 c0       	rjmp	.+2      	; 0x44e <controller+0x2a>
void controller(volatile ModuleValues_t *vals){
	
	static float f32_DutyCycleCmd = 50.0 ;
	float f32_CurrentDelta = 0.0 ;
	static uint8_t b_saturation = 0;
	int8_t i8_throttle_cmd = 0;
     44c:	10 e0       	ldi	r17, 0x00	; 0
	
	if (vals->motor_status == BRAKE)
	{
		i8_throttle_cmd = -(int8_t)vals->u8_brake_cmd ;
	}
	if (vals->motor_status == ACCEL)
     44e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     450:	81 30       	cpi	r24, 0x01	; 1
     452:	09 f4       	brne	.+2      	; 0x456 <controller+0x32>
	{
		i8_throttle_cmd = vals->u8_accel_cmd ;
     454:	1f 89       	ldd	r17, Y+23	; 0x17
	}
	
	if (vals->ctrl_type == CURRENT)
     456:	89 a1       	ldd	r24, Y+33	; 0x21
     458:	81 11       	cpse	r24, r1
     45a:	7b c0       	rjmp	.+246    	; 0x552 <controller+0x12e>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
     45c:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     460:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     464:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     468:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     46c:	20 e0       	ldi	r18, 0x00	; 0
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	4e eb       	ldi	r20, 0xBE	; 190
     472:	52 e4       	ldi	r21, 0x42	; 66
     474:	c7 01       	movw	r24, r14
     476:	b6 01       	movw	r22, r12
     478:	0e 94 32 13 	call	0x2664	; 0x2664 <__gesf2>
     47c:	88 23       	and	r24, r24
     47e:	54 f4       	brge	.+20     	; 0x494 <controller+0x70>
     480:	20 e0       	ldi	r18, 0x00	; 0
     482:	30 e0       	ldi	r19, 0x00	; 0
     484:	48 e4       	ldi	r20, 0x48	; 72
     486:	52 e4       	ldi	r21, 0x42	; 66
     488:	c7 01       	movw	r24, r14
     48a:	b6 01       	movw	r22, r12
     48c:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <__cmpsf2>
     490:	18 16       	cp	r1, r24
     492:	6c f0       	brlt	.+26     	; 0x4ae <controller+0x8a>
		{
			b_saturation = 1 ;
     494:	81 e0       	ldi	r24, 0x01	; 1
     496:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <b_saturation.2178>
		} else {
			b_saturation = 0;
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     49a:	61 2f       	mov	r22, r17
     49c:	11 0f       	add	r17, r17
     49e:	77 0b       	sbc	r23, r23
     4a0:	88 0b       	sbc	r24, r24
     4a2:	99 0b       	sbc	r25, r25
     4a4:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
     4ac:	25 c0       	rjmp	.+74     	; 0x4f8 <controller+0xd4>
	{
		if (f32_DutyCycleCmd >= 95 || f32_DutyCycleCmd <= 50)
		{
			b_saturation = 1 ;
		} else {
			b_saturation = 0;
     4ae:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <b_saturation.2178>
		}
		//-vals->f32_motor_current
		f32_CurrentDelta = ((float)(i8_throttle_cmd))	;
     4b2:	61 2f       	mov	r22, r17
     4b4:	11 0f       	add	r17, r17
     4b6:	77 0b       	sbc	r23, r23
     4b8:	88 0b       	sbc	r24, r24
     4ba:	99 0b       	sbc	r25, r25
     4bc:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     4c0:	6b 01       	movw	r12, r22
     4c2:	7c 01       	movw	r14, r24
		
		if (!b_saturation) // prevents over integration of an error that cannot be dealt with (because the duty cycle reaches a limit) integral windup protection
		{
			f32_Integrator+=f32_CurrentDelta*TimeStep ;
     4c4:	2a e0       	ldi	r18, 0x0A	; 10
     4c6:	37 ed       	ldi	r19, 0xD7	; 215
     4c8:	43 ea       	ldi	r20, 0xA3	; 163
     4ca:	5b e3       	ldi	r21, 0x3B	; 59
     4cc:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     4d0:	9b 01       	movw	r18, r22
     4d2:	ac 01       	movw	r20, r24
     4d4:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     4d8:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     4dc:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     4e0:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     4e4:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     4e8:	60 93 f3 01 	sts	0x01F3, r22	; 0x8001f3 <f32_Integrator>
     4ec:	70 93 f4 01 	sts	0x01F4, r23	; 0x8001f4 <f32_Integrator+0x1>
     4f0:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <f32_Integrator+0x2>
     4f4:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <f32_Integrator+0x3>
		}
		
		f32_DutyCycleCmd=Kp*f32_CurrentDelta+f32_Integrator*Ki ;
		f32_DutyCycleCmd=f32_DutyCycleCmd+50.0 ;
     4f8:	27 ed       	ldi	r18, 0xD7	; 215
     4fa:	33 ea       	ldi	r19, 0xA3	; 163
     4fc:	48 e8       	ldi	r20, 0x88	; 136
     4fe:	51 e4       	ldi	r21, 0x41	; 65
     500:	60 91 f3 01 	lds	r22, 0x01F3	; 0x8001f3 <f32_Integrator>
     504:	70 91 f4 01 	lds	r23, 0x01F4	; 0x8001f4 <f32_Integrator+0x1>
     508:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <f32_Integrator+0x2>
     50c:	90 91 f6 01 	lds	r25, 0x01F6	; 0x8001f6 <f32_Integrator+0x3>
     510:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     514:	4b 01       	movw	r8, r22
     516:	5c 01       	movw	r10, r24
     518:	27 e8       	ldi	r18, 0x87	; 135
     51a:	3f eb       	ldi	r19, 0xBF	; 191
     51c:	46 e2       	ldi	r20, 0x26	; 38
     51e:	5e e3       	ldi	r21, 0x3E	; 62
     520:	c7 01       	movw	r24, r14
     522:	b6 01       	movw	r22, r12
     524:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     528:	9b 01       	movw	r18, r22
     52a:	ac 01       	movw	r20, r24
     52c:	c5 01       	movw	r24, r10
     52e:	b4 01       	movw	r22, r8
     530:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	48 e4       	ldi	r20, 0x48	; 72
     53a:	52 e4       	ldi	r21, 0x42	; 66
     53c:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     540:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     544:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     548:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     54c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
     550:	11 c0       	rjmp	.+34     	; 0x574 <controller+0x150>
	
	}else if (vals->ctrl_type == PWM)
     552:	89 a1       	ldd	r24, Y+33	; 0x21
     554:	81 30       	cpi	r24, 0x01	; 1
     556:	71 f4       	brne	.+28     	; 0x574 <controller+0x150>
	{
		f32_DutyCycleCmd = (float)(vals->u8_duty_cycle);
     558:	69 8d       	ldd	r22, Y+25	; 0x19
     55a:	70 e0       	ldi	r23, 0x00	; 0
     55c:	80 e0       	ldi	r24, 0x00	; 0
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     564:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__data_start>
     568:	70 93 01 01 	sts	0x0101, r23	; 0x800101 <__data_start+0x1>
     56c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_start+0x2>
     570:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_start+0x3>
			//f32_DutyCycleCmd ++ ;
		//}
	}
	
	//bounding of duty cycle for well function of bootstrap capacitors
	if (f32_DutyCycleCmd > 95)
     574:	c0 90 00 01 	lds	r12, 0x0100	; 0x800100 <__data_start>
     578:	d0 90 01 01 	lds	r13, 0x0101	; 0x800101 <__data_start+0x1>
     57c:	e0 90 02 01 	lds	r14, 0x0102	; 0x800102 <__data_start+0x2>
     580:	f0 90 03 01 	lds	r15, 0x0103	; 0x800103 <__data_start+0x3>
     584:	20 e0       	ldi	r18, 0x00	; 0
     586:	30 e0       	ldi	r19, 0x00	; 0
     588:	4e eb       	ldi	r20, 0xBE	; 190
     58a:	52 e4       	ldi	r21, 0x42	; 66
     58c:	c7 01       	movw	r24, r14
     58e:	b6 01       	movw	r22, r12
     590:	0e 94 32 13 	call	0x2664	; 0x2664 <__gesf2>
     594:	18 16       	cp	r1, r24
     596:	6c f4       	brge	.+26     	; 0x5b2 <controller+0x18e>
	{
		f32_DutyCycleCmd = 95;
     598:	80 e0       	ldi	r24, 0x00	; 0
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	ae eb       	ldi	r26, 0xBE	; 190
     59e:	b2 e4       	ldi	r27, 0x42	; 66
     5a0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5a4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5a8:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5ac:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
     5b0:	16 c0       	rjmp	.+44     	; 0x5de <controller+0x1ba>
	}
	
	if (f32_DutyCycleCmd < 50)// bounding at 50 to prevent rheostatic braking and backwards motion
     5b2:	20 e0       	ldi	r18, 0x00	; 0
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	48 e4       	ldi	r20, 0x48	; 72
     5b8:	52 e4       	ldi	r21, 0x42	; 66
     5ba:	c7 01       	movw	r24, r14
     5bc:	b6 01       	movw	r22, r12
     5be:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <__cmpsf2>
     5c2:	88 23       	and	r24, r24
     5c4:	64 f4       	brge	.+24     	; 0x5de <controller+0x1ba>
	{
		f32_DutyCycleCmd = 50;
     5c6:	80 e0       	ldi	r24, 0x00	; 0
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	a8 e4       	ldi	r26, 0x48	; 72
     5cc:	b2 e4       	ldi	r27, 0x42	; 66
     5ce:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     5d2:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5d6:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
     5da:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
	if (SW_MODE == BIPOLAR)
	{
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3 (non inverted)
		OCR3B = OCR3A ; //PWM_PE4 (inverted)
	}else{//UNIPOLAR
		OCR3A = (int)((f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE3
     5de:	06 e9       	ldi	r16, 0x96	; 150
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	f8 01       	movw	r30, r16
     5e4:	e0 80       	ld	r14, Z
     5e6:	f1 80       	ldd	r15, Z+1	; 0x01
     5e8:	20 e0       	ldi	r18, 0x00	; 0
     5ea:	30 e0       	ldi	r19, 0x00	; 0
     5ec:	48 ec       	ldi	r20, 0xC8	; 200
     5ee:	52 e4       	ldi	r21, 0x42	; 66
     5f0:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     5f4:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     5f8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     5fc:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     600:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
     604:	4b 01       	movw	r8, r22
     606:	5c 01       	movw	r10, r24
     608:	b7 01       	movw	r22, r14
     60a:	80 e0       	ldi	r24, 0x00	; 0
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     612:	9b 01       	movw	r18, r22
     614:	ac 01       	movw	r20, r24
     616:	c5 01       	movw	r24, r10
     618:	b4 01       	movw	r22, r8
     61a:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     61e:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     622:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     626:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		OCR3B = (int)(ICR3-(f32_DutyCycleCmd/100.0)*ICR3) ; //PWM_PE4
     62a:	f8 01       	movw	r30, r16
     62c:	60 81       	ld	r22, Z
     62e:	71 81       	ldd	r23, Z+1	; 0x01
     630:	00 81       	ld	r16, Z
     632:	11 81       	ldd	r17, Z+1	; 0x01
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     63c:	6b 01       	movw	r12, r22
     63e:	7c 01       	movw	r14, r24
     640:	20 e0       	ldi	r18, 0x00	; 0
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	48 ec       	ldi	r20, 0xC8	; 200
     646:	52 e4       	ldi	r21, 0x42	; 66
     648:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     64c:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     650:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     654:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     658:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
     65c:	4b 01       	movw	r8, r22
     65e:	5c 01       	movw	r10, r24
     660:	b8 01       	movw	r22, r16
     662:	80 e0       	ldi	r24, 0x00	; 0
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     66a:	9b 01       	movw	r18, r22
     66c:	ac 01       	movw	r20, r24
     66e:	c5 01       	movw	r24, r10
     670:	b4 01       	movw	r22, r8
     672:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     676:	9b 01       	movw	r18, r22
     678:	ac 01       	movw	r20, r24
     67a:	c7 01       	movw	r24, r14
     67c:	b6 01       	movw	r22, r12
     67e:	0e 94 7e 11 	call	0x22fc	; 0x22fc <__subsf3>
     682:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     686:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     68a:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	}
	
	vals->u8_duty_cycle = (uint8_t)f32_DutyCycleCmd ; //exporting the duty cycle to be able to read in on the CAN and USB
     68e:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <__data_start>
     692:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <__data_start+0x1>
     696:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_start+0x2>
     69a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_start+0x3>
     69e:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     6a2:	69 8f       	std	Y+25, r22	; 0x19

}
     6a4:	df 91       	pop	r29
     6a6:	cf 91       	pop	r28
     6a8:	1f 91       	pop	r17
     6aa:	0f 91       	pop	r16
     6ac:	ff 90       	pop	r15
     6ae:	ef 90       	pop	r14
     6b0:	df 90       	pop	r13
     6b2:	cf 90       	pop	r12
     6b4:	bf 90       	pop	r11
     6b6:	af 90       	pop	r10
     6b8:	9f 90       	pop	r9
     6ba:	8f 90       	pop	r8
     6bc:	08 95       	ret

000006be <drivers_init>:

void drivers_init() // defining pin PB4 as logical output
{
	DDRD |= (1 << PD3) ;
     6be:	53 9a       	sbi	0x0a, 3	; 10
     6c0:	08 95       	ret

000006c2 <drivers>:
}

void drivers(uint8_t b_state) //when pin PB4 is high : drivers are shut down, when pin is low, drivers are ON (inverted logic) IR2104SPbF drivers
{
	if (b_state == 1)
     6c2:	81 30       	cpi	r24, 0x01	; 1
     6c4:	11 f4       	brne	.+4      	; 0x6ca <drivers+0x8>
	{
		PORTD |= (1 << PD3) ;
     6c6:	5b 9a       	sbi	0x0b, 3	; 11
     6c8:	08 95       	ret
	}else{
		PORTD &= ~(1 << PD3) ;
     6ca:	5b 98       	cbi	0x0b, 3	; 11
     6cc:	08 95       	ret

000006ce <SPI_handler_0>:
static uint8_t u8_rxBuffer[3];

/////////////////////////  SPI  /////////////////////////

void SPI_handler_0(volatile float * f32_batt_volt) // motor current ***CH0 - S_B_V, BATTERY VOLTAGE
{
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
     6d2:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(0, u8_txBuffer);
     6d4:	6a ef       	ldi	r22, 0xFA	; 250
     6d6:	71 e0       	ldi	r23, 0x01	; 1
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     6de:	21 e0       	ldi	r18, 0x01	; 1
     6e0:	43 e0       	ldi	r20, 0x03	; 3
     6e2:	50 e0       	ldi	r21, 0x00	; 0
     6e4:	67 ef       	ldi	r22, 0xF7	; 247
     6e6:	71 e0       	ldi	r23, 0x01	; 1
     6e8:	8a ef       	ldi	r24, 0xFA	; 250
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	0e 94 1e 11 	call	0x223c	; 0x223c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     6f0:	e7 ef       	ldi	r30, 0xF7	; 247
     6f2:	f1 e0       	ldi	r31, 0x01	; 1
     6f4:	61 81       	ldd	r22, Z+1	; 0x01
     6f6:	6f 71       	andi	r22, 0x1F	; 31
     6f8:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC0_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	*f32_batt_volt = VOLT_CONVERSION_OFFSET+(((float)u16_ADC0_reg/VOLT_CONVERSION_COEFF)*10 - 17);
     6fa:	70 e0       	ldi	r23, 0x00	; 0
     6fc:	76 2f       	mov	r23, r22
     6fe:	66 27       	eor	r22, r22
     700:	82 81       	ldd	r24, Z+2	; 0x02
     702:	68 2b       	or	r22, r24
     704:	80 e0       	ldi	r24, 0x00	; 0
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     70c:	20 e0       	ldi	r18, 0x00	; 0
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	49 e8       	ldi	r20, 0x89	; 137
     712:	52 e4       	ldi	r21, 0x42	; 66
     714:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	40 e2       	ldi	r20, 0x20	; 32
     71e:	51 e4       	ldi	r21, 0x41	; 65
     720:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     724:	20 e0       	ldi	r18, 0x00	; 0
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	48 e8       	ldi	r20, 0x88	; 136
     72a:	51 e4       	ldi	r21, 0x41	; 65
     72c:	0e 94 7e 11 	call	0x22fc	; 0x22fc <__subsf3>
     730:	20 e0       	ldi	r18, 0x00	; 0
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	a9 01       	movw	r20, r18
     736:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     73a:	68 83       	st	Y, r22
     73c:	79 83       	std	Y+1, r23	; 0x01
     73e:	8a 83       	std	Y+2, r24	; 0x02
     740:	9b 83       	std	Y+3, r25	; 0x03
}
     742:	df 91       	pop	r29
     744:	cf 91       	pop	r28
     746:	08 95       	ret

00000748 <SPI_handler_1>:

void SPI_handler_1(volatile float * f32_batt_current) // battery current ***CH1 - S_B_I, BATTERY CURRENT
{
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
     74c:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(1, u8_txBuffer);
     74e:	6a ef       	ldi	r22, 0xFA	; 250
     750:	71 e0       	ldi	r23, 0x01	; 1
     752:	81 e0       	ldi	r24, 0x01	; 1
     754:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     758:	21 e0       	ldi	r18, 0x01	; 1
     75a:	43 e0       	ldi	r20, 0x03	; 3
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	67 ef       	ldi	r22, 0xF7	; 247
     760:	71 e0       	ldi	r23, 0x01	; 1
     762:	8a ef       	ldi	r24, 0xFA	; 250
     764:	91 e0       	ldi	r25, 0x01	; 1
     766:	0e 94 1e 11 	call	0x223c	; 0x223c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     76a:	e7 ef       	ldi	r30, 0xF7	; 247
     76c:	f1 e0       	ldi	r31, 0x01	; 1
     76e:	61 81       	ldd	r22, Z+1	; 0x01
     770:	6f 71       	andi	r22, 0x1F	; 31
     772:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC1_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_current_sensor(f32_batt_current, u16_ADC1_reg, 1);
     774:	70 e0       	ldi	r23, 0x00	; 0
     776:	76 2f       	mov	r23, r22
     778:	66 27       	eor	r22, r22
     77a:	82 81       	ldd	r24, Z+2	; 0x02
     77c:	68 2b       	or	r22, r24
     77e:	41 e0       	ldi	r20, 0x01	; 1
     780:	ce 01       	movw	r24, r28
     782:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <handle_current_sensor>
}
     786:	df 91       	pop	r29
     788:	cf 91       	pop	r28
     78a:	08 95       	ret

0000078c <SPI_handler_4>:
	//ATTENTION - IMPLEMENT CONVERSION HERE
	//handle_current_sensor(p_f32_motcurrent, u16_ADC0_reg,0);
}
*/
void SPI_handler_4(volatile uint8_t * u8_motor_temp) //motor temperature ***CH4 - S_M_T, MOTOR TEMPERATURE
{
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(4, u8_txBuffer);
     792:	6a ef       	ldi	r22, 0xFA	; 250
     794:	71 e0       	ldi	r23, 0x01	; 1
     796:	84 e0       	ldi	r24, 0x04	; 4
     798:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     79c:	21 e0       	ldi	r18, 0x01	; 1
     79e:	43 e0       	ldi	r20, 0x03	; 3
     7a0:	50 e0       	ldi	r21, 0x00	; 0
     7a2:	67 ef       	ldi	r22, 0xF7	; 247
     7a4:	71 e0       	ldi	r23, 0x01	; 1
     7a6:	8a ef       	ldi	r24, 0xFA	; 250
     7a8:	91 e0       	ldi	r25, 0x01	; 1
     7aa:	0e 94 1e 11 	call	0x223c	; 0x223c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7ae:	e7 ef       	ldi	r30, 0xF7	; 247
     7b0:	f1 e0       	ldi	r31, 0x01	; 1
     7b2:	61 81       	ldd	r22, Z+1	; 0x01
     7b4:	6f 71       	andi	r22, 0x1F	; 31
     7b6:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC4_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	
	handle_temp_sensor(u8_motor_temp, u16_ADC4_reg);
     7b8:	70 e0       	ldi	r23, 0x00	; 0
     7ba:	76 2f       	mov	r23, r22
     7bc:	66 27       	eor	r22, r22
     7be:	82 81       	ldd	r24, Z+2	; 0x02
     7c0:	68 2b       	or	r22, r24
     7c2:	ce 01       	movw	r24, r28
     7c4:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <handle_temp_sensor>
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <SPI_handler_6>:
	u16_ADC5_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
}
*/
void SPI_handler_6(volatile float * f32_actuator_feedback) //CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
{
     7ce:	0f 93       	push	r16
     7d0:	1f 93       	push	r17
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	00 d0       	rcall	.+0      	; 0x7d8 <SPI_handler_6+0xa>
     7d8:	00 d0       	rcall	.+0      	; 0x7da <SPI_handler_6+0xc>
     7da:	cd b7       	in	r28, 0x3d	; 61
     7dc:	de b7       	in	r29, 0x3e	; 62
     7de:	8c 01       	movw	r16, r24
	Set_ADC_Channel_ext(6, u8_txBuffer);
     7e0:	6a ef       	ldi	r22, 0xFA	; 250
     7e2:	71 e0       	ldi	r23, 0x01	; 1
     7e4:	86 e0       	ldi	r24, 0x06	; 6
     7e6:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     7ea:	21 e0       	ldi	r18, 0x01	; 1
     7ec:	43 e0       	ldi	r20, 0x03	; 3
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	67 ef       	ldi	r22, 0xF7	; 247
     7f2:	71 e0       	ldi	r23, 0x01	; 1
     7f4:	8a ef       	ldi	r24, 0xFA	; 250
     7f6:	91 e0       	ldi	r25, 0x01	; 1
     7f8:	0e 94 1e 11 	call	0x223c	; 0x223c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     7fc:	e7 ef       	ldi	r30, 0xF7	; 247
     7fe:	f1 e0       	ldi	r31, 0x01	; 1
     800:	61 81       	ldd	r22, Z+1	; 0x01
     802:	6f 71       	andi	r22, 0x1F	; 31
     804:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC6_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//handle_actuator_feedback(f32_actuator_feedback, u16_ADC6_reg);
	
	volatile float new_f32_actuator_feedback = ((volatile float)u16_ADC6_reg*5.0/4096.0);
     806:	70 e0       	ldi	r23, 0x00	; 0
     808:	76 2f       	mov	r23, r22
     80a:	66 27       	eor	r22, r22
     80c:	82 81       	ldd	r24, Z+2	; 0x02
     80e:	68 2b       	or	r22, r24
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	40 ea       	ldi	r20, 0xA0	; 160
     81e:	50 e4       	ldi	r21, 0x40	; 64
     820:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     824:	20 e0       	ldi	r18, 0x00	; 0
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	40 e8       	ldi	r20, 0x80	; 128
     82a:	59 e3       	ldi	r21, 0x39	; 57
     82c:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     830:	69 83       	std	Y+1, r22	; 0x01
     832:	7a 83       	std	Y+2, r23	; 0x02
     834:	8b 83       	std	Y+3, r24	; 0x03
     836:	9c 83       	std	Y+4, r25	; 0x04
	//set new feedback to feedback pointer
	*f32_actuator_feedback = (new_f32_actuator_feedback*100 + 25);
     838:	69 81       	ldd	r22, Y+1	; 0x01
     83a:	7a 81       	ldd	r23, Y+2	; 0x02
     83c:	8b 81       	ldd	r24, Y+3	; 0x03
     83e:	9c 81       	ldd	r25, Y+4	; 0x04
     840:	20 e0       	ldi	r18, 0x00	; 0
     842:	30 e0       	ldi	r19, 0x00	; 0
     844:	48 ec       	ldi	r20, 0xC8	; 200
     846:	52 e4       	ldi	r21, 0x42	; 66
     848:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	30 e0       	ldi	r19, 0x00	; 0
     850:	48 ec       	ldi	r20, 0xC8	; 200
     852:	51 e4       	ldi	r21, 0x41	; 65
     854:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     858:	f8 01       	movw	r30, r16
     85a:	60 83       	st	Z, r22
     85c:	71 83       	std	Z+1, r23	; 0x01
     85e:	82 83       	std	Z+2, r24	; 0x02
     860:	93 83       	std	Z+3, r25	; 0x03
}
     862:	0f 90       	pop	r0
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	1f 91       	pop	r17
     870:	0f 91       	pop	r16
     872:	08 95       	ret

00000874 <SPI_handler_7>:

void SPI_handler_7(volatile float * f32_motor_current) //CH7 - S_M_I, MOTOR CURRENT
{
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	ec 01       	movw	r28, r24
	Set_ADC_Channel_ext(7, u8_txBuffer);
     87a:	6a ef       	ldi	r22, 0xFA	; 250
     87c:	71 e0       	ldi	r23, 0x01	; 1
     87e:	87 e0       	ldi	r24, 0x07	; 7
     880:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <Set_ADC_Channel_ext>
	spi_trancieve(u8_txBuffer, u8_rxBuffer, 3, 1);
     884:	21 e0       	ldi	r18, 0x01	; 1
     886:	43 e0       	ldi	r20, 0x03	; 3
     888:	50 e0       	ldi	r21, 0x00	; 0
     88a:	67 ef       	ldi	r22, 0xF7	; 247
     88c:	71 e0       	ldi	r23, 0x01	; 1
     88e:	8a ef       	ldi	r24, 0xFA	; 250
     890:	91 e0       	ldi	r25, 0x01	; 1
     892:	0e 94 1e 11 	call	0x223c	; 0x223c <spi_trancieve>
	u8_rxBuffer[1]&= ~(0b111<<5);
     896:	e7 ef       	ldi	r30, 0xF7	; 247
     898:	f1 e0       	ldi	r31, 0x01	; 1
     89a:	61 81       	ldd	r22, Z+1	; 0x01
     89c:	6f 71       	andi	r22, 0x1F	; 31
     89e:	61 83       	std	Z+1, r22	; 0x01
	u16_ADC7_reg = (u8_rxBuffer[1] << 8 ) | u8_rxBuffer[2];
	//ATTENTION - IMPLEMENT CONVERSION HERE
	handle_current_sensor(f32_motor_current, u16_ADC7_reg, 0);
     8a0:	70 e0       	ldi	r23, 0x00	; 0
     8a2:	76 2f       	mov	r23, r22
     8a4:	66 27       	eor	r22, r22
     8a6:	82 81       	ldd	r24, Z+2	; 0x02
     8a8:	68 2b       	or	r22, r24
     8aa:	40 e0       	ldi	r20, 0x00	; 0
     8ac:	ce 01       	movw	r24, r28
     8ae:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <handle_current_sensor>
}
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	08 95       	ret

000008b8 <handle_can>:

///////////////////////  CAN  /////////////////////////


//receiving
void handle_can(volatile ModuleValues_t *vals, CanMessage_t *rx){
     8b8:	0f 93       	push	r16
     8ba:	1f 93       	push	r17
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	8c 01       	movw	r16, r24
     8c2:	eb 01       	movw	r28, r22
	if (can_read_message_if_new(rx) && vals->motor_status != ERR){
     8c4:	cb 01       	movw	r24, r22
     8c6:	0e 94 39 10 	call	0x2072	; 0x2072 <can_read_message_if_new>
     8ca:	88 23       	and	r24, r24
     8cc:	09 f4       	brne	.+2      	; 0x8d0 <handle_can+0x18>
     8ce:	46 c0       	rjmp	.+140    	; 0x95c <handle_can+0xa4>
     8d0:	f8 01       	movw	r30, r16
     8d2:	86 8d       	ldd	r24, Z+30	; 0x1e
     8d4:	84 30       	cpi	r24, 0x04	; 4
     8d6:	09 f4       	brne	.+2      	; 0x8da <handle_can+0x22>
     8d8:	41 c0       	rjmp	.+130    	; 0x95c <handle_can+0xa4>
		switch (rx->id){
     8da:	88 81       	ld	r24, Y
     8dc:	99 81       	ldd	r25, Y+1	; 0x01
     8de:	80 32       	cpi	r24, 0x20	; 32
     8e0:	f1 e0       	ldi	r31, 0x01	; 1
     8e2:	9f 07       	cpc	r25, r31
     8e4:	91 f1       	breq	.+100    	; 0x94a <handle_can+0x92>
     8e6:	80 33       	cpi	r24, 0x30	; 48
     8e8:	92 40       	sbci	r25, 0x02	; 2
     8ea:	c1 f5       	brne	.+112    	; 0x95c <handle_can+0xa4>
			case DASHBOARD_CAN_ID	: //receiving can messages from the steering wheel
				
				vals->message_mode = CAN ;
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	f8 01       	movw	r30, r16
     8f0:	87 8f       	std	Z+31, r24	; 0x1f
				vals->ctrl_type = CURRENT ;
     8f2:	11 a2       	std	Z+33, r1	; 0x21
				vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE ; // resetting to max value each time a message is received.
     8f4:	82 e3       	ldi	r24, 0x32	; 50
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	93 8f       	std	Z+27, r25	; 0x1b
     8fa:	82 8f       	std	Z+26, r24	; 0x1a
				if (rx->data.u8[3] > 8)
     8fc:	8e 81       	ldd	r24, Y+6	; 0x06
     8fe:	89 30       	cpi	r24, 0x09	; 9
     900:	40 f0       	brcs	.+16     	; 0x912 <handle_can+0x5a>
				{
					vals->u8_accel_cmd = rx->data.u8[3]/8 ; 
     902:	86 95       	lsr	r24
     904:	86 95       	lsr	r24
     906:	86 95       	lsr	r24
     908:	87 8b       	std	Z+23, r24	; 0x17
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     90a:	8e e1       	ldi	r24, 0x1E	; 30
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	95 8f       	std	Z+29, r25	; 0x1d
     910:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] > 8)
     912:	8f 81       	ldd	r24, Y+7	; 0x07
     914:	89 30       	cpi	r24, 0x09	; 9
     916:	88 f0       	brcs	.+34     	; 0x93a <handle_can+0x82>
				{
					vals->u8_brake_cmd = rx->data.u8[2]/10 ;
     918:	8d 81       	ldd	r24, Y+5	; 0x05
     91a:	9d ec       	ldi	r25, 0xCD	; 205
     91c:	89 9f       	mul	r24, r25
     91e:	81 2d       	mov	r24, r1
     920:	11 24       	eor	r1, r1
     922:	86 95       	lsr	r24
     924:	86 95       	lsr	r24
     926:	86 95       	lsr	r24
     928:	f8 01       	movw	r30, r16
     92a:	80 8f       	std	Z+24, r24	; 0x18
					vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE ;
     92c:	8e e1       	ldi	r24, 0x1E	; 30
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	95 8f       	std	Z+29, r25	; 0x1d
     932:	84 8f       	std	Z+28, r24	; 0x1c
				}
				
				if (rx->data.u8[4] <= 8)
     934:	8f 81       	ldd	r24, Y+7	; 0x07
     936:	89 30       	cpi	r24, 0x09	; 9
     938:	10 f4       	brcc	.+4      	; 0x93e <handle_can+0x86>
				{
					vals->u8_brake_cmd = 0;
     93a:	f8 01       	movw	r30, r16
     93c:	10 8e       	std	Z+24, r1	; 0x18
				}
				if (rx->data.u8[3] <= 8)
     93e:	8e 81       	ldd	r24, Y+6	; 0x06
     940:	89 30       	cpi	r24, 0x09	; 9
     942:	60 f4       	brcc	.+24     	; 0x95c <handle_can+0xa4>
				{
					vals->u8_accel_cmd = 0;
     944:	f8 01       	movw	r30, r16
     946:	17 8a       	std	Z+23, r1	; 0x17
     948:	09 c0       	rjmp	.+18     	; 0x95c <handle_can+0xa4>
				}
				
			break;
			
			case E_CLUTCH_CAN_ID :
				vals->pwtrain_type = GEAR ;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	f8 01       	movw	r30, r16
     94e:	82 a3       	std	Z+34, r24	; 0x22
				vals->u16_motor_speed = rx->data.u16[0] ; //receiving motor speed from encoder from clutch board
     950:	8b 81       	ldd	r24, Y+3	; 0x03
     952:	9c 81       	ldd	r25, Y+4	; 0x04
     954:	96 8b       	std	Z+22, r25	; 0x16
     956:	85 8b       	std	Z+21, r24	; 0x15
				vals->gear_status = rx->data.u8[2] ; //receiving gear status from the clutch board 
     958:	8d 81       	ldd	r24, Y+5	; 0x05
     95a:	82 af       	std	Z+58, r24	; 0x3a
			break;
		}
	}
}
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	1f 91       	pop	r17
     962:	0f 91       	pop	r16
     964:	08 95       	ret

00000966 <handle_motor_status_can_msg>:

//sending
void handle_motor_status_can_msg(volatile ModuleValues_t vals){
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	cf 93       	push	r28
     96c:	df 93       	push	r29
     96e:	cd b7       	in	r28, 0x3d	; 61
     970:	de b7       	in	r29, 0x3e	; 62
	
	txFrame.id = MOTOR_CAN_ID;
     972:	08 eb       	ldi	r16, 0xB8	; 184
     974:	13 e0       	ldi	r17, 0x03	; 3
     976:	80 e5       	ldi	r24, 0x50	; 80
     978:	92 e0       	ldi	r25, 0x02	; 2
     97a:	f8 01       	movw	r30, r16
     97c:	91 83       	std	Z+1, r25	; 0x01
     97e:	80 83       	st	Z, r24
	txFrame.length = 8;
     980:	88 e0       	ldi	r24, 0x08	; 8
     982:	82 83       	std	Z+2, r24	; 0x02
	
	txFrame.data.u8[0] = vals.motor_status;
     984:	8d a1       	ldd	r24, Y+37	; 0x25
     986:	83 83       	std	Z+3, r24	; 0x03
	txFrame.data.i8[1] = (int8_t)(vals.f32_motor_current*10);
     988:	69 85       	ldd	r22, Y+9	; 0x09
     98a:	7a 85       	ldd	r23, Y+10	; 0x0a
     98c:	8b 85       	ldd	r24, Y+11	; 0x0b
     98e:	9c 85       	ldd	r25, Y+12	; 0x0c
     990:	20 e0       	ldi	r18, 0x00	; 0
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	40 e2       	ldi	r20, 0x20	; 32
     996:	51 e4       	ldi	r21, 0x41	; 65
     998:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     99c:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     9a0:	f8 01       	movw	r30, r16
     9a2:	64 83       	std	Z+4, r22	; 0x04
	txFrame.data.u16[1] = (uint16_t)(vals.f32_batt_volt*10);
     9a4:	69 89       	ldd	r22, Y+17	; 0x11
     9a6:	7a 89       	ldd	r23, Y+18	; 0x12
     9a8:	8b 89       	ldd	r24, Y+19	; 0x13
     9aa:	9c 89       	ldd	r25, Y+20	; 0x14
     9ac:	20 e0       	ldi	r18, 0x00	; 0
     9ae:	30 e0       	ldi	r19, 0x00	; 0
     9b0:	40 e2       	ldi	r20, 0x20	; 32
     9b2:	51 e4       	ldi	r21, 0x41	; 65
     9b4:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     9b8:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     9bc:	f8 01       	movw	r30, r16
     9be:	76 83       	std	Z+6, r23	; 0x06
     9c0:	65 83       	std	Z+5, r22	; 0x05
	txFrame.data.u16[2] = (uint16_t)abs((int16_t)vals.f32_energy/100.0) ;
     9c2:	6d 89       	ldd	r22, Y+21	; 0x15
     9c4:	7e 89       	ldd	r23, Y+22	; 0x16
     9c6:	8f 89       	ldd	r24, Y+23	; 0x17
     9c8:	98 8d       	ldd	r25, Y+24	; 0x18
     9ca:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     9ce:	07 2e       	mov	r0, r23
     9d0:	00 0c       	add	r0, r0
     9d2:	88 0b       	sbc	r24, r24
     9d4:	99 0b       	sbc	r25, r25
     9d6:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     9da:	20 e0       	ldi	r18, 0x00	; 0
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	48 ec       	ldi	r20, 0xC8	; 200
     9e0:	52 e4       	ldi	r21, 0x42	; 66
     9e2:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
     9e6:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     9ea:	9b 01       	movw	r18, r22
     9ec:	77 23       	and	r23, r23
     9ee:	24 f4       	brge	.+8      	; 0x9f8 <handle_motor_status_can_msg+0x92>
     9f0:	22 27       	eor	r18, r18
     9f2:	33 27       	eor	r19, r19
     9f4:	26 1b       	sub	r18, r22
     9f6:	37 0b       	sbc	r19, r23
     9f8:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <txFrame+0x8>
     9fc:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <txFrame+0x7>
	txFrame.data.u8[6] = (uint8_t)(vals.u16_car_speed*3.6*0.5) ; //sent in km/h
     a00:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a02:	7b 8d       	ldd	r23, Y+27	; 0x1b
     a04:	08 eb       	ldi	r16, 0xB8	; 184
     a06:	13 e0       	ldi	r17, 0x03	; 3
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     a10:	26 e6       	ldi	r18, 0x66	; 102
     a12:	36 e6       	ldi	r19, 0x66	; 102
     a14:	46 e6       	ldi	r20, 0x66	; 102
     a16:	50 e4       	ldi	r21, 0x40	; 64
     a18:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     a1c:	20 e0       	ldi	r18, 0x00	; 0
     a1e:	30 e0       	ldi	r19, 0x00	; 0
     a20:	40 e0       	ldi	r20, 0x00	; 0
     a22:	5f e3       	ldi	r21, 0x3F	; 63
     a24:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
     a28:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     a2c:	f8 01       	movw	r30, r16
     a2e:	61 87       	std	Z+9, r22	; 0x09
	txFrame.data.u8[7] = vals.u8_motor_temp;
     a30:	89 8d       	ldd	r24, Y+25	; 0x19
     a32:	82 87       	std	Z+10, r24	; 0x0a
		
	can_send_message(&txFrame);
     a34:	c8 01       	movw	r24, r16
     a36:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <can_send_message>
}
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	08 95       	ret

00000a44 <handle_clutch_cmd_can_msg>:

void handle_clutch_cmd_can_msg(volatile ModuleValues_t vals){
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	cd b7       	in	r28, 0x3d	; 61
     a4a:	de b7       	in	r29, 0x3e	; 62
	
	txFrame1.id = MOTOR_CL_CMD_CAN_ID;
     a4c:	ed ea       	ldi	r30, 0xAD	; 173
     a4e:	f3 e0       	ldi	r31, 0x03	; 3
     a50:	81 e5       	ldi	r24, 0x51	; 81
     a52:	92 e0       	ldi	r25, 0x02	; 2
     a54:	91 83       	std	Z+1, r25	; 0x01
     a56:	80 83       	st	Z, r24
	txFrame1.length = 1;
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	82 83       	std	Z+2, r24	; 0x02

	txFrame1.data.u8[0] = vals.gear_required;
     a5c:	21 96       	adiw	r28, 0x01	; 1
     a5e:	8f ad       	ldd	r24, Y+63	; 0x3f
     a60:	21 97       	sbiw	r28, 0x01	; 1
     a62:	83 83       	std	Z+3, r24	; 0x03
		
	can_send_message(&txFrame1);
     a64:	cf 01       	movw	r24, r30
     a66:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <can_send_message>
}
     a6a:	df 91       	pop	r29
     a6c:	cf 91       	pop	r28
     a6e:	08 95       	ret

00000a70 <receive_uart>:

///////////////////  UART  ////////////////////
//RECEIVING
//Send the commands via USB without a whitespace and terminate with \r\n 
void receive_uart(volatile ModuleValues_t * vals)
{
     a70:	af 92       	push	r10
     a72:	bf 92       	push	r11
     a74:	cf 92       	push	r12
     a76:	df 92       	push	r13
     a78:	ef 92       	push	r14
     a7a:	ff 92       	push	r15
     a7c:	0f 93       	push	r16
     a7e:	1f 93       	push	r17
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	cd b7       	in	r28, 0x3d	; 61
     a86:	de b7       	in	r29, 0x3e	; 62
     a88:	66 97       	sbiw	r28, 0x16	; 22
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	de bf       	out	0x3e, r29	; 62
     a90:	0f be       	out	0x3f, r0	; 63
     a92:	cd bf       	out	0x3d, r28	; 61
     a94:	6c 01       	movw	r12, r24
	
	char uart_characters_received[22] = {0};
     a96:	fe 01       	movw	r30, r28
     a98:	31 96       	adiw	r30, 0x01	; 1
     a9a:	96 e1       	ldi	r25, 0x16	; 22
     a9c:	df 01       	movw	r26, r30
     a9e:	1d 92       	st	X+, r1
     aa0:	9a 95       	dec	r25
     aa2:	e9 f7       	brne	.-6      	; 0xa9e <receive_uart+0x2e>
		int16_t uart0_getData(void); // reads single byte from a buffer // returns negative value if buffer is empty (upper byte is non zero)
		uint8_t uart0_LoadData(uint8_t *data); // reads single byte from a buffer and loads it into *data byte
		// in case of empty buffers returned flag is set to BUFFER_EMPTY - NULL
		
		extern volatile uint8_t rx0_Head, rx0_Tail;
		inline uint8_t uart0_AvailableBytes(void) { return (rx0_Head - rx0_Tail) & RX0_BUFFER_MASK; }
     aa4:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
     aa8:	20 91 e5 03 	lds	r18, 0x03E5	; 0x8003e5 <rx0_Tail>
	uint16_t uart_uint16_received = 0;

	if(uart_AvailableBytes() != 0)
     aac:	92 1b       	sub	r25, r18
     aae:	9f 71       	andi	r25, 0x1F	; 31
     ab0:	09 f4       	brne	.+2      	; 0xab4 <receive_uart+0x44>
     ab2:	4e c1       	rjmp	.+668    	; 0xd50 <receive_uart+0x2e0>
	{
		//IT IS ALWAYS ASSUMMED THAT CONTROLLER IS IN BELT MODE
		
		vals->message_mode = UART;
     ab4:	f6 01       	movw	r30, r12
     ab6:	17 8e       	std	Z+31, r1	; 0x1f
		vals->pwtrain_type = BELT;
     ab8:	12 a2       	std	Z+34, r1	; 0x22
		vals->ctrl_type = CURRENT;
     aba:	11 a2       	std	Z+33, r1	; 0x21
		
		uart0_getln(uart_characters_received, 22);				// reads until \r\n
     abc:	66 e1       	ldi	r22, 0x16	; 22
     abe:	ce 01       	movw	r24, r28
     ac0:	01 96       	adiw	r24, 0x01	; 1
     ac2:	08 d5       	rcall	.+2576   	; 0x14d4 <uart0_getln>
		uart_uint16_received = atoi(uart_characters_received);	//convert characters to integers ### may want to change the data type later if its fucking up
     ac4:	ce 01       	movw	r24, r28
     ac6:	01 96       	adiw	r24, 0x01	; 1
     ac8:	0e 94 a2 13 	call	0x2744	; 0x2744 <atoi>
     acc:	5c 01       	movw	r10, r24
     ace:	8c 01       	movw	r16, r24
		
		if((vals->motor_enabled == 0) && strcmp(uart_characters_received, "StartMotorControl") == 0)
     ad0:	d6 01       	movw	r26, r12
     ad2:	8d 91       	ld	r24, X+
     ad4:	9c 91       	ld	r25, X
     ad6:	89 2b       	or	r24, r25
     ad8:	71 f4       	brne	.+28     	; 0xaf6 <receive_uart+0x86>
     ada:	6f e4       	ldi	r22, 0x4F	; 79
     adc:	71 e0       	ldi	r23, 0x01	; 1
     ade:	ce 01       	movw	r24, r28
     ae0:	01 96       	adiw	r24, 0x01	; 1
     ae2:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     ae6:	89 2b       	or	r24, r25
     ae8:	31 f4       	brne	.+12     	; 0xaf6 <receive_uart+0x86>
		{
			//MOTOR: Start Current Control (ACCELERATION or DEACCELERATION)
			vals->ctrl_type = CURRENT;
     aea:	f6 01       	movw	r30, r12
     aec:	11 a2       	std	Z+33, r1	; 0x21
			vals->motor_enabled = 1;
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	91 83       	std	Z+1, r25	; 0x01
     af4:	80 83       	st	Z, r24
		}
		
		if((vals->motor_enabled) && strcmp(uart_characters_received, "StopMotorControl") == 0)
     af6:	d6 01       	movw	r26, r12
     af8:	8d 91       	ld	r24, X+
     afa:	9c 91       	ld	r25, X
     afc:	89 2b       	or	r24, r25
     afe:	71 f0       	breq	.+28     	; 0xb1c <receive_uart+0xac>
     b00:	61 e6       	ldi	r22, 0x61	; 97
     b02:	71 e0       	ldi	r23, 0x01	; 1
     b04:	ce 01       	movw	r24, r28
     b06:	01 96       	adiw	r24, 0x01	; 1
     b08:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     b0c:	89 2b       	or	r24, r25
     b0e:	31 f4       	brne	.+12     	; 0xb1c <receive_uart+0xac>
		{
			//MOTOR: Stop Current Control (ACCELERATION or DEACCELERATION)
			vals->motor_enabled = 0;
     b10:	f6 01       	movw	r30, r12
     b12:	11 82       	std	Z+1, r1	; 0x01
     b14:	10 82       	st	Z, r1
			vals->u8_accel_cmd = 0;
     b16:	17 8a       	std	Z+23, r1	; 0x17
			vals->u16_watchdog_throttle = 0;
     b18:	15 8e       	std	Z+29, r1	; 0x1d
     b1a:	14 8e       	std	Z+28, r1	; 0x1c
			
		}
		
		if(strcmp(uart_characters_received, "StartClutchControl") == 0)
     b1c:	62 e7       	ldi	r22, 0x72	; 114
     b1e:	71 e0       	ldi	r23, 0x01	; 1
     b20:	ce 01       	movw	r24, r28
     b22:	01 96       	adiw	r24, 0x01	; 1
     b24:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     b28:	89 2b       	or	r24, r25
     b2a:	11 f5       	brne	.+68     	; 0xb70 <receive_uart+0x100>
		{
			//ACTUATOR: Start clutch/actuator control/movement
			vals->clutch_enabled = 0; //disables the actuator P-controller from automatically handing actuator position based on statemachine
     b2c:	d6 01       	movw	r26, r12
     b2e:	94 96       	adiw	r26, 0x24	; 36
     b30:	1c 92       	st	X, r1
     b32:	1e 92       	st	-X, r1
     b34:	93 97       	sbiw	r26, 0x23	; 35
			switch(vals->gear_status){
     b36:	da 96       	adiw	r26, 0x3a	; 58
     b38:	8c 91       	ld	r24, X
     b3a:	81 30       	cpi	r24, 0x01	; 1
     b3c:	51 f0       	breq	.+20     	; 0xb52 <receive_uart+0xe2>
     b3e:	18 f0       	brcs	.+6      	; 0xb46 <receive_uart+0xd6>
     b40:	82 30       	cpi	r24, 0x02	; 2
     b42:	89 f0       	breq	.+34     	; 0xb66 <receive_uart+0xf6>
     b44:	15 c0       	rjmp	.+42     	; 0xb70 <receive_uart+0x100>
				case NEUTRAL:
					vals->position_uart_instruction = vals->position_neutral;
     b46:	f6 01       	movw	r30, r12
     b48:	84 a9       	ldd	r24, Z+52	; 0x34
     b4a:	95 a9       	ldd	r25, Z+53	; 0x35
     b4c:	93 ab       	std	Z+51, r25	; 0x33
     b4e:	82 ab       	std	Z+50, r24	; 0x32
				break;
     b50:	0f c0       	rjmp	.+30     	; 0xb70 <receive_uart+0x100>
				
				case GEAR1:
					vals->position_uart_instruction = vals->position_gear_1;
     b52:	d6 01       	movw	r26, r12
     b54:	d6 96       	adiw	r26, 0x36	; 54
     b56:	8d 91       	ld	r24, X+
     b58:	9c 91       	ld	r25, X
     b5a:	d7 97       	sbiw	r26, 0x37	; 55
     b5c:	d3 96       	adiw	r26, 0x33	; 51
     b5e:	9c 93       	st	X, r25
     b60:	8e 93       	st	-X, r24
     b62:	d2 97       	sbiw	r26, 0x32	; 50
				break;
     b64:	05 c0       	rjmp	.+10     	; 0xb70 <receive_uart+0x100>
				
				case GEAR2:
					vals->position_uart_instruction = vals->position_gear_2;
     b66:	f6 01       	movw	r30, r12
     b68:	80 ad       	ldd	r24, Z+56	; 0x38
     b6a:	91 ad       	ldd	r25, Z+57	; 0x39
     b6c:	93 ab       	std	Z+51, r25	; 0x33
     b6e:	82 ab       	std	Z+50, r24	; 0x32
				break;
			}
		}
		
		if(strcmp(uart_characters_received, "StopClutchControl") == 0)
     b70:	65 e8       	ldi	r22, 0x85	; 133
     b72:	71 e0       	ldi	r23, 0x01	; 1
     b74:	ce 01       	movw	r24, r28
     b76:	01 96       	adiw	r24, 0x01	; 1
     b78:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     b7c:	89 2b       	or	r24, r25
     b7e:	39 f4       	brne	.+14     	; 0xb8e <receive_uart+0x11e>
		{
			//ACTUATOR: Stop clutch/actuator control/movement
			vals->clutch_enabled = 1; //re-enable actuator P-controller
     b80:	81 e0       	ldi	r24, 0x01	; 1
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	d6 01       	movw	r26, r12
     b86:	94 96       	adiw	r26, 0x24	; 36
     b88:	9c 93       	st	X, r25
     b8a:	8e 93       	st	-X, r24
     b8c:	93 97       	sbiw	r26, 0x23	; 35
			//vals->u8_actuator_duty_cycle = 50; //
		}
		
		//CURRENT CONTROL: 0=10 deacceleration, 20=10 acceleration, 10=0 constant speed
		if((vals->motor_enabled) && ((uart_uint16_received > 10) & (uart_uint16_received <= 20)))
     b8e:	f6 01       	movw	r30, r12
     b90:	80 81       	ld	r24, Z
     b92:	91 81       	ldd	r25, Z+1	; 0x01
     b94:	89 2b       	or	r24, r25
     b96:	39 f0       	breq	.+14     	; 0xba6 <receive_uart+0x136>
     b98:	c5 01       	movw	r24, r10
     b9a:	0b 97       	sbiw	r24, 0x0b	; 11
     b9c:	0a 97       	sbiw	r24, 0x0a	; 10
     b9e:	18 f4       	brcc	.+6      	; 0xba6 <receive_uart+0x136>
		{
			//ACCELERATION
			vals->u8_accel_cmd = (uart_uint16_received - 10);
     ba0:	86 ef       	ldi	r24, 0xF6	; 246
     ba2:	8a 0d       	add	r24, r10
     ba4:	87 8b       	std	Z+23, r24	; 0x17
		}
		
		if((vals->motor_enabled) && (uart_uint16_received >= 0) & (uart_uint16_received < 10))
     ba6:	d6 01       	movw	r26, r12
     ba8:	8d 91       	ld	r24, X+
     baa:	9c 91       	ld	r25, X
     bac:	11 97       	sbiw	r26, 0x01	; 1
     bae:	89 2b       	or	r24, r25
     bb0:	39 f0       	breq	.+14     	; 0xbc0 <receive_uart+0x150>
     bb2:	0a 30       	cpi	r16, 0x0A	; 10
     bb4:	11 05       	cpc	r17, r1
     bb6:	20 f4       	brcc	.+8      	; 0xbc0 <receive_uart+0x150>
		{
			//DEACCELERATION
			vals->u8_brake_cmd = (UART_CONTROL_OFFSET - uart_uint16_received);		
     bb8:	8a e0       	ldi	r24, 0x0A	; 10
     bba:	8a 19       	sub	r24, r10
     bbc:	58 96       	adiw	r26, 0x18	; 24
     bbe:	8c 93       	st	X, r24
		}
		
		if((vals->motor_enabled) && (uart_uint16_received == 0))
     bc0:	f6 01       	movw	r30, r12
     bc2:	80 81       	ld	r24, Z
     bc4:	91 81       	ldd	r25, Z+1	; 0x01
     bc6:	89 2b       	or	r24, r25
     bc8:	31 f0       	breq	.+12     	; 0xbd6 <receive_uart+0x166>
     bca:	01 2b       	or	r16, r17
     bcc:	21 f4       	brne	.+8      	; 0xbd6 <receive_uart+0x166>
		{
			//STOP DRIVING MOTOR
			vals->u8_accel_cmd = 0;
     bce:	17 8a       	std	Z+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
     bd0:	10 8e       	std	Z+24, r1	; 0x18
			vals->u8_duty_cycle = 50;
     bd2:	82 e3       	ldi	r24, 0x32	; 50
     bd4:	81 8f       	std	Z+25, r24	; 0x19
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "n") == 0))
     bd6:	d6 01       	movw	r26, r12
     bd8:	93 96       	adiw	r26, 0x23	; 35
     bda:	8d 91       	ld	r24, X+
     bdc:	9c 91       	ld	r25, X
     bde:	94 97       	sbiw	r26, 0x24	; 36
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	51 f4       	brne	.+20     	; 0xbf8 <receive_uart+0x188>
     be4:	67 e9       	ldi	r22, 0x97	; 151
     be6:	71 e0       	ldi	r23, 0x01	; 1
     be8:	ce 01       	movw	r24, r28
     bea:	01 96       	adiw	r24, 0x01	; 1
     bec:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     bf0:	89 2b       	or	r24, r25
     bf2:	11 f4       	brne	.+4      	; 0xbf8 <receive_uart+0x188>
		{
			//ACTUATOR: go to neutral position
			vals->gear_required = NEUTRAL;
     bf4:	f6 01       	movw	r30, r12
     bf6:	13 ae       	std	Z+59, r1	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "f") == 0))
     bf8:	d6 01       	movw	r26, r12
     bfa:	93 96       	adiw	r26, 0x23	; 35
     bfc:	8d 91       	ld	r24, X+
     bfe:	9c 91       	ld	r25, X
     c00:	94 97       	sbiw	r26, 0x24	; 36
     c02:	01 97       	sbiw	r24, 0x01	; 1
     c04:	59 f4       	brne	.+22     	; 0xc1c <receive_uart+0x1ac>
     c06:	69 e9       	ldi	r22, 0x99	; 153
     c08:	71 e0       	ldi	r23, 0x01	; 1
     c0a:	ce 01       	movw	r24, r28
     c0c:	01 96       	adiw	r24, 0x01	; 1
     c0e:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     c12:	89 2b       	or	r24, r25
     c14:	19 f4       	brne	.+6      	; 0xc1c <receive_uart+0x1ac>
		{
			//ACTUATOR: go to first gear position 
			vals->gear_required = GEAR1;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	f6 01       	movw	r30, r12
     c1a:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 1) && (strcmp(uart_characters_received, "s") == 0))
     c1c:	d6 01       	movw	r26, r12
     c1e:	93 96       	adiw	r26, 0x23	; 35
     c20:	8d 91       	ld	r24, X+
     c22:	9c 91       	ld	r25, X
     c24:	94 97       	sbiw	r26, 0x24	; 36
     c26:	01 97       	sbiw	r24, 0x01	; 1
     c28:	59 f4       	brne	.+22     	; 0xc40 <receive_uart+0x1d0>
     c2a:	65 eb       	ldi	r22, 0xB5	; 181
     c2c:	71 e0       	ldi	r23, 0x01	; 1
     c2e:	ce 01       	movw	r24, r28
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     c36:	89 2b       	or	r24, r25
     c38:	19 f4       	brne	.+6      	; 0xc40 <receive_uart+0x1d0>
		{
			//ACTUATOR: go to second gear position 
			vals->gear_required = GEAR2;
     c3a:	82 e0       	ldi	r24, 0x02	; 2
     c3c:	f6 01       	movw	r30, r12
     c3e:	83 af       	std	Z+59, r24	; 0x3b
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "release") == 0))
     c40:	d6 01       	movw	r26, r12
     c42:	93 96       	adiw	r26, 0x23	; 35
     c44:	8d 91       	ld	r24, X+
     c46:	9c 91       	ld	r25, X
     c48:	94 97       	sbiw	r26, 0x24	; 36
     c4a:	89 2b       	or	r24, r25
     c4c:	59 f4       	brne	.+22     	; 0xc64 <receive_uart+0x1f4>
     c4e:	6b e9       	ldi	r22, 0x9B	; 155
     c50:	71 e0       	ldi	r23, 0x01	; 1
     c52:	ce 01       	movw	r24, r28
     c54:	01 96       	adiw	r24, 0x01	; 1
     c56:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     c5a:	89 2b       	or	r24, r25
     c5c:	19 f4       	brne	.+6      	; 0xc64 <receive_uart+0x1f4>
		{
			//ACTUATOR: STOP 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(0);
     c5e:	80 e0       	ldi	r24, 0x00	; 0
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	c8 da       	rcall	.-2672   	; 0x1f4 <actuator_pwm>
		}

		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "start") == 0))
     c64:	f6 01       	movw	r30, r12
     c66:	83 a1       	ldd	r24, Z+35	; 0x23
     c68:	94 a1       	ldd	r25, Z+36	; 0x24
     c6a:	89 2b       	or	r24, r25
     c6c:	59 f4       	brne	.+22     	; 0xc84 <receive_uart+0x214>
     c6e:	63 ea       	ldi	r22, 0xA3	; 163
     c70:	71 e0       	ldi	r23, 0x01	; 1
     c72:	ce 01       	movw	r24, r28
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     c7a:	89 2b       	or	r24, r25
     c7c:	19 f4       	brne	.+6      	; 0xc84 <receive_uart+0x214>
		{
			//ACTUATOR: START 50% PWM SIGNAL TO UN-LOCK THE ACTUATOR
			actuator_pwm(1);
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	b8 da       	rcall	.-2704   	; 0x1f4 <actuator_pwm>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setNeutralPos") == 0))
     c84:	d6 01       	movw	r26, r12
     c86:	93 96       	adiw	r26, 0x23	; 35
     c88:	8d 91       	ld	r24, X+
     c8a:	9c 91       	ld	r25, X
     c8c:	94 97       	sbiw	r26, 0x24	; 36
     c8e:	89 2b       	or	r24, r25
     c90:	a9 f4       	brne	.+42     	; 0xcbc <receive_uart+0x24c>
     c92:	69 ea       	ldi	r22, 0xA9	; 169
     c94:	71 e0       	ldi	r23, 0x01	; 1
     c96:	ce 01       	movw	r24, r28
     c98:	01 96       	adiw	r24, 0x01	; 1
     c9a:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     c9e:	89 2b       	or	r24, r25
     ca0:	69 f4       	brne	.+26     	; 0xcbc <receive_uart+0x24c>
		{
			vals->gear_required = NEUTRAL;
     ca2:	f6 01       	movw	r30, r12
     ca4:	13 ae       	std	Z+59, r1	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     ca6:	e0 ac       	ldd	r14, Z+56	; 0x38
     ca8:	f1 ac       	ldd	r15, Z+57	; 0x39
     caa:	06 a9       	ldd	r16, Z+54	; 0x36
     cac:	17 a9       	ldd	r17, Z+55	; 0x37
     cae:	24 a9       	ldd	r18, Z+52	; 0x34
     cb0:	35 a9       	ldd	r19, Z+53	; 0x35
     cb2:	42 a9       	ldd	r20, Z+50	; 0x32
     cb4:	53 a9       	ldd	r21, Z+51	; 0x33
     cb6:	62 ad       	ldd	r22, Z+58	; 0x3a
     cb8:	83 ad       	ldd	r24, Z+59	; 0x3b
     cba:	69 da       	rcall	.-2862   	; 0x18e <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setFirstGearPos") == 0))
     cbc:	d6 01       	movw	r26, r12
     cbe:	93 96       	adiw	r26, 0x23	; 35
     cc0:	8d 91       	ld	r24, X+
     cc2:	9c 91       	ld	r25, X
     cc4:	94 97       	sbiw	r26, 0x24	; 36
     cc6:	89 2b       	or	r24, r25
     cc8:	b1 f4       	brne	.+44     	; 0xcf6 <receive_uart+0x286>
     cca:	67 eb       	ldi	r22, 0xB7	; 183
     ccc:	71 e0       	ldi	r23, 0x01	; 1
     cce:	ce 01       	movw	r24, r28
     cd0:	01 96       	adiw	r24, 0x01	; 1
     cd2:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     cd6:	89 2b       	or	r24, r25
     cd8:	71 f4       	brne	.+28     	; 0xcf6 <receive_uart+0x286>
		{
			vals->gear_required = GEAR1;
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	f6 01       	movw	r30, r12
     cde:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     ce0:	e0 ac       	ldd	r14, Z+56	; 0x38
     ce2:	f1 ac       	ldd	r15, Z+57	; 0x39
     ce4:	06 a9       	ldd	r16, Z+54	; 0x36
     ce6:	17 a9       	ldd	r17, Z+55	; 0x37
     ce8:	24 a9       	ldd	r18, Z+52	; 0x34
     cea:	35 a9       	ldd	r19, Z+53	; 0x35
     cec:	42 a9       	ldd	r20, Z+50	; 0x32
     cee:	53 a9       	ldd	r21, Z+51	; 0x33
     cf0:	62 ad       	ldd	r22, Z+58	; 0x3a
     cf2:	83 ad       	ldd	r24, Z+59	; 0x3b
     cf4:	4c da       	rcall	.-2920   	; 0x18e <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && (strcmp(uart_characters_received, "setSecondGearPos") == 0))
     cf6:	d6 01       	movw	r26, r12
     cf8:	93 96       	adiw	r26, 0x23	; 35
     cfa:	8d 91       	ld	r24, X+
     cfc:	9c 91       	ld	r25, X
     cfe:	94 97       	sbiw	r26, 0x24	; 36
     d00:	89 2b       	or	r24, r25
     d02:	b1 f4       	brne	.+44     	; 0xd30 <receive_uart+0x2c0>
     d04:	67 ec       	ldi	r22, 0xC7	; 199
     d06:	71 e0       	ldi	r23, 0x01	; 1
     d08:	ce 01       	movw	r24, r28
     d0a:	01 96       	adiw	r24, 0x01	; 1
     d0c:	0e 94 bf 13 	call	0x277e	; 0x277e <strcmp>
     d10:	89 2b       	or	r24, r25
     d12:	71 f4       	brne	.+28     	; 0xd30 <receive_uart+0x2c0>
		{
			vals->gear_required = GEAR2;
     d14:	82 e0       	ldi	r24, 0x02	; 2
     d16:	f6 01       	movw	r30, r12
     d18:	83 af       	std	Z+59, r24	; 0x3b
			actuator_save_position(vals->gear_required, vals->gear_status, vals->position_uart_instruction, vals->position_neutral, vals->position_gear_1, vals->position_gear_2);
     d1a:	e0 ac       	ldd	r14, Z+56	; 0x38
     d1c:	f1 ac       	ldd	r15, Z+57	; 0x39
     d1e:	06 a9       	ldd	r16, Z+54	; 0x36
     d20:	17 a9       	ldd	r17, Z+55	; 0x37
     d22:	24 a9       	ldd	r18, Z+52	; 0x34
     d24:	35 a9       	ldd	r19, Z+53	; 0x35
     d26:	42 a9       	ldd	r20, Z+50	; 0x32
     d28:	53 a9       	ldd	r21, Z+51	; 0x33
     d2a:	62 ad       	ldd	r22, Z+58	; 0x3a
     d2c:	83 ad       	ldd	r24, Z+59	; 0x3b
     d2e:	2f da       	rcall	.-2978   	; 0x18e <actuator_save_position>
		}
		
		if((vals->clutch_enabled == 0) && ((uart_uint16_received > 0) &&  (uart_uint16_received < 1000)))
     d30:	d6 01       	movw	r26, r12
     d32:	93 96       	adiw	r26, 0x23	; 35
     d34:	8d 91       	ld	r24, X+
     d36:	9c 91       	ld	r25, X
     d38:	94 97       	sbiw	r26, 0x24	; 36
     d3a:	89 2b       	or	r24, r25
     d3c:	41 f4       	brne	.+16     	; 0xd4e <receive_uart+0x2de>
     d3e:	c5 01       	movw	r24, r10
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	87 3e       	cpi	r24, 0xE7	; 231
     d44:	93 40       	sbci	r25, 0x03	; 3
		{
			//vals->gear_required = NEUTRAL;
			vals->position_uart_instruction = uart_uint16_received;
     d46:	18 f4       	brcc	.+6      	; 0xd4e <receive_uart+0x2de>
     d48:	f6 01       	movw	r30, r12
     d4a:	b3 aa       	std	Z+51, r11	; 0x33
		}
		
		uart_flush();
     d4c:	a2 aa       	std	Z+50, r10	; 0x32
     d4e:	78 d3       	rcall	.+1776   	; 0x1440 <uart0_flush>
	}
}
     d50:	66 96       	adiw	r28, 0x16	; 22
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	de bf       	out	0x3e, r29	; 62
     d58:	0f be       	out	0x3f, r0	; 63
     d5a:	cd bf       	out	0x3d, r28	; 61
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	0f 91       	pop	r16
     d64:	ff 90       	pop	r15
     d66:	ef 90       	pop	r14
     d68:	df 90       	pop	r13
     d6a:	cf 90       	pop	r12
     d6c:	bf 90       	pop	r11
     d6e:	af 90       	pop	r10
     d70:	08 95       	ret

00000d72 <send_uart>:
		
		
//sending
//sends motor current and current cmd through USB
void send_uart(volatile ModuleValues_t vals)
{
     d72:	ef 92       	push	r14
     d74:	ff 92       	push	r15
     d76:	0f 93       	push	r16
     d78:	1f 93       	push	r17
     d7a:	cf 93       	push	r28
     d7c:	df 93       	push	r29
     d7e:	cd b7       	in	r28, 0x3d	; 61
     d80:	de b7       	in	r29, 0x3e	; 62
	printf("\r\n");
     d82:	88 ed       	ldi	r24, 0xD8	; 216
     d84:	91 e0       	ldi	r25, 0x01	; 1
     d86:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <puts>
	printf("%i", (int16_t)vals.actuator_in_position);
     d8a:	8e a5       	ldd	r24, Y+46	; 0x2e
     d8c:	9f a5       	ldd	r25, Y+47	; 0x2f
     d8e:	9f 93       	push	r25
     d90:	8f 93       	push	r24
     d92:	0f 2e       	mov	r0, r31
     d94:	fa ed       	ldi	r31, 0xDA	; 218
     d96:	ef 2e       	mov	r14, r31
     d98:	f1 e0       	ldi	r31, 0x01	; 1
     d9a:	ff 2e       	mov	r15, r31
     d9c:	f0 2d       	mov	r31, r0
     d9e:	ff 92       	push	r15
     da0:	ef 92       	push	r14
     da2:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     da6:	8c e2       	ldi	r24, 0x2C	; 44
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u", vals.gear_required);
     dae:	25 96       	adiw	r28, 0x05	; 5
     db0:	8f ad       	ldd	r24, Y+63	; 0x3f
     db2:	25 97       	sbiw	r28, 0x05	; 5
     db4:	1f 92       	push	r1
     db6:	8f 93       	push	r24
     db8:	0d ed       	ldi	r16, 0xDD	; 221
     dba:	11 e0       	ldi	r17, 0x01	; 1
     dbc:	1f 93       	push	r17
     dbe:	0f 93       	push	r16
     dc0:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     dc4:	8c e2       	ldi	r24, 0x2C	; 44
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.gear_status);
     dcc:	24 96       	adiw	r28, 0x04	; 4
     dce:	8f ad       	ldd	r24, Y+63	; 0x3f
     dd0:	24 97       	sbiw	r28, 0x04	; 4
     dd2:	1f 92       	push	r1
     dd4:	8f 93       	push	r24
     dd6:	1f 93       	push	r17
     dd8:	0f 93       	push	r16
     dda:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     dde:	8c e2       	ldi	r24, 0x2C	; 44
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u", vals.motor_status);
     de6:	8f a1       	ldd	r24, Y+39	; 0x27
     de8:	1f 92       	push	r1
     dea:	8f 93       	push	r24
     dec:	1f 93       	push	r17
     dee:	0f 93       	push	r16
     df0:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     df4:	8c e2       	ldi	r24, 0x2C	; 44
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.message_mode);
     dfc:	88 a5       	ldd	r24, Y+40	; 0x28
     dfe:	1f 92       	push	r1
     e00:	8f 93       	push	r24
     e02:	1f 93       	push	r17
     e04:	0f 93       	push	r16
     e06:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e0a:	8c e2       	ldi	r24, 0x2C	; 44
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.u8_duty_cycle);
     e12:	8a a1       	ldd	r24, Y+34	; 0x22
     e14:	1f 92       	push	r1
     e16:	8f 93       	push	r24
     e18:	1f 93       	push	r17
     e1a:	0f 93       	push	r16
     e1c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e20:	8c e2       	ldi	r24, 0x2C	; 44
     e22:	90 e0       	ldi	r25, 0x00	; 0
     e24:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	//printf("%u",vals.u8_accel_cmd);
	//printf(",");
	//printf("%u",vals.u8_brake_cmd);
	//printf(",");
	printf("%i",(int16_t)(vals.f32_batt_volt));
     e28:	6b 89       	ldd	r22, Y+19	; 0x13
     e2a:	7c 89       	ldd	r23, Y+20	; 0x14
     e2c:	8d 89       	ldd	r24, Y+21	; 0x15
     e2e:	9e 89       	ldd	r25, Y+22	; 0x16
     e30:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     e34:	7f 93       	push	r23
     e36:	6f 93       	push	r22
     e38:	ff 92       	push	r15
     e3a:	ef 92       	push	r14
     e3c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e40:	8c e2       	ldi	r24, 0x2C	; 44
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	//printf("%i",(int16_t)(vals.f32_motor_current));
	//printf(","); 
	//printf("%i",(int16_t)(vals.f32_batt_current*1000));
	//printf(",");
	printf("%i",(int16_t)(vals.f32_actuator_feedback));
     e48:	6c a9       	ldd	r22, Y+52	; 0x34
     e4a:	7d a9       	ldd	r23, Y+53	; 0x35
     e4c:	8e a9       	ldd	r24, Y+54	; 0x36
     e4e:	9f a9       	ldd	r25, Y+55	; 0x37
     e50:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     e54:	7f 93       	push	r23
     e56:	6f 93       	push	r22
     e58:	ff 92       	push	r15
     e5a:	ef 92       	push	r14
     e5c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e60:	0f b6       	in	r0, 0x3f	; 63
     e62:	f8 94       	cli
     e64:	de bf       	out	0x3e, r29	; 62
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	cd bf       	out	0x3d, r28	; 61
     e6a:	8c e2       	ldi	r24, 0x2C	; 44
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	//printf("%u",vals.position_uart_instruction);
	//printf(",");
	printf("%i",vals.motor_enabled);
     e72:	89 85       	ldd	r24, Y+9	; 0x09
     e74:	9a 85       	ldd	r25, Y+10	; 0x0a
     e76:	9f 93       	push	r25
     e78:	8f 93       	push	r24
     e7a:	ff 92       	push	r15
     e7c:	ef 92       	push	r14
     e7e:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e82:	8c e2       	ldi	r24, 0x2C	; 44
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%i",vals.clutch_enabled);
     e8a:	8c a5       	ldd	r24, Y+44	; 0x2c
     e8c:	9d a5       	ldd	r25, Y+45	; 0x2d
     e8e:	9f 93       	push	r25
     e90:	8f 93       	push	r24
     e92:	ff 92       	push	r15
     e94:	ef 92       	push	r14
     e96:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     e9a:	8c e2       	ldi	r24, 0x2C	; 44
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.position_neutral);
     ea2:	8d ad       	ldd	r24, Y+61	; 0x3d
     ea4:	9e ad       	ldd	r25, Y+62	; 0x3e
     ea6:	9f 93       	push	r25
     ea8:	8f 93       	push	r24
     eaa:	1f 93       	push	r17
     eac:	0f 93       	push	r16
     eae:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     eb2:	8c e2       	ldi	r24, 0x2C	; 44
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.position_gear_1);
     eba:	21 96       	adiw	r28, 0x01	; 1
     ebc:	8e ad       	ldd	r24, Y+62	; 0x3e
     ebe:	9f ad       	ldd	r25, Y+63	; 0x3f
     ec0:	21 97       	sbiw	r28, 0x01	; 1
     ec2:	9f 93       	push	r25
     ec4:	8f 93       	push	r24
     ec6:	1f 93       	push	r17
     ec8:	0f 93       	push	r16
     eca:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     ece:	8c e2       	ldi	r24, 0x2C	; 44
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%u",vals.position_gear_2);	
     ed6:	23 96       	adiw	r28, 0x03	; 3
     ed8:	8e ad       	ldd	r24, Y+62	; 0x3e
     eda:	9f ad       	ldd	r25, Y+63	; 0x3f
     edc:	23 97       	sbiw	r28, 0x03	; 3
     ede:	9f 93       	push	r25
     ee0:	8f 93       	push	r24
     ee2:	1f 93       	push	r17
     ee4:	0f 93       	push	r16
     ee6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     eea:	8c e2       	ldi	r24, 0x2C	; 44
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	//printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
	//printf(",");
	printf("%i", (int16_t)vals.u8_actuator_duty_cycle);
     ef2:	88 ad       	ldd	r24, Y+56	; 0x38
     ef4:	1f 92       	push	r1
     ef6:	8f 93       	push	r24
     ef8:	ff 92       	push	r15
     efa:	ef 92       	push	r14
     efc:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	printf(",");
     f00:	8c e2       	ldi	r24, 0x2C	; 44
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <putchar>
	printf("%i", (int16_t)vals.uart_debug);
     f08:	68 a9       	ldd	r22, Y+48	; 0x30
     f0a:	79 a9       	ldd	r23, Y+49	; 0x31
     f0c:	8a a9       	ldd	r24, Y+50	; 0x32
     f0e:	9b a9       	ldd	r25, Y+51	; 0x33
     f10:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     f14:	7f 93       	push	r23
     f16:	6f 93       	push	r22
     f18:	ff 92       	push	r15
     f1a:	ef 92       	push	r14
     f1c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <printf>
	
}
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	f8 94       	cli
     f24:	de bf       	out	0x3e, r29	; 62
     f26:	0f be       	out	0x3f, r0	; 63
     f28:	cd bf       	out	0x3d, r28	; 61
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	1f 91       	pop	r17
     f30:	0f 91       	pop	r16
     f32:	ff 90       	pop	r15
     f34:	ef 90       	pop	r14
     f36:	08 95       	ret

00000f38 <manage_LEDs>:

///////////////// LED /////////////////////
void manage_LEDs(volatile ModuleValues_t vals)
{	
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
	switch (vals.motor_status)
     f40:	8b a1       	ldd	r24, Y+35	; 0x23
     f42:	82 30       	cpi	r24, 0x02	; 2
     f44:	91 f1       	breq	.+100    	; 0xfaa <manage_LEDs+0x72>
     f46:	28 f4       	brcc	.+10     	; 0xf52 <manage_LEDs+0x1a>
     f48:	88 23       	and	r24, r24
     f4a:	49 f0       	breq	.+18     	; 0xf5e <manage_LEDs+0x26>
     f4c:	81 30       	cpi	r24, 0x01	; 1
     f4e:	19 f1       	breq	.+70     	; 0xf96 <manage_LEDs+0x5e>
     f50:	49 c0       	rjmp	.+146    	; 0xfe4 <manage_LEDs+0xac>
     f52:	84 30       	cpi	r24, 0x04	; 4
     f54:	f1 f1       	breq	.+124    	; 0xfd2 <manage_LEDs+0x9a>
     f56:	98 f1       	brcs	.+102    	; 0xfbe <manage_LEDs+0x86>
     f58:	85 30       	cpi	r24, 0x05	; 5
     f5a:	99 f0       	breq	.+38     	; 0xf82 <manage_LEDs+0x4a>
     f5c:	43 c0       	rjmp	.+134    	; 0xfe4 <manage_LEDs+0xac>
	{
		case OFF :
			rgbled_turn_off(LED_GREEN);
     f5e:	80 e4       	ldi	r24, 0x40	; 64
     f60:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_on(LED_BLUE);
     f64:	80 e8       	ldi	r24, 0x80	; 128
     f66:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
			if (vals.u16_watchdog_can == 0) //no can messages
     f6a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f6c:	98 a1       	ldd	r25, Y+32	; 0x20
     f6e:	89 2b       	or	r24, r25
     f70:	21 f4       	brne	.+8      	; 0xf7a <manage_LEDs+0x42>
			{
				rgbled_turn_on(LED_RED);
     f72:	80 e2       	ldi	r24, 0x20	; 32
     f74:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
     f78:	35 c0       	rjmp	.+106    	; 0xfe4 <manage_LEDs+0xac>
			}else{
				rgbled_turn_off(LED_RED);
     f7a:	80 e2       	ldi	r24, 0x20	; 32
     f7c:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
     f80:	31 c0       	rjmp	.+98     	; 0xfe4 <manage_LEDs+0xac>
			}
		break ;
		
		case ENGAGE :
			rgbled_turn_off(LED_RED);
     f82:	80 e2       	ldi	r24, 0x20	; 32
     f84:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     f88:	80 e4       	ldi	r24, 0x40	; 64
     f8a:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
			rgbled_turn_on(LED_BLUE);
     f8e:	80 e8       	ldi	r24, 0x80	; 128
     f90:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
		break ;
     f94:	27 c0       	rjmp	.+78     	; 0xfe4 <manage_LEDs+0xac>
		
		case ACCEL :
			rgbled_turn_off(LED_RED);
     f96:	80 e2       	ldi	r24, 0x20	; 32
     f98:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     f9c:	80 e8       	ldi	r24, 0x80	; 128
     f9e:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fa2:	80 e4       	ldi	r24, 0x40	; 64
     fa4:	0e 94 09 11 	call	0x2212	; 0x2212 <rgbled_toggle>
		break;
     fa8:	1d c0       	rjmp	.+58     	; 0xfe4 <manage_LEDs+0xac>
		
		case BRAKE :
			rgbled_turn_off(LED_BLUE);
     faa:	80 e8       	ldi	r24, 0x80	; 128
     fac:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_toggle(LED_GREEN);
     fb0:	80 e4       	ldi	r24, 0x40	; 64
     fb2:	0e 94 09 11 	call	0x2212	; 0x2212 <rgbled_toggle>
			rgbled_toggle(LED_RED);
     fb6:	80 e2       	ldi	r24, 0x20	; 32
     fb8:	0e 94 09 11 	call	0x2212	; 0x2212 <rgbled_toggle>
		break;
     fbc:	13 c0       	rjmp	.+38     	; 0xfe4 <manage_LEDs+0xac>
		
		case IDLE :
			rgbled_turn_off(LED_RED);
     fbe:	80 e2       	ldi	r24, 0x20	; 32
     fc0:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fc4:	80 e8       	ldi	r24, 0x80	; 128
     fc6:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_on(LED_GREEN);
     fca:	80 e4       	ldi	r24, 0x40	; 64
     fcc:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
		break;
     fd0:	09 c0       	rjmp	.+18     	; 0xfe4 <manage_LEDs+0xac>
		
		case ERR :
			rgbled_turn_off(LED_GREEN);
     fd2:	80 e4       	ldi	r24, 0x40	; 64
     fd4:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_off(LED_BLUE);
     fd8:	80 e8       	ldi	r24, 0x80	; 128
     fda:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <rgbled_turn_off>
			rgbled_turn_on(LED_RED);
     fde:	80 e2       	ldi	r24, 0x20	; 32
     fe0:	0e 94 04 11 	call	0x2208	; 0x2208 <rgbled_turn_on>
		break;
	}
     fe4:	df 91       	pop	r29
     fe6:	cf 91       	pop	r28
     fe8:	08 95       	ret

00000fea <speed_init>:
static uint16_t u16_speed_array [4];

void speed_init()
{
	//pin
	DDRE &= ~(1<<PD1); //define pin as input
     fea:	69 98       	cbi	0x0d, 1	; 13
	PORTE &= ~(1<<PD1); //no pull-up
     fec:	71 98       	cbi	0x0e, 1	; 14
	//int
	EIMSK &= ~(1<<INT1) ; // interrupt disable to prevent interrupt raise during init
     fee:	e9 98       	cbi	0x1d, 1	; 29
	#ifdef SPEED_SENSOR_REED
	EICRA |= (1<<ISC10)|(1<<ISC10); // interrupt on rising edge
	#endif
	
	#ifdef SPEED_SENSOR_HALL
	EICRA |= (1<<ISC10); // interrupt on rising and falling edge
     ff0:	e9 e6       	ldi	r30, 0x69	; 105
     ff2:	f0 e0       	ldi	r31, 0x00	; 0
     ff4:	80 81       	ld	r24, Z
     ff6:	84 60       	ori	r24, 0x04	; 4
     ff8:	80 83       	st	Z, r24
	#endif
		
	EIFR |= (1<<INTF1) ; // clear flag
     ffa:	e1 9a       	sbi	0x1c, 1	; 28
	EIMSK |= (1<<INT1) ; // interrupt enable
     ffc:	e9 9a       	sbi	0x1d, 1	; 29
     ffe:	08 95       	ret

00001000 <handle_speed_sensor>:
		u16_speed_array[n] = 0;
	}
}

void handle_speed_sensor(volatile uint16_t *u16_speed, volatile uint16_t *u16_counter) // period in 1ms
{
    1000:	0f 93       	push	r16
    1002:	1f 93       	push	r17
    1004:	cf 93       	push	r28
    1006:	df 93       	push	r29
	
	if (*u16_counter > 70)
    1008:	fb 01       	movw	r30, r22
    100a:	20 81       	ld	r18, Z
    100c:	31 81       	ldd	r19, Z+1	; 0x01
    100e:	27 34       	cpi	r18, 0x47	; 71
    1010:	31 05       	cpc	r19, r1
    1012:	b8 f0       	brcs	.+46     	; 0x1042 <handle_speed_sensor+0x42>
    1014:	eb 01       	movw	r28, r22
    1016:	8c 01       	movw	r16, r24
	{
		*u16_speed = (uint16_t)(f32_speed_ratio/((float)*u16_counter));
    1018:	60 81       	ld	r22, Z
    101a:	71 81       	ldd	r23, Z+1	; 0x01
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
    1024:	9b 01       	movw	r18, r22
    1026:	ac 01       	movw	r20, r24
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	76 e7       	ldi	r23, 0x76	; 118
    102c:	88 e8       	ldi	r24, 0x88	; 136
    102e:	96 e4       	ldi	r25, 0x46	; 70
    1030:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
    1034:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
    1038:	f8 01       	movw	r30, r16
    103a:	71 83       	std	Z+1, r23	; 0x01
    103c:	60 83       	st	Z, r22
		*u16_counter = 0 ;
    103e:	19 82       	std	Y+1, r1	; 0x01
    1040:	18 82       	st	Y, r1
	}	
}
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	08 95       	ret

0000104c <compute_synch_duty>:

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
    104c:	cf 92       	push	r12
    104e:	df 92       	push	r13
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	cf 93       	push	r28
    1056:	df 93       	push	r29
    1058:	1f 92       	push	r1
    105a:	cd b7       	in	r28, 0x3d	; 61
    105c:	de b7       	in	r29, 0x3e	; 62
    105e:	89 83       	std	Y+1, r24	; 0x01
    1060:	69 01       	movw	r12, r18
    1062:	7a 01       	movw	r14, r20
	uint8_t Duty = 50 ;
	if (gear == GEAR1)//gear powertrain
    1064:	61 30       	cpi	r22, 0x01	; 1
    1066:	19 f5       	brne	.+70     	; 0x10ae <compute_synch_duty+0x62>
	{
		Duty = (speed_10ms*DUTY_CALC1/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5
    1068:	69 81       	ldd	r22, Y+1	; 0x01
    106a:	70 e0       	ldi	r23, 0x00	; 0
    106c:	80 e0       	ldi	r24, 0x00	; 0
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
    1074:	22 e1       	ldi	r18, 0x12	; 18
    1076:	35 e8       	ldi	r19, 0x85	; 133
    1078:	41 e6       	ldi	r20, 0x61	; 97
    107a:	5e e3       	ldi	r21, 0x3E	; 62
    107c:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    1080:	a7 01       	movw	r20, r14
    1082:	96 01       	movw	r18, r12
    1084:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
    1088:	20 e0       	ldi	r18, 0x00	; 0
    108a:	30 e0       	ldi	r19, 0x00	; 0
    108c:	48 ec       	ldi	r20, 0xC8	; 200
    108e:	52 e4       	ldi	r21, 0x42	; 66
    1090:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    1094:	20 e0       	ldi	r18, 0x00	; 0
    1096:	30 e0       	ldi	r19, 0x00	; 0
    1098:	48 e4       	ldi	r20, 0x48	; 72
    109a:	52 e4       	ldi	r21, 0x42	; 66
    109c:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
    10a0:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
    10a4:	86 2f       	mov	r24, r22
		if (Duty == 50)
    10a6:	62 33       	cpi	r22, 0x32	; 50
    10a8:	29 f5       	brne	.+74     	; 0x10f4 <compute_synch_duty+0xa8>
		{
			Duty = 52 ;
    10aa:	84 e3       	ldi	r24, 0x34	; 52
    10ac:	23 c0       	rjmp	.+70     	; 0x10f4 <compute_synch_duty+0xa8>
		}		
	}
	//ATTENTION - IF GEAR TWO IS IMPLEMENTED THEN THIS MUST BE CHANGED BECAUSE GEAR2 IS USED FOR "BELT" MODE (MOTORS ARE MANUALLY MOVED AND THEN LOCKED WITH BOLT AND THE ACTUATOR IS DISABLED)
	if (gear == GEAR2)//for belt powertrain
    10ae:	62 30       	cpi	r22, 0x02	; 2
    10b0:	01 f5       	brne	.+64     	; 0x10f2 <compute_synch_duty+0xa6>
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
    10b2:	69 81       	ldd	r22, Y+1	; 0x01
    10b4:	70 e0       	ldi	r23, 0x00	; 0
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
    10be:	23 ee       	ldi	r18, 0xE3	; 227
    10c0:	3e ee       	ldi	r19, 0xEE	; 238
    10c2:	4b e3       	ldi	r20, 0x3B	; 59
    10c4:	5e e3       	ldi	r21, 0x3E	; 62
    10c6:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    10ca:	a7 01       	movw	r20, r14
    10cc:	96 01       	movw	r18, r12
    10ce:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
    10d2:	20 e0       	ldi	r18, 0x00	; 0
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	48 ec       	ldi	r20, 0xC8	; 200
    10d8:	52 e4       	ldi	r21, 0x42	; 66
    10da:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    10de:	20 e0       	ldi	r18, 0x00	; 0
    10e0:	30 e0       	ldi	r19, 0x00	; 0
    10e2:	48 e4       	ldi	r20, 0x48	; 72
    10e4:	52 e4       	ldi	r21, 0x42	; 66
    10e6:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
    10ea:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
    10ee:	86 2f       	mov	r24, r22
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <compute_synch_duty+0xa8>
	}	
}

uint8_t compute_synch_duty(volatile uint8_t speed_10ms, ClutchState_t gear, float vbatt) // computing the duty cycle to reach synchronous speed before engaging the gears
{
	uint8_t Duty = 50 ;
    10f2:	82 e3       	ldi	r24, 0x32	; 50
	if (gear == GEAR2)//for belt powertrain
	{
		Duty = (speed_10ms*DUTY_CALC2/vbatt)*100 + 50 ;// Vm/2Vbatt +0.5	
	}
	return Duty ;
}
    10f4:	0f 90       	pop	r0
    10f6:	df 91       	pop	r29
    10f8:	cf 91       	pop	r28
    10fa:	ff 90       	pop	r15
    10fc:	ef 90       	pop	r14
    10fe:	df 90       	pop	r13
    1100:	cf 90       	pop	r12
    1102:	08 95       	ret

00001104 <state_handler>:
static uint8_t starting_engage = 0;
//static uint8_t engage_count = 0;
uint16_t actuator_target_position = 0;

void state_handler(volatile ModuleValues_t * vals)
{
    1104:	cf 93       	push	r28
    1106:	df 93       	push	r29
    1108:	ec 01       	movw	r28, r24
		}else if(b_major_fault && fault_clear_count < 3){
		b_major_fault = 0;
	} */
	
	//uart is not spamming the UM so must reload watchdog timer here
	if(vals->message_mode == UART){
    110a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    110c:	81 11       	cpse	r24, r1
    110e:	08 c0       	rjmp	.+16     	; 0x1120 <state_handler+0x1c>
		vals->u16_watchdog_can = WATCHDOG_CAN_RELOAD_VALUE;
    1110:	82 e3       	ldi	r24, 0x32	; 50
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	9b 8f       	std	Y+27, r25	; 0x1b
    1116:	8a 8f       	std	Y+26, r24	; 0x1a
		vals->u16_watchdog_throttle = WATCHDOG_THROTTLE_RELOAD_VALUE;
    1118:	8e e1       	ldi	r24, 0x1E	; 30
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	9d 8f       	std	Y+29, r25	; 0x1d
    111e:	8c 8f       	std	Y+28, r24	; 0x1c
			b_major_fault = 1;
			fault_timeout = 600 ;
			fault_clear_count ++;
		}
	}
	if (fault_timeout > 0)
    1120:	80 91 fd 01 	lds	r24, 0x01FD	; 0x8001fd <fault_timeout>
    1124:	90 91 fe 01 	lds	r25, 0x01FE	; 0x8001fe <fault_timeout+0x1>
    1128:	00 97       	sbiw	r24, 0x00	; 0
    112a:	31 f0       	breq	.+12     	; 0x1138 <state_handler+0x34>
	{
		fault_timeout -- ;
    112c:	01 97       	sbiw	r24, 0x01	; 1
    112e:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <fault_timeout+0x1>
    1132:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <fault_timeout>
    1136:	05 c0       	rjmp	.+10     	; 0x1142 <state_handler+0x3e>
	}else if(b_major_fault && fault_clear_count < 3){
    1138:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    113c:	81 11       	cpse	r24, r1
		b_major_fault = 0;
    113e:	10 92 ff 01 	sts	0x01FF, r1	; 0x8001ff <b_major_fault>
	}

	switch(vals->motor_status)
    1142:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1144:	82 30       	cpi	r24, 0x02	; 2
    1146:	09 f4       	brne	.+2      	; 0x114a <state_handler+0x46>
    1148:	b7 c0       	rjmp	.+366    	; 0x12b8 <state_handler+0x1b4>
    114a:	30 f4       	brcc	.+12     	; 0x1158 <state_handler+0x54>
    114c:	88 23       	and	r24, r24
    114e:	61 f0       	breq	.+24     	; 0x1168 <state_handler+0x64>
    1150:	81 30       	cpi	r24, 0x01	; 1
    1152:	09 f4       	brne	.+2      	; 0x1156 <state_handler+0x52>
    1154:	8f c0       	rjmp	.+286    	; 0x1274 <state_handler+0x170>
    1156:	e1 c0       	rjmp	.+450    	; 0x131a <state_handler+0x216>
    1158:	84 30       	cpi	r24, 0x04	; 4
    115a:	09 f4       	brne	.+2      	; 0x115e <state_handler+0x5a>
    115c:	cf c0       	rjmp	.+414    	; 0x12fc <state_handler+0x1f8>
    115e:	a0 f0       	brcs	.+40     	; 0x1188 <state_handler+0x84>
    1160:	85 30       	cpi	r24, 0x05	; 5
    1162:	09 f4       	brne	.+2      	; 0x1166 <state_handler+0x62>
    1164:	51 c0       	rjmp	.+162    	; 0x1208 <state_handler+0x104>
    1166:	d9 c0       	rjmp	.+434    	; 0x131a <state_handler+0x216>
	{
		case OFF:
			//transition 1 (see documentation for the state machine description)
			if (vals->u16_watchdog_can > 0 && b_board_powered)
    1168:	8a 8d       	ldd	r24, Y+26	; 0x1a
    116a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    116c:	89 2b       	or	r24, r25
    116e:	11 f0       	breq	.+4      	; 0x1174 <state_handler+0x70>
			{
				vals->motor_status = IDLE;
    1170:	83 e0       	ldi	r24, 0x03	; 3
    1172:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			//During
			drivers(0);//drivers shutdown
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	a5 da       	rcall	.-2742   	; 0x6c2 <drivers>
			vals->b_driver_status = 0;
			reset_I(); //reset integrator
    1178:	18 a2       	std	Y+32, r1	; 0x20
    117a:	30 d9       	rcall	.-3488   	; 0x3dc <reset_I>
			vals->u8_brake_cmd = 0;
    117c:	18 8e       	std	Y+24, r1	; 0x18
			vals->u8_accel_cmd = 0;
    117e:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_duty_cycle = 50;
    1180:	82 e3       	ldi	r24, 0x32	; 50
    1182:	89 8f       	std	Y+25, r24	; 0x19
			vals->gear_required = NEUTRAL ;
    1184:	1b ae       	std	Y+59, r1	; 0x3b
		
		break;
    1186:	c9 c0       	rjmp	.+402    	; 0x131a <state_handler+0x216>
		
		case IDLE: 
		
			if (vals->pwtrain_type == BELT)
    1188:	8a a1       	ldd	r24, Y+34	; 0x22
    118a:	81 11       	cpse	r24, r1
			{
				//controller(vals);
				drivers(0); //disable
    118c:	24 c0       	rjmp	.+72     	; 0x11d6 <state_handler+0xd2>
    118e:	99 da       	rcall	.-2766   	; 0x6c2 <drivers>
				reset_I();
    1190:	25 d9       	rcall	.-3510   	; 0x3dc <reset_I>
    1192:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1194:	89 8f       	std	Y+25, r24	; 0x19
    1196:	88 8d       	ldd	r24, Y+24	; 0x18
				
				//transition 7
				if (vals->u8_brake_cmd > 0)
    1198:	88 23       	and	r24, r24
    119a:	69 f0       	breq	.+26     	; 0x11b6 <state_handler+0xb2>
    119c:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    119e:	3b 85       	ldd	r19, Y+11	; 0x0b
    11a0:	4c 85       	ldd	r20, Y+12	; 0x0c
    11a2:	5d 85       	ldd	r21, Y+13	; 0x0d
    11a4:	8b 89       	ldd	r24, Y+19	; 0x13
    11a6:	9c 89       	ldd	r25, Y+20	; 0x14
    11a8:	62 e0       	ldi	r22, 0x02	; 2
    11aa:	50 df       	rcall	.-352    	; 0x104c <compute_synch_duty>
    11ac:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11ae:	89 8d       	ldd	r24, Y+25	; 0x19
    11b0:	1e d9       	rcall	.-3524   	; 0x3ee <set_I>
    11b2:	82 e0       	ldi	r24, 0x02	; 2
					vals->motor_status = BRAKE;
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
    11b6:	8f 89       	ldd	r24, Y+23	; 0x17
				}
				//transition 5
				if (vals->u8_accel_cmd > 0)
    11b8:	88 23       	and	r24, r24
    11ba:	69 f0       	breq	.+26     	; 0x11d6 <state_handler+0xd2>
    11bc:	2a 85       	ldd	r18, Y+10	; 0x0a
				{
					vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, GEAR2, vals->f32_batt_volt) ; //Setting duty
    11be:	3b 85       	ldd	r19, Y+11	; 0x0b
    11c0:	4c 85       	ldd	r20, Y+12	; 0x0c
    11c2:	5d 85       	ldd	r21, Y+13	; 0x0d
    11c4:	8b 89       	ldd	r24, Y+19	; 0x13
    11c6:	9c 89       	ldd	r25, Y+20	; 0x14
    11c8:	62 e0       	ldi	r22, 0x02	; 2
    11ca:	40 df       	rcall	.-384    	; 0x104c <compute_synch_duty>
    11cc:	89 8f       	std	Y+25, r24	; 0x19
					set_I(vals->u8_duty_cycle) ; //set integrator
    11ce:	89 8d       	ldd	r24, Y+25	; 0x19
    11d0:	0e d9       	rcall	.-3556   	; 0x3ee <set_I>
    11d2:	81 e0       	ldi	r24, 0x01	; 1
					vals->motor_status = ACCEL;
    11d4:	8e 8f       	std	Y+30, r24	; 0x1e
    11d6:	8a a1       	ldd	r24, Y+34	; 0x22
				}
			}
			
			if (vals->pwtrain_type == GEAR)
    11d8:	81 30       	cpi	r24, 0x01	; 1
    11da:	09 f0       	breq	.+2      	; 0x11de <state_handler+0xda>
    11dc:	9e c0       	rjmp	.+316    	; 0x131a <state_handler+0x216>
    11de:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				//transition 5
				if ((vals->u8_accel_cmd > 0 || vals->u8_brake_cmd > 0) && vals->gear_status == NEUTRAL)
    11e0:	81 11       	cpse	r24, r1
    11e2:	03 c0       	rjmp	.+6      	; 0x11ea <state_handler+0xe6>
    11e4:	88 8d       	ldd	r24, Y+24	; 0x18
    11e6:	88 23       	and	r24, r24
    11e8:	41 f0       	breq	.+16     	; 0x11fa <state_handler+0xf6>
    11ea:	8a ad       	ldd	r24, Y+58	; 0x3a
    11ec:	81 11       	cpse	r24, r1
    11ee:	05 c0       	rjmp	.+10     	; 0x11fa <state_handler+0xf6>
				{
					vals->motor_status = ENGAGE;
    11f0:	85 e0       	ldi	r24, 0x05	; 5
					starting_engage = 1;
    11f2:	8e 8f       	std	Y+30, r24	; 0x1e
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				}
				drivers(0); //disable
    11fa:	80 e0       	ldi	r24, 0x00	; 0
    11fc:	62 da       	rcall	.-2876   	; 0x6c2 <drivers>
				vals->gear_required = NEUTRAL ;
    11fe:	1b ae       	std	Y+59, r1	; 0x3b
				reset_I();
    1200:	ed d8       	rcall	.-3622   	; 0x3dc <reset_I>
    1202:	82 e3       	ldi	r24, 0x32	; 50
				vals->u8_duty_cycle = 50 ;
    1204:	89 8f       	std	Y+25, r24	; 0x19
    1206:	89 c0       	rjmp	.+274    	; 0x131a <state_handler+0x216>
    1208:	81 e0       	ldi	r24, 0x01	; 1
			
		break;
		
		case ENGAGE: // /!\ TODO : with the two gears, all turning motion has to be inverted for the inner gear.
			
			vals->gear_required = GEAR1;
    120a:	8b af       	std	Y+59, r24	; 0x3b
    120c:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <starting_engage>
			if (starting_engage)
    1210:	88 23       	and	r24, r24
    1212:	69 f0       	breq	.+26     	; 0x122e <state_handler+0x12a>
			{
				vals->u8_duty_cycle = compute_synch_duty(vals->u16_car_speed, vals->gear_required, vals->f32_batt_volt) ; //Setting duty
    1214:	2a 85       	ldd	r18, Y+10	; 0x0a
    1216:	3b 85       	ldd	r19, Y+11	; 0x0b
    1218:	4c 85       	ldd	r20, Y+12	; 0x0c
    121a:	5d 85       	ldd	r21, Y+13	; 0x0d
    121c:	6b ad       	ldd	r22, Y+59	; 0x3b
    121e:	8b 89       	ldd	r24, Y+19	; 0x13
    1220:	9c 89       	ldd	r25, Y+20	; 0x14
    1222:	14 df       	rcall	.-472    	; 0x104c <compute_synch_duty>
				set_I(vals->u8_duty_cycle) ; //set integrator
    1224:	89 8f       	std	Y+25, r24	; 0x19
    1226:	89 8d       	ldd	r24, Y+25	; 0x19
    1228:	e2 d8       	rcall	.-3644   	; 0x3ee <set_I>
				starting_engage = 0;
    122a:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <starting_engage>
			}
			//save_ctrl_type = vals->ctrl_type ; // PWM type ctrl is needed only for the engagement process. The mode will be reverted to previous in ACCEL and BRAKE modes
			vals->ctrl_type = PWM ;
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	89 a3       	std	Y+33, r24	; 0x21
			controller(vals) ; //speed up motor to synch speed
    1232:	ce 01       	movw	r24, r28
    1234:	f7 d8       	rcall	.-3602   	; 0x424 <controller>
    1236:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    1238:	44 da       	rcall	.-2936   	; 0x6c2 <drivers>
    123a:	88 8d       	ldd	r24, Y+24	; 0x18
    123c:	88 23       	and	r24, r24
			
			*/
			//*****************--------------------------------TESTING END--------------------------*****************
			
			//transition 9, GEAR
			if (vals->u8_brake_cmd > 0 && vals->gear_status == GEAR1)
    123e:	29 f0       	breq	.+10     	; 0x124a <state_handler+0x146>
    1240:	8a ad       	ldd	r24, Y+58	; 0x3a
    1242:	81 30       	cpi	r24, 0x01	; 1
    1244:	11 f4       	brne	.+4      	; 0x124a <state_handler+0x146>
    1246:	82 e0       	ldi	r24, 0x02	; 2
    1248:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = BRAKE;
    124a:	8f 89       	ldd	r24, Y+23	; 0x17
    124c:	88 23       	and	r24, r24
			}
			//transition 10, GEAR
			if (vals->u8_accel_cmd > 0 && vals->gear_status == GEAR1)
    124e:	21 f0       	breq	.+8      	; 0x1258 <state_handler+0x154>
    1250:	8a ad       	ldd	r24, Y+58	; 0x3a
    1252:	81 30       	cpi	r24, 0x01	; 1
    1254:	09 f4       	brne	.+2      	; 0x1258 <state_handler+0x154>
    1256:	8e 8f       	std	Y+30, r24	; 0x1e
    1258:	8f 89       	ldd	r24, Y+23	; 0x17
			{
				vals->motor_status = ACCEL;
    125a:	81 11       	cpse	r24, r1
			}
			//transition 11, GEAR
			if (vals->u8_accel_cmd == 0 && vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    125c:	5e c0       	rjmp	.+188    	; 0x131a <state_handler+0x216>
    125e:	88 8d       	ldd	r24, Y+24	; 0x18
    1260:	81 11       	cpse	r24, r1
    1262:	5b c0       	rjmp	.+182    	; 0x131a <state_handler+0x216>
    1264:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1266:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1268:	89 2b       	or	r24, r25
    126a:	09 f0       	breq	.+2      	; 0x126e <state_handler+0x16a>
    126c:	56 c0       	rjmp	.+172    	; 0x131a <state_handler+0x216>
			{
				vals->motor_status = IDLE;
    126e:	83 e0       	ldi	r24, 0x03	; 3
    1270:	8e 8f       	std	Y+30, r24	; 0x1e
    1272:	53 c0       	rjmp	.+166    	; 0x131a <state_handler+0x216>
			}
		break;
		
		case ACCEL:			
			vals->ctrl_type = CURRENT;
    1274:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals);
    1276:	ce 01       	movw	r24, r28
    1278:	d5 d8       	rcall	.-3670   	; 0x424 <controller>
    127a:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    127c:	22 da       	rcall	.-3004   	; 0x6c2 <drivers>
    127e:	8f 89       	ldd	r24, Y+23	; 0x17
    1280:	81 11       	cpse	r24, r1
			//transition 6
			if (vals->u8_accel_cmd == 0 && vals->u16_watchdog_throttle == 0)
    1282:	06 c0       	rjmp	.+12     	; 0x1290 <state_handler+0x18c>
    1284:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1286:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1288:	89 2b       	or	r24, r25
    128a:	11 f4       	brne	.+4      	; 0x1290 <state_handler+0x18c>
    128c:	83 e0       	ldi	r24, 0x03	; 3
    128e:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    1290:	8a a1       	ldd	r24, Y+34	; 0x22
    1292:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 12, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    1294:	41 f4       	brne	.+16     	; 0x12a6 <state_handler+0x1a2>
    1296:	8a ad       	ldd	r24, Y+58	; 0x3a
    1298:	81 11       	cpse	r24, r1
    129a:	05 c0       	rjmp	.+10     	; 0x12a6 <state_handler+0x1a2>
    129c:	85 e0       	ldi	r24, 0x05	; 5
    129e:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12a0:	81 e0       	ldi	r24, 0x01	; 1
				starting_engage = 1;
    12a2:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
			}
			//transition 14
			if (vals->u8_brake_cmd > 0 && vals->u8_accel_cmd == 0)
    12a6:	88 8d       	ldd	r24, Y+24	; 0x18
    12a8:	88 23       	and	r24, r24
    12aa:	b9 f1       	breq	.+110    	; 0x131a <state_handler+0x216>
    12ac:	8f 89       	ldd	r24, Y+23	; 0x17
    12ae:	81 11       	cpse	r24, r1
    12b0:	34 c0       	rjmp	.+104    	; 0x131a <state_handler+0x216>
			{
				vals->motor_status = BRAKE;
    12b2:	82 e0       	ldi	r24, 0x02	; 2
    12b4:	8e 8f       	std	Y+30, r24	; 0x1e
    12b6:	31 c0       	rjmp	.+98     	; 0x131a <state_handler+0x216>
			}
		break;
		
		case BRAKE:
			vals->ctrl_type = CURRENT ;
    12b8:	19 a2       	std	Y+33, r1	; 0x21
			controller(vals); //negative throttle cmd
    12ba:	ce 01       	movw	r24, r28
    12bc:	b3 d8       	rcall	.-3738   	; 0x424 <controller>
    12be:	81 e0       	ldi	r24, 0x01	; 1
			drivers(1);
    12c0:	00 da       	rcall	.-3072   	; 0x6c2 <drivers>
    12c2:	88 8d       	ldd	r24, Y+24	; 0x18
    12c4:	81 11       	cpse	r24, r1
			//transition 8
			if (vals->u8_brake_cmd == 0 && vals->u16_watchdog_throttle == 0)
    12c6:	06 c0       	rjmp	.+12     	; 0x12d4 <state_handler+0x1d0>
    12c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12cc:	89 2b       	or	r24, r25
    12ce:	11 f4       	brne	.+4      	; 0x12d4 <state_handler+0x1d0>
    12d0:	83 e0       	ldi	r24, 0x03	; 3
    12d2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = IDLE;
    12d4:	8a a1       	ldd	r24, Y+34	; 0x22
    12d6:	81 30       	cpi	r24, 0x01	; 1
			}
			//transition 13, GEAR
			if (vals->pwtrain_type == GEAR && vals->gear_status == NEUTRAL)
    12d8:	41 f4       	brne	.+16     	; 0x12ea <state_handler+0x1e6>
    12da:	8a ad       	ldd	r24, Y+58	; 0x3a
    12dc:	81 11       	cpse	r24, r1
    12de:	05 c0       	rjmp	.+10     	; 0x12ea <state_handler+0x1e6>
    12e0:	85 e0       	ldi	r24, 0x05	; 5
    12e2:	8e 8f       	std	Y+30, r24	; 0x1e
			{
				vals->motor_status = ENGAGE;
    12e4:	81 e0       	ldi	r24, 0x01	; 1
    12e6:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <starting_engage>
				starting_engage = 1;
    12ea:	88 8d       	ldd	r24, Y+24	; 0x18
			}
			//transition 15
			if (vals->u8_brake_cmd == 0 && vals->u8_accel_cmd > 0)
    12ec:	81 11       	cpse	r24, r1
    12ee:	15 c0       	rjmp	.+42     	; 0x131a <state_handler+0x216>
    12f0:	8f 89       	ldd	r24, Y+23	; 0x17
    12f2:	88 23       	and	r24, r24
    12f4:	91 f0       	breq	.+36     	; 0x131a <state_handler+0x216>
			{
				vals->motor_status = ACCEL;
    12f6:	81 e0       	ldi	r24, 0x01	; 1
    12f8:	8e 8f       	std	Y+30, r24	; 0x1e
    12fa:	0f c0       	rjmp	.+30     	; 0x131a <state_handler+0x216>
		
		case ERR:
			//transition 4
			//ATTENTION: "TAKEN OUT": && vals->u8_motor_temp < MAX_TEMP
			//TODO: Implement what the actuator should do when in error mode 
			if (!b_major_fault)
    12fc:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <b_major_fault>
    1300:	81 11       	cpse	r24, r1
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <state_handler+0x204>
			{
				vals->motor_status = IDLE;
    1304:	83 e0       	ldi	r24, 0x03	; 3
    1306:	8e 8f       	std	Y+30, r24	; 0x1e
			}
			drivers(0);//drivers shutdown
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	db d9       	rcall	.-3146   	; 0x6c2 <drivers>
    130c:	18 a2       	std	Y+32, r1	; 0x20
			vals->b_driver_status = 0;
    130e:	1b ae       	std	Y+59, r1	; 0x3b
			vals->gear_required = NEUTRAL;
    1310:	65 d8       	rcall	.-3894   	; 0x3dc <reset_I>
			reset_I(); //reset integrator
    1312:	18 8e       	std	Y+24, r1	; 0x18
    1314:	1f 8a       	std	Y+23, r1	; 0x17
			vals->u8_brake_cmd = 0;
    1316:	82 e3       	ldi	r24, 0x32	; 50
			vals->u8_accel_cmd = 0;
    1318:	89 8f       	std	Y+25, r24	; 0x19
			vals->u8_duty_cycle = 50;
    131a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    131c:	83 30       	cpi	r24, 0x03	; 3
		break;	
	}
	
	if ((vals->motor_status == IDLE || vals->motor_status == ACCEL || vals->motor_status == BRAKE || vals->motor_status == ENGAGE) && (vals->u16_watchdog_can == 0 || !b_board_powered))
    131e:	49 f0       	breq	.+18     	; 0x1332 <state_handler+0x22e>
    1320:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1322:	81 30       	cpi	r24, 0x01	; 1
    1324:	31 f0       	breq	.+12     	; 0x1332 <state_handler+0x22e>
    1326:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1328:	82 30       	cpi	r24, 0x02	; 2
    132a:	19 f0       	breq	.+6      	; 0x1332 <state_handler+0x22e>
    132c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    132e:	85 30       	cpi	r24, 0x05	; 5
    1330:	29 f4       	brne	.+10     	; 0x133c <state_handler+0x238>
    1332:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1334:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1336:	89 2b       	or	r24, r25
    1338:	09 f4       	brne	.+2      	; 0x133c <state_handler+0x238>
    133a:	1e 8e       	std	Y+30, r1	; 0x1e
    133c:	df 91       	pop	r29
	{
		// transition 2
		vals->motor_status = OFF;
    133e:	cf 91       	pop	r28
	if (b_major_fault || vals->u8_motor_temp >= MAX_TEMP) //over current, over voltage, over temp
	{
		//transition 3
		vals->motor_status = ERR;
	}*/
}
    1340:	08 95       	ret

00001342 <pwm_init>:
#include "pwm.h"
#include <avr/interrupt.h>
#include <avr/io.h>

void pwm_init(void)
{
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
	}else{//UNIPOLAR
		
		//Set pwm_pins as output;
		//PE3: MOTOR, H-BRIDGE, PE4: MOTOR, H-BRIDGE, PE5: ACTUATOR
		
		PORTE &= ~((1<<PE3)|(1<<PE4)|(1<<PE5));
    1346:	8e b1       	in	r24, 0x0e	; 14
    1348:	87 7c       	andi	r24, 0xC7	; 199
    134a:	8e b9       	out	0x0e, r24	; 14
		DDRE |= (1<<PE3)|(1<<PE4)|(1<<PE5);
    134c:	8d b1       	in	r24, 0x0d	; 13
    134e:	88 63       	ori	r24, 0x38	; 56
    1350:	8d b9       	out	0x0d, r24	; 13
		
		//Timer 3 phase correct pwm, TOP at ICR (mode 10)
		TCCR3B |= (1<<WGM33);
    1352:	a1 e9       	ldi	r26, 0x91	; 145
    1354:	b0 e0       	ldi	r27, 0x00	; 0
    1356:	8c 91       	ld	r24, X
    1358:	80 61       	ori	r24, 0x10	; 16
    135a:	8c 93       	st	X, r24
		TCCR3B &= ~(1<<WGM32);
    135c:	8c 91       	ld	r24, X
    135e:	87 7f       	andi	r24, 0xF7	; 247
    1360:	8c 93       	st	X, r24
		TCCR3A |= (1<<WGM31);
    1362:	e0 e9       	ldi	r30, 0x90	; 144
    1364:	f0 e0       	ldi	r31, 0x00	; 0
    1366:	80 81       	ld	r24, Z
    1368:	82 60       	ori	r24, 0x02	; 2
    136a:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<WGM30);
    136c:	80 81       	ld	r24, Z
    136e:	8e 7f       	andi	r24, 0xFE	; 254
    1370:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3A on Compare Match when up-counting. clear OC3A on Compare Match when downcounting.
		TCCR3A |= (1<<COM3A1);
    1372:	80 81       	ld	r24, Z
    1374:	80 68       	ori	r24, 0x80	; 128
    1376:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3A0);
    1378:	80 81       	ld	r24, Z
    137a:	8f 7b       	andi	r24, 0xBF	; 191
    137c:	80 83       	st	Z, r24
		
		//MOTOR PWM: H-BRIDGE
		// Set OC3B on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3B1);
    137e:	80 81       	ld	r24, Z
    1380:	80 62       	ori	r24, 0x20	; 32
    1382:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3B0);
    1384:	80 81       	ld	r24, Z
    1386:	8f 7e       	andi	r24, 0xEF	; 239
    1388:	80 83       	st	Z, r24
		
		//ACTUATOR PWM:
		// Set OC3C on Compare Match when up-counting. Clear OC3B on Compare Match when downcounting.
		TCCR3A |= (1<<COM3C1);
    138a:	80 81       	ld	r24, Z
    138c:	88 60       	ori	r24, 0x08	; 8
    138e:	80 83       	st	Z, r24
		TCCR3A &= ~(1<<COM3C0);
    1390:	80 81       	ld	r24, Z
    1392:	8b 7f       	andi	r24, 0xFB	; 251
    1394:	80 83       	st	Z, r24
		
		//Set prescale clk/1 for timer 3
		TCCR3B |= (1<<CS30);
    1396:	8c 91       	ld	r24, X
    1398:	81 60       	ori	r24, 0x01	; 1
    139a:	8c 93       	st	X, r24
		TCCR3B &= ~((1<<CS32)|(1<<CS31));
    139c:	8c 91       	ld	r24, X
    139e:	89 7f       	andi	r24, 0xF9	; 249
    13a0:	8c 93       	st	X, r24
		
		//Set top value for timer 3
		ICR3 = 0x85; //30kHz  0x85, 20kHz : 0x100
    13a2:	c6 e9       	ldi	r28, 0x96	; 150
    13a4:	d0 e0       	ldi	r29, 0x00	; 0
    13a6:	85 e8       	ldi	r24, 0x85	; 133
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	99 83       	std	Y+1, r25	; 0x01
    13ac:	88 83       	st	Y, r24
		
		//initialising compare registers at Duty cycle 50%
		OCR3A = (int)((0.5)*ICR3) ;		//OUTPUT PIN, PWM_PE3, MOTOR PWM: H-BRIDGE
    13ae:	68 81       	ld	r22, Y
    13b0:	79 81       	ldd	r23, Y+1	; 0x01
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
    13ba:	20 e0       	ldi	r18, 0x00	; 0
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	40 e0       	ldi	r20, 0x00	; 0
    13c0:	5f e3       	ldi	r21, 0x3F	; 63
    13c2:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    13c6:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
    13ca:	e8 e9       	ldi	r30, 0x98	; 152
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	71 83       	std	Z+1, r23	; 0x01
    13d0:	60 83       	st	Z, r22
		OCR3B = ICR3-OCR3A ;			//OUTPUT PIN, PWM_PE4, MOTOR PWM: H-BRIDGE
    13d2:	88 81       	ld	r24, Y
    13d4:	99 81       	ldd	r25, Y+1	; 0x01
    13d6:	20 81       	ld	r18, Z
    13d8:	31 81       	ldd	r19, Z+1	; 0x01
    13da:	82 1b       	sub	r24, r18
    13dc:	93 0b       	sbc	r25, r19
    13de:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    13e2:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
		OCR3C = (int)((0.5)*ICR3);		//OUTPUT PIN, PWM_PE5, ACTUATOR PWM: ACTUATOR H-BRIDGE DRIVER
    13e6:	68 81       	ld	r22, Y
    13e8:	79 81       	ldd	r23, Y+1	; 0x01
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
    13f2:	20 e0       	ldi	r18, 0x00	; 0
    13f4:	30 e0       	ldi	r19, 0x00	; 0
    13f6:	40 e0       	ldi	r20, 0x00	; 0
    13f8:	5f e3       	ldi	r21, 0x3F	; 63
    13fa:	0e 94 36 13 	call	0x266c	; 0x266c <__mulsf3>
    13fe:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
    1402:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    1406:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
	}
}
    140a:	df 91       	pop	r29
    140c:	cf 91       	pop	r28
    140e:	08 95       	ret

00001410 <uart0_putc>:
    1410:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <tx0_Head>
    1414:	9f 5f       	subi	r25, 0xFF	; 255
    1416:	9f 71       	andi	r25, 0x1F	; 31
    1418:	20 91 e4 03 	lds	r18, 0x03E4	; 0x8003e4 <tx0_Tail>
    141c:	92 17       	cp	r25, r18
    141e:	e1 f3       	breq	.-8      	; 0x1418 <uart0_putc+0x8>
    1420:	e9 2f       	mov	r30, r25
    1422:	f0 e0       	ldi	r31, 0x00	; 0
    1424:	e5 5d       	subi	r30, 0xD5	; 213
    1426:	fb 4f       	sbci	r31, 0xFB	; 251
    1428:	80 83       	st	Z, r24
    142a:	2f b7       	in	r18, 0x3f	; 63
    142c:	f8 94       	cli
    142e:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <tx0_Head>
    1432:	e1 ec       	ldi	r30, 0xC1	; 193
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	80 81       	ld	r24, Z
    1438:	80 62       	ori	r24, 0x20	; 32
    143a:	80 83       	st	Z, r24
    143c:	2f bf       	out	0x3f, r18	; 63
    143e:	08 95       	ret

00001440 <uart0_flush>:
    1440:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <tx0_Tail>
    1444:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <tx0_Head>
    1448:	98 13       	cpse	r25, r24
    144a:	fa cf       	rjmp	.-12     	; 0x1440 <uart0_flush>
    144c:	08 95       	ret

0000144e <uart1_putc>:
    144e:	90 91 2a 04 	lds	r25, 0x042A	; 0x80042a <tx1_Head>
    1452:	9f 5f       	subi	r25, 0xFF	; 255
    1454:	9f 71       	andi	r25, 0x1F	; 31
    1456:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <tx1_Tail>
    145a:	92 17       	cp	r25, r18
    145c:	e1 f3       	breq	.-8      	; 0x1456 <uart1_putc+0x8>
    145e:	e9 2f       	mov	r30, r25
    1460:	f0 e0       	ldi	r31, 0x00	; 0
    1462:	ea 51       	subi	r30, 0x1A	; 26
    1464:	fc 4f       	sbci	r31, 0xFC	; 252
    1466:	80 83       	st	Z, r24
    1468:	2f b7       	in	r18, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <tx1_Head>
    1470:	e9 ec       	ldi	r30, 0xC9	; 201
    1472:	f0 e0       	ldi	r31, 0x00	; 0
    1474:	80 81       	ld	r24, Z
    1476:	80 62       	ori	r24, 0x20	; 32
    1478:	80 83       	st	Z, r24
    147a:	2f bf       	out	0x3f, r18	; 63
    147c:	08 95       	ret

0000147e <uart_putchar>:
    147e:	cf 93       	push	r28
    1480:	c8 2f       	mov	r28, r24
    1482:	fb 01       	movw	r30, r22
    1484:	84 85       	ldd	r24, Z+12	; 0x0c
    1486:	95 85       	ldd	r25, Z+13	; 0x0d
    1488:	01 97       	sbiw	r24, 0x01	; 1
    148a:	39 f0       	breq	.+14     	; 0x149a <uart_putchar+0x1c>
    148c:	ca 30       	cpi	r28, 0x0A	; 10
    148e:	11 f4       	brne	.+4      	; 0x1494 <uart_putchar+0x16>
    1490:	8d e0       	ldi	r24, 0x0D	; 13
    1492:	be df       	rcall	.-132    	; 0x1410 <uart0_putc>
    1494:	8c 2f       	mov	r24, r28
    1496:	bc df       	rcall	.-136    	; 0x1410 <uart0_putc>
    1498:	06 c0       	rjmp	.+12     	; 0x14a6 <uart_putchar+0x28>
    149a:	ca 30       	cpi	r28, 0x0A	; 10
    149c:	11 f4       	brne	.+4      	; 0x14a2 <uart_putchar+0x24>
    149e:	8d e0       	ldi	r24, 0x0D	; 13
    14a0:	d6 df       	rcall	.-84     	; 0x144e <uart1_putc>
    14a2:	8c 2f       	mov	r24, r28
    14a4:	d4 df       	rcall	.-88     	; 0x144e <uart1_putc>
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	cf 91       	pop	r28
    14ac:	08 95       	ret

000014ae <uart0_getc>:
    14ae:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    14b2:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    14b6:	89 17       	cp	r24, r25
    14b8:	59 f0       	breq	.+22     	; 0x14d0 <uart0_getc+0x22>
    14ba:	8f 5f       	subi	r24, 0xFF	; 255
    14bc:	98 2f       	mov	r25, r24
    14be:	9f 71       	andi	r25, 0x1F	; 31
    14c0:	e9 2f       	mov	r30, r25
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	ed 53       	subi	r30, 0x3D	; 61
    14c6:	fc 4f       	sbci	r31, 0xFC	; 252
    14c8:	80 81       	ld	r24, Z
    14ca:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <rx0_Tail>
    14ce:	08 95       	ret
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	08 95       	ret

000014d4 <uart0_getln>:
    14d4:	0f 93       	push	r16
    14d6:	1f 93       	push	r17
    14d8:	cf 93       	push	r28
    14da:	df 93       	push	r29
    14dc:	ec 01       	movw	r28, r24
    14de:	61 30       	cpi	r22, 0x01	; 1
    14e0:	b1 f0       	breq	.+44     	; 0x150e <uart0_getln+0x3a>
    14e2:	62 50       	subi	r22, 0x02	; 2
    14e4:	06 2f       	mov	r16, r22
    14e6:	10 e0       	ldi	r17, 0x00	; 0
    14e8:	0f 5f       	subi	r16, 0xFF	; 255
    14ea:	1f 4f       	sbci	r17, 0xFF	; 255
    14ec:	08 0f       	add	r16, r24
    14ee:	19 1f       	adc	r17, r25
    14f0:	de df       	rcall	.-68     	; 0x14ae <uart0_getc>
    14f2:	88 83       	st	Y, r24
    14f4:	88 23       	and	r24, r24
    14f6:	e1 f3       	breq	.-8      	; 0x14f0 <uart0_getln+0x1c>
    14f8:	8d 30       	cpi	r24, 0x0D	; 13
    14fa:	21 f4       	brne	.+8      	; 0x1504 <uart0_getln+0x30>
    14fc:	d8 df       	rcall	.-80     	; 0x14ae <uart0_getc>
    14fe:	88 23       	and	r24, r24
    1500:	e9 f3       	breq	.-6      	; 0x14fc <uart0_getln+0x28>
    1502:	05 c0       	rjmp	.+10     	; 0x150e <uart0_getln+0x3a>
    1504:	21 96       	adiw	r28, 0x01	; 1
    1506:	c0 17       	cp	r28, r16
    1508:	d1 07       	cpc	r29, r17
    150a:	91 f7       	brne	.-28     	; 0x14f0 <uart0_getln+0x1c>
    150c:	e8 01       	movw	r28, r16
    150e:	18 82       	st	Y, r1
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	08 95       	ret

0000151a <uart0_getData>:
    151a:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <rx0_Tail>
    151e:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <rx0_Head>
    1522:	89 17       	cp	r24, r25
    1524:	61 f0       	breq	.+24     	; 0x153e <uart0_getData+0x24>
    1526:	8f 5f       	subi	r24, 0xFF	; 255
    1528:	8f 71       	andi	r24, 0x1F	; 31
    152a:	e8 2f       	mov	r30, r24
    152c:	f0 e0       	ldi	r31, 0x00	; 0
    152e:	ed 53       	subi	r30, 0x3D	; 61
    1530:	fc 4f       	sbci	r31, 0xFC	; 252
    1532:	90 81       	ld	r25, Z
    1534:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <rx0_Tail>
    1538:	89 2f       	mov	r24, r25
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	08 95       	ret
    153e:	8f ef       	ldi	r24, 0xFF	; 255
    1540:	9f ef       	ldi	r25, 0xFF	; 255
    1542:	08 95       	ret

00001544 <uart1_getData>:
    1544:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <rx1_Tail>
    1548:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <rx1_Head>
    154c:	89 17       	cp	r24, r25
    154e:	61 f0       	breq	.+24     	; 0x1568 <uart1_getData+0x24>
    1550:	8f 5f       	subi	r24, 0xFF	; 255
    1552:	8f 71       	andi	r24, 0x1F	; 31
    1554:	e8 2f       	mov	r30, r24
    1556:	f0 e0       	ldi	r31, 0x00	; 0
    1558:	e9 5f       	subi	r30, 0xF9	; 249
    155a:	fb 4f       	sbci	r31, 0xFB	; 251
    155c:	90 81       	ld	r25, Z
    155e:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <rx1_Tail>
    1562:	89 2f       	mov	r24, r25
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	08 95       	ret
    1568:	8f ef       	ldi	r24, 0xFF	; 255
    156a:	9f ef       	ldi	r25, 0xFF	; 255
    156c:	08 95       	ret

0000156e <uart_getchar>:
    156e:	cf 93       	push	r28
    1570:	df 93       	push	r29
    1572:	fc 01       	movw	r30, r24
    1574:	84 85       	ldd	r24, Z+12	; 0x0c
    1576:	95 85       	ldd	r25, Z+13	; 0x0d
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	41 f0       	breq	.+16     	; 0x158c <uart_getchar+0x1e>
    157c:	ce df       	rcall	.-100    	; 0x151a <uart0_getData>
    157e:	ec 01       	movw	r28, r24
    1580:	99 23       	and	r25, r25
    1582:	e4 f3       	brlt	.-8      	; 0x157c <uart_getchar+0xe>
    1584:	45 df       	rcall	.-374    	; 0x1410 <uart0_putc>
    1586:	ce 01       	movw	r24, r28
    1588:	99 27       	eor	r25, r25
    158a:	07 c0       	rjmp	.+14     	; 0x159a <uart_getchar+0x2c>
    158c:	db df       	rcall	.-74     	; 0x1544 <uart1_getData>
    158e:	ec 01       	movw	r28, r24
    1590:	99 23       	and	r25, r25
    1592:	e4 f3       	brlt	.-8      	; 0x158c <uart_getchar+0x1e>
    1594:	5c df       	rcall	.-328    	; 0x144e <uart1_putc>
    1596:	ce 01       	movw	r24, r28
    1598:	99 27       	eor	r25, r25
    159a:	99 27       	eor	r25, r25
    159c:	df 91       	pop	r29
    159e:	cf 91       	pop	r28
    15a0:	08 95       	ret

000015a2 <__vector_22>:
    15a2:	0f 93       	push	r16
    15a4:	0f b7       	in	r16, 0x3f	; 63
    15a6:	ef 93       	push	r30
    15a8:	ff 93       	push	r31
    15aa:	e0 91 e4 03 	lds	r30, 0x03E4	; 0x8003e4 <tx0_Tail>
    15ae:	f0 91 06 04 	lds	r31, 0x0406	; 0x800406 <tx0_Head>
    15b2:	e3 95       	inc	r30
    15b4:	ef 71       	andi	r30, 0x1F	; 31
    15b6:	ef 13       	cpse	r30, r31
    15b8:	05 c0       	rjmp	.+10     	; 0x15c4 <USART0_TX_CONTINUE>
    15ba:	f0 91 c1 00 	lds	r31, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    15be:	ff 7d       	andi	r31, 0xDF	; 223
    15c0:	f0 93 c1 00 	sts	0x00C1, r31	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

000015c4 <USART0_TX_CONTINUE>:
    15c4:	e0 93 e4 03 	sts	0x03E4, r30	; 0x8003e4 <tx0_Tail>
    15c8:	f0 e0       	ldi	r31, 0x00	; 0
    15ca:	e5 5d       	subi	r30, 0xD5	; 213
    15cc:	fb 4f       	sbci	r31, 0xFB	; 251
    15ce:	e0 81       	ld	r30, Z
    15d0:	e0 93 c6 00 	sts	0x00C6, r30	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

000015d4 <USART0_TX_EXIT>:
    15d4:	ff 91       	pop	r31
    15d6:	ef 91       	pop	r30
    15d8:	0f bf       	out	0x3f, r16	; 63
    15da:	0f 91       	pop	r16
    15dc:	18 95       	reti

000015de <__vector_21>:
    15de:	0f 93       	push	r16
    15e0:	0f b7       	in	r16, 0x3f	; 63
    15e2:	9f 93       	push	r25
    15e4:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    15e8:	ef 93       	push	r30
    15ea:	ff 93       	push	r31
    15ec:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <rx0_Head>
    15f0:	f0 91 e5 03 	lds	r31, 0x03E5	; 0x8003e5 <rx0_Tail>
    15f4:	e3 95       	inc	r30
    15f6:	ef 71       	andi	r30, 0x1F	; 31
    15f8:	fe 17       	cp	r31, r30
    15fa:	31 f0       	breq	.+12     	; 0x1608 <USART0_RX_EXIT>
    15fc:	e0 93 27 04 	sts	0x0427, r30	; 0x800427 <rx0_Head>
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	ed 53       	subi	r30, 0x3D	; 61
    1604:	fc 4f       	sbci	r31, 0xFC	; 252
    1606:	90 83       	st	Z, r25

00001608 <USART0_RX_EXIT>:
    1608:	ff 91       	pop	r31
    160a:	ef 91       	pop	r30
    160c:	9f 91       	pop	r25
    160e:	0f bf       	out	0x3f, r16	; 63
    1610:	0f 91       	pop	r16
    1612:	18 95       	reti

00001614 <__vector_33>:
    1614:	0f 93       	push	r16
    1616:	0f b7       	in	r16, 0x3f	; 63
    1618:	ef 93       	push	r30
    161a:	ff 93       	push	r31
    161c:	e0 91 28 04 	lds	r30, 0x0428	; 0x800428 <tx1_Tail>
    1620:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <tx1_Head>
    1624:	e3 95       	inc	r30
    1626:	ef 71       	andi	r30, 0x1F	; 31
    1628:	ef 13       	cpse	r30, r31
    162a:	05 c0       	rjmp	.+10     	; 0x1636 <USART1_TX_CONTINUE>
    162c:	f0 91 c9 00 	lds	r31, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1630:	ff 7d       	andi	r31, 0xDF	; 223
    1632:	f0 93 c9 00 	sts	0x00C9, r31	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

00001636 <USART1_TX_CONTINUE>:
    1636:	e0 93 28 04 	sts	0x0428, r30	; 0x800428 <tx1_Tail>
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	ea 51       	subi	r30, 0x1A	; 26
    163e:	fc 4f       	sbci	r31, 0xFC	; 252
    1640:	e0 81       	ld	r30, Z
    1642:	e0 93 ce 00 	sts	0x00CE, r30	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>

00001646 <USART1_TX_EXIT>:
    1646:	ff 91       	pop	r31
    1648:	ef 91       	pop	r30
    164a:	0f bf       	out	0x3f, r16	; 63
    164c:	0f 91       	pop	r16
    164e:	18 95       	reti

00001650 <__vector_32>:
    1650:	0f 93       	push	r16
    1652:	0f b7       	in	r16, 0x3f	; 63
    1654:	9f 93       	push	r25
    1656:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    165a:	ef 93       	push	r30
    165c:	ff 93       	push	r31
    165e:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <rx1_Head>
    1662:	f0 91 e3 03 	lds	r31, 0x03E3	; 0x8003e3 <rx1_Tail>
    1666:	e3 95       	inc	r30
    1668:	ef 71       	andi	r30, 0x1F	; 31
    166a:	fe 17       	cp	r31, r30
    166c:	31 f0       	breq	.+12     	; 0x167a <USART1_RX_EXIT>
    166e:	e0 93 29 04 	sts	0x0429, r30	; 0x800429 <rx1_Head>
    1672:	f0 e0       	ldi	r31, 0x00	; 0
    1674:	e9 5f       	subi	r30, 0xF9	; 249
    1676:	fb 4f       	sbci	r31, 0xFB	; 251
    1678:	90 83       	st	Z, r25

0000167a <USART1_RX_EXIT>:
    167a:	ff 91       	pop	r31
    167c:	ef 91       	pop	r30
    167e:	9f 91       	pop	r25
    1680:	0f bf       	out	0x3f, r16	; 63
    1682:	0f 91       	pop	r16
    1684:	18 95       	reti

00001686 <timer1_init_ts>:
//for speed
volatile uint16_t u16_speed_count = 0;


void timer1_init_ts(){
	TCCR1B |= (1<<CS10)|(1<<CS11); // timer 1 prescaler set CLK/64
    1686:	e1 e8       	ldi	r30, 0x81	; 129
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	80 81       	ld	r24, Z
    168c:	83 60       	ori	r24, 0x03	; 3
    168e:	80 83       	st	Z, r24
	TCCR1B |= (1<<WGM12); //CTC
    1690:	80 81       	ld	r24, Z
    1692:	88 60       	ori	r24, 0x08	; 8
    1694:	80 83       	st	Z, r24
	TCNT1 = 0; //reset timer value
    1696:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    169a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
	TIMSK1 |= (1<<OCIE1A); //enable interrupt
    169e:	ef e6       	ldi	r30, 0x6F	; 111
    16a0:	f0 e0       	ldi	r31, 0x00	; 0
    16a2:	80 81       	ld	r24, Z
    16a4:	82 60       	ori	r24, 0x02	; 2
    16a6:	80 83       	st	Z, r24
	OCR1A = 125; //compare value //every 1ms
    16a8:	8d e7       	ldi	r24, 0x7D	; 125
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16b0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16b4:	08 95       	ret

000016b6 <timer0_init_ts>:
}

void timer0_init_ts(){ 
	TCCR0A |= (1<<CS02)|(1<<CS00); // timer 0 prescaler set CLK/1024
    16b6:	84 b5       	in	r24, 0x24	; 36
    16b8:	85 60       	ori	r24, 0x05	; 5
    16ba:	84 bd       	out	0x24, r24	; 36
	TCCR0A |= (1<<WGM01); //CTC
    16bc:	84 b5       	in	r24, 0x24	; 36
    16be:	88 60       	ori	r24, 0x08	; 8
    16c0:	84 bd       	out	0x24, r24	; 36
	TCNT0 = 0; //reset timer value
    16c2:	16 bc       	out	0x26, r1	; 38
	TIMSK0 |= (1<<OCIE0A); //enable interrupt
    16c4:	ee e6       	ldi	r30, 0x6E	; 110
    16c6:	f0 e0       	ldi	r31, 0x00	; 0
    16c8:	80 81       	ld	r24, Z
    16ca:	82 60       	ori	r24, 0x02	; 2
    16cc:	80 83       	st	Z, r24
	OCR0A = 39; //compare value // 78 for 10ms, 39 for 5ms, 19 for 2.56ms
    16ce:	87 e2       	ldi	r24, 0x27	; 39
    16d0:	87 bd       	out	0x27, r24	; 39
    16d2:	08 95       	ret

000016d4 <main>:
};


int main(void)	
{
	cli();
    16d4:	f8 94       	cli
	rgbled_init();
    16d6:	92 d5       	rcall	.+2852   	; 0x21fc <rgbled_init>
	DWC_init();
    16d8:	11 d2       	rcall	.+1058   	; 0x1afc <DWC_init>
	pwm_init();
    16da:	33 de       	rcall	.-922    	; 0x1342 <pwm_init>
    16dc:	60 e0       	ldi	r22, 0x00	; 0
	can_init(0,0);
    16de:	70 e0       	ldi	r23, 0x00	; 0
    16e0:	80 e0       	ldi	r24, 0x00	; 0
    16e2:	90 e0       	ldi	r25, 0x00	; 0
	timer1_init_ts();
    16e4:	71 d4       	rcall	.+2274   	; 0x1fc8 <can_init>
	timer0_init_ts();
    16e6:	cf df       	rcall	.-98     	; 0x1686 <timer1_init_ts>
    16e8:	e6 df       	rcall	.-52     	; 0x16b6 <timer0_init_ts>
	speed_init();
    16ea:	7f dc       	rcall	.-1794   	; 0xfea <speed_init>
    16ec:	80 e0       	ldi	r24, 0x00	; 0
	spi_init(DIV_4); // clk at clkio/4 = 2MHz init of SPI for external ADC device
    16ee:	95 d5       	rcall	.+2858   	; 0x221a <spi_init>
    16f0:	82 e1       	ldi	r24, 0x12	; 18
    16f2:	91 e0       	ldi	r25, 0x01	; 1
	actuator_init(&ComValues);
    16f4:	0e 94 72 00 	call	0xe4	; 0xe4 <actuator_init>
    16f8:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	{
	#ifdef USART0_RS485_MODE
		RS485_CONTROL0_DDR |= (1<<RS485_CONTROL0_IONUM); // default pin state is low
	#endif
		
		UBRR0L_REGISTER = (uint8_t) ubrr_value;
    16fc:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		
	#ifdef USART_SKIP_UBRRH_IF_ZERO
		if(__builtin_constant_p(ubrr_value))
			if(((ubrr_value>>8) != 0)) // requires -Os flag - do not use in non-inline functions
	#endif
			UBRR0H_REGISTER = (ubrr_value>>8);
    1700:	88 e9       	ldi	r24, 0x98	; 152
    1702:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		#endif
	#elif defined(USART0_MPCM_MODE)
		UCSR0A_REGISTER |= (1<<MPCM0_BIT);
	#endif
		
		UCSR0B_REGISTER = USART0_CONFIG_B;
    1706:	eb e4       	ldi	r30, 0x4B	; 75
    1708:	f4 e0       	ldi	r31, 0x04	; 4
	
	//uart_set_FrameFormat(USART_8BIT_DATA|USART_1STOP_BIT|USART_NO_PARITY|USART_ASYNC_MODE); // default settings
	uart_init(BAUD_CALC(500000)); // 8n1 transmission is set as default
	stdout = &uart0_io; // attach uart stream to stdout & stdin
    170a:	84 e0       	ldi	r24, 0x04	; 4
    170c:	91 e0       	ldi	r25, 0x01	; 1
    170e:	93 83       	std	Z+3, r25	; 0x03
    1710:	82 83       	std	Z+2, r24	; 0x02
    1712:	91 83       	std	Z+1, r25	; 0x01
    1714:	80 83       	st	Z, r24
	stdin = &uart0_io; // uart0_in and uart0_out are only available if NO_USART_RX or NO_USART_TX is defined
    1716:	0e 94 5f 03 	call	0x6be	; 0x6be <drivers_init>
	drivers_init();
    171a:	80 e0       	ldi	r24, 0x00	; 0
    171c:	0e 94 61 03 	call	0x6c2	; 0x6c2 <drivers>
	drivers(0);
    1720:	78 94       	sei
	sei();
    1722:	c1 e0       	ldi	r28, 0x01	; 1
	
    while (1){
		
		handle_can(&ComValues, &rxFrame); //receive CAN
    1724:	67 e9       	ldi	r22, 0x97	; 151
    1726:	73 e0       	ldi	r23, 0x03	; 3
    1728:	82 e1       	ldi	r24, 0x12	; 18
    172a:	91 e0       	ldi	r25, 0x01	; 1
    172c:	c5 d8       	rcall	.-3702   	; 0x8b8 <handle_can>
    172e:	82 e1       	ldi	r24, 0x12	; 18
		receive_uart(&ComValues);
    1730:	91 e0       	ldi	r25, 0x01	; 1
    1732:	9e d9       	rcall	.-3268   	; 0xa70 <receive_uart>
    1734:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <b_send_can>
		
		//#ifdef ENABLE_UART_TX
		//	receive_uart(&ComValues);
		//#endif
		
		if (b_send_can)
    1738:	88 23       	and	r24, r24
    173a:	09 f4       	brne	.+2      	; 0x173e <main+0x6a>
    173c:	41 c0       	rjmp	.+130    	; 0x17c0 <main+0xec>
    173e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <b_select_can_msg>
		{
			if (b_select_can_msg)// sending one or the other
    1742:	88 23       	and	r24, r24
    1744:	f1 f0       	breq	.+60     	; 0x1782 <main+0xae>
    1746:	8d b7       	in	r24, 0x3d	; 61
    1748:	9e b7       	in	r25, 0x3e	; 62
			{
				handle_motor_status_can_msg(ComValues); //send motor status on CAN
    174a:	cd 97       	sbiw	r24, 0x3d	; 61
    174c:	0f b6       	in	r0, 0x3f	; 63
    174e:	f8 94       	cli
    1750:	9e bf       	out	0x3e, r25	; 62
    1752:	0f be       	out	0x3f, r0	; 63
    1754:	8d bf       	out	0x3d, r24	; 61
    1756:	ad b7       	in	r26, 0x3d	; 61
    1758:	be b7       	in	r27, 0x3e	; 62
    175a:	11 96       	adiw	r26, 0x01	; 1
    175c:	8d e3       	ldi	r24, 0x3D	; 61
    175e:	e2 e1       	ldi	r30, 0x12	; 18
    1760:	f1 e0       	ldi	r31, 0x01	; 1
    1762:	01 90       	ld	r0, Z+
    1764:	0d 92       	st	X+, r0
    1766:	8a 95       	dec	r24
    1768:	e1 f7       	brne	.-8      	; 0x1762 <main+0x8e>
    176a:	fd d8       	rcall	.-3590   	; 0x966 <handle_motor_status_can_msg>
    176c:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 0;
    1770:	8d b7       	in	r24, 0x3d	; 61
    1772:	9e b7       	in	r25, 0x3e	; 62
    1774:	cd 96       	adiw	r24, 0x3d	; 61
    1776:	0f b6       	in	r0, 0x3f	; 63
    1778:	f8 94       	cli
    177a:	9e bf       	out	0x3e, r25	; 62
    177c:	0f be       	out	0x3f, r0	; 63
    177e:	8d bf       	out	0x3d, r24	; 61
    1780:	1d c0       	rjmp	.+58     	; 0x17bc <main+0xe8>
    1782:	8d b7       	in	r24, 0x3d	; 61
    1784:	9e b7       	in	r25, 0x3e	; 62
			}else{
				handle_clutch_cmd_can_msg(ComValues); // send clutch command on CAN
    1786:	cd 97       	sbiw	r24, 0x3d	; 61
    1788:	0f b6       	in	r0, 0x3f	; 63
    178a:	f8 94       	cli
    178c:	9e bf       	out	0x3e, r25	; 62
    178e:	0f be       	out	0x3f, r0	; 63
    1790:	8d bf       	out	0x3d, r24	; 61
    1792:	ad b7       	in	r26, 0x3d	; 61
    1794:	be b7       	in	r27, 0x3e	; 62
    1796:	11 96       	adiw	r26, 0x01	; 1
    1798:	8d e3       	ldi	r24, 0x3D	; 61
    179a:	e2 e1       	ldi	r30, 0x12	; 18
    179c:	f1 e0       	ldi	r31, 0x01	; 1
    179e:	01 90       	ld	r0, Z+
    17a0:	0d 92       	st	X+, r0
    17a2:	8a 95       	dec	r24
    17a4:	e1 f7       	brne	.-8      	; 0x179e <main+0xca>
    17a6:	4e d9       	rcall	.-3428   	; 0xa44 <handle_clutch_cmd_can_msg>
    17a8:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <b_select_can_msg>
				b_select_can_msg = 1;
    17ac:	8d b7       	in	r24, 0x3d	; 61
    17ae:	9e b7       	in	r25, 0x3e	; 62
    17b0:	cd 96       	adiw	r24, 0x3d	; 61
    17b2:	0f b6       	in	r0, 0x3f	; 63
    17b4:	f8 94       	cli
    17b6:	9e bf       	out	0x3e, r25	; 62
    17b8:	0f be       	out	0x3f, r0	; 63
    17ba:	8d bf       	out	0x3d, r24	; 61
    17bc:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <b_send_can>
			}
			b_send_can = 0;
    17c0:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <b_send_uart>
		}
		
		if (b_send_uart)
    17c4:	88 23       	and	r24, r24
    17c6:	09 f4       	brne	.+2      	; 0x17ca <main+0xf6>
    17c8:	ad cf       	rjmp	.-166    	; 0x1724 <main+0x50>
    17ca:	8d b7       	in	r24, 0x3d	; 61
    17cc:	9e b7       	in	r25, 0x3e	; 62
		{
			send_uart(ComValues);
    17ce:	cd 97       	sbiw	r24, 0x3d	; 61
    17d0:	0f b6       	in	r0, 0x3f	; 63
    17d2:	f8 94       	cli
    17d4:	9e bf       	out	0x3e, r25	; 62
    17d6:	0f be       	out	0x3f, r0	; 63
    17d8:	8d bf       	out	0x3d, r24	; 61
    17da:	ad b7       	in	r26, 0x3d	; 61
    17dc:	be b7       	in	r27, 0x3e	; 62
    17de:	11 96       	adiw	r26, 0x01	; 1
    17e0:	8d e3       	ldi	r24, 0x3D	; 61
    17e2:	e2 e1       	ldi	r30, 0x12	; 18
    17e4:	f1 e0       	ldi	r31, 0x01	; 1
    17e6:	01 90       	ld	r0, Z+
    17e8:	0d 92       	st	X+, r0
    17ea:	8a 95       	dec	r24
    17ec:	e1 f7       	brne	.-8      	; 0x17e6 <main+0x112>
    17ee:	c1 da       	rcall	.-2686   	; 0xd72 <send_uart>
    17f0:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <b_send_uart>
			//send_uart(&ComValues);
			b_send_uart = 0;
    17f4:	8d b7       	in	r24, 0x3d	; 61
    17f6:	9e b7       	in	r25, 0x3e	; 62
    17f8:	cd 96       	adiw	r24, 0x3d	; 61
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	9e bf       	out	0x3e, r25	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	8d bf       	out	0x3d, r24	; 61
    1804:	8f cf       	rjmp	.-226    	; 0x1724 <main+0x50>

00001806 <__vector_16>:
    1806:	1f 92       	push	r1
    1808:	0f 92       	push	r0
		}
	}
}


ISR(TIMER0_COMP_vect){ // every 5ms
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	0f 92       	push	r0
    180e:	11 24       	eor	r1, r1
    1810:	0b b6       	in	r0, 0x3b	; 59
    1812:	0f 92       	push	r0
    1814:	ef 92       	push	r14
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	2f 93       	push	r18
    181c:	3f 93       	push	r19
    181e:	4f 93       	push	r20
    1820:	5f 93       	push	r21
    1822:	6f 93       	push	r22
    1824:	7f 93       	push	r23
    1826:	8f 93       	push	r24
    1828:	9f 93       	push	r25
    182a:	af 93       	push	r26
    182c:	bf 93       	push	r27
    182e:	ef 93       	push	r30
    1830:	ff 93       	push	r31
	handle_DWC(&ComValues); // sets accel and brake cmds to 0 when shell's telemetry system is triggered
    1832:	82 e1       	ldi	r24, 0x12	; 18
    1834:	91 e0       	ldi	r25, 0x01	; 1
    1836:	63 d1       	rcall	.+710    	; 0x1afe <handle_DWC>
	state_handler(&ComValues); // manages the state machine
    1838:	82 e1       	ldi	r24, 0x12	; 18
    183a:	91 e0       	ldi	r25, 0x01	; 1
    183c:	63 dc       	rcall	.-1850   	; 0x1104 <state_handler>
	actuator_p_controller(&ComValues); // manages the actuator's state machine for clutch position 
    183e:	82 e1       	ldi	r24, 0x12	; 18
    1840:	91 e0       	ldi	r25, 0x01	; 1
    1842:	0e 94 98 01 	call	0x330	; 0x330 <actuator_p_controller>
	actuator_update(&ComValues); //Update information from local actuator structure to main program 
    1846:	82 e1       	ldi	r24, 0x12	; 18
    1848:	91 e0       	ldi	r25, 0x01	; 1
    184a:	0e 94 98 00 	call	0x130	; 0x130 <actuator_update>
	
	//UART TIMER: MUST MAKE CODE TO DISABLE UART COMS AFTER CERTAIN NUMBER OF TIME?
	
	if (systic_counter_fast == 7) // every 41ms
    184e:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <systic_counter_fast>
    1852:	87 30       	cpi	r24, 0x07	; 7
    1854:	09 f0       	breq	.+2      	; 0x1858 <__vector_16+0x52>
    1856:	51 c0       	rjmp	.+162    	; 0x18fa <__vector_16+0xf4>
	{
		b_send_can = 1;
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <b_send_can>
		b_send_uart = 1;
    185e:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <b_send_uart>
		
		if (ComValues.u16_watchdog_can != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    1862:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <ComValues+0x1a>
    1866:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <ComValues+0x1b>
    186a:	89 2b       	or	r24, r25
    186c:	b1 f0       	breq	.+44     	; 0x189a <__vector_16+0x94>
    186e:	e2 e1       	ldi	r30, 0x12	; 18
    1870:	f1 e0       	ldi	r31, 0x01	; 1
    1872:	97 8d       	ldd	r25, Z+31	; 0x1f
    1874:	27 8d       	ldd	r18, Z+31	; 0x1f
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	91 30       	cpi	r25, 0x01	; 1
    187a:	09 f0       	breq	.+2      	; 0x187e <__vector_16+0x78>
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	81 11       	cpse	r24, r1
    1880:	05 c0       	rjmp	.+10     	; 0x188c <__vector_16+0x86>
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	21 11       	cpse	r18, r1
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	88 23       	and	r24, r24
    188a:	39 f0       	breq	.+14     	; 0x189a <__vector_16+0x94>
		{
			ComValues.u16_watchdog_can -- ;
    188c:	e2 e1       	ldi	r30, 0x12	; 18
    188e:	f1 e0       	ldi	r31, 0x01	; 1
    1890:	82 8d       	ldd	r24, Z+26	; 0x1a
    1892:	93 8d       	ldd	r25, Z+27	; 0x1b
    1894:	01 97       	sbiw	r24, 0x01	; 1
    1896:	93 8f       	std	Z+27, r25	; 0x1b
    1898:	82 8f       	std	Z+26, r24	; 0x1a
		}
		
		if (ComValues.u16_watchdog_throttle != 0 && ((ComValues.message_mode == CAN) | (ComValues.message_mode == UART))) //if in uart ctrl mode (see Digicom.h), the watchdog is not used
    189a:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <ComValues+0x1c>
    189e:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <ComValues+0x1d>
    18a2:	89 2b       	or	r24, r25
    18a4:	b1 f0       	breq	.+44     	; 0x18d2 <__vector_16+0xcc>
    18a6:	e2 e1       	ldi	r30, 0x12	; 18
    18a8:	f1 e0       	ldi	r31, 0x01	; 1
    18aa:	97 8d       	ldd	r25, Z+31	; 0x1f
    18ac:	27 8d       	ldd	r18, Z+31	; 0x1f
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	91 30       	cpi	r25, 0x01	; 1
    18b2:	09 f0       	breq	.+2      	; 0x18b6 <__vector_16+0xb0>
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	81 11       	cpse	r24, r1
    18b8:	05 c0       	rjmp	.+10     	; 0x18c4 <__vector_16+0xbe>
    18ba:	81 e0       	ldi	r24, 0x01	; 1
    18bc:	21 11       	cpse	r18, r1
    18be:	80 e0       	ldi	r24, 0x00	; 0
    18c0:	88 23       	and	r24, r24
    18c2:	39 f0       	breq	.+14     	; 0x18d2 <__vector_16+0xcc>
		{
			ComValues.u16_watchdog_throttle -- ;
    18c4:	e2 e1       	ldi	r30, 0x12	; 18
    18c6:	f1 e0       	ldi	r31, 0x01	; 1
    18c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    18ca:	95 8d       	ldd	r25, Z+29	; 0x1d
    18cc:	01 97       	sbiw	r24, 0x01	; 1
    18ce:	95 8f       	std	Z+29, r25	; 0x1d
    18d0:	84 8f       	std	Z+28, r24	; 0x1c
		}else if (ComValues.message_mode == UART)
		{
			ComValues.u16_watchdog_throttle -- ;
		} */
		
		handle_joulemeter(&ComValues.f32_energy, ComValues.f32_batt_current, ComValues.f32_batt_volt, 41) ;	//unprecise, to be corrected	
    18d2:	e2 e1       	ldi	r30, 0x12	; 18
    18d4:	f1 e0       	ldi	r31, 0x01	; 1
    18d6:	02 85       	ldd	r16, Z+10	; 0x0a
    18d8:	13 85       	ldd	r17, Z+11	; 0x0b
    18da:	24 85       	ldd	r18, Z+12	; 0x0c
    18dc:	35 85       	ldd	r19, Z+13	; 0x0d
    18de:	46 81       	ldd	r20, Z+6	; 0x06
    18e0:	57 81       	ldd	r21, Z+7	; 0x07
    18e2:	60 85       	ldd	r22, Z+8	; 0x08
    18e4:	71 85       	ldd	r23, Z+9	; 0x09
    18e6:	0f 2e       	mov	r0, r31
    18e8:	f9 e2       	ldi	r31, 0x29	; 41
    18ea:	ef 2e       	mov	r14, r31
    18ec:	f0 2d       	mov	r31, r0
    18ee:	80 e2       	ldi	r24, 0x20	; 32
    18f0:	91 e0       	ldi	r25, 0x01	; 1
    18f2:	e6 d1       	rcall	.+972    	; 0x1cc0 <handle_joulemeter>
		systic_counter_fast = 0;
    18f4:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <systic_counter_fast>
    18f8:	03 c0       	rjmp	.+6      	; 0x1900 <__vector_16+0xfa>
	
	} else {
		systic_counter_fast ++;
    18fa:	8f 5f       	subi	r24, 0xFF	; 255
    18fc:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <systic_counter_fast>
	}
	
	if (systic_counter_slow == 100) // every 0.5s 
    1900:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <systic_counter_slow>
    1904:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <systic_counter_slow+0x1>
    1908:	84 36       	cpi	r24, 0x64	; 100
    190a:	91 05       	cpc	r25, r1
    190c:	01 f5       	brne	.+64     	; 0x194e <__vector_16+0x148>
	{
		manage_LEDs(ComValues); //UM LED according to motor state
    190e:	8d b7       	in	r24, 0x3d	; 61
    1910:	9e b7       	in	r25, 0x3e	; 62
    1912:	cd 97       	sbiw	r24, 0x3d	; 61
    1914:	0f b6       	in	r0, 0x3f	; 63
    1916:	f8 94       	cli
    1918:	9e bf       	out	0x3e, r25	; 62
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	8d bf       	out	0x3d, r24	; 61
    191e:	ad b7       	in	r26, 0x3d	; 61
    1920:	be b7       	in	r27, 0x3e	; 62
    1922:	11 96       	adiw	r26, 0x01	; 1
    1924:	8d e3       	ldi	r24, 0x3D	; 61
    1926:	e2 e1       	ldi	r30, 0x12	; 18
    1928:	f1 e0       	ldi	r31, 0x01	; 1
    192a:	01 90       	ld	r0, Z+
    192c:	0d 92       	st	X+, r0
    192e:	8a 95       	dec	r24
    1930:	e1 f7       	brne	.-8      	; 0x192a <__vector_16+0x124>
    1932:	02 db       	rcall	.-2556   	; 0xf38 <manage_LEDs>
		systic_counter_slow = 0;
    1934:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <systic_counter_slow+0x1>
    1938:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <systic_counter_slow>
    193c:	8d b7       	in	r24, 0x3d	; 61
    193e:	9e b7       	in	r25, 0x3e	; 62
    1940:	cd 96       	adiw	r24, 0x3d	; 61
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	9e bf       	out	0x3e, r25	; 62
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	8d bf       	out	0x3d, r24	; 61
    194c:	05 c0       	rjmp	.+10     	; 0x1958 <__vector_16+0x152>
		} else {
		systic_counter_slow ++;
    194e:	01 96       	adiw	r24, 0x01	; 1
    1950:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <systic_counter_slow+0x1>
    1954:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <systic_counter_slow>
	}
}
    1958:	ff 91       	pop	r31
    195a:	ef 91       	pop	r30
    195c:	bf 91       	pop	r27
    195e:	af 91       	pop	r26
    1960:	9f 91       	pop	r25
    1962:	8f 91       	pop	r24
    1964:	7f 91       	pop	r23
    1966:	6f 91       	pop	r22
    1968:	5f 91       	pop	r21
    196a:	4f 91       	pop	r20
    196c:	3f 91       	pop	r19
    196e:	2f 91       	pop	r18
    1970:	1f 91       	pop	r17
    1972:	0f 91       	pop	r16
    1974:	ef 90       	pop	r14
    1976:	0f 90       	pop	r0
    1978:	0b be       	out	0x3b, r0	; 59
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	0f 90       	pop	r0
    1980:	1f 90       	pop	r1
    1982:	18 95       	reti

00001984 <__vector_12>:
*	CH2 : Battery voltage
*	CH4 : Motor temperature
*/


ISR(TIMER1_COMPA_vect){// every 1ms
    1984:	1f 92       	push	r1
    1986:	0f 92       	push	r0
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	0f 92       	push	r0
    198c:	11 24       	eor	r1, r1
    198e:	0b b6       	in	r0, 0x3b	; 59
    1990:	0f 92       	push	r0
    1992:	2f 93       	push	r18
    1994:	3f 93       	push	r19
    1996:	4f 93       	push	r20
    1998:	5f 93       	push	r21
    199a:	6f 93       	push	r22
    199c:	7f 93       	push	r23
    199e:	8f 93       	push	r24
    19a0:	9f 93       	push	r25
    19a2:	af 93       	push	r26
    19a4:	bf 93       	push	r27
    19a6:	ef 93       	push	r30
    19a8:	ff 93       	push	r31
	
	if (u16_speed_count < 2000 ) //after 3s with no magnet, speed = 0
    19aa:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19ae:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19b2:	80 3d       	cpi	r24, 0xD0	; 208
    19b4:	97 40       	sbci	r25, 0x07	; 7
    19b6:	50 f4       	brcc	.+20     	; 0x19cc <__vector_12+0x48>
	{
		u16_speed_count ++ ;
    19b8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <u16_speed_count>
    19bc:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <u16_speed_count+0x1>
    19c0:	01 96       	adiw	r24, 0x01	; 1
    19c2:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <u16_speed_count+0x1>
    19c6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <u16_speed_count>
    19ca:	08 c0       	rjmp	.+16     	; 0x19dc <__vector_12+0x58>
	} else
	{
		ComValues.u16_car_speed = 0;
    19cc:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <ComValues+0x14>
    19d0:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <ComValues+0x13>
		u16_speed_count = 0;
    19d4:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <u16_speed_count+0x1>
    19d8:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <u16_speed_count>
	CH5 - S_S_01, SPARE
	CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
	CH7 - S_M_I, MOTOR CURRENT
	*/
	
	if (u8_SPI_count == 7)
    19dc:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    19e0:	87 30       	cpi	r24, 0x07	; 7
    19e2:	41 f4       	brne	.+16     	; 0x19f4 <__vector_12+0x70>
	{
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
    19e4:	84 e1       	ldi	r24, 0x14	; 20
    19e6:	91 e0       	ldi	r25, 0x01	; 1
    19e8:	0e 94 3a 04 	call	0x874	; 0x874 <SPI_handler_7>
		u8_SPI_count = 0 ;
    19ec:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <u8_SPI_count>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
		u8_SPI_count ++ ;
	}
	if (u8_SPI_count == 5)
    19f0:	80 e0       	ldi	r24, 0x00	; 0
    19f2:	13 c0       	rjmp	.+38     	; 0x1a1a <__vector_12+0x96>
		//CH7 - S_M_I, MOTOR CURRENT
		SPI_handler_7(&ComValues.f32_motor_current);
		u8_SPI_count = 0 ;
	}
	
	if (u8_SPI_count == 6)
    19f4:	86 30       	cpi	r24, 0x06	; 6
    19f6:	49 f4       	brne	.+18     	; 0x1a0a <__vector_12+0x86>
	{
		//CH6 - S_A_S0, ACTUATOR POSITION FEEDBACK
		SPI_handler_6(&ComValues.f32_actuator_feedback);
    19f8:	8d e3       	ldi	r24, 0x3D	; 61
    19fa:	91 e0       	ldi	r25, 0x01	; 1
    19fc:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPI_handler_6>
		u8_SPI_count ++ ;
    1a00:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a04:	8f 5f       	subi	r24, 0xFF	; 255
    1a06:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	if (u8_SPI_count == 5)
    1a0a:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a0e:	85 30       	cpi	r24, 0x05	; 5
    1a10:	21 f4       	brne	.+8      	; 0x1a1a <__vector_12+0x96>
	{
		//CH5 - S_S_01, SPARE
		//SPI_handler_5(&ComValues."VARIABLE HERE");
		u8_SPI_count ++ ;
    1a12:	86 e0       	ldi	r24, 0x06	; 6
    1a14:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a18:	13 c0       	rjmp	.+38     	; 0x1a40 <__vector_12+0xbc>
	}
	
	if (u8_SPI_count == 4)
    1a1a:	84 30       	cpi	r24, 0x04	; 4
    1a1c:	49 f4       	brne	.+18     	; 0x1a30 <__vector_12+0xac>
	{
		//CH4 - S_M_T, MOTOR TEMPERATURE
		SPI_handler_4(&ComValues.u8_motor_temp);
    1a1e:	84 e2       	ldi	r24, 0x24	; 36
    1a20:	91 e0       	ldi	r25, 0x01	; 1
    1a22:	0e 94 c6 03 	call	0x78c	; 0x78c <SPI_handler_4>
		u8_SPI_count ++ ;
    1a26:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a2a:	8f 5f       	subi	r24, 0xFF	; 255
    1a2c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
	
	if (u8_SPI_count == 3)
    1a30:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a34:	83 30       	cpi	r24, 0x03	; 3
    1a36:	21 f4       	brne	.+8      	; 0x1a40 <__vector_12+0xbc>
	{
		//CH3 - X, N/C
		//SPI_handler_3(&ComValues.u8_motor_temp);
		u8_SPI_count  ++ ;
    1a38:	84 e0       	ldi	r24, 0x04	; 4
    1a3a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a3e:	13 c0       	rjmp	.+38     	; 0x1a66 <__vector_12+0xe2>
	}
	
	if (u8_SPI_count == 2)
    1a40:	82 30       	cpi	r24, 0x02	; 2
    1a42:	21 f4       	brne	.+8      	; 0x1a4c <__vector_12+0xc8>
	{
		//CH2 - X, N/C
		//SPI_handler_2(&ComValues.u8_motor_temp);
		u8_SPI_count ++ ;
    1a44:	83 e0       	ldi	r24, 0x03	; 3
    1a46:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
    1a4a:	1a c0       	rjmp	.+52     	; 0x1a80 <__vector_12+0xfc>
	}
	
	if (u8_SPI_count == 1)
    1a4c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	49 f4       	brne	.+18     	; 0x1a66 <__vector_12+0xe2>
	{
		//CH1 - S_B_I, BATTERY CURRENT
		SPI_handler_1(&ComValues.f32_batt_current);
    1a54:	88 e1       	ldi	r24, 0x18	; 24
    1a56:	91 e0       	ldi	r25, 0x01	; 1
    1a58:	0e 94 a4 03 	call	0x748	; 0x748 <SPI_handler_1>
		u8_SPI_count ++ ;
    1a5c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a60:	8f 5f       	subi	r24, 0xFF	; 255
    1a62:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}	
	
	if (u8_SPI_count == 0)
    1a66:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	09 c0       	rjmp	.+18     	; 0x1a80 <__vector_12+0xfc>
	{
		//CH0 - S_B_V, BATTERY VOLTAGE
		SPI_handler_0(&ComValues.f32_batt_volt);
    1a6e:	8c e1       	ldi	r24, 0x1C	; 28
    1a70:	91 e0       	ldi	r25, 0x01	; 1
    1a72:	0e 94 67 03 	call	0x6ce	; 0x6ce <SPI_handler_0>
		u8_SPI_count ++ ;
    1a76:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <u8_SPI_count>
    1a7a:	8f 5f       	subi	r24, 0xFF	; 255
    1a7c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <u8_SPI_count>
	}
}
    1a80:	ff 91       	pop	r31
    1a82:	ef 91       	pop	r30
    1a84:	bf 91       	pop	r27
    1a86:	af 91       	pop	r26
    1a88:	9f 91       	pop	r25
    1a8a:	8f 91       	pop	r24
    1a8c:	7f 91       	pop	r23
    1a8e:	6f 91       	pop	r22
    1a90:	5f 91       	pop	r21
    1a92:	4f 91       	pop	r20
    1a94:	3f 91       	pop	r19
    1a96:	2f 91       	pop	r18
    1a98:	0f 90       	pop	r0
    1a9a:	0b be       	out	0x3b, r0	; 59
    1a9c:	0f 90       	pop	r0
    1a9e:	0f be       	out	0x3f, r0	; 63
    1aa0:	0f 90       	pop	r0
    1aa2:	1f 90       	pop	r1
    1aa4:	18 95       	reti

00001aa6 <__vector_6>:


ISR(INT5_vect) //interrupt on rising front of the speed sensor (each time a magnet passes in front of sensor)
{
    1aa6:	1f 92       	push	r1
    1aa8:	0f 92       	push	r0
    1aaa:	0f b6       	in	r0, 0x3f	; 63
    1aac:	0f 92       	push	r0
    1aae:	11 24       	eor	r1, r1
    1ab0:	0b b6       	in	r0, 0x3b	; 59
    1ab2:	0f 92       	push	r0
    1ab4:	2f 93       	push	r18
    1ab6:	3f 93       	push	r19
    1ab8:	4f 93       	push	r20
    1aba:	5f 93       	push	r21
    1abc:	6f 93       	push	r22
    1abe:	7f 93       	push	r23
    1ac0:	8f 93       	push	r24
    1ac2:	9f 93       	push	r25
    1ac4:	af 93       	push	r26
    1ac6:	bf 93       	push	r27
    1ac8:	ef 93       	push	r30
    1aca:	ff 93       	push	r31
	//rgbled_toggle(LED_GREEN); //uncomment to test speed sensor mounting. should blink periodically. 
	//remember to comment the "manage_LED" function
	handle_speed_sensor(&ComValues.u16_car_speed, &u16_speed_count);
    1acc:	60 e0       	ldi	r22, 0x00	; 0
    1ace:	72 e0       	ldi	r23, 0x02	; 2
    1ad0:	85 e2       	ldi	r24, 0x25	; 37
    1ad2:	91 e0       	ldi	r25, 0x01	; 1
    1ad4:	95 da       	rcall	.-2774   	; 0x1000 <handle_speed_sensor>
}
    1ad6:	ff 91       	pop	r31
    1ad8:	ef 91       	pop	r30
    1ada:	bf 91       	pop	r27
    1adc:	af 91       	pop	r26
    1ade:	9f 91       	pop	r25
    1ae0:	8f 91       	pop	r24
    1ae2:	7f 91       	pop	r23
    1ae4:	6f 91       	pop	r22
    1ae6:	5f 91       	pop	r21
    1ae8:	4f 91       	pop	r20
    1aea:	3f 91       	pop	r19
    1aec:	2f 91       	pop	r18
    1aee:	0f 90       	pop	r0
    1af0:	0b be       	out	0x3b, r0	; 59
    1af2:	0f 90       	pop	r0
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	0f 90       	pop	r0
    1af8:	1f 90       	pop	r1
    1afa:	18 95       	reti

00001afc <DWC_init>:
#include "sensors.h"
#include <avr/io.h>
#include <stdio.h>

void DWC_init()
{
    1afc:	08 95       	ret

00001afe <handle_DWC>:
void handle_DWC(volatile ModuleValues_t *vals)
{
	// check pin value
	  uint8_t b_DWC_cut = !(PINF & 4); //read pin
	  
	  if (b_DWC_cut)
    1afe:	7a 99       	sbic	0x0f, 2	; 15
    1b00:	03 c0       	rjmp	.+6      	; 0x1b08 <handle_DWC+0xa>
	  {
		  vals->u8_accel_cmd = 0.0 ;
    1b02:	fc 01       	movw	r30, r24
    1b04:	17 8a       	std	Z+23, r1	; 0x17
		  vals->u8_brake_cmd = 0.0 ;
    1b06:	10 8e       	std	Z+24, r1	; 0x18
    1b08:	08 95       	ret

00001b0a <handle_current_sensor>:
	  }
}

void handle_current_sensor(volatile float *f32_current, uint16_t u16_ADC_reg, uint8_t u8_sensor_num)
{
    1b0a:	8f 92       	push	r8
    1b0c:	9f 92       	push	r9
    1b0e:	af 92       	push	r10
    1b10:	bf 92       	push	r11
    1b12:	cf 92       	push	r12
    1b14:	df 92       	push	r13
    1b16:	ef 92       	push	r14
    1b18:	ff 92       	push	r15
    1b1a:	0f 93       	push	r16
    1b1c:	1f 93       	push	r17
    1b1e:	cf 93       	push	r28
    1b20:	df 93       	push	r29
    1b22:	00 d0       	rcall	.+0      	; 0x1b24 <handle_current_sensor+0x1a>
    1b24:	00 d0       	rcall	.+0      	; 0x1b26 <handle_current_sensor+0x1c>
    1b26:	cd b7       	in	r28, 0x3d	; 61
    1b28:	de b7       	in	r29, 0x3e	; 62
    1b2a:	8c 01       	movw	r16, r24
    1b2c:	f4 2e       	mov	r15, r20
	//volatile float f_new_current = ((((volatile float)u16_ADC_reg*5.0/4096.0) - TRANSDUCER_OFFSET)/TRANSDUCER_SENSIBILITY) ;// /3 because current passes 3x in transducer for more precision.
	volatile float f_new_current = ((volatile float)u16_ADC_reg*5.0/4096.0)*8 - 20;
    1b2e:	80 e0       	ldi	r24, 0x00	; 0
    1b30:	90 e0       	ldi	r25, 0x00	; 0
    1b32:	e6 d4       	rcall	.+2508   	; 0x2500 <__floatunsisf>
    1b34:	20 e0       	ldi	r18, 0x00	; 0
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	40 ea       	ldi	r20, 0xA0	; 160
    1b3a:	50 e4       	ldi	r21, 0x40	; 64
    1b3c:	97 d5       	rcall	.+2862   	; 0x266c <__mulsf3>
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	40 e8       	ldi	r20, 0x80	; 128
    1b44:	59 e3       	ldi	r21, 0x39	; 57
    1b46:	92 d5       	rcall	.+2852   	; 0x266c <__mulsf3>
    1b48:	20 e0       	ldi	r18, 0x00	; 0
    1b4a:	30 e0       	ldi	r19, 0x00	; 0
    1b4c:	40 e0       	ldi	r20, 0x00	; 0
    1b4e:	51 e4       	ldi	r21, 0x41	; 65
    1b50:	8d d5       	rcall	.+2842   	; 0x266c <__mulsf3>
    1b52:	20 e0       	ldi	r18, 0x00	; 0
    1b54:	30 e0       	ldi	r19, 0x00	; 0
    1b56:	40 ea       	ldi	r20, 0xA0	; 160
    1b58:	51 e4       	ldi	r21, 0x41	; 65
    1b5a:	d0 d3       	rcall	.+1952   	; 0x22fc <__subsf3>
    1b5c:	69 83       	std	Y+1, r22	; 0x01
    1b5e:	7a 83       	std	Y+2, r23	; 0x02
    1b60:	8b 83       	std	Y+3, r24	; 0x03
    1b62:	9c 83       	std	Y+4, r25	; 0x04
	if (u8_sensor_num)
    1b64:	ff 20       	and	r15, r15
    1b66:	49 f0       	breq	.+18     	; 0x1b7a <handle_current_sensor+0x70>
	{//batt
		//f_new_current = (f_new_current+CORRECTION_OFFSET_BAT);// correction of offset
		f_new_current = (f_new_current);
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6c:	ab 81       	ldd	r26, Y+3	; 0x03
    1b6e:	bc 81       	ldd	r27, Y+4	; 0x04
    1b70:	89 83       	std	Y+1, r24	; 0x01
    1b72:	9a 83       	std	Y+2, r25	; 0x02
    1b74:	ab 83       	std	Y+3, r26	; 0x03
    1b76:	bc 83       	std	Y+4, r27	; 0x04
    1b78:	08 c0       	rjmp	.+16     	; 0x1b8a <handle_current_sensor+0x80>
	}else{
		//f_new_current = (f_new_current+CORRECTION_OFFSET_MOT);// correction of offset
		f_new_current = (f_new_current);
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7e:	ab 81       	ldd	r26, Y+3	; 0x03
    1b80:	bc 81       	ldd	r27, Y+4	; 0x04
    1b82:	89 83       	std	Y+1, r24	; 0x01
    1b84:	9a 83       	std	Y+2, r25	; 0x02
    1b86:	ab 83       	std	Y+3, r26	; 0x03
    1b88:	bc 83       	std	Y+4, r27	; 0x04
	}
	
	*f32_current = (*f32_current)*(1-LOWPASS_CONSTANT) + LOWPASS_CONSTANT*f_new_current ;// low pass filter ---------------------TODO test
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	60 81       	ld	r22, Z
    1b8e:	71 81       	ldd	r23, Z+1	; 0x01
    1b90:	82 81       	ldd	r24, Z+2	; 0x02
    1b92:	93 81       	ldd	r25, Z+3	; 0x03
    1b94:	89 80       	ldd	r8, Y+1	; 0x01
    1b96:	9a 80       	ldd	r9, Y+2	; 0x02
    1b98:	ab 80       	ldd	r10, Y+3	; 0x03
    1b9a:	bc 80       	ldd	r11, Y+4	; 0x04
    1b9c:	26 e6       	ldi	r18, 0x66	; 102
    1b9e:	36 e6       	ldi	r19, 0x66	; 102
    1ba0:	46 e6       	ldi	r20, 0x66	; 102
    1ba2:	5f e3       	ldi	r21, 0x3F	; 63
    1ba4:	63 d5       	rcall	.+2758   	; 0x266c <__mulsf3>
    1ba6:	6b 01       	movw	r12, r22
    1ba8:	7c 01       	movw	r14, r24
    1baa:	2d ec       	ldi	r18, 0xCD	; 205
    1bac:	3c ec       	ldi	r19, 0xCC	; 204
    1bae:	4c ec       	ldi	r20, 0xCC	; 204
    1bb0:	5d e3       	ldi	r21, 0x3D	; 61
    1bb2:	c5 01       	movw	r24, r10
    1bb4:	b4 01       	movw	r22, r8
    1bb6:	5a d5       	rcall	.+2740   	; 0x266c <__mulsf3>
    1bb8:	9b 01       	movw	r18, r22
    1bba:	ac 01       	movw	r20, r24
    1bbc:	c7 01       	movw	r24, r14
    1bbe:	b6 01       	movw	r22, r12
    1bc0:	9e d3       	rcall	.+1852   	; 0x22fe <__addsf3>
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	60 83       	st	Z, r22
    1bc6:	71 83       	std	Z+1, r23	; 0x01
    1bc8:	82 83       	std	Z+2, r24	; 0x02
    1bca:	93 83       	std	Z+3, r25	; 0x03
}
    1bcc:	0f 90       	pop	r0
    1bce:	0f 90       	pop	r0
    1bd0:	0f 90       	pop	r0
    1bd2:	0f 90       	pop	r0
    1bd4:	df 91       	pop	r29
    1bd6:	cf 91       	pop	r28
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	bf 90       	pop	r11
    1be6:	af 90       	pop	r10
    1be8:	9f 90       	pop	r9
    1bea:	8f 90       	pop	r8
    1bec:	08 95       	ret

00001bee <handle_temp_sensor>:

void handle_temp_sensor(volatile uint8_t *u8_temp, uint16_t u16_ADC_reg)
{
    1bee:	cf 92       	push	r12
    1bf0:	df 92       	push	r13
    1bf2:	ef 92       	push	r14
    1bf4:	ff 92       	push	r15
    1bf6:	cf 93       	push	r28
    1bf8:	df 93       	push	r29
    1bfa:	ec 01       	movw	r28, r24
	float f_sens_volt = ((float)u16_ADC_reg*5.0/4096.0);
    1bfc:	80 e0       	ldi	r24, 0x00	; 0
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	7f d4       	rcall	.+2302   	; 0x2500 <__floatunsisf>
    1c02:	20 e0       	ldi	r18, 0x00	; 0
    1c04:	30 e0       	ldi	r19, 0x00	; 0
    1c06:	40 ea       	ldi	r20, 0xA0	; 160
    1c08:	50 e4       	ldi	r21, 0x40	; 64
    1c0a:	30 d5       	rcall	.+2656   	; 0x266c <__mulsf3>
    1c0c:	20 e0       	ldi	r18, 0x00	; 0
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
    1c10:	40 e8       	ldi	r20, 0x80	; 128
    1c12:	59 e3       	ldi	r21, 0x39	; 57
    1c14:	2b d5       	rcall	.+2646   	; 0x266c <__mulsf3>
    1c16:	6b 01       	movw	r12, r22
    1c18:	7c 01       	movw	r14, r24
	// 3.7 -> 4.7V => T = 55.5*V-155.5
	// 4.7 -> 5V => T = 220*V-840
	// this approximation system is used because it requires less processing power and variable accuracy than the 3rd order polyfit. 
	// Here we approximate the curve by three straight lines
	
	if (f_sens_volt <= 3.7)
    1c1a:	2d ec       	ldi	r18, 0xCD	; 205
    1c1c:	3c ec       	ldi	r19, 0xCC	; 204
    1c1e:	4c e6       	ldi	r20, 0x6C	; 108
    1c20:	50 e4       	ldi	r21, 0x40	; 64
    1c22:	d1 d3       	rcall	.+1954   	; 0x23c6 <__cmpsf2>
    1c24:	18 16       	cp	r1, r24
    1c26:	74 f0       	brlt	.+28     	; 0x1c44 <handle_temp_sensor+0x56>
	{
		*u8_temp = (uint8_t)(20.0*f_sens_volt-22.0);
    1c28:	20 e0       	ldi	r18, 0x00	; 0
    1c2a:	30 e0       	ldi	r19, 0x00	; 0
    1c2c:	40 ea       	ldi	r20, 0xA0	; 160
    1c2e:	51 e4       	ldi	r21, 0x41	; 65
    1c30:	c7 01       	movw	r24, r14
    1c32:	b6 01       	movw	r22, r12
    1c34:	1b d5       	rcall	.+2614   	; 0x266c <__mulsf3>
    1c36:	20 e0       	ldi	r18, 0x00	; 0
    1c38:	30 e0       	ldi	r19, 0x00	; 0
    1c3a:	40 eb       	ldi	r20, 0xB0	; 176
    1c3c:	51 e4       	ldi	r21, 0x41	; 65
    1c3e:	5e d3       	rcall	.+1724   	; 0x22fc <__subsf3>
    1c40:	33 d4       	rcall	.+2150   	; 0x24a8 <__fixunssfsi>
    1c42:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt <= 4.7 && f_sens_volt > 3.7)
    1c44:	26 e6       	ldi	r18, 0x66	; 102
    1c46:	36 e6       	ldi	r19, 0x66	; 102
    1c48:	46 e9       	ldi	r20, 0x96	; 150
    1c4a:	50 e4       	ldi	r21, 0x40	; 64
    1c4c:	c7 01       	movw	r24, r14
    1c4e:	b6 01       	movw	r22, r12
    1c50:	ba d3       	rcall	.+1908   	; 0x23c6 <__cmpsf2>
    1c52:	18 16       	cp	r1, r24
    1c54:	bc f0       	brlt	.+46     	; 0x1c84 <handle_temp_sensor+0x96>
    1c56:	2d ec       	ldi	r18, 0xCD	; 205
    1c58:	3c ec       	ldi	r19, 0xCC	; 204
    1c5a:	4c e6       	ldi	r20, 0x6C	; 108
    1c5c:	50 e4       	ldi	r21, 0x40	; 64
    1c5e:	c7 01       	movw	r24, r14
    1c60:	b6 01       	movw	r22, r12
    1c62:	00 d5       	rcall	.+2560   	; 0x2664 <__gesf2>
    1c64:	18 16       	cp	r1, r24
    1c66:	74 f4       	brge	.+28     	; 0x1c84 <handle_temp_sensor+0x96>
	{
		*u8_temp = (uint8_t)(55.5*f_sens_volt-155.5);
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	4e e5       	ldi	r20, 0x5E	; 94
    1c6e:	52 e4       	ldi	r21, 0x42	; 66
    1c70:	c7 01       	movw	r24, r14
    1c72:	b6 01       	movw	r22, r12
    1c74:	fb d4       	rcall	.+2550   	; 0x266c <__mulsf3>
    1c76:	20 e0       	ldi	r18, 0x00	; 0
    1c78:	30 e8       	ldi	r19, 0x80	; 128
    1c7a:	4b e1       	ldi	r20, 0x1B	; 27
    1c7c:	53 e4       	ldi	r21, 0x43	; 67
    1c7e:	3e d3       	rcall	.+1660   	; 0x22fc <__subsf3>
    1c80:	13 d4       	rcall	.+2086   	; 0x24a8 <__fixunssfsi>
    1c82:	68 83       	st	Y, r22
	}
	
	if (f_sens_volt > 4.7)
    1c84:	26 e6       	ldi	r18, 0x66	; 102
    1c86:	36 e6       	ldi	r19, 0x66	; 102
    1c88:	46 e9       	ldi	r20, 0x96	; 150
    1c8a:	50 e4       	ldi	r21, 0x40	; 64
    1c8c:	c7 01       	movw	r24, r14
    1c8e:	b6 01       	movw	r22, r12
    1c90:	e9 d4       	rcall	.+2514   	; 0x2664 <__gesf2>
    1c92:	18 16       	cp	r1, r24
	{
		*u8_temp = (uint8_t)(200.0*f_sens_volt-840.0);
    1c94:	74 f4       	brge	.+28     	; 0x1cb2 <handle_temp_sensor+0xc4>
    1c96:	20 e0       	ldi	r18, 0x00	; 0
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	48 e4       	ldi	r20, 0x48	; 72
    1c9c:	53 e4       	ldi	r21, 0x43	; 67
    1c9e:	c7 01       	movw	r24, r14
    1ca0:	b6 01       	movw	r22, r12
    1ca2:	e4 d4       	rcall	.+2504   	; 0x266c <__mulsf3>
    1ca4:	20 e0       	ldi	r18, 0x00	; 0
    1ca6:	30 e0       	ldi	r19, 0x00	; 0
    1ca8:	42 e5       	ldi	r20, 0x52	; 82
    1caa:	54 e4       	ldi	r21, 0x44	; 68
    1cac:	27 d3       	rcall	.+1614   	; 0x22fc <__subsf3>
    1cae:	fc d3       	rcall	.+2040   	; 0x24a8 <__fixunssfsi>
    1cb0:	68 83       	st	Y, r22
    1cb2:	df 91       	pop	r29
    1cb4:	cf 91       	pop	r28
	}
}
    1cb6:	ff 90       	pop	r15
    1cb8:	ef 90       	pop	r14
    1cba:	df 90       	pop	r13
    1cbc:	cf 90       	pop	r12
    1cbe:	08 95       	ret

00001cc0 <handle_joulemeter>:
    1cc0:	4f 92       	push	r4
    1cc2:	5f 92       	push	r5

void handle_joulemeter(volatile float *f32_energy, volatile float f32_bat_current, volatile float f32_bat_voltage, uint8_t u8_time_period) //units : A, V, ms
{
    1cc4:	6f 92       	push	r6
    1cc6:	7f 92       	push	r7
    1cc8:	8f 92       	push	r8
    1cca:	9f 92       	push	r9
    1ccc:	af 92       	push	r10
    1cce:	bf 92       	push	r11
    1cd0:	cf 92       	push	r12
    1cd2:	df 92       	push	r13
    1cd4:	ef 92       	push	r14
    1cd6:	0f 93       	push	r16
    1cd8:	1f 93       	push	r17
    1cda:	cf 93       	push	r28
    1cdc:	df 93       	push	r29
    1cde:	cd b7       	in	r28, 0x3d	; 61
    1ce0:	de b7       	in	r29, 0x3e	; 62
    1ce2:	28 97       	sbiw	r28, 0x08	; 8
    1ce4:	0f b6       	in	r0, 0x3f	; 63
    1ce6:	f8 94       	cli
    1ce8:	de bf       	out	0x3e, r29	; 62
    1cea:	0f be       	out	0x3f, r0	; 63
    1cec:	cd bf       	out	0x3d, r28	; 61
    1cee:	6c 01       	movw	r12, r24
    1cf0:	49 83       	std	Y+1, r20	; 0x01
    1cf2:	5a 83       	std	Y+2, r21	; 0x02
    1cf4:	6b 83       	std	Y+3, r22	; 0x03
    1cf6:	7c 83       	std	Y+4, r23	; 0x04
    1cf8:	0d 83       	std	Y+5, r16	; 0x05
    1cfa:	1e 83       	std	Y+6, r17	; 0x06
    1cfc:	2f 83       	std	Y+7, r18	; 0x07
    1cfe:	38 87       	std	Y+8, r19	; 0x08
	*f32_energy += f32_bat_voltage*f32_bat_current*(float)u8_time_period/1000 ;
    1d00:	6d 81       	ldd	r22, Y+5	; 0x05
    1d02:	7e 81       	ldd	r23, Y+6	; 0x06
    1d04:	8f 81       	ldd	r24, Y+7	; 0x07
    1d06:	98 85       	ldd	r25, Y+8	; 0x08
    1d08:	29 81       	ldd	r18, Y+1	; 0x01
    1d0a:	3a 81       	ldd	r19, Y+2	; 0x02
    1d0c:	4b 81       	ldd	r20, Y+3	; 0x03
    1d0e:	5c 81       	ldd	r21, Y+4	; 0x04
    1d10:	f6 01       	movw	r30, r12
    1d12:	80 80       	ld	r8, Z
    1d14:	91 80       	ldd	r9, Z+1	; 0x01
    1d16:	a2 80       	ldd	r10, Z+2	; 0x02
    1d18:	b3 80       	ldd	r11, Z+3	; 0x03
    1d1a:	a8 d4       	rcall	.+2384   	; 0x266c <__mulsf3>
    1d1c:	2b 01       	movw	r4, r22
    1d1e:	3c 01       	movw	r6, r24
    1d20:	6e 2d       	mov	r22, r14
    1d22:	70 e0       	ldi	r23, 0x00	; 0
    1d24:	80 e0       	ldi	r24, 0x00	; 0
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	eb d3       	rcall	.+2006   	; 0x2500 <__floatunsisf>
    1d2a:	9b 01       	movw	r18, r22
    1d2c:	ac 01       	movw	r20, r24
    1d2e:	c3 01       	movw	r24, r6
    1d30:	b2 01       	movw	r22, r4
    1d32:	9c d4       	rcall	.+2360   	; 0x266c <__mulsf3>
    1d34:	20 e0       	ldi	r18, 0x00	; 0
    1d36:	30 e0       	ldi	r19, 0x00	; 0
    1d38:	4a e7       	ldi	r20, 0x7A	; 122
    1d3a:	54 e4       	ldi	r21, 0x44	; 68
    1d3c:	48 d3       	rcall	.+1680   	; 0x23ce <__divsf3>
    1d3e:	a5 01       	movw	r20, r10
    1d40:	94 01       	movw	r18, r8
    1d42:	dd d2       	rcall	.+1466   	; 0x22fe <__addsf3>
    1d44:	f6 01       	movw	r30, r12
    1d46:	60 83       	st	Z, r22
    1d48:	71 83       	std	Z+1, r23	; 0x01
    1d4a:	82 83       	std	Z+2, r24	; 0x02
    1d4c:	93 83       	std	Z+3, r25	; 0x03
}
    1d4e:	28 96       	adiw	r28, 0x08	; 8
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	de bf       	out	0x3e, r29	; 62
    1d56:	0f be       	out	0x3f, r0	; 63
    1d58:	cd bf       	out	0x3d, r28	; 61
    1d5a:	df 91       	pop	r29
    1d5c:	cf 91       	pop	r28
    1d5e:	1f 91       	pop	r17
    1d60:	0f 91       	pop	r16
    1d62:	ef 90       	pop	r14
    1d64:	df 90       	pop	r13
    1d66:	cf 90       	pop	r12
    1d68:	bf 90       	pop	r11
    1d6a:	af 90       	pop	r10
    1d6c:	9f 90       	pop	r9
    1d6e:	8f 90       	pop	r8
    1d70:	7f 90       	pop	r7
    1d72:	6f 90       	pop	r6
    1d74:	5f 90       	pop	r5
    1d76:	4f 90       	pop	r4
    1d78:	08 95       	ret

00001d7a <Set_ADC_Channel_ext>:
	ADMUX = (ADMUX & 0xF8)|channel; // clears the bottom 3 bits before ORing
}

void Set_ADC_Channel_ext(uint8_t u8_CHn, uint8_t * u8_ADC_tx) //for MCP3208 external ADC
{
	switch(u8_CHn)
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	88 30       	cpi	r24, 0x08	; 8
    1d7e:	91 05       	cpc	r25, r1
    1d80:	88 f5       	brcc	.+98     	; 0x1de4 <Set_ADC_Channel_ext+0x6a>
    1d82:	fc 01       	movw	r30, r24
    1d84:	e6 5b       	subi	r30, 0xB6	; 182
    1d86:	ff 4f       	sbci	r31, 0xFF	; 255
    1d88:	d4 c4       	rjmp	.+2472   	; 0x2732 <__tablejump2__>
	{
		case 0 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d8a:	86 e0       	ldi	r24, 0x06	; 6
    1d8c:	fb 01       	movw	r30, r22
    1d8e:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b00 ;
    1d90:	11 82       	std	Z+1, r1	; 0x01
		break;
    1d92:	08 95       	ret
		
		case 1 :
			u8_ADC_tx[0] = 0b00000110 ;
    1d94:	86 e0       	ldi	r24, 0x06	; 6
    1d96:	fb 01       	movw	r30, r22
    1d98:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b01 << 6 ;
    1d9a:	80 e4       	ldi	r24, 0x40	; 64
    1d9c:	81 83       	std	Z+1, r24	; 0x01
		break;
    1d9e:	08 95       	ret
		
		case 2 :
			u8_ADC_tx[0] = 0b00000110 ;
    1da0:	86 e0       	ldi	r24, 0x06	; 6
    1da2:	fb 01       	movw	r30, r22
    1da4:	80 83       	st	Z, r24
			u8_ADC_tx[1] = 0b10 << 6 ;
    1da6:	80 e8       	ldi	r24, 0x80	; 128
    1da8:	81 83       	std	Z+1, r24	; 0x01
		break;
    1daa:	08 95       	ret
		
		case 3 :
		u8_ADC_tx[0] = 0b00000110 ;
    1dac:	86 e0       	ldi	r24, 0x06	; 6
    1dae:	fb 01       	movw	r30, r22
    1db0:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1db2:	80 ec       	ldi	r24, 0xC0	; 192
    1db4:	81 83       	std	Z+1, r24	; 0x01
		break;
    1db6:	08 95       	ret
		
		case 4 :
		u8_ADC_tx[0] = 0b00000111 ;
    1db8:	87 e0       	ldi	r24, 0x07	; 7
    1dba:	fb 01       	movw	r30, r22
    1dbc:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b00 << 6 ;
    1dbe:	11 82       	std	Z+1, r1	; 0x01
		break;
    1dc0:	08 95       	ret
		
		case 5 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dc2:	87 e0       	ldi	r24, 0x07	; 7
    1dc4:	fb 01       	movw	r30, r22
    1dc6:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b01 << 6 ;
    1dc8:	80 e4       	ldi	r24, 0x40	; 64
    1dca:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dcc:	08 95       	ret
		
		case 6 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dce:	87 e0       	ldi	r24, 0x07	; 7
    1dd0:	fb 01       	movw	r30, r22
    1dd2:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b10 << 6 ;
    1dd4:	80 e8       	ldi	r24, 0x80	; 128
    1dd6:	81 83       	std	Z+1, r24	; 0x01
		break;
    1dd8:	08 95       	ret
		
		case 7 :
		u8_ADC_tx[0] = 0b00000111 ;
    1dda:	87 e0       	ldi	r24, 0x07	; 7
    1ddc:	fb 01       	movw	r30, r22
    1dde:	80 83       	st	Z, r24
		u8_ADC_tx[1] = 0b11 << 6 ;
    1de0:	80 ec       	ldi	r24, 0xC0	; 192
    1de2:	81 83       	std	Z+1, r24	; 0x01
    1de4:	08 95       	ret

00001de6 <__vector_18>:

/**************************************************************************************************
*   CAN ISR - See 'can.h' Header file for Description
**************************************************************************************************/
ISR(CANIT_vect)
{
    1de6:	1f 92       	push	r1
    1de8:	0f 92       	push	r0
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	0f 92       	push	r0
    1dee:	11 24       	eor	r1, r1
    1df0:	0b b6       	in	r0, 0x3b	; 59
    1df2:	0f 92       	push	r0
    1df4:	2f 93       	push	r18
    1df6:	3f 93       	push	r19
    1df8:	4f 93       	push	r20
    1dfa:	5f 93       	push	r21
    1dfc:	6f 93       	push	r22
    1dfe:	8f 93       	push	r24
    1e00:	9f 93       	push	r25
    1e02:	af 93       	push	r26
    1e04:	bf 93       	push	r27
    1e06:	ef 93       	push	r30
    1e08:	ff 93       	push	r31
    1e0a:	cf 93       	push	r28
    1e0c:	df 93       	push	r29
    1e0e:	1f 92       	push	r1
    1e10:	cd b7       	in	r28, 0x3d	; 61
    1e12:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t mob_status;

	uint8_t mob_interrupts = CANSIT2;
    1e14:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__TEXT_REGION_LENGTH__+0x7e00e0>

	// TX
	if ((mob_interrupts & (1 << SIT0)) && (CANIE2 & (1 << ENMOB0))) {
    1e18:	80 ff       	sbrs	r24, 0
    1e1a:	47 c0       	rjmp	.+142    	; 0x1eaa <__vector_18+0xc4>
    1e1c:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1e20:	90 ff       	sbrs	r25, 0
    1e22:	43 c0       	rjmp	.+134    	; 0x1eaa <__vector_18+0xc4>
		CANPAGE = (0x0 << MOBNB0); //Select TX Mob (Mob0)
    1e24:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		mob_status = CANSTMOB;
    1e28:	ee ee       	ldi	r30, 0xEE	; 238
    1e2a:	f0 e0       	ldi	r31, 0x00	; 0
    1e2c:	80 81       	ld	r24, Z
    1e2e:	89 83       	std	Y+1, r24	; 0x01
		CANSTMOB &= ~(1 << TXOK); //clear MB1, TX interrupt
    1e30:	80 81       	ld	r24, Z
    1e32:	8f 7b       	andi	r24, 0xBF	; 191
    1e34:	80 83       	st	Z, r24

		if (tx_on != tx_off) {
    1e36:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e3a:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <tx_on>
    1e3e:	98 17       	cp	r25, r24
    1e40:	89 f1       	breq	.+98     	; 0x1ea4 <__vector_18+0xbe>
			unsigned char pos;
			pos = tx_off & (TX_SIZE-1);
			//set ID
			CANIDT4 = tx_frames[pos].array[0];
    1e42:	8f 70       	andi	r24, 0x0F	; 15
    1e44:	2b e0       	ldi	r18, 0x0B	; 11
    1e46:	82 9f       	mul	r24, r18
    1e48:	c0 01       	movw	r24, r0
    1e4a:	11 24       	eor	r1, r1
    1e4c:	fc 01       	movw	r30, r24
    1e4e:	e1 54       	subi	r30, 0x41	; 65
    1e50:	fd 4f       	sbci	r31, 0xFD	; 253
    1e52:	20 81       	ld	r18, Z
    1e54:	20 93 f0 00 	sts	0x00F0, r18	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
			CANIDT2 = tx_frames[pos].array[0];
    1e58:	20 81       	ld	r18, Z
    1e5a:	20 93 f2 00 	sts	0x00F2, r18	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
			CANIDT1 = tx_frames[pos].array[1];
    1e5e:	21 81       	ldd	r18, Z+1	; 0x01
    1e60:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

			//program data registers - auto increment CANMSG
			CANMSG = tx_frames[pos].data[0];
    1e64:	23 81       	ldd	r18, Z+3	; 0x03
    1e66:	aa ef       	ldi	r26, 0xFA	; 250
    1e68:	b0 e0       	ldi	r27, 0x00	; 0
    1e6a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[1];
    1e6c:	24 81       	ldd	r18, Z+4	; 0x04
    1e6e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[2];
    1e70:	25 81       	ldd	r18, Z+5	; 0x05
    1e72:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[3];
    1e74:	26 81       	ldd	r18, Z+6	; 0x06
    1e76:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[4];
    1e78:	27 81       	ldd	r18, Z+7	; 0x07
    1e7a:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[5];
    1e7c:	20 85       	ldd	r18, Z+8	; 0x08
    1e7e:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[6];
    1e80:	21 85       	ldd	r18, Z+9	; 0x09
    1e82:	2c 93       	st	X, r18
			CANMSG = tx_frames[pos].data[7];
    1e84:	22 85       	ldd	r18, Z+10	; 0x0a
    1e86:	2c 93       	st	X, r18

			//set length and request send
			CANCDMOB = (1 << CONMOB0) | tx_frames[pos].length;
    1e88:	fc 01       	movw	r30, r24
    1e8a:	ef 53       	subi	r30, 0x3F	; 63
    1e8c:	fd 4f       	sbci	r31, 0xFD	; 253
    1e8e:	80 81       	ld	r24, Z
    1e90:	8f 70       	andi	r24, 0x0F	; 15
    1e92:	80 64       	ori	r24, 0x40	; 64
    1e94:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
			tx_off++;
    1e98:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <tx_off>
    1e9c:	8f 5f       	subi	r24, 0xFF	; 255
    1e9e:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <tx_off>
    1ea2:	7d c0       	rjmp	.+250    	; 0x1f9e <__vector_18+0x1b8>
		} else {
			tx_busy = 0;
    1ea4:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <tx_busy>
    1ea8:	7a c0       	rjmp	.+244    	; 0x1f9e <__vector_18+0x1b8>
		}
	}
	// RX
	else if ((mob_interrupts & (1 << SIT1)) && (CANIE2 & (1 << ENMOB1))) {
    1eaa:	81 ff       	sbrs	r24, 1
    1eac:	78 c0       	rjmp	.+240    	; 0x1f9e <__vector_18+0x1b8>
    1eae:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
    1eb2:	81 ff       	sbrs	r24, 1
    1eb4:	74 c0       	rjmp	.+232    	; 0x1f9e <__vector_18+0x1b8>
		//Select RX Mob (Mob1)
		CANPAGE = (0x1 << MOBNB0);
    1eb6:	80 e1       	ldi	r24, 0x10	; 16
    1eb8:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		if (((rx_on - rx_off) & RX_ABS_MASK) < RX_SIZE) {
    1ebc:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <rx_on>
    1ec0:	28 2f       	mov	r18, r24
    1ec2:	30 e0       	ldi	r19, 0x00	; 0
    1ec4:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <rx_off>
    1ec8:	29 1b       	sub	r18, r25
    1eca:	31 09       	sbc	r19, r1
    1ecc:	2f 77       	andi	r18, 0x7F	; 127
    1ece:	33 27       	eor	r19, r19
    1ed0:	20 31       	cpi	r18, 0x10	; 16
    1ed2:	31 05       	cpc	r19, r1
    1ed4:	0c f0       	brlt	.+2      	; 0x1ed8 <__vector_18+0xf2>
    1ed6:	58 c0       	rjmp	.+176    	; 0x1f88 <__vector_18+0x1a2>
			unsigned char pos;
			pos = rx_on & (RX_SIZE-1);
			//Read length
			rx_frames[pos].length = CANCDMOB & 0x0F;
    1ed8:	e8 2f       	mov	r30, r24
    1eda:	ef 70       	andi	r30, 0x0F	; 15
    1edc:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
    1ee0:	2e 2f       	mov	r18, r30
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	4b e0       	ldi	r20, 0x0B	; 11
    1ee6:	e4 9f       	mul	r30, r20
    1ee8:	f0 01       	movw	r30, r0
    1eea:	11 24       	eor	r1, r1
    1eec:	e1 5f       	subi	r30, 0xF1	; 241
    1eee:	fd 4f       	sbci	r31, 0xFD	; 253
    1ef0:	9f 70       	andi	r25, 0x0F	; 15
    1ef2:	42 81       	ldd	r20, Z+2	; 0x02
    1ef4:	40 7f       	andi	r20, 0xF0	; 240
    1ef6:	94 2b       	or	r25, r20
    1ef8:	92 83       	std	Z+2, r25	; 0x02
			//Read ID
			rx_frames[pos].array[0] = (CANIDT2 & 0xE0) | (CANIDT4 & 0x07);
    1efa:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    1efe:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    1f02:	40 7e       	andi	r20, 0xE0	; 224
    1f04:	97 70       	andi	r25, 0x07	; 7
    1f06:	94 2b       	or	r25, r20
    1f08:	90 83       	st	Z, r25
			rx_frames[pos].array[1] = CANIDT1;
    1f0a:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    1f0e:	91 83       	std	Z+1, r25	; 0x01

			//read data registers - auto increment CANMSG
			rx_frames[pos].data[0] = CANMSG;
    1f10:	aa ef       	ldi	r26, 0xFA	; 250
    1f12:	b0 e0       	ldi	r27, 0x00	; 0
    1f14:	9c 91       	ld	r25, X
    1f16:	93 83       	std	Z+3, r25	; 0x03
			rx_frames[pos].data[1] = CANMSG;
    1f18:	9c 91       	ld	r25, X
    1f1a:	94 83       	std	Z+4, r25	; 0x04
			rx_frames[pos].data[2] = CANMSG;
    1f1c:	9c 91       	ld	r25, X
    1f1e:	95 83       	std	Z+5, r25	; 0x05
			rx_frames[pos].data[3] = CANMSG;
    1f20:	9c 91       	ld	r25, X
    1f22:	96 83       	std	Z+6, r25	; 0x06
			rx_frames[pos].data[4] = CANMSG;
    1f24:	9c 91       	ld	r25, X
    1f26:	97 83       	std	Z+7, r25	; 0x07
			rx_frames[pos].data[5] = CANMSG;
    1f28:	9c 91       	ld	r25, X
    1f2a:	90 87       	std	Z+8, r25	; 0x08
			rx_frames[pos].data[6] = CANMSG;
    1f2c:	9c 91       	ld	r25, X
    1f2e:	91 87       	std	Z+9, r25	; 0x09
			rx_frames[pos].data[7] = CANMSG;
    1f30:	9c 91       	ld	r25, X
    1f32:	92 87       	std	Z+10, r25	; 0x0a
			rx_on++;
    1f34:	8f 5f       	subi	r24, 0xFF	; 255
    1f36:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <rx_on>

			// Reset if reset can message
			if(rx_frames[pos].id == 0x000 && rx_frames[pos].data[0] == 0x03){
    1f3a:	40 81       	ld	r20, Z
    1f3c:	42 95       	swap	r20
    1f3e:	46 95       	lsr	r20
    1f40:	47 70       	andi	r20, 0x07	; 7
    1f42:	51 81       	ldd	r21, Z+1	; 0x01
    1f44:	65 2f       	mov	r22, r21
    1f46:	66 0f       	add	r22, r22
    1f48:	66 0f       	add	r22, r22
    1f4a:	66 0f       	add	r22, r22
    1f4c:	86 2f       	mov	r24, r22
    1f4e:	84 2b       	or	r24, r20
    1f50:	95 2f       	mov	r25, r21
    1f52:	92 95       	swap	r25
    1f54:	96 95       	lsr	r25
    1f56:	97 70       	andi	r25, 0x07	; 7
    1f58:	89 2b       	or	r24, r25
    1f5a:	b1 f4       	brne	.+44     	; 0x1f88 <__vector_18+0x1a2>
    1f5c:	8b e0       	ldi	r24, 0x0B	; 11
    1f5e:	82 9f       	mul	r24, r18
    1f60:	f0 01       	movw	r30, r0
    1f62:	83 9f       	mul	r24, r19
    1f64:	f0 0d       	add	r31, r0
    1f66:	11 24       	eor	r1, r1
    1f68:	e1 5f       	subi	r30, 0xF1	; 241
    1f6a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f6c:	83 81       	ldd	r24, Z+3	; 0x03
    1f6e:	83 30       	cpi	r24, 0x03	; 3
    1f70:	59 f4       	brne	.+22     	; 0x1f88 <__vector_18+0x1a2>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    1f72:	98 e0       	ldi	r25, 0x08	; 8
    1f74:	88 e1       	ldi	r24, 0x18	; 24
    1f76:	0f b6       	in	r0, 0x3f	; 63
    1f78:	f8 94       	cli
    1f7a:	a8 95       	wdr
    1f7c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f80:	0f be       	out	0x3f, r0	; 63
    1f82:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1f86:	ff cf       	rjmp	.-2      	; 0x1f86 <__vector_18+0x1a0>
				while(1); //wait for watchdog
			}
		}

		// Clear irq
		mob_status = CANSTMOB;
    1f88:	ee ee       	ldi	r30, 0xEE	; 238
    1f8a:	f0 e0       	ldi	r31, 0x00	; 0
    1f8c:	80 81       	ld	r24, Z
    1f8e:	89 83       	std	Y+1, r24	; 0x01
		(void)mob_status;
    1f90:	89 81       	ldd	r24, Y+1	; 0x01

		CANSTMOB &= ~(1 << RXOK);
    1f92:	80 81       	ld	r24, Z
    1f94:	8f 7d       	andi	r24, 0xDF	; 223
    1f96:	80 83       	st	Z, r24
		CANCDMOB = (1 << CONMOB1);			//Set Mob 1 as RX
    1f98:	80 e8       	ldi	r24, 0x80	; 128
    1f9a:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	}
}
    1f9e:	0f 90       	pop	r0
    1fa0:	df 91       	pop	r29
    1fa2:	cf 91       	pop	r28
    1fa4:	ff 91       	pop	r31
    1fa6:	ef 91       	pop	r30
    1fa8:	bf 91       	pop	r27
    1faa:	af 91       	pop	r26
    1fac:	9f 91       	pop	r25
    1fae:	8f 91       	pop	r24
    1fb0:	6f 91       	pop	r22
    1fb2:	5f 91       	pop	r21
    1fb4:	4f 91       	pop	r20
    1fb6:	3f 91       	pop	r19
    1fb8:	2f 91       	pop	r18
    1fba:	0f 90       	pop	r0
    1fbc:	0b be       	out	0x3b, r0	; 59
    1fbe:	0f 90       	pop	r0
    1fc0:	0f be       	out	0x3f, r0	; 63
    1fc2:	0f 90       	pop	r0
    1fc4:	1f 90       	pop	r1
    1fc6:	18 95       	reti

00001fc8 <can_init>:


void can_init(uint16_t accept_mask_id, uint16_t accept_tag_id) {
    1fc8:	cf 93       	push	r28
    1fca:	df 93       	push	r29
	// Reset CAN controller
	CANGCON = (1 << SWRES);
    1fcc:	e8 ed       	ldi	r30, 0xD8	; 216
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	21 e0       	ldi	r18, 0x01	; 1
    1fd2:	20 83       	st	Z, r18

	CANBT1 = (BRP_VALUE - 1) << 1;
    1fd4:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
	CANBT2 = ((SJW_VALUE - 1) << 5) | ((PROP_SEG - 1) << 1);
    1fd8:	2c e0       	ldi	r18, 0x0C	; 12
    1fda:	20 93 e3 00 	sts	0x00E3, r18	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	CANBT3 = ((PHASE_SEG_2 - 1) << 4) | ((PHASE_SEG_1 - 1) << 1) | 1;
    1fde:	27 e3       	ldi	r18, 0x37	; 55
    1fe0:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>

	CANTIM = 0;
    1fe4:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <__TEXT_REGION_LENGTH__+0x7e00e7>
    1fe8:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <__TEXT_REGION_LENGTH__+0x7e00e6>
	CANTTC = 0;
    1fec:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    1ff0:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	CANHPMOB = 0;
    1ff4:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
	CANTCON = 0;
    1ff8:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

	// Switch to Mob 0 access
	CANPAGE = (0x0 << MOBNB0);
    1ffc:	cd ee       	ldi	r28, 0xED	; 237
    1ffe:	d0 e0       	ldi	r29, 0x00	; 0
    2000:	18 82       	st	Y, r1
	CANSTMOB = 0;
    2002:	ae ee       	ldi	r26, 0xEE	; 238
    2004:	b0 e0       	ldi	r27, 0x00	; 0
    2006:	1c 92       	st	X, r1

	// Switch to Mob 1 access
	CANPAGE = (0x1 << MOBNB0);
    2008:	20 e1       	ldi	r18, 0x10	; 16
    200a:	28 83       	st	Y, r18
	CANSTMOB = 0;
    200c:	1c 92       	st	X, r1
	CANIDM4 = 0;
    200e:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	CANIDM2 = (accept_mask_id << 5) & 0xFF;
    2012:	28 2f       	mov	r18, r24
    2014:	22 95       	swap	r18
    2016:	22 0f       	add	r18, r18
    2018:	20 7e       	andi	r18, 0xE0	; 224
    201a:	20 93 f6 00 	sts	0x00F6, r18	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = (accept_mask_id >> 3) & 0xFF;
    201e:	96 95       	lsr	r25
    2020:	87 95       	ror	r24
    2022:	96 95       	lsr	r25
    2024:	87 95       	ror	r24
    2026:	96 95       	lsr	r25
    2028:	87 95       	ror	r24
    202a:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	CANIDT4 = 0;
    202e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDT2 = (accept_tag_id << 5) & 0xFF;
    2032:	86 2f       	mov	r24, r22
    2034:	82 95       	swap	r24
    2036:	88 0f       	add	r24, r24
    2038:	80 7e       	andi	r24, 0xE0	; 224
    203a:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = (accept_tag_id >> 3) & 0xFF;
    203e:	76 95       	lsr	r23
    2040:	67 95       	ror	r22
    2042:	76 95       	lsr	r23
    2044:	67 95       	ror	r22
    2046:	76 95       	lsr	r23
    2048:	67 95       	ror	r22
    204a:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>

	// Set Mob 1 as RX
	CANCDMOB = (1 << CONMOB1);
    204e:	80 e8       	ldi	r24, 0x80	; 128
    2050:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>

	// Enable Mob 0 and 1
	CANEN2 = (1 << ENMOB1) | (1 << ENMOB0);
    2054:	83 e0       	ldi	r24, 0x03	; 3
    2056:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <__TEXT_REGION_LENGTH__+0x7e00dc>
	// Enable Mob 0 and 1 Interrupt
	CANIE2 = (1 << ENMOB1) | (1 << ENMOB0);
    205a:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	// Enable TX and RX interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);	
    205e:	80 eb       	ldi	r24, 0xB0	; 176
    2060:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>

	// Enable CAN controller
	CANGCON = (1 << ENASTB);
    2064:	82 e0       	ldi	r24, 0x02	; 2
    2066:	80 83       	st	Z, r24

	reset = 0;
    2068:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <reset>
}
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	08 95       	ret

00002072 <can_read_message_if_new>:

bool can_read_message_if_new(CanMessage_t* message) {
    2072:	cf 93       	push	r28
    2074:	df 93       	push	r29
    2076:	ec 01       	movw	r28, r24
	// Check if there is a new message
	if (rx_on == rx_off) {
    2078:	40 91 0b 02 	lds	r20, 0x020B	; 0x80020b <rx_off>
    207c:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <rx_on>
    2080:	24 17       	cp	r18, r20
    2082:	89 f1       	breq	.+98     	; 0x20e6 <can_read_message_if_new+0x74>
    2084:	a4 2f       	mov	r26, r20
    2086:	af 70       	andi	r26, 0x0F	; 15
	}

	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
    2088:	8b e0       	ldi	r24, 0x0B	; 11
    208a:	a8 9f       	mul	r26, r24
    208c:	b0 01       	movw	r22, r0
    208e:	11 24       	eor	r1, r1
    2090:	fb 01       	movw	r30, r22
    2092:	e1 5f       	subi	r30, 0xF1	; 241
    2094:	fd 4f       	sbci	r31, 0xFD	; 253
    2096:	20 81       	ld	r18, Z
    2098:	22 95       	swap	r18
    209a:	26 95       	lsr	r18
    209c:	27 70       	andi	r18, 0x07	; 7
    209e:	31 81       	ldd	r19, Z+1	; 0x01
    20a0:	53 2f       	mov	r21, r19
    20a2:	55 0f       	add	r21, r21
    20a4:	55 0f       	add	r21, r21
    20a6:	55 0f       	add	r21, r21
    20a8:	25 2b       	or	r18, r21
    20aa:	32 95       	swap	r19
    20ac:	36 95       	lsr	r19
    20ae:	37 70       	andi	r19, 0x07	; 7
    20b0:	28 83       	st	Y, r18
    20b2:	39 83       	std	Y+1, r19	; 0x01
	message->length = frame->length;
    20b4:	fb 01       	movw	r30, r22
    20b6:	ef 5e       	subi	r30, 0xEF	; 239
    20b8:	fd 4f       	sbci	r31, 0xFD	; 253
    20ba:	20 81       	ld	r18, Z
    20bc:	2f 70       	andi	r18, 0x0F	; 15
    20be:	2a 83       	std	Y+2, r18	; 0x02
	for (int i = 0; i < message->length; i++) {
    20c0:	22 23       	and	r18, r18
    20c2:	99 f0       	breq	.+38     	; 0x20ea <can_read_message_if_new+0x78>
    20c4:	db 01       	movw	r26, r22
    20c6:	ae 5e       	subi	r26, 0xEE	; 238
    20c8:	bd 4f       	sbci	r27, 0xFD	; 253
    20ca:	fe 01       	movw	r30, r28
    20cc:	33 96       	adiw	r30, 0x03	; 3
    20ce:	30 e0       	ldi	r19, 0x00	; 0
    20d0:	2d 5f       	subi	r18, 0xFD	; 253
    20d2:	3f 4f       	sbci	r19, 0xFF	; 255
    20d4:	ce 01       	movw	r24, r28
    20d6:	82 0f       	add	r24, r18
    20d8:	93 1f       	adc	r25, r19
		message->data.u8[i] = frame->data[i];
    20da:	2d 91       	ld	r18, X+
    20dc:	21 93       	st	Z+, r18
	// Read the can frame
	can_frame* frame = &rx_frames[(rx_off & (RX_SIZE - 1))];

	message->id = frame->id;
	message->length = frame->length;
	for (int i = 0; i < message->length; i++) {
    20de:	e8 17       	cp	r30, r24
    20e0:	f9 07       	cpc	r31, r25
    20e2:	d9 f7       	brne	.-10     	; 0x20da <can_read_message_if_new+0x68>
    20e4:	02 c0       	rjmp	.+4      	; 0x20ea <can_read_message_if_new+0x78>
}

bool can_read_message_if_new(CanMessage_t* message) {
	// Check if there is a new message
	if (rx_on == rx_off) {
		return false;
    20e6:	80 e0       	ldi	r24, 0x00	; 0
    20e8:	04 c0       	rjmp	.+8      	; 0x20f2 <can_read_message_if_new+0x80>
		message->data.u8[i] = frame->data[i];
	}

	// Advance to next can message
	if (rx_on != rx_off) {
		rx_off++;
    20ea:	4f 5f       	subi	r20, 0xFF	; 255
    20ec:	40 93 0b 02 	sts	0x020B, r20	; 0x80020b <rx_off>
	}

	return true;
    20f0:	81 e0       	ldi	r24, 0x01	; 1
}
    20f2:	df 91       	pop	r29
    20f4:	cf 91       	pop	r28
    20f6:	08 95       	ret

000020f8 <can_send_message>:

bool can_send_message(CanMessage_t* message) {
    20f8:	cf 93       	push	r28
    20fa:	df 93       	push	r29
    20fc:	fc 01       	movw	r30, r24
	bool result = false;

	CANGIE &= ~(1 << ENIT);
    20fe:	ab ed       	ldi	r26, 0xDB	; 219
    2100:	b0 e0       	ldi	r27, 0x00	; 0
    2102:	8c 91       	ld	r24, X
    2104:	8f 77       	andi	r24, 0x7F	; 127
    2106:	8c 93       	st	X, r24

	if (!tx_busy) {
    2108:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <tx_busy>
    210c:	81 11       	cpse	r24, r1
    210e:	27 c0       	rjmp	.+78     	; 0x215e <can_send_message+0x66>
		// Switch to Mob 0 access
		CANPAGE = 0 << 4;
    2110:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

		// Set ID
		CANIDT2 = message->id << 5;
    2114:	80 81       	ld	r24, Z
    2116:	82 95       	swap	r24
    2118:	88 0f       	add	r24, r24
    211a:	80 7e       	andi	r24, 0xE0	; 224
    211c:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
		CANIDT1 = message->id >> 3;
    2120:	80 81       	ld	r24, Z
    2122:	91 81       	ldd	r25, Z+1	; 0x01
    2124:	96 95       	lsr	r25
    2126:	87 95       	ror	r24
    2128:	96 95       	lsr	r25
    212a:	87 95       	ror	r24
    212c:	96 95       	lsr	r25
    212e:	87 95       	ror	r24
    2130:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2134:	df 01       	movw	r26, r30
    2136:	13 96       	adiw	r26, 0x03	; 3
    2138:	9f 01       	movw	r18, r30
    213a:	25 5f       	subi	r18, 0xF5	; 245
    213c:	3f 4f       	sbci	r19, 0xFF	; 255

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
    213e:	ca ef       	ldi	r28, 0xFA	; 250
    2140:	d0 e0       	ldi	r29, 0x00	; 0
    2142:	9d 91       	ld	r25, X+
    2144:	98 83       	st	Y, r25
		// Set ID
		CANIDT2 = message->id << 5;
		CANIDT1 = message->id >> 3;

		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
    2146:	a2 17       	cp	r26, r18
    2148:	b3 07       	cpc	r27, r19
    214a:	d9 f7       	brne	.-10     	; 0x2142 <can_send_message+0x4a>
			CANMSG = message->data.u8[i];
		}
		
		result = true;
		tx_busy = 1;
    214c:	81 e0       	ldi	r24, 0x01	; 1
    214e:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <tx_busy>

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
    2152:	82 81       	ldd	r24, Z+2	; 0x02
    2154:	80 64       	ori	r24, 0x40	; 64
    2156:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
		// Program data registers - auto increment
		for (int i = 0; i < 8; i++) {
			CANMSG = message->data.u8[i];
		}
		
		result = true;
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	43 c0       	rjmp	.+134    	; 0x21e4 <can_send_message+0xec>
		tx_busy = 1;

		// Set length, start send which restarts tx interrupt
		CANCDMOB = (1 << CONMOB0) | message->length;
	}
	else if (TX_SIZE - ((tx_on - tx_off) & TX_ABS_MASK)) {
    215e:	20 91 0d 02 	lds	r18, 0x020D	; 0x80020d <tx_on>
    2162:	82 2f       	mov	r24, r18
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <tx_off>
    216a:	83 1b       	sub	r24, r19
    216c:	91 09       	sbc	r25, r1
    216e:	8f 77       	andi	r24, 0x7F	; 127
    2170:	99 27       	eor	r25, r25
    2172:	40 97       	sbiw	r24, 0x10	; 16
    2174:	b1 f1       	breq	.+108    	; 0x21e2 <can_send_message+0xea>
		// Copy data into TX buffer
		tx_frames[tx_on & (TX_SIZE-1)].id = message->id;
    2176:	a2 2f       	mov	r26, r18
    2178:	af 70       	andi	r26, 0x0F	; 15
    217a:	8b e0       	ldi	r24, 0x0B	; 11
    217c:	a8 9f       	mul	r26, r24
    217e:	d0 01       	movw	r26, r0
    2180:	11 24       	eor	r1, r1
    2182:	ed 01       	movw	r28, r26
    2184:	c1 54       	subi	r28, 0x41	; 65
    2186:	dd 4f       	sbci	r29, 0xFD	; 253
    2188:	80 81       	ld	r24, Z
    218a:	98 2f       	mov	r25, r24
    218c:	92 95       	swap	r25
    218e:	99 0f       	add	r25, r25
    2190:	90 7e       	andi	r25, 0xE0	; 224
    2192:	88 81       	ld	r24, Y
    2194:	8f 71       	andi	r24, 0x1F	; 31
    2196:	89 2b       	or	r24, r25
    2198:	88 83       	st	Y, r24
    219a:	80 81       	ld	r24, Z
    219c:	98 2f       	mov	r25, r24
    219e:	96 95       	lsr	r25
    21a0:	96 95       	lsr	r25
    21a2:	96 95       	lsr	r25
    21a4:	89 81       	ldd	r24, Y+1	; 0x01
    21a6:	80 7e       	andi	r24, 0xE0	; 224
    21a8:	89 2b       	or	r24, r25
    21aa:	89 83       	std	Y+1, r24	; 0x01
    21ac:	91 81       	ldd	r25, Z+1	; 0x01
    21ae:	92 95       	swap	r25
    21b0:	99 0f       	add	r25, r25
    21b2:	90 7e       	andi	r25, 0xE0	; 224
    21b4:	8f 71       	andi	r24, 0x1F	; 31
    21b6:	89 2b       	or	r24, r25
    21b8:	89 83       	std	Y+1, r24	; 0x01
		tx_frames[tx_on & (TX_SIZE-1)].length = message->length;
    21ba:	82 81       	ldd	r24, Z+2	; 0x02
    21bc:	98 2f       	mov	r25, r24
    21be:	9f 70       	andi	r25, 0x0F	; 15
    21c0:	8a 81       	ldd	r24, Y+2	; 0x02
    21c2:	80 7f       	andi	r24, 0xF0	; 240
    21c4:	89 2b       	or	r24, r25
    21c6:	8a 83       	std	Y+2, r24	; 0x02
		memcpy(tx_frames[tx_on & (TX_SIZE-1)].data, &message->data, CAN_FRAME_DATA_MAX_LENGTH);
    21c8:	ae 53       	subi	r26, 0x3E	; 62
    21ca:	bd 4f       	sbci	r27, 0xFD	; 253
    21cc:	33 96       	adiw	r30, 0x03	; 3
    21ce:	88 e0       	ldi	r24, 0x08	; 8
    21d0:	01 90       	ld	r0, Z+
    21d2:	0d 92       	st	X+, r0
    21d4:	8a 95       	dec	r24
    21d6:	e1 f7       	brne	.-8      	; 0x21d0 <can_send_message+0xd8>

		/*for (int i = 0; i < 8; i++) {
			tx_frames[tx_on & (TX_SIZE-1)].data[i] = message->data.u8[i];
		}*/

		tx_on++;
    21d8:	2f 5f       	subi	r18, 0xFF	; 255
    21da:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <tx_on>
		result = true;
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	01 c0       	rjmp	.+2      	; 0x21e4 <can_send_message+0xec>

	return true;
}

bool can_send_message(CanMessage_t* message) {
	bool result = false;
    21e2:	80 e0       	ldi	r24, 0x00	; 0

		tx_on++;
		result = true;
	}

	CANGIE |= (1 << ENIT);
    21e4:	eb ed       	ldi	r30, 0xDB	; 219
    21e6:	f0 e0       	ldi	r31, 0x00	; 0
    21e8:	90 81       	ld	r25, Z
    21ea:	90 68       	ori	r25, 0x80	; 128
    21ec:	90 83       	st	Z, r25

	return result;
    21ee:	df 91       	pop	r29
    21f0:	cf 91       	pop	r28
    21f2:	08 95       	ret

000021f4 <rgbled_turn_off>:
	DDRB |= LED_ALL;
	rgbled_turn_off(LED_ALL);
}

void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
    21f4:	95 b1       	in	r25, 0x05	; 5
    21f6:	89 2b       	or	r24, r25
    21f8:	85 b9       	out	0x05, r24	; 5
    21fa:	08 95       	ret

000021fc <rgbled_init>:
#include "rgbled.h"
#include <avr/io.h>


void rgbled_init() {
	DDRB |= LED_ALL;
    21fc:	84 b1       	in	r24, 0x04	; 4
    21fe:	80 6e       	ori	r24, 0xE0	; 224
    2200:	84 b9       	out	0x04, r24	; 4
	rgbled_turn_off(LED_ALL);
    2202:	80 ee       	ldi	r24, 0xE0	; 224
    2204:	f7 cf       	rjmp	.-18     	; 0x21f4 <rgbled_turn_off>
    2206:	08 95       	ret

00002208 <rgbled_turn_on>:
void rgbled_turn_off(RgbLedColor_t color) {
	PORTB |= color;
}

void rgbled_turn_on(RgbLedColor_t color) {
	PORTB &= ~color;
    2208:	95 b1       	in	r25, 0x05	; 5
    220a:	80 95       	com	r24
    220c:	98 23       	and	r25, r24
    220e:	95 b9       	out	0x05, r25	; 5
    2210:	08 95       	ret

00002212 <rgbled_toggle>:
}

void rgbled_toggle(RgbLedColor_t color) {
	PORTB ^= color;
    2212:	95 b1       	in	r25, 0x05	; 5
    2214:	89 27       	eor	r24, r25
    2216:	85 b9       	out	0x05, r24	; 5
    2218:	08 95       	ret

0000221a <spi_init>:
#define PIN_SCK PB1
#define PIN_SS PB0

void spi_init(spi_prescale_t clock_prescale) {
	// Set MOSI, SS, and SCK output, all others input
	DDR_SPI |= (1 << PIN_MOSI) | (1 << PIN_SCK) | (1 << PIN_SS);
    221a:	94 b1       	in	r25, 0x04	; 4
    221c:	97 60       	ori	r25, 0x07	; 7
    221e:	94 b9       	out	0x04, r25	; 4
	
	uint8_t SPI2X_val = (uint8_t)((clock_prescale >> 2) & 0b001);
    2220:	82 fb       	bst	r24, 2
    2222:	99 27       	eor	r25, r25
    2224:	90 f9       	bld	r25, 0
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0) | (1 << CPOL) | (1 << CPHA);
	SPSR = (SPI2X_val << SPI2X);
*/

	// Enable SPI, Master, selected prescaling, mode 0 (CPOL = CPHA = 0)
	SPCR = (1 << SPE) | (1 << MSTR) | (SPR1_val << SPR1) | (SPR0_val << SPR0);
    2226:	28 2f       	mov	r18, r24
    2228:	22 70       	andi	r18, 0x02	; 2
    222a:	81 70       	andi	r24, 0x01	; 1
    222c:	80 65       	ori	r24, 0x50	; 80
    222e:	82 2b       	or	r24, r18
    2230:	8c bd       	out	0x2c, r24	; 44
	SPCR &= ~((1 << CPOL) | (1 << CPHA));
    2232:	8c b5       	in	r24, 0x2c	; 44
    2234:	83 7f       	andi	r24, 0xF3	; 243
    2236:	8c bd       	out	0x2c, r24	; 44
	SPSR = (SPI2X_val << SPI2X);
    2238:	9d bd       	out	0x2d, r25	; 45
    223a:	08 95       	ret

0000223c <spi_trancieve>:

}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
    223c:	cf 93       	push	r28
    223e:	df 93       	push	r29
    2240:	ec 01       	movw	r28, r24
	PORTB &= ~(1 << PIN_SS);
    2242:	28 98       	cbi	0x05, 0	; 5

	for (size_t i = 0; i < length; i++) {
    2244:	41 15       	cp	r20, r1
    2246:	51 05       	cpc	r21, r1
    2248:	c1 f0       	breq	.+48     	; 0x227a <spi_trancieve+0x3e>
    224a:	fb 01       	movw	r30, r22
    224c:	dc 01       	movw	r26, r24
    224e:	46 0f       	add	r20, r22
    2250:	57 1f       	adc	r21, r23
		SPDR = (tx_buffer != NULL) ? tx_buffer[i] : 0xFF;
    2252:	8f ef       	ldi	r24, 0xFF	; 255
    2254:	20 97       	sbiw	r28, 0x00	; 0
    2256:	11 f0       	breq	.+4      	; 0x225c <spi_trancieve+0x20>
    2258:	9c 91       	ld	r25, X
    225a:	01 c0       	rjmp	.+2      	; 0x225e <spi_trancieve+0x22>
    225c:	98 2f       	mov	r25, r24
    225e:	9e bd       	out	0x2e, r25	; 46

		while(!(SPSR & (1 << SPIF)));
    2260:	0d b4       	in	r0, 0x2d	; 45
    2262:	07 fe       	sbrs	r0, 7
    2264:	fd cf       	rjmp	.-6      	; 0x2260 <spi_trancieve+0x24>
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
    2266:	61 15       	cp	r22, r1
    2268:	71 05       	cpc	r23, r1
    226a:	11 f0       	breq	.+4      	; 0x2270 <spi_trancieve+0x34>
    226c:	9e b5       	in	r25, 0x2e	; 46
    226e:	90 83       	st	Z, r25
    2270:	31 96       	adiw	r30, 0x01	; 1
    2272:	11 96       	adiw	r26, 0x01	; 1
}

void spi_trancieve(uint8_t* tx_buffer, uint8_t* rx_buffer, size_t length, bool last_in_transmission) {
	PORTB &= ~(1 << PIN_SS);

	for (size_t i = 0; i < length; i++) {
    2274:	e4 17       	cp	r30, r20
    2276:	f5 07       	cpc	r31, r21
    2278:	69 f7       	brne	.-38     	; 0x2254 <spi_trancieve+0x18>
		while(!(SPSR & (1 << SPIF)));
		
		if (rx_buffer != NULL) rx_buffer[i] = SPDR;
	}

	if (last_in_transmission) {
    227a:	21 11       	cpse	r18, r1
		PORTB |= (1 << PIN_SS);
    227c:	28 9a       	sbi	0x05, 0	; 5
	}
}
    227e:	df 91       	pop	r29
    2280:	cf 91       	pop	r28
    2282:	08 95       	ret

00002284 <__vector_17>:

uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
    2284:	1f 92       	push	r1
    2286:	0f 92       	push	r0
    2288:	0f b6       	in	r0, 0x3f	; 63
    228a:	0f 92       	push	r0
    228c:	11 24       	eor	r1, r1
    228e:	0b b6       	in	r0, 0x3b	; 59
    2290:	0f 92       	push	r0
    2292:	2f 93       	push	r18
    2294:	3f 93       	push	r19
    2296:	4f 93       	push	r20
    2298:	5f 93       	push	r21
    229a:	6f 93       	push	r22
    229c:	7f 93       	push	r23
    229e:	8f 93       	push	r24
    22a0:	af 93       	push	r26
    22a2:	bf 93       	push	r27
    22a4:	ef 93       	push	r30
    22a6:	ff 93       	push	r31
    22a8:	af e8       	ldi	r26, 0x8F	; 143
    22aa:	b3 e0       	ldi	r27, 0x03	; 3
    22ac:	ef e6       	ldi	r30, 0x6F	; 111
    22ae:	f3 e0       	ldi	r31, 0x03	; 3
    22b0:	2f e8       	ldi	r18, 0x8F	; 143
    22b2:	33 e0       	ldi	r19, 0x03	; 3
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
		if (timer_enabled[t]){
    22b4:	8d 91       	ld	r24, X+
    22b6:	88 23       	and	r24, r24
    22b8:	59 f0       	breq	.+22     	; 0x22d0 <__vector_17+0x4c>
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
    22ba:	40 81       	ld	r20, Z
    22bc:	51 81       	ldd	r21, Z+1	; 0x01
    22be:	62 81       	ldd	r22, Z+2	; 0x02
    22c0:	73 81       	ldd	r23, Z+3	; 0x03
    22c2:	50 5e       	subi	r21, 0xE0	; 224
    22c4:	6f 4f       	sbci	r22, 0xFF	; 255
    22c6:	7f 4f       	sbci	r23, 0xFF	; 255
    22c8:	40 83       	st	Z, r20
    22ca:	51 83       	std	Z+1, r21	; 0x01
    22cc:	62 83       	std	Z+2, r22	; 0x02
    22ce:	73 83       	std	Z+3, r23	; 0x03
    22d0:	34 96       	adiw	r30, 0x04	; 4
uint16_t timer_elapsed_ms(timer_t timer) {
	return elapsed_microseconds[timer] / 1000;
}

ISR(TIMER0_OVF_vect) {
	for (int t = 0; t < NUMBER_OF_TIMERS; t++) {
    22d2:	e2 17       	cp	r30, r18
    22d4:	f3 07       	cpc	r31, r19
    22d6:	71 f7       	brne	.-36     	; 0x22b4 <__vector_17+0x30>
		if (timer_enabled[t]){
			elapsed_microseconds[t] += (1000000ULL * 256 * 256) / F_CPU;
		}
	}
}
    22d8:	ff 91       	pop	r31
    22da:	ef 91       	pop	r30
    22dc:	bf 91       	pop	r27
    22de:	af 91       	pop	r26
    22e0:	8f 91       	pop	r24
    22e2:	7f 91       	pop	r23
    22e4:	6f 91       	pop	r22
    22e6:	5f 91       	pop	r21
    22e8:	4f 91       	pop	r20
    22ea:	3f 91       	pop	r19
    22ec:	2f 91       	pop	r18
    22ee:	0f 90       	pop	r0
    22f0:	0b be       	out	0x3b, r0	; 59
    22f2:	0f 90       	pop	r0
    22f4:	0f be       	out	0x3f, r0	; 63
    22f6:	0f 90       	pop	r0
    22f8:	1f 90       	pop	r1
    22fa:	18 95       	reti

000022fc <__subsf3>:
    22fc:	50 58       	subi	r21, 0x80	; 128

000022fe <__addsf3>:
    22fe:	bb 27       	eor	r27, r27
    2300:	aa 27       	eor	r26, r26
    2302:	0e d0       	rcall	.+28     	; 0x2320 <__addsf3x>
    2304:	75 c1       	rjmp	.+746    	; 0x25f0 <__fp_round>
    2306:	66 d1       	rcall	.+716    	; 0x25d4 <__fp_pscA>
    2308:	30 f0       	brcs	.+12     	; 0x2316 <__addsf3+0x18>
    230a:	6b d1       	rcall	.+726    	; 0x25e2 <__fp_pscB>
    230c:	20 f0       	brcs	.+8      	; 0x2316 <__addsf3+0x18>
    230e:	31 f4       	brne	.+12     	; 0x231c <__addsf3+0x1e>
    2310:	9f 3f       	cpi	r25, 0xFF	; 255
    2312:	11 f4       	brne	.+4      	; 0x2318 <__addsf3+0x1a>
    2314:	1e f4       	brtc	.+6      	; 0x231c <__addsf3+0x1e>
    2316:	5b c1       	rjmp	.+694    	; 0x25ce <__fp_nan>
    2318:	0e f4       	brtc	.+2      	; 0x231c <__addsf3+0x1e>
    231a:	e0 95       	com	r30
    231c:	e7 fb       	bst	r30, 7
    231e:	51 c1       	rjmp	.+674    	; 0x25c2 <__fp_inf>

00002320 <__addsf3x>:
    2320:	e9 2f       	mov	r30, r25
    2322:	77 d1       	rcall	.+750    	; 0x2612 <__fp_split3>
    2324:	80 f3       	brcs	.-32     	; 0x2306 <__addsf3+0x8>
    2326:	ba 17       	cp	r27, r26
    2328:	62 07       	cpc	r22, r18
    232a:	73 07       	cpc	r23, r19
    232c:	84 07       	cpc	r24, r20
    232e:	95 07       	cpc	r25, r21
    2330:	18 f0       	brcs	.+6      	; 0x2338 <__addsf3x+0x18>
    2332:	71 f4       	brne	.+28     	; 0x2350 <__addsf3x+0x30>
    2334:	9e f5       	brtc	.+102    	; 0x239c <__addsf3x+0x7c>
    2336:	8f c1       	rjmp	.+798    	; 0x2656 <__fp_zero>
    2338:	0e f4       	brtc	.+2      	; 0x233c <__addsf3x+0x1c>
    233a:	e0 95       	com	r30
    233c:	0b 2e       	mov	r0, r27
    233e:	ba 2f       	mov	r27, r26
    2340:	a0 2d       	mov	r26, r0
    2342:	0b 01       	movw	r0, r22
    2344:	b9 01       	movw	r22, r18
    2346:	90 01       	movw	r18, r0
    2348:	0c 01       	movw	r0, r24
    234a:	ca 01       	movw	r24, r20
    234c:	a0 01       	movw	r20, r0
    234e:	11 24       	eor	r1, r1
    2350:	ff 27       	eor	r31, r31
    2352:	59 1b       	sub	r21, r25
    2354:	99 f0       	breq	.+38     	; 0x237c <__addsf3x+0x5c>
    2356:	59 3f       	cpi	r21, 0xF9	; 249
    2358:	50 f4       	brcc	.+20     	; 0x236e <__addsf3x+0x4e>
    235a:	50 3e       	cpi	r21, 0xE0	; 224
    235c:	68 f1       	brcs	.+90     	; 0x23b8 <__addsf3x+0x98>
    235e:	1a 16       	cp	r1, r26
    2360:	f0 40       	sbci	r31, 0x00	; 0
    2362:	a2 2f       	mov	r26, r18
    2364:	23 2f       	mov	r18, r19
    2366:	34 2f       	mov	r19, r20
    2368:	44 27       	eor	r20, r20
    236a:	58 5f       	subi	r21, 0xF8	; 248
    236c:	f3 cf       	rjmp	.-26     	; 0x2354 <__addsf3x+0x34>
    236e:	46 95       	lsr	r20
    2370:	37 95       	ror	r19
    2372:	27 95       	ror	r18
    2374:	a7 95       	ror	r26
    2376:	f0 40       	sbci	r31, 0x00	; 0
    2378:	53 95       	inc	r21
    237a:	c9 f7       	brne	.-14     	; 0x236e <__addsf3x+0x4e>
    237c:	7e f4       	brtc	.+30     	; 0x239c <__addsf3x+0x7c>
    237e:	1f 16       	cp	r1, r31
    2380:	ba 0b       	sbc	r27, r26
    2382:	62 0b       	sbc	r22, r18
    2384:	73 0b       	sbc	r23, r19
    2386:	84 0b       	sbc	r24, r20
    2388:	ba f0       	brmi	.+46     	; 0x23b8 <__addsf3x+0x98>
    238a:	91 50       	subi	r25, 0x01	; 1
    238c:	a1 f0       	breq	.+40     	; 0x23b6 <__addsf3x+0x96>
    238e:	ff 0f       	add	r31, r31
    2390:	bb 1f       	adc	r27, r27
    2392:	66 1f       	adc	r22, r22
    2394:	77 1f       	adc	r23, r23
    2396:	88 1f       	adc	r24, r24
    2398:	c2 f7       	brpl	.-16     	; 0x238a <__addsf3x+0x6a>
    239a:	0e c0       	rjmp	.+28     	; 0x23b8 <__addsf3x+0x98>
    239c:	ba 0f       	add	r27, r26
    239e:	62 1f       	adc	r22, r18
    23a0:	73 1f       	adc	r23, r19
    23a2:	84 1f       	adc	r24, r20
    23a4:	48 f4       	brcc	.+18     	; 0x23b8 <__addsf3x+0x98>
    23a6:	87 95       	ror	r24
    23a8:	77 95       	ror	r23
    23aa:	67 95       	ror	r22
    23ac:	b7 95       	ror	r27
    23ae:	f7 95       	ror	r31
    23b0:	9e 3f       	cpi	r25, 0xFE	; 254
    23b2:	08 f0       	brcs	.+2      	; 0x23b6 <__addsf3x+0x96>
    23b4:	b3 cf       	rjmp	.-154    	; 0x231c <__addsf3+0x1e>
    23b6:	93 95       	inc	r25
    23b8:	88 0f       	add	r24, r24
    23ba:	08 f0       	brcs	.+2      	; 0x23be <__addsf3x+0x9e>
    23bc:	99 27       	eor	r25, r25
    23be:	ee 0f       	add	r30, r30
    23c0:	97 95       	ror	r25
    23c2:	87 95       	ror	r24
    23c4:	08 95       	ret

000023c6 <__cmpsf2>:
    23c6:	d9 d0       	rcall	.+434    	; 0x257a <__fp_cmp>
    23c8:	08 f4       	brcc	.+2      	; 0x23cc <__cmpsf2+0x6>
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	08 95       	ret

000023ce <__divsf3>:
    23ce:	0c d0       	rcall	.+24     	; 0x23e8 <__divsf3x>
    23d0:	0f c1       	rjmp	.+542    	; 0x25f0 <__fp_round>
    23d2:	07 d1       	rcall	.+526    	; 0x25e2 <__fp_pscB>
    23d4:	40 f0       	brcs	.+16     	; 0x23e6 <__divsf3+0x18>
    23d6:	fe d0       	rcall	.+508    	; 0x25d4 <__fp_pscA>
    23d8:	30 f0       	brcs	.+12     	; 0x23e6 <__divsf3+0x18>
    23da:	21 f4       	brne	.+8      	; 0x23e4 <__divsf3+0x16>
    23dc:	5f 3f       	cpi	r21, 0xFF	; 255
    23de:	19 f0       	breq	.+6      	; 0x23e6 <__divsf3+0x18>
    23e0:	f0 c0       	rjmp	.+480    	; 0x25c2 <__fp_inf>
    23e2:	51 11       	cpse	r21, r1
    23e4:	39 c1       	rjmp	.+626    	; 0x2658 <__fp_szero>
    23e6:	f3 c0       	rjmp	.+486    	; 0x25ce <__fp_nan>

000023e8 <__divsf3x>:
    23e8:	14 d1       	rcall	.+552    	; 0x2612 <__fp_split3>
    23ea:	98 f3       	brcs	.-26     	; 0x23d2 <__divsf3+0x4>

000023ec <__divsf3_pse>:
    23ec:	99 23       	and	r25, r25
    23ee:	c9 f3       	breq	.-14     	; 0x23e2 <__divsf3+0x14>
    23f0:	55 23       	and	r21, r21
    23f2:	b1 f3       	breq	.-20     	; 0x23e0 <__divsf3+0x12>
    23f4:	95 1b       	sub	r25, r21
    23f6:	55 0b       	sbc	r21, r21
    23f8:	bb 27       	eor	r27, r27
    23fa:	aa 27       	eor	r26, r26
    23fc:	62 17       	cp	r22, r18
    23fe:	73 07       	cpc	r23, r19
    2400:	84 07       	cpc	r24, r20
    2402:	38 f0       	brcs	.+14     	; 0x2412 <__divsf3_pse+0x26>
    2404:	9f 5f       	subi	r25, 0xFF	; 255
    2406:	5f 4f       	sbci	r21, 0xFF	; 255
    2408:	22 0f       	add	r18, r18
    240a:	33 1f       	adc	r19, r19
    240c:	44 1f       	adc	r20, r20
    240e:	aa 1f       	adc	r26, r26
    2410:	a9 f3       	breq	.-22     	; 0x23fc <__divsf3_pse+0x10>
    2412:	33 d0       	rcall	.+102    	; 0x247a <__divsf3_pse+0x8e>
    2414:	0e 2e       	mov	r0, r30
    2416:	3a f0       	brmi	.+14     	; 0x2426 <__divsf3_pse+0x3a>
    2418:	e0 e8       	ldi	r30, 0x80	; 128
    241a:	30 d0       	rcall	.+96     	; 0x247c <__divsf3_pse+0x90>
    241c:	91 50       	subi	r25, 0x01	; 1
    241e:	50 40       	sbci	r21, 0x00	; 0
    2420:	e6 95       	lsr	r30
    2422:	00 1c       	adc	r0, r0
    2424:	ca f7       	brpl	.-14     	; 0x2418 <__divsf3_pse+0x2c>
    2426:	29 d0       	rcall	.+82     	; 0x247a <__divsf3_pse+0x8e>
    2428:	fe 2f       	mov	r31, r30
    242a:	27 d0       	rcall	.+78     	; 0x247a <__divsf3_pse+0x8e>
    242c:	66 0f       	add	r22, r22
    242e:	77 1f       	adc	r23, r23
    2430:	88 1f       	adc	r24, r24
    2432:	bb 1f       	adc	r27, r27
    2434:	26 17       	cp	r18, r22
    2436:	37 07       	cpc	r19, r23
    2438:	48 07       	cpc	r20, r24
    243a:	ab 07       	cpc	r26, r27
    243c:	b0 e8       	ldi	r27, 0x80	; 128
    243e:	09 f0       	breq	.+2      	; 0x2442 <__divsf3_pse+0x56>
    2440:	bb 0b       	sbc	r27, r27
    2442:	80 2d       	mov	r24, r0
    2444:	bf 01       	movw	r22, r30
    2446:	ff 27       	eor	r31, r31
    2448:	93 58       	subi	r25, 0x83	; 131
    244a:	5f 4f       	sbci	r21, 0xFF	; 255
    244c:	2a f0       	brmi	.+10     	; 0x2458 <__divsf3_pse+0x6c>
    244e:	9e 3f       	cpi	r25, 0xFE	; 254
    2450:	51 05       	cpc	r21, r1
    2452:	68 f0       	brcs	.+26     	; 0x246e <__divsf3_pse+0x82>
    2454:	b6 c0       	rjmp	.+364    	; 0x25c2 <__fp_inf>
    2456:	00 c1       	rjmp	.+512    	; 0x2658 <__fp_szero>
    2458:	5f 3f       	cpi	r21, 0xFF	; 255
    245a:	ec f3       	brlt	.-6      	; 0x2456 <__divsf3_pse+0x6a>
    245c:	98 3e       	cpi	r25, 0xE8	; 232
    245e:	dc f3       	brlt	.-10     	; 0x2456 <__divsf3_pse+0x6a>
    2460:	86 95       	lsr	r24
    2462:	77 95       	ror	r23
    2464:	67 95       	ror	r22
    2466:	b7 95       	ror	r27
    2468:	f7 95       	ror	r31
    246a:	9f 5f       	subi	r25, 0xFF	; 255
    246c:	c9 f7       	brne	.-14     	; 0x2460 <__divsf3_pse+0x74>
    246e:	88 0f       	add	r24, r24
    2470:	91 1d       	adc	r25, r1
    2472:	96 95       	lsr	r25
    2474:	87 95       	ror	r24
    2476:	97 f9       	bld	r25, 7
    2478:	08 95       	ret
    247a:	e1 e0       	ldi	r30, 0x01	; 1
    247c:	66 0f       	add	r22, r22
    247e:	77 1f       	adc	r23, r23
    2480:	88 1f       	adc	r24, r24
    2482:	bb 1f       	adc	r27, r27
    2484:	62 17       	cp	r22, r18
    2486:	73 07       	cpc	r23, r19
    2488:	84 07       	cpc	r24, r20
    248a:	ba 07       	cpc	r27, r26
    248c:	20 f0       	brcs	.+8      	; 0x2496 <__divsf3_pse+0xaa>
    248e:	62 1b       	sub	r22, r18
    2490:	73 0b       	sbc	r23, r19
    2492:	84 0b       	sbc	r24, r20
    2494:	ba 0b       	sbc	r27, r26
    2496:	ee 1f       	adc	r30, r30
    2498:	88 f7       	brcc	.-30     	; 0x247c <__divsf3_pse+0x90>
    249a:	e0 95       	com	r30
    249c:	08 95       	ret

0000249e <__fixsfsi>:
    249e:	04 d0       	rcall	.+8      	; 0x24a8 <__fixunssfsi>
    24a0:	68 94       	set
    24a2:	b1 11       	cpse	r27, r1
    24a4:	d9 c0       	rjmp	.+434    	; 0x2658 <__fp_szero>
    24a6:	08 95       	ret

000024a8 <__fixunssfsi>:
    24a8:	bc d0       	rcall	.+376    	; 0x2622 <__fp_splitA>
    24aa:	88 f0       	brcs	.+34     	; 0x24ce <__fixunssfsi+0x26>
    24ac:	9f 57       	subi	r25, 0x7F	; 127
    24ae:	90 f0       	brcs	.+36     	; 0x24d4 <__fixunssfsi+0x2c>
    24b0:	b9 2f       	mov	r27, r25
    24b2:	99 27       	eor	r25, r25
    24b4:	b7 51       	subi	r27, 0x17	; 23
    24b6:	a0 f0       	brcs	.+40     	; 0x24e0 <__fixunssfsi+0x38>
    24b8:	d1 f0       	breq	.+52     	; 0x24ee <__fixunssfsi+0x46>
    24ba:	66 0f       	add	r22, r22
    24bc:	77 1f       	adc	r23, r23
    24be:	88 1f       	adc	r24, r24
    24c0:	99 1f       	adc	r25, r25
    24c2:	1a f0       	brmi	.+6      	; 0x24ca <__fixunssfsi+0x22>
    24c4:	ba 95       	dec	r27
    24c6:	c9 f7       	brne	.-14     	; 0x24ba <__fixunssfsi+0x12>
    24c8:	12 c0       	rjmp	.+36     	; 0x24ee <__fixunssfsi+0x46>
    24ca:	b1 30       	cpi	r27, 0x01	; 1
    24cc:	81 f0       	breq	.+32     	; 0x24ee <__fixunssfsi+0x46>
    24ce:	c3 d0       	rcall	.+390    	; 0x2656 <__fp_zero>
    24d0:	b1 e0       	ldi	r27, 0x01	; 1
    24d2:	08 95       	ret
    24d4:	c0 c0       	rjmp	.+384    	; 0x2656 <__fp_zero>
    24d6:	67 2f       	mov	r22, r23
    24d8:	78 2f       	mov	r23, r24
    24da:	88 27       	eor	r24, r24
    24dc:	b8 5f       	subi	r27, 0xF8	; 248
    24de:	39 f0       	breq	.+14     	; 0x24ee <__fixunssfsi+0x46>
    24e0:	b9 3f       	cpi	r27, 0xF9	; 249
    24e2:	cc f3       	brlt	.-14     	; 0x24d6 <__fixunssfsi+0x2e>
    24e4:	86 95       	lsr	r24
    24e6:	77 95       	ror	r23
    24e8:	67 95       	ror	r22
    24ea:	b3 95       	inc	r27
    24ec:	d9 f7       	brne	.-10     	; 0x24e4 <__fixunssfsi+0x3c>
    24ee:	3e f4       	brtc	.+14     	; 0x24fe <__fixunssfsi+0x56>
    24f0:	90 95       	com	r25
    24f2:	80 95       	com	r24
    24f4:	70 95       	com	r23
    24f6:	61 95       	neg	r22
    24f8:	7f 4f       	sbci	r23, 0xFF	; 255
    24fa:	8f 4f       	sbci	r24, 0xFF	; 255
    24fc:	9f 4f       	sbci	r25, 0xFF	; 255
    24fe:	08 95       	ret

00002500 <__floatunsisf>:
    2500:	e8 94       	clt
    2502:	09 c0       	rjmp	.+18     	; 0x2516 <__floatsisf+0x12>

00002504 <__floatsisf>:
    2504:	97 fb       	bst	r25, 7
    2506:	3e f4       	brtc	.+14     	; 0x2516 <__floatsisf+0x12>
    2508:	90 95       	com	r25
    250a:	80 95       	com	r24
    250c:	70 95       	com	r23
    250e:	61 95       	neg	r22
    2510:	7f 4f       	sbci	r23, 0xFF	; 255
    2512:	8f 4f       	sbci	r24, 0xFF	; 255
    2514:	9f 4f       	sbci	r25, 0xFF	; 255
    2516:	99 23       	and	r25, r25
    2518:	a9 f0       	breq	.+42     	; 0x2544 <__floatsisf+0x40>
    251a:	f9 2f       	mov	r31, r25
    251c:	96 e9       	ldi	r25, 0x96	; 150
    251e:	bb 27       	eor	r27, r27
    2520:	93 95       	inc	r25
    2522:	f6 95       	lsr	r31
    2524:	87 95       	ror	r24
    2526:	77 95       	ror	r23
    2528:	67 95       	ror	r22
    252a:	b7 95       	ror	r27
    252c:	f1 11       	cpse	r31, r1
    252e:	f8 cf       	rjmp	.-16     	; 0x2520 <__floatsisf+0x1c>
    2530:	fa f4       	brpl	.+62     	; 0x2570 <__floatsisf+0x6c>
    2532:	bb 0f       	add	r27, r27
    2534:	11 f4       	brne	.+4      	; 0x253a <__floatsisf+0x36>
    2536:	60 ff       	sbrs	r22, 0
    2538:	1b c0       	rjmp	.+54     	; 0x2570 <__floatsisf+0x6c>
    253a:	6f 5f       	subi	r22, 0xFF	; 255
    253c:	7f 4f       	sbci	r23, 0xFF	; 255
    253e:	8f 4f       	sbci	r24, 0xFF	; 255
    2540:	9f 4f       	sbci	r25, 0xFF	; 255
    2542:	16 c0       	rjmp	.+44     	; 0x2570 <__floatsisf+0x6c>
    2544:	88 23       	and	r24, r24
    2546:	11 f0       	breq	.+4      	; 0x254c <__floatsisf+0x48>
    2548:	96 e9       	ldi	r25, 0x96	; 150
    254a:	11 c0       	rjmp	.+34     	; 0x256e <__floatsisf+0x6a>
    254c:	77 23       	and	r23, r23
    254e:	21 f0       	breq	.+8      	; 0x2558 <__floatsisf+0x54>
    2550:	9e e8       	ldi	r25, 0x8E	; 142
    2552:	87 2f       	mov	r24, r23
    2554:	76 2f       	mov	r23, r22
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <__floatsisf+0x5e>
    2558:	66 23       	and	r22, r22
    255a:	71 f0       	breq	.+28     	; 0x2578 <__floatsisf+0x74>
    255c:	96 e8       	ldi	r25, 0x86	; 134
    255e:	86 2f       	mov	r24, r22
    2560:	70 e0       	ldi	r23, 0x00	; 0
    2562:	60 e0       	ldi	r22, 0x00	; 0
    2564:	2a f0       	brmi	.+10     	; 0x2570 <__floatsisf+0x6c>
    2566:	9a 95       	dec	r25
    2568:	66 0f       	add	r22, r22
    256a:	77 1f       	adc	r23, r23
    256c:	88 1f       	adc	r24, r24
    256e:	da f7       	brpl	.-10     	; 0x2566 <__floatsisf+0x62>
    2570:	88 0f       	add	r24, r24
    2572:	96 95       	lsr	r25
    2574:	87 95       	ror	r24
    2576:	97 f9       	bld	r25, 7
    2578:	08 95       	ret

0000257a <__fp_cmp>:
    257a:	99 0f       	add	r25, r25
    257c:	00 08       	sbc	r0, r0
    257e:	55 0f       	add	r21, r21
    2580:	aa 0b       	sbc	r26, r26
    2582:	e0 e8       	ldi	r30, 0x80	; 128
    2584:	fe ef       	ldi	r31, 0xFE	; 254
    2586:	16 16       	cp	r1, r22
    2588:	17 06       	cpc	r1, r23
    258a:	e8 07       	cpc	r30, r24
    258c:	f9 07       	cpc	r31, r25
    258e:	c0 f0       	brcs	.+48     	; 0x25c0 <__fp_cmp+0x46>
    2590:	12 16       	cp	r1, r18
    2592:	13 06       	cpc	r1, r19
    2594:	e4 07       	cpc	r30, r20
    2596:	f5 07       	cpc	r31, r21
    2598:	98 f0       	brcs	.+38     	; 0x25c0 <__fp_cmp+0x46>
    259a:	62 1b       	sub	r22, r18
    259c:	73 0b       	sbc	r23, r19
    259e:	84 0b       	sbc	r24, r20
    25a0:	95 0b       	sbc	r25, r21
    25a2:	39 f4       	brne	.+14     	; 0x25b2 <__fp_cmp+0x38>
    25a4:	0a 26       	eor	r0, r26
    25a6:	61 f0       	breq	.+24     	; 0x25c0 <__fp_cmp+0x46>
    25a8:	23 2b       	or	r18, r19
    25aa:	24 2b       	or	r18, r20
    25ac:	25 2b       	or	r18, r21
    25ae:	21 f4       	brne	.+8      	; 0x25b8 <__fp_cmp+0x3e>
    25b0:	08 95       	ret
    25b2:	0a 26       	eor	r0, r26
    25b4:	09 f4       	brne	.+2      	; 0x25b8 <__fp_cmp+0x3e>
    25b6:	a1 40       	sbci	r26, 0x01	; 1
    25b8:	a6 95       	lsr	r26
    25ba:	8f ef       	ldi	r24, 0xFF	; 255
    25bc:	81 1d       	adc	r24, r1
    25be:	81 1d       	adc	r24, r1
    25c0:	08 95       	ret

000025c2 <__fp_inf>:
    25c2:	97 f9       	bld	r25, 7
    25c4:	9f 67       	ori	r25, 0x7F	; 127
    25c6:	80 e8       	ldi	r24, 0x80	; 128
    25c8:	70 e0       	ldi	r23, 0x00	; 0
    25ca:	60 e0       	ldi	r22, 0x00	; 0
    25cc:	08 95       	ret

000025ce <__fp_nan>:
    25ce:	9f ef       	ldi	r25, 0xFF	; 255
    25d0:	80 ec       	ldi	r24, 0xC0	; 192
    25d2:	08 95       	ret

000025d4 <__fp_pscA>:
    25d4:	00 24       	eor	r0, r0
    25d6:	0a 94       	dec	r0
    25d8:	16 16       	cp	r1, r22
    25da:	17 06       	cpc	r1, r23
    25dc:	18 06       	cpc	r1, r24
    25de:	09 06       	cpc	r0, r25
    25e0:	08 95       	ret

000025e2 <__fp_pscB>:
    25e2:	00 24       	eor	r0, r0
    25e4:	0a 94       	dec	r0
    25e6:	12 16       	cp	r1, r18
    25e8:	13 06       	cpc	r1, r19
    25ea:	14 06       	cpc	r1, r20
    25ec:	05 06       	cpc	r0, r21
    25ee:	08 95       	ret

000025f0 <__fp_round>:
    25f0:	09 2e       	mov	r0, r25
    25f2:	03 94       	inc	r0
    25f4:	00 0c       	add	r0, r0
    25f6:	11 f4       	brne	.+4      	; 0x25fc <__fp_round+0xc>
    25f8:	88 23       	and	r24, r24
    25fa:	52 f0       	brmi	.+20     	; 0x2610 <__fp_round+0x20>
    25fc:	bb 0f       	add	r27, r27
    25fe:	40 f4       	brcc	.+16     	; 0x2610 <__fp_round+0x20>
    2600:	bf 2b       	or	r27, r31
    2602:	11 f4       	brne	.+4      	; 0x2608 <__fp_round+0x18>
    2604:	60 ff       	sbrs	r22, 0
    2606:	04 c0       	rjmp	.+8      	; 0x2610 <__fp_round+0x20>
    2608:	6f 5f       	subi	r22, 0xFF	; 255
    260a:	7f 4f       	sbci	r23, 0xFF	; 255
    260c:	8f 4f       	sbci	r24, 0xFF	; 255
    260e:	9f 4f       	sbci	r25, 0xFF	; 255
    2610:	08 95       	ret

00002612 <__fp_split3>:
    2612:	57 fd       	sbrc	r21, 7
    2614:	90 58       	subi	r25, 0x80	; 128
    2616:	44 0f       	add	r20, r20
    2618:	55 1f       	adc	r21, r21
    261a:	59 f0       	breq	.+22     	; 0x2632 <__fp_splitA+0x10>
    261c:	5f 3f       	cpi	r21, 0xFF	; 255
    261e:	71 f0       	breq	.+28     	; 0x263c <__fp_splitA+0x1a>
    2620:	47 95       	ror	r20

00002622 <__fp_splitA>:
    2622:	88 0f       	add	r24, r24
    2624:	97 fb       	bst	r25, 7
    2626:	99 1f       	adc	r25, r25
    2628:	61 f0       	breq	.+24     	; 0x2642 <__fp_splitA+0x20>
    262a:	9f 3f       	cpi	r25, 0xFF	; 255
    262c:	79 f0       	breq	.+30     	; 0x264c <__fp_splitA+0x2a>
    262e:	87 95       	ror	r24
    2630:	08 95       	ret
    2632:	12 16       	cp	r1, r18
    2634:	13 06       	cpc	r1, r19
    2636:	14 06       	cpc	r1, r20
    2638:	55 1f       	adc	r21, r21
    263a:	f2 cf       	rjmp	.-28     	; 0x2620 <__fp_split3+0xe>
    263c:	46 95       	lsr	r20
    263e:	f1 df       	rcall	.-30     	; 0x2622 <__fp_splitA>
    2640:	08 c0       	rjmp	.+16     	; 0x2652 <__fp_splitA+0x30>
    2642:	16 16       	cp	r1, r22
    2644:	17 06       	cpc	r1, r23
    2646:	18 06       	cpc	r1, r24
    2648:	99 1f       	adc	r25, r25
    264a:	f1 cf       	rjmp	.-30     	; 0x262e <__fp_splitA+0xc>
    264c:	86 95       	lsr	r24
    264e:	71 05       	cpc	r23, r1
    2650:	61 05       	cpc	r22, r1
    2652:	08 94       	sec
    2654:	08 95       	ret

00002656 <__fp_zero>:
    2656:	e8 94       	clt

00002658 <__fp_szero>:
    2658:	bb 27       	eor	r27, r27
    265a:	66 27       	eor	r22, r22
    265c:	77 27       	eor	r23, r23
    265e:	cb 01       	movw	r24, r22
    2660:	97 f9       	bld	r25, 7
    2662:	08 95       	ret

00002664 <__gesf2>:
    2664:	8a df       	rcall	.-236    	; 0x257a <__fp_cmp>
    2666:	08 f4       	brcc	.+2      	; 0x266a <__gesf2+0x6>
    2668:	8f ef       	ldi	r24, 0xFF	; 255
    266a:	08 95       	ret

0000266c <__mulsf3>:
    266c:	0b d0       	rcall	.+22     	; 0x2684 <__mulsf3x>
    266e:	c0 cf       	rjmp	.-128    	; 0x25f0 <__fp_round>
    2670:	b1 df       	rcall	.-158    	; 0x25d4 <__fp_pscA>
    2672:	28 f0       	brcs	.+10     	; 0x267e <__mulsf3+0x12>
    2674:	b6 df       	rcall	.-148    	; 0x25e2 <__fp_pscB>
    2676:	18 f0       	brcs	.+6      	; 0x267e <__mulsf3+0x12>
    2678:	95 23       	and	r25, r21
    267a:	09 f0       	breq	.+2      	; 0x267e <__mulsf3+0x12>
    267c:	a2 cf       	rjmp	.-188    	; 0x25c2 <__fp_inf>
    267e:	a7 cf       	rjmp	.-178    	; 0x25ce <__fp_nan>
    2680:	11 24       	eor	r1, r1
    2682:	ea cf       	rjmp	.-44     	; 0x2658 <__fp_szero>

00002684 <__mulsf3x>:
    2684:	c6 df       	rcall	.-116    	; 0x2612 <__fp_split3>
    2686:	a0 f3       	brcs	.-24     	; 0x2670 <__mulsf3+0x4>

00002688 <__mulsf3_pse>:
    2688:	95 9f       	mul	r25, r21
    268a:	d1 f3       	breq	.-12     	; 0x2680 <__mulsf3+0x14>
    268c:	95 0f       	add	r25, r21
    268e:	50 e0       	ldi	r21, 0x00	; 0
    2690:	55 1f       	adc	r21, r21
    2692:	62 9f       	mul	r22, r18
    2694:	f0 01       	movw	r30, r0
    2696:	72 9f       	mul	r23, r18
    2698:	bb 27       	eor	r27, r27
    269a:	f0 0d       	add	r31, r0
    269c:	b1 1d       	adc	r27, r1
    269e:	63 9f       	mul	r22, r19
    26a0:	aa 27       	eor	r26, r26
    26a2:	f0 0d       	add	r31, r0
    26a4:	b1 1d       	adc	r27, r1
    26a6:	aa 1f       	adc	r26, r26
    26a8:	64 9f       	mul	r22, r20
    26aa:	66 27       	eor	r22, r22
    26ac:	b0 0d       	add	r27, r0
    26ae:	a1 1d       	adc	r26, r1
    26b0:	66 1f       	adc	r22, r22
    26b2:	82 9f       	mul	r24, r18
    26b4:	22 27       	eor	r18, r18
    26b6:	b0 0d       	add	r27, r0
    26b8:	a1 1d       	adc	r26, r1
    26ba:	62 1f       	adc	r22, r18
    26bc:	73 9f       	mul	r23, r19
    26be:	b0 0d       	add	r27, r0
    26c0:	a1 1d       	adc	r26, r1
    26c2:	62 1f       	adc	r22, r18
    26c4:	83 9f       	mul	r24, r19
    26c6:	a0 0d       	add	r26, r0
    26c8:	61 1d       	adc	r22, r1
    26ca:	22 1f       	adc	r18, r18
    26cc:	74 9f       	mul	r23, r20
    26ce:	33 27       	eor	r19, r19
    26d0:	a0 0d       	add	r26, r0
    26d2:	61 1d       	adc	r22, r1
    26d4:	23 1f       	adc	r18, r19
    26d6:	84 9f       	mul	r24, r20
    26d8:	60 0d       	add	r22, r0
    26da:	21 1d       	adc	r18, r1
    26dc:	82 2f       	mov	r24, r18
    26de:	76 2f       	mov	r23, r22
    26e0:	6a 2f       	mov	r22, r26
    26e2:	11 24       	eor	r1, r1
    26e4:	9f 57       	subi	r25, 0x7F	; 127
    26e6:	50 40       	sbci	r21, 0x00	; 0
    26e8:	8a f0       	brmi	.+34     	; 0x270c <__mulsf3_pse+0x84>
    26ea:	e1 f0       	breq	.+56     	; 0x2724 <__mulsf3_pse+0x9c>
    26ec:	88 23       	and	r24, r24
    26ee:	4a f0       	brmi	.+18     	; 0x2702 <__mulsf3_pse+0x7a>
    26f0:	ee 0f       	add	r30, r30
    26f2:	ff 1f       	adc	r31, r31
    26f4:	bb 1f       	adc	r27, r27
    26f6:	66 1f       	adc	r22, r22
    26f8:	77 1f       	adc	r23, r23
    26fa:	88 1f       	adc	r24, r24
    26fc:	91 50       	subi	r25, 0x01	; 1
    26fe:	50 40       	sbci	r21, 0x00	; 0
    2700:	a9 f7       	brne	.-22     	; 0x26ec <__mulsf3_pse+0x64>
    2702:	9e 3f       	cpi	r25, 0xFE	; 254
    2704:	51 05       	cpc	r21, r1
    2706:	70 f0       	brcs	.+28     	; 0x2724 <__mulsf3_pse+0x9c>
    2708:	5c cf       	rjmp	.-328    	; 0x25c2 <__fp_inf>
    270a:	a6 cf       	rjmp	.-180    	; 0x2658 <__fp_szero>
    270c:	5f 3f       	cpi	r21, 0xFF	; 255
    270e:	ec f3       	brlt	.-6      	; 0x270a <__mulsf3_pse+0x82>
    2710:	98 3e       	cpi	r25, 0xE8	; 232
    2712:	dc f3       	brlt	.-10     	; 0x270a <__mulsf3_pse+0x82>
    2714:	86 95       	lsr	r24
    2716:	77 95       	ror	r23
    2718:	67 95       	ror	r22
    271a:	b7 95       	ror	r27
    271c:	f7 95       	ror	r31
    271e:	e7 95       	ror	r30
    2720:	9f 5f       	subi	r25, 0xFF	; 255
    2722:	c1 f7       	brne	.-16     	; 0x2714 <__mulsf3_pse+0x8c>
    2724:	fe 2b       	or	r31, r30
    2726:	88 0f       	add	r24, r24
    2728:	91 1d       	adc	r25, r1
    272a:	96 95       	lsr	r25
    272c:	87 95       	ror	r24
    272e:	97 f9       	bld	r25, 7
    2730:	08 95       	ret

00002732 <__tablejump2__>:
    2732:	ee 0f       	add	r30, r30
    2734:	ff 1f       	adc	r31, r31
    2736:	00 24       	eor	r0, r0
    2738:	00 1c       	adc	r0, r0
    273a:	0b be       	out	0x3b, r0	; 59
    273c:	07 90       	elpm	r0, Z+
    273e:	f6 91       	elpm	r31, Z
    2740:	e0 2d       	mov	r30, r0
    2742:	09 94       	ijmp

00002744 <atoi>:
    2744:	fc 01       	movw	r30, r24
    2746:	88 27       	eor	r24, r24
    2748:	99 27       	eor	r25, r25
    274a:	e8 94       	clt
    274c:	21 91       	ld	r18, Z+
    274e:	20 32       	cpi	r18, 0x20	; 32
    2750:	e9 f3       	breq	.-6      	; 0x274c <atoi+0x8>
    2752:	29 30       	cpi	r18, 0x09	; 9
    2754:	10 f0       	brcs	.+4      	; 0x275a <atoi+0x16>
    2756:	2e 30       	cpi	r18, 0x0E	; 14
    2758:	c8 f3       	brcs	.-14     	; 0x274c <atoi+0x8>
    275a:	2b 32       	cpi	r18, 0x2B	; 43
    275c:	39 f0       	breq	.+14     	; 0x276c <atoi+0x28>
    275e:	2d 32       	cpi	r18, 0x2D	; 45
    2760:	31 f4       	brne	.+12     	; 0x276e <atoi+0x2a>
    2762:	68 94       	set
    2764:	03 c0       	rjmp	.+6      	; 0x276c <atoi+0x28>
    2766:	14 d0       	rcall	.+40     	; 0x2790 <__mulhi_const_10>
    2768:	82 0f       	add	r24, r18
    276a:	91 1d       	adc	r25, r1
    276c:	21 91       	ld	r18, Z+
    276e:	20 53       	subi	r18, 0x30	; 48
    2770:	2a 30       	cpi	r18, 0x0A	; 10
    2772:	c8 f3       	brcs	.-14     	; 0x2766 <atoi+0x22>
    2774:	1e f4       	brtc	.+6      	; 0x277c <atoi+0x38>
    2776:	90 95       	com	r25
    2778:	81 95       	neg	r24
    277a:	9f 4f       	sbci	r25, 0xFF	; 255
    277c:	08 95       	ret

0000277e <strcmp>:
    277e:	fb 01       	movw	r30, r22
    2780:	dc 01       	movw	r26, r24
    2782:	8d 91       	ld	r24, X+
    2784:	01 90       	ld	r0, Z+
    2786:	80 19       	sub	r24, r0
    2788:	01 10       	cpse	r0, r1
    278a:	d9 f3       	breq	.-10     	; 0x2782 <strcmp+0x4>
    278c:	99 0b       	sbc	r25, r25
    278e:	08 95       	ret

00002790 <__mulhi_const_10>:
    2790:	7a e0       	ldi	r23, 0x0A	; 10
    2792:	97 9f       	mul	r25, r23
    2794:	90 2d       	mov	r25, r0
    2796:	87 9f       	mul	r24, r23
    2798:	80 2d       	mov	r24, r0
    279a:	91 0d       	add	r25, r1
    279c:	11 24       	eor	r1, r1
    279e:	08 95       	ret

000027a0 <printf>:
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	cd b7       	in	r28, 0x3d	; 61
    27a6:	de b7       	in	r29, 0x3e	; 62
    27a8:	ae 01       	movw	r20, r28
    27aa:	4b 5f       	subi	r20, 0xFB	; 251
    27ac:	5f 4f       	sbci	r21, 0xFF	; 255
    27ae:	fa 01       	movw	r30, r20
    27b0:	61 91       	ld	r22, Z+
    27b2:	71 91       	ld	r23, Z+
    27b4:	af 01       	movw	r20, r30
    27b6:	80 91 4d 04 	lds	r24, 0x044D	; 0x80044d <__iob+0x2>
    27ba:	90 91 4e 04 	lds	r25, 0x044E	; 0x80044e <__iob+0x3>
    27be:	38 d0       	rcall	.+112    	; 0x2830 <vfprintf>
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	08 95       	ret

000027c6 <putchar>:
    27c6:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27ca:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27ce:	43 c2       	rjmp	.+1158   	; 0x2c56 <fputc>

000027d0 <puts>:
    27d0:	0f 93       	push	r16
    27d2:	1f 93       	push	r17
    27d4:	cf 93       	push	r28
    27d6:	df 93       	push	r29
    27d8:	e0 91 4d 04 	lds	r30, 0x044D	; 0x80044d <__iob+0x2>
    27dc:	f0 91 4e 04 	lds	r31, 0x044E	; 0x80044e <__iob+0x3>
    27e0:	23 81       	ldd	r18, Z+3	; 0x03
    27e2:	21 ff       	sbrs	r18, 1
    27e4:	1b c0       	rjmp	.+54     	; 0x281c <puts+0x4c>
    27e6:	8c 01       	movw	r16, r24
    27e8:	d0 e0       	ldi	r29, 0x00	; 0
    27ea:	c0 e0       	ldi	r28, 0x00	; 0
    27ec:	f8 01       	movw	r30, r16
    27ee:	81 91       	ld	r24, Z+
    27f0:	8f 01       	movw	r16, r30
    27f2:	60 91 4d 04 	lds	r22, 0x044D	; 0x80044d <__iob+0x2>
    27f6:	70 91 4e 04 	lds	r23, 0x044E	; 0x80044e <__iob+0x3>
    27fa:	db 01       	movw	r26, r22
    27fc:	18 96       	adiw	r26, 0x08	; 8
    27fe:	ed 91       	ld	r30, X+
    2800:	fc 91       	ld	r31, X
    2802:	19 97       	sbiw	r26, 0x09	; 9
    2804:	88 23       	and	r24, r24
    2806:	31 f0       	breq	.+12     	; 0x2814 <puts+0x44>
    2808:	09 95       	icall
    280a:	89 2b       	or	r24, r25
    280c:	79 f3       	breq	.-34     	; 0x27ec <puts+0x1c>
    280e:	df ef       	ldi	r29, 0xFF	; 255
    2810:	cf ef       	ldi	r28, 0xFF	; 255
    2812:	ec cf       	rjmp	.-40     	; 0x27ec <puts+0x1c>
    2814:	8a e0       	ldi	r24, 0x0A	; 10
    2816:	09 95       	icall
    2818:	89 2b       	or	r24, r25
    281a:	19 f0       	breq	.+6      	; 0x2822 <puts+0x52>
    281c:	8f ef       	ldi	r24, 0xFF	; 255
    281e:	9f ef       	ldi	r25, 0xFF	; 255
    2820:	02 c0       	rjmp	.+4      	; 0x2826 <puts+0x56>
    2822:	8d 2f       	mov	r24, r29
    2824:	9c 2f       	mov	r25, r28
    2826:	df 91       	pop	r29
    2828:	cf 91       	pop	r28
    282a:	1f 91       	pop	r17
    282c:	0f 91       	pop	r16
    282e:	08 95       	ret

00002830 <vfprintf>:
    2830:	2f 92       	push	r2
    2832:	3f 92       	push	r3
    2834:	4f 92       	push	r4
    2836:	5f 92       	push	r5
    2838:	6f 92       	push	r6
    283a:	7f 92       	push	r7
    283c:	8f 92       	push	r8
    283e:	9f 92       	push	r9
    2840:	af 92       	push	r10
    2842:	bf 92       	push	r11
    2844:	cf 92       	push	r12
    2846:	df 92       	push	r13
    2848:	ef 92       	push	r14
    284a:	ff 92       	push	r15
    284c:	0f 93       	push	r16
    284e:	1f 93       	push	r17
    2850:	cf 93       	push	r28
    2852:	df 93       	push	r29
    2854:	cd b7       	in	r28, 0x3d	; 61
    2856:	de b7       	in	r29, 0x3e	; 62
    2858:	2b 97       	sbiw	r28, 0x0b	; 11
    285a:	0f b6       	in	r0, 0x3f	; 63
    285c:	f8 94       	cli
    285e:	de bf       	out	0x3e, r29	; 62
    2860:	0f be       	out	0x3f, r0	; 63
    2862:	cd bf       	out	0x3d, r28	; 61
    2864:	6c 01       	movw	r12, r24
    2866:	7b 01       	movw	r14, r22
    2868:	8a 01       	movw	r16, r20
    286a:	fc 01       	movw	r30, r24
    286c:	17 82       	std	Z+7, r1	; 0x07
    286e:	16 82       	std	Z+6, r1	; 0x06
    2870:	83 81       	ldd	r24, Z+3	; 0x03
    2872:	81 ff       	sbrs	r24, 1
    2874:	bf c1       	rjmp	.+894    	; 0x2bf4 <vfprintf+0x3c4>
    2876:	ce 01       	movw	r24, r28
    2878:	01 96       	adiw	r24, 0x01	; 1
    287a:	3c 01       	movw	r6, r24
    287c:	f6 01       	movw	r30, r12
    287e:	93 81       	ldd	r25, Z+3	; 0x03
    2880:	f7 01       	movw	r30, r14
    2882:	93 fd       	sbrc	r25, 3
    2884:	85 91       	lpm	r24, Z+
    2886:	93 ff       	sbrs	r25, 3
    2888:	81 91       	ld	r24, Z+
    288a:	7f 01       	movw	r14, r30
    288c:	88 23       	and	r24, r24
    288e:	09 f4       	brne	.+2      	; 0x2892 <vfprintf+0x62>
    2890:	ad c1       	rjmp	.+858    	; 0x2bec <vfprintf+0x3bc>
    2892:	85 32       	cpi	r24, 0x25	; 37
    2894:	39 f4       	brne	.+14     	; 0x28a4 <vfprintf+0x74>
    2896:	93 fd       	sbrc	r25, 3
    2898:	85 91       	lpm	r24, Z+
    289a:	93 ff       	sbrs	r25, 3
    289c:	81 91       	ld	r24, Z+
    289e:	7f 01       	movw	r14, r30
    28a0:	85 32       	cpi	r24, 0x25	; 37
    28a2:	21 f4       	brne	.+8      	; 0x28ac <vfprintf+0x7c>
    28a4:	b6 01       	movw	r22, r12
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	d6 d1       	rcall	.+940    	; 0x2c56 <fputc>
    28aa:	e8 cf       	rjmp	.-48     	; 0x287c <vfprintf+0x4c>
    28ac:	91 2c       	mov	r9, r1
    28ae:	21 2c       	mov	r2, r1
    28b0:	31 2c       	mov	r3, r1
    28b2:	ff e1       	ldi	r31, 0x1F	; 31
    28b4:	f3 15       	cp	r31, r3
    28b6:	d8 f0       	brcs	.+54     	; 0x28ee <vfprintf+0xbe>
    28b8:	8b 32       	cpi	r24, 0x2B	; 43
    28ba:	79 f0       	breq	.+30     	; 0x28da <vfprintf+0xaa>
    28bc:	38 f4       	brcc	.+14     	; 0x28cc <vfprintf+0x9c>
    28be:	80 32       	cpi	r24, 0x20	; 32
    28c0:	79 f0       	breq	.+30     	; 0x28e0 <vfprintf+0xb0>
    28c2:	83 32       	cpi	r24, 0x23	; 35
    28c4:	a1 f4       	brne	.+40     	; 0x28ee <vfprintf+0xbe>
    28c6:	23 2d       	mov	r18, r3
    28c8:	20 61       	ori	r18, 0x10	; 16
    28ca:	1d c0       	rjmp	.+58     	; 0x2906 <vfprintf+0xd6>
    28cc:	8d 32       	cpi	r24, 0x2D	; 45
    28ce:	61 f0       	breq	.+24     	; 0x28e8 <vfprintf+0xb8>
    28d0:	80 33       	cpi	r24, 0x30	; 48
    28d2:	69 f4       	brne	.+26     	; 0x28ee <vfprintf+0xbe>
    28d4:	23 2d       	mov	r18, r3
    28d6:	21 60       	ori	r18, 0x01	; 1
    28d8:	16 c0       	rjmp	.+44     	; 0x2906 <vfprintf+0xd6>
    28da:	83 2d       	mov	r24, r3
    28dc:	82 60       	ori	r24, 0x02	; 2
    28de:	38 2e       	mov	r3, r24
    28e0:	e3 2d       	mov	r30, r3
    28e2:	e4 60       	ori	r30, 0x04	; 4
    28e4:	3e 2e       	mov	r3, r30
    28e6:	2a c0       	rjmp	.+84     	; 0x293c <vfprintf+0x10c>
    28e8:	f3 2d       	mov	r31, r3
    28ea:	f8 60       	ori	r31, 0x08	; 8
    28ec:	1d c0       	rjmp	.+58     	; 0x2928 <vfprintf+0xf8>
    28ee:	37 fc       	sbrc	r3, 7
    28f0:	2d c0       	rjmp	.+90     	; 0x294c <vfprintf+0x11c>
    28f2:	20 ed       	ldi	r18, 0xD0	; 208
    28f4:	28 0f       	add	r18, r24
    28f6:	2a 30       	cpi	r18, 0x0A	; 10
    28f8:	40 f0       	brcs	.+16     	; 0x290a <vfprintf+0xda>
    28fa:	8e 32       	cpi	r24, 0x2E	; 46
    28fc:	b9 f4       	brne	.+46     	; 0x292c <vfprintf+0xfc>
    28fe:	36 fc       	sbrc	r3, 6
    2900:	75 c1       	rjmp	.+746    	; 0x2bec <vfprintf+0x3bc>
    2902:	23 2d       	mov	r18, r3
    2904:	20 64       	ori	r18, 0x40	; 64
    2906:	32 2e       	mov	r3, r18
    2908:	19 c0       	rjmp	.+50     	; 0x293c <vfprintf+0x10c>
    290a:	36 fe       	sbrs	r3, 6
    290c:	06 c0       	rjmp	.+12     	; 0x291a <vfprintf+0xea>
    290e:	8a e0       	ldi	r24, 0x0A	; 10
    2910:	98 9e       	mul	r9, r24
    2912:	20 0d       	add	r18, r0
    2914:	11 24       	eor	r1, r1
    2916:	92 2e       	mov	r9, r18
    2918:	11 c0       	rjmp	.+34     	; 0x293c <vfprintf+0x10c>
    291a:	ea e0       	ldi	r30, 0x0A	; 10
    291c:	2e 9e       	mul	r2, r30
    291e:	20 0d       	add	r18, r0
    2920:	11 24       	eor	r1, r1
    2922:	22 2e       	mov	r2, r18
    2924:	f3 2d       	mov	r31, r3
    2926:	f0 62       	ori	r31, 0x20	; 32
    2928:	3f 2e       	mov	r3, r31
    292a:	08 c0       	rjmp	.+16     	; 0x293c <vfprintf+0x10c>
    292c:	8c 36       	cpi	r24, 0x6C	; 108
    292e:	21 f4       	brne	.+8      	; 0x2938 <vfprintf+0x108>
    2930:	83 2d       	mov	r24, r3
    2932:	80 68       	ori	r24, 0x80	; 128
    2934:	38 2e       	mov	r3, r24
    2936:	02 c0       	rjmp	.+4      	; 0x293c <vfprintf+0x10c>
    2938:	88 36       	cpi	r24, 0x68	; 104
    293a:	41 f4       	brne	.+16     	; 0x294c <vfprintf+0x11c>
    293c:	f7 01       	movw	r30, r14
    293e:	93 fd       	sbrc	r25, 3
    2940:	85 91       	lpm	r24, Z+
    2942:	93 ff       	sbrs	r25, 3
    2944:	81 91       	ld	r24, Z+
    2946:	7f 01       	movw	r14, r30
    2948:	81 11       	cpse	r24, r1
    294a:	b3 cf       	rjmp	.-154    	; 0x28b2 <vfprintf+0x82>
    294c:	98 2f       	mov	r25, r24
    294e:	9f 7d       	andi	r25, 0xDF	; 223
    2950:	95 54       	subi	r25, 0x45	; 69
    2952:	93 30       	cpi	r25, 0x03	; 3
    2954:	28 f4       	brcc	.+10     	; 0x2960 <vfprintf+0x130>
    2956:	0c 5f       	subi	r16, 0xFC	; 252
    2958:	1f 4f       	sbci	r17, 0xFF	; 255
    295a:	9f e3       	ldi	r25, 0x3F	; 63
    295c:	99 83       	std	Y+1, r25	; 0x01
    295e:	0d c0       	rjmp	.+26     	; 0x297a <vfprintf+0x14a>
    2960:	83 36       	cpi	r24, 0x63	; 99
    2962:	31 f0       	breq	.+12     	; 0x2970 <vfprintf+0x140>
    2964:	83 37       	cpi	r24, 0x73	; 115
    2966:	71 f0       	breq	.+28     	; 0x2984 <vfprintf+0x154>
    2968:	83 35       	cpi	r24, 0x53	; 83
    296a:	09 f0       	breq	.+2      	; 0x296e <vfprintf+0x13e>
    296c:	55 c0       	rjmp	.+170    	; 0x2a18 <vfprintf+0x1e8>
    296e:	20 c0       	rjmp	.+64     	; 0x29b0 <vfprintf+0x180>
    2970:	f8 01       	movw	r30, r16
    2972:	80 81       	ld	r24, Z
    2974:	89 83       	std	Y+1, r24	; 0x01
    2976:	0e 5f       	subi	r16, 0xFE	; 254
    2978:	1f 4f       	sbci	r17, 0xFF	; 255
    297a:	88 24       	eor	r8, r8
    297c:	83 94       	inc	r8
    297e:	91 2c       	mov	r9, r1
    2980:	53 01       	movw	r10, r6
    2982:	12 c0       	rjmp	.+36     	; 0x29a8 <vfprintf+0x178>
    2984:	28 01       	movw	r4, r16
    2986:	f2 e0       	ldi	r31, 0x02	; 2
    2988:	4f 0e       	add	r4, r31
    298a:	51 1c       	adc	r5, r1
    298c:	f8 01       	movw	r30, r16
    298e:	a0 80       	ld	r10, Z
    2990:	b1 80       	ldd	r11, Z+1	; 0x01
    2992:	36 fe       	sbrs	r3, 6
    2994:	03 c0       	rjmp	.+6      	; 0x299c <vfprintf+0x16c>
    2996:	69 2d       	mov	r22, r9
    2998:	70 e0       	ldi	r23, 0x00	; 0
    299a:	02 c0       	rjmp	.+4      	; 0x29a0 <vfprintf+0x170>
    299c:	6f ef       	ldi	r22, 0xFF	; 255
    299e:	7f ef       	ldi	r23, 0xFF	; 255
    29a0:	c5 01       	movw	r24, r10
    29a2:	4e d1       	rcall	.+668    	; 0x2c40 <strnlen>
    29a4:	4c 01       	movw	r8, r24
    29a6:	82 01       	movw	r16, r4
    29a8:	f3 2d       	mov	r31, r3
    29aa:	ff 77       	andi	r31, 0x7F	; 127
    29ac:	3f 2e       	mov	r3, r31
    29ae:	15 c0       	rjmp	.+42     	; 0x29da <vfprintf+0x1aa>
    29b0:	28 01       	movw	r4, r16
    29b2:	22 e0       	ldi	r18, 0x02	; 2
    29b4:	42 0e       	add	r4, r18
    29b6:	51 1c       	adc	r5, r1
    29b8:	f8 01       	movw	r30, r16
    29ba:	a0 80       	ld	r10, Z
    29bc:	b1 80       	ldd	r11, Z+1	; 0x01
    29be:	36 fe       	sbrs	r3, 6
    29c0:	03 c0       	rjmp	.+6      	; 0x29c8 <vfprintf+0x198>
    29c2:	69 2d       	mov	r22, r9
    29c4:	70 e0       	ldi	r23, 0x00	; 0
    29c6:	02 c0       	rjmp	.+4      	; 0x29cc <vfprintf+0x19c>
    29c8:	6f ef       	ldi	r22, 0xFF	; 255
    29ca:	7f ef       	ldi	r23, 0xFF	; 255
    29cc:	c5 01       	movw	r24, r10
    29ce:	2d d1       	rcall	.+602    	; 0x2c2a <strnlen_P>
    29d0:	4c 01       	movw	r8, r24
    29d2:	f3 2d       	mov	r31, r3
    29d4:	f0 68       	ori	r31, 0x80	; 128
    29d6:	3f 2e       	mov	r3, r31
    29d8:	82 01       	movw	r16, r4
    29da:	33 fc       	sbrc	r3, 3
    29dc:	19 c0       	rjmp	.+50     	; 0x2a10 <vfprintf+0x1e0>
    29de:	82 2d       	mov	r24, r2
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	88 16       	cp	r8, r24
    29e4:	99 06       	cpc	r9, r25
    29e6:	a0 f4       	brcc	.+40     	; 0x2a10 <vfprintf+0x1e0>
    29e8:	b6 01       	movw	r22, r12
    29ea:	80 e2       	ldi	r24, 0x20	; 32
    29ec:	90 e0       	ldi	r25, 0x00	; 0
    29ee:	33 d1       	rcall	.+614    	; 0x2c56 <fputc>
    29f0:	2a 94       	dec	r2
    29f2:	f5 cf       	rjmp	.-22     	; 0x29de <vfprintf+0x1ae>
    29f4:	f5 01       	movw	r30, r10
    29f6:	37 fc       	sbrc	r3, 7
    29f8:	85 91       	lpm	r24, Z+
    29fa:	37 fe       	sbrs	r3, 7
    29fc:	81 91       	ld	r24, Z+
    29fe:	5f 01       	movw	r10, r30
    2a00:	b6 01       	movw	r22, r12
    2a02:	90 e0       	ldi	r25, 0x00	; 0
    2a04:	28 d1       	rcall	.+592    	; 0x2c56 <fputc>
    2a06:	21 10       	cpse	r2, r1
    2a08:	2a 94       	dec	r2
    2a0a:	21 e0       	ldi	r18, 0x01	; 1
    2a0c:	82 1a       	sub	r8, r18
    2a0e:	91 08       	sbc	r9, r1
    2a10:	81 14       	cp	r8, r1
    2a12:	91 04       	cpc	r9, r1
    2a14:	79 f7       	brne	.-34     	; 0x29f4 <vfprintf+0x1c4>
    2a16:	e1 c0       	rjmp	.+450    	; 0x2bda <vfprintf+0x3aa>
    2a18:	84 36       	cpi	r24, 0x64	; 100
    2a1a:	11 f0       	breq	.+4      	; 0x2a20 <vfprintf+0x1f0>
    2a1c:	89 36       	cpi	r24, 0x69	; 105
    2a1e:	39 f5       	brne	.+78     	; 0x2a6e <vfprintf+0x23e>
    2a20:	f8 01       	movw	r30, r16
    2a22:	37 fe       	sbrs	r3, 7
    2a24:	07 c0       	rjmp	.+14     	; 0x2a34 <vfprintf+0x204>
    2a26:	60 81       	ld	r22, Z
    2a28:	71 81       	ldd	r23, Z+1	; 0x01
    2a2a:	82 81       	ldd	r24, Z+2	; 0x02
    2a2c:	93 81       	ldd	r25, Z+3	; 0x03
    2a2e:	0c 5f       	subi	r16, 0xFC	; 252
    2a30:	1f 4f       	sbci	r17, 0xFF	; 255
    2a32:	08 c0       	rjmp	.+16     	; 0x2a44 <vfprintf+0x214>
    2a34:	60 81       	ld	r22, Z
    2a36:	71 81       	ldd	r23, Z+1	; 0x01
    2a38:	07 2e       	mov	r0, r23
    2a3a:	00 0c       	add	r0, r0
    2a3c:	88 0b       	sbc	r24, r24
    2a3e:	99 0b       	sbc	r25, r25
    2a40:	0e 5f       	subi	r16, 0xFE	; 254
    2a42:	1f 4f       	sbci	r17, 0xFF	; 255
    2a44:	f3 2d       	mov	r31, r3
    2a46:	ff 76       	andi	r31, 0x6F	; 111
    2a48:	3f 2e       	mov	r3, r31
    2a4a:	97 ff       	sbrs	r25, 7
    2a4c:	09 c0       	rjmp	.+18     	; 0x2a60 <vfprintf+0x230>
    2a4e:	90 95       	com	r25
    2a50:	80 95       	com	r24
    2a52:	70 95       	com	r23
    2a54:	61 95       	neg	r22
    2a56:	7f 4f       	sbci	r23, 0xFF	; 255
    2a58:	8f 4f       	sbci	r24, 0xFF	; 255
    2a5a:	9f 4f       	sbci	r25, 0xFF	; 255
    2a5c:	f0 68       	ori	r31, 0x80	; 128
    2a5e:	3f 2e       	mov	r3, r31
    2a60:	2a e0       	ldi	r18, 0x0A	; 10
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	a3 01       	movw	r20, r6
    2a66:	33 d1       	rcall	.+614    	; 0x2cce <__ultoa_invert>
    2a68:	88 2e       	mov	r8, r24
    2a6a:	86 18       	sub	r8, r6
    2a6c:	44 c0       	rjmp	.+136    	; 0x2af6 <vfprintf+0x2c6>
    2a6e:	85 37       	cpi	r24, 0x75	; 117
    2a70:	31 f4       	brne	.+12     	; 0x2a7e <vfprintf+0x24e>
    2a72:	23 2d       	mov	r18, r3
    2a74:	2f 7e       	andi	r18, 0xEF	; 239
    2a76:	b2 2e       	mov	r11, r18
    2a78:	2a e0       	ldi	r18, 0x0A	; 10
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	25 c0       	rjmp	.+74     	; 0x2ac8 <vfprintf+0x298>
    2a7e:	93 2d       	mov	r25, r3
    2a80:	99 7f       	andi	r25, 0xF9	; 249
    2a82:	b9 2e       	mov	r11, r25
    2a84:	8f 36       	cpi	r24, 0x6F	; 111
    2a86:	c1 f0       	breq	.+48     	; 0x2ab8 <vfprintf+0x288>
    2a88:	18 f4       	brcc	.+6      	; 0x2a90 <vfprintf+0x260>
    2a8a:	88 35       	cpi	r24, 0x58	; 88
    2a8c:	79 f0       	breq	.+30     	; 0x2aac <vfprintf+0x27c>
    2a8e:	ae c0       	rjmp	.+348    	; 0x2bec <vfprintf+0x3bc>
    2a90:	80 37       	cpi	r24, 0x70	; 112
    2a92:	19 f0       	breq	.+6      	; 0x2a9a <vfprintf+0x26a>
    2a94:	88 37       	cpi	r24, 0x78	; 120
    2a96:	21 f0       	breq	.+8      	; 0x2aa0 <vfprintf+0x270>
    2a98:	a9 c0       	rjmp	.+338    	; 0x2bec <vfprintf+0x3bc>
    2a9a:	e9 2f       	mov	r30, r25
    2a9c:	e0 61       	ori	r30, 0x10	; 16
    2a9e:	be 2e       	mov	r11, r30
    2aa0:	b4 fe       	sbrs	r11, 4
    2aa2:	0d c0       	rjmp	.+26     	; 0x2abe <vfprintf+0x28e>
    2aa4:	fb 2d       	mov	r31, r11
    2aa6:	f4 60       	ori	r31, 0x04	; 4
    2aa8:	bf 2e       	mov	r11, r31
    2aaa:	09 c0       	rjmp	.+18     	; 0x2abe <vfprintf+0x28e>
    2aac:	34 fe       	sbrs	r3, 4
    2aae:	0a c0       	rjmp	.+20     	; 0x2ac4 <vfprintf+0x294>
    2ab0:	29 2f       	mov	r18, r25
    2ab2:	26 60       	ori	r18, 0x06	; 6
    2ab4:	b2 2e       	mov	r11, r18
    2ab6:	06 c0       	rjmp	.+12     	; 0x2ac4 <vfprintf+0x294>
    2ab8:	28 e0       	ldi	r18, 0x08	; 8
    2aba:	30 e0       	ldi	r19, 0x00	; 0
    2abc:	05 c0       	rjmp	.+10     	; 0x2ac8 <vfprintf+0x298>
    2abe:	20 e1       	ldi	r18, 0x10	; 16
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	02 c0       	rjmp	.+4      	; 0x2ac8 <vfprintf+0x298>
    2ac4:	20 e1       	ldi	r18, 0x10	; 16
    2ac6:	32 e0       	ldi	r19, 0x02	; 2
    2ac8:	f8 01       	movw	r30, r16
    2aca:	b7 fe       	sbrs	r11, 7
    2acc:	07 c0       	rjmp	.+14     	; 0x2adc <vfprintf+0x2ac>
    2ace:	60 81       	ld	r22, Z
    2ad0:	71 81       	ldd	r23, Z+1	; 0x01
    2ad2:	82 81       	ldd	r24, Z+2	; 0x02
    2ad4:	93 81       	ldd	r25, Z+3	; 0x03
    2ad6:	0c 5f       	subi	r16, 0xFC	; 252
    2ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    2ada:	06 c0       	rjmp	.+12     	; 0x2ae8 <vfprintf+0x2b8>
    2adc:	60 81       	ld	r22, Z
    2ade:	71 81       	ldd	r23, Z+1	; 0x01
    2ae0:	80 e0       	ldi	r24, 0x00	; 0
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	0e 5f       	subi	r16, 0xFE	; 254
    2ae6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ae8:	a3 01       	movw	r20, r6
    2aea:	f1 d0       	rcall	.+482    	; 0x2cce <__ultoa_invert>
    2aec:	88 2e       	mov	r8, r24
    2aee:	86 18       	sub	r8, r6
    2af0:	fb 2d       	mov	r31, r11
    2af2:	ff 77       	andi	r31, 0x7F	; 127
    2af4:	3f 2e       	mov	r3, r31
    2af6:	36 fe       	sbrs	r3, 6
    2af8:	0d c0       	rjmp	.+26     	; 0x2b14 <vfprintf+0x2e4>
    2afa:	23 2d       	mov	r18, r3
    2afc:	2e 7f       	andi	r18, 0xFE	; 254
    2afe:	a2 2e       	mov	r10, r18
    2b00:	89 14       	cp	r8, r9
    2b02:	58 f4       	brcc	.+22     	; 0x2b1a <vfprintf+0x2ea>
    2b04:	34 fe       	sbrs	r3, 4
    2b06:	0b c0       	rjmp	.+22     	; 0x2b1e <vfprintf+0x2ee>
    2b08:	32 fc       	sbrc	r3, 2
    2b0a:	09 c0       	rjmp	.+18     	; 0x2b1e <vfprintf+0x2ee>
    2b0c:	83 2d       	mov	r24, r3
    2b0e:	8e 7e       	andi	r24, 0xEE	; 238
    2b10:	a8 2e       	mov	r10, r24
    2b12:	05 c0       	rjmp	.+10     	; 0x2b1e <vfprintf+0x2ee>
    2b14:	b8 2c       	mov	r11, r8
    2b16:	a3 2c       	mov	r10, r3
    2b18:	03 c0       	rjmp	.+6      	; 0x2b20 <vfprintf+0x2f0>
    2b1a:	b8 2c       	mov	r11, r8
    2b1c:	01 c0       	rjmp	.+2      	; 0x2b20 <vfprintf+0x2f0>
    2b1e:	b9 2c       	mov	r11, r9
    2b20:	a4 fe       	sbrs	r10, 4
    2b22:	0f c0       	rjmp	.+30     	; 0x2b42 <vfprintf+0x312>
    2b24:	fe 01       	movw	r30, r28
    2b26:	e8 0d       	add	r30, r8
    2b28:	f1 1d       	adc	r31, r1
    2b2a:	80 81       	ld	r24, Z
    2b2c:	80 33       	cpi	r24, 0x30	; 48
    2b2e:	21 f4       	brne	.+8      	; 0x2b38 <vfprintf+0x308>
    2b30:	9a 2d       	mov	r25, r10
    2b32:	99 7e       	andi	r25, 0xE9	; 233
    2b34:	a9 2e       	mov	r10, r25
    2b36:	09 c0       	rjmp	.+18     	; 0x2b4a <vfprintf+0x31a>
    2b38:	a2 fe       	sbrs	r10, 2
    2b3a:	06 c0       	rjmp	.+12     	; 0x2b48 <vfprintf+0x318>
    2b3c:	b3 94       	inc	r11
    2b3e:	b3 94       	inc	r11
    2b40:	04 c0       	rjmp	.+8      	; 0x2b4a <vfprintf+0x31a>
    2b42:	8a 2d       	mov	r24, r10
    2b44:	86 78       	andi	r24, 0x86	; 134
    2b46:	09 f0       	breq	.+2      	; 0x2b4a <vfprintf+0x31a>
    2b48:	b3 94       	inc	r11
    2b4a:	a3 fc       	sbrc	r10, 3
    2b4c:	10 c0       	rjmp	.+32     	; 0x2b6e <vfprintf+0x33e>
    2b4e:	a0 fe       	sbrs	r10, 0
    2b50:	06 c0       	rjmp	.+12     	; 0x2b5e <vfprintf+0x32e>
    2b52:	b2 14       	cp	r11, r2
    2b54:	80 f4       	brcc	.+32     	; 0x2b76 <vfprintf+0x346>
    2b56:	28 0c       	add	r2, r8
    2b58:	92 2c       	mov	r9, r2
    2b5a:	9b 18       	sub	r9, r11
    2b5c:	0d c0       	rjmp	.+26     	; 0x2b78 <vfprintf+0x348>
    2b5e:	b2 14       	cp	r11, r2
    2b60:	58 f4       	brcc	.+22     	; 0x2b78 <vfprintf+0x348>
    2b62:	b6 01       	movw	r22, r12
    2b64:	80 e2       	ldi	r24, 0x20	; 32
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	76 d0       	rcall	.+236    	; 0x2c56 <fputc>
    2b6a:	b3 94       	inc	r11
    2b6c:	f8 cf       	rjmp	.-16     	; 0x2b5e <vfprintf+0x32e>
    2b6e:	b2 14       	cp	r11, r2
    2b70:	18 f4       	brcc	.+6      	; 0x2b78 <vfprintf+0x348>
    2b72:	2b 18       	sub	r2, r11
    2b74:	02 c0       	rjmp	.+4      	; 0x2b7a <vfprintf+0x34a>
    2b76:	98 2c       	mov	r9, r8
    2b78:	21 2c       	mov	r2, r1
    2b7a:	a4 fe       	sbrs	r10, 4
    2b7c:	0f c0       	rjmp	.+30     	; 0x2b9c <vfprintf+0x36c>
    2b7e:	b6 01       	movw	r22, r12
    2b80:	80 e3       	ldi	r24, 0x30	; 48
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	68 d0       	rcall	.+208    	; 0x2c56 <fputc>
    2b86:	a2 fe       	sbrs	r10, 2
    2b88:	16 c0       	rjmp	.+44     	; 0x2bb6 <vfprintf+0x386>
    2b8a:	a1 fc       	sbrc	r10, 1
    2b8c:	03 c0       	rjmp	.+6      	; 0x2b94 <vfprintf+0x364>
    2b8e:	88 e7       	ldi	r24, 0x78	; 120
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	02 c0       	rjmp	.+4      	; 0x2b98 <vfprintf+0x368>
    2b94:	88 e5       	ldi	r24, 0x58	; 88
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	b6 01       	movw	r22, r12
    2b9a:	0c c0       	rjmp	.+24     	; 0x2bb4 <vfprintf+0x384>
    2b9c:	8a 2d       	mov	r24, r10
    2b9e:	86 78       	andi	r24, 0x86	; 134
    2ba0:	51 f0       	breq	.+20     	; 0x2bb6 <vfprintf+0x386>
    2ba2:	a1 fe       	sbrs	r10, 1
    2ba4:	02 c0       	rjmp	.+4      	; 0x2baa <vfprintf+0x37a>
    2ba6:	8b e2       	ldi	r24, 0x2B	; 43
    2ba8:	01 c0       	rjmp	.+2      	; 0x2bac <vfprintf+0x37c>
    2baa:	80 e2       	ldi	r24, 0x20	; 32
    2bac:	a7 fc       	sbrc	r10, 7
    2bae:	8d e2       	ldi	r24, 0x2D	; 45
    2bb0:	b6 01       	movw	r22, r12
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	50 d0       	rcall	.+160    	; 0x2c56 <fputc>
    2bb6:	89 14       	cp	r8, r9
    2bb8:	30 f4       	brcc	.+12     	; 0x2bc6 <vfprintf+0x396>
    2bba:	b6 01       	movw	r22, r12
    2bbc:	80 e3       	ldi	r24, 0x30	; 48
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	4a d0       	rcall	.+148    	; 0x2c56 <fputc>
    2bc2:	9a 94       	dec	r9
    2bc4:	f8 cf       	rjmp	.-16     	; 0x2bb6 <vfprintf+0x386>
    2bc6:	8a 94       	dec	r8
    2bc8:	f3 01       	movw	r30, r6
    2bca:	e8 0d       	add	r30, r8
    2bcc:	f1 1d       	adc	r31, r1
    2bce:	80 81       	ld	r24, Z
    2bd0:	b6 01       	movw	r22, r12
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	40 d0       	rcall	.+128    	; 0x2c56 <fputc>
    2bd6:	81 10       	cpse	r8, r1
    2bd8:	f6 cf       	rjmp	.-20     	; 0x2bc6 <vfprintf+0x396>
    2bda:	22 20       	and	r2, r2
    2bdc:	09 f4       	brne	.+2      	; 0x2be0 <vfprintf+0x3b0>
    2bde:	4e ce       	rjmp	.-868    	; 0x287c <vfprintf+0x4c>
    2be0:	b6 01       	movw	r22, r12
    2be2:	80 e2       	ldi	r24, 0x20	; 32
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	37 d0       	rcall	.+110    	; 0x2c56 <fputc>
    2be8:	2a 94       	dec	r2
    2bea:	f7 cf       	rjmp	.-18     	; 0x2bda <vfprintf+0x3aa>
    2bec:	f6 01       	movw	r30, r12
    2bee:	86 81       	ldd	r24, Z+6	; 0x06
    2bf0:	97 81       	ldd	r25, Z+7	; 0x07
    2bf2:	02 c0       	rjmp	.+4      	; 0x2bf8 <vfprintf+0x3c8>
    2bf4:	8f ef       	ldi	r24, 0xFF	; 255
    2bf6:	9f ef       	ldi	r25, 0xFF	; 255
    2bf8:	2b 96       	adiw	r28, 0x0b	; 11
    2bfa:	0f b6       	in	r0, 0x3f	; 63
    2bfc:	f8 94       	cli
    2bfe:	de bf       	out	0x3e, r29	; 62
    2c00:	0f be       	out	0x3f, r0	; 63
    2c02:	cd bf       	out	0x3d, r28	; 61
    2c04:	df 91       	pop	r29
    2c06:	cf 91       	pop	r28
    2c08:	1f 91       	pop	r17
    2c0a:	0f 91       	pop	r16
    2c0c:	ff 90       	pop	r15
    2c0e:	ef 90       	pop	r14
    2c10:	df 90       	pop	r13
    2c12:	cf 90       	pop	r12
    2c14:	bf 90       	pop	r11
    2c16:	af 90       	pop	r10
    2c18:	9f 90       	pop	r9
    2c1a:	8f 90       	pop	r8
    2c1c:	7f 90       	pop	r7
    2c1e:	6f 90       	pop	r6
    2c20:	5f 90       	pop	r5
    2c22:	4f 90       	pop	r4
    2c24:	3f 90       	pop	r3
    2c26:	2f 90       	pop	r2
    2c28:	08 95       	ret

00002c2a <strnlen_P>:
    2c2a:	fc 01       	movw	r30, r24
    2c2c:	05 90       	lpm	r0, Z+
    2c2e:	61 50       	subi	r22, 0x01	; 1
    2c30:	70 40       	sbci	r23, 0x00	; 0
    2c32:	01 10       	cpse	r0, r1
    2c34:	d8 f7       	brcc	.-10     	; 0x2c2c <strnlen_P+0x2>
    2c36:	80 95       	com	r24
    2c38:	90 95       	com	r25
    2c3a:	8e 0f       	add	r24, r30
    2c3c:	9f 1f       	adc	r25, r31
    2c3e:	08 95       	ret

00002c40 <strnlen>:
    2c40:	fc 01       	movw	r30, r24
    2c42:	61 50       	subi	r22, 0x01	; 1
    2c44:	70 40       	sbci	r23, 0x00	; 0
    2c46:	01 90       	ld	r0, Z+
    2c48:	01 10       	cpse	r0, r1
    2c4a:	d8 f7       	brcc	.-10     	; 0x2c42 <strnlen+0x2>
    2c4c:	80 95       	com	r24
    2c4e:	90 95       	com	r25
    2c50:	8e 0f       	add	r24, r30
    2c52:	9f 1f       	adc	r25, r31
    2c54:	08 95       	ret

00002c56 <fputc>:
    2c56:	0f 93       	push	r16
    2c58:	1f 93       	push	r17
    2c5a:	cf 93       	push	r28
    2c5c:	df 93       	push	r29
    2c5e:	fb 01       	movw	r30, r22
    2c60:	23 81       	ldd	r18, Z+3	; 0x03
    2c62:	21 fd       	sbrc	r18, 1
    2c64:	03 c0       	rjmp	.+6      	; 0x2c6c <fputc+0x16>
    2c66:	8f ef       	ldi	r24, 0xFF	; 255
    2c68:	9f ef       	ldi	r25, 0xFF	; 255
    2c6a:	2c c0       	rjmp	.+88     	; 0x2cc4 <fputc+0x6e>
    2c6c:	22 ff       	sbrs	r18, 2
    2c6e:	16 c0       	rjmp	.+44     	; 0x2c9c <fputc+0x46>
    2c70:	46 81       	ldd	r20, Z+6	; 0x06
    2c72:	57 81       	ldd	r21, Z+7	; 0x07
    2c74:	24 81       	ldd	r18, Z+4	; 0x04
    2c76:	35 81       	ldd	r19, Z+5	; 0x05
    2c78:	42 17       	cp	r20, r18
    2c7a:	53 07       	cpc	r21, r19
    2c7c:	44 f4       	brge	.+16     	; 0x2c8e <fputc+0x38>
    2c7e:	a0 81       	ld	r26, Z
    2c80:	b1 81       	ldd	r27, Z+1	; 0x01
    2c82:	9d 01       	movw	r18, r26
    2c84:	2f 5f       	subi	r18, 0xFF	; 255
    2c86:	3f 4f       	sbci	r19, 0xFF	; 255
    2c88:	31 83       	std	Z+1, r19	; 0x01
    2c8a:	20 83       	st	Z, r18
    2c8c:	8c 93       	st	X, r24
    2c8e:	26 81       	ldd	r18, Z+6	; 0x06
    2c90:	37 81       	ldd	r19, Z+7	; 0x07
    2c92:	2f 5f       	subi	r18, 0xFF	; 255
    2c94:	3f 4f       	sbci	r19, 0xFF	; 255
    2c96:	37 83       	std	Z+7, r19	; 0x07
    2c98:	26 83       	std	Z+6, r18	; 0x06
    2c9a:	14 c0       	rjmp	.+40     	; 0x2cc4 <fputc+0x6e>
    2c9c:	8b 01       	movw	r16, r22
    2c9e:	ec 01       	movw	r28, r24
    2ca0:	fb 01       	movw	r30, r22
    2ca2:	00 84       	ldd	r0, Z+8	; 0x08
    2ca4:	f1 85       	ldd	r31, Z+9	; 0x09
    2ca6:	e0 2d       	mov	r30, r0
    2ca8:	09 95       	icall
    2caa:	89 2b       	or	r24, r25
    2cac:	e1 f6       	brne	.-72     	; 0x2c66 <fputc+0x10>
    2cae:	d8 01       	movw	r26, r16
    2cb0:	16 96       	adiw	r26, 0x06	; 6
    2cb2:	8d 91       	ld	r24, X+
    2cb4:	9c 91       	ld	r25, X
    2cb6:	17 97       	sbiw	r26, 0x07	; 7
    2cb8:	01 96       	adiw	r24, 0x01	; 1
    2cba:	17 96       	adiw	r26, 0x07	; 7
    2cbc:	9c 93       	st	X, r25
    2cbe:	8e 93       	st	-X, r24
    2cc0:	16 97       	sbiw	r26, 0x06	; 6
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	08 95       	ret

00002cce <__ultoa_invert>:
    2cce:	fa 01       	movw	r30, r20
    2cd0:	aa 27       	eor	r26, r26
    2cd2:	28 30       	cpi	r18, 0x08	; 8
    2cd4:	51 f1       	breq	.+84     	; 0x2d2a <__ultoa_invert+0x5c>
    2cd6:	20 31       	cpi	r18, 0x10	; 16
    2cd8:	81 f1       	breq	.+96     	; 0x2d3a <__ultoa_invert+0x6c>
    2cda:	e8 94       	clt
    2cdc:	6f 93       	push	r22
    2cde:	6e 7f       	andi	r22, 0xFE	; 254
    2ce0:	6e 5f       	subi	r22, 0xFE	; 254
    2ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce4:	8f 4f       	sbci	r24, 0xFF	; 255
    2ce6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ce8:	af 4f       	sbci	r26, 0xFF	; 255
    2cea:	b1 e0       	ldi	r27, 0x01	; 1
    2cec:	3e d0       	rcall	.+124    	; 0x2d6a <__ultoa_invert+0x9c>
    2cee:	b4 e0       	ldi	r27, 0x04	; 4
    2cf0:	3c d0       	rcall	.+120    	; 0x2d6a <__ultoa_invert+0x9c>
    2cf2:	67 0f       	add	r22, r23
    2cf4:	78 1f       	adc	r23, r24
    2cf6:	89 1f       	adc	r24, r25
    2cf8:	9a 1f       	adc	r25, r26
    2cfa:	a1 1d       	adc	r26, r1
    2cfc:	68 0f       	add	r22, r24
    2cfe:	79 1f       	adc	r23, r25
    2d00:	8a 1f       	adc	r24, r26
    2d02:	91 1d       	adc	r25, r1
    2d04:	a1 1d       	adc	r26, r1
    2d06:	6a 0f       	add	r22, r26
    2d08:	71 1d       	adc	r23, r1
    2d0a:	81 1d       	adc	r24, r1
    2d0c:	91 1d       	adc	r25, r1
    2d0e:	a1 1d       	adc	r26, r1
    2d10:	20 d0       	rcall	.+64     	; 0x2d52 <__ultoa_invert+0x84>
    2d12:	09 f4       	brne	.+2      	; 0x2d16 <__ultoa_invert+0x48>
    2d14:	68 94       	set
    2d16:	3f 91       	pop	r19
    2d18:	2a e0       	ldi	r18, 0x0A	; 10
    2d1a:	26 9f       	mul	r18, r22
    2d1c:	11 24       	eor	r1, r1
    2d1e:	30 19       	sub	r19, r0
    2d20:	30 5d       	subi	r19, 0xD0	; 208
    2d22:	31 93       	st	Z+, r19
    2d24:	de f6       	brtc	.-74     	; 0x2cdc <__ultoa_invert+0xe>
    2d26:	cf 01       	movw	r24, r30
    2d28:	08 95       	ret
    2d2a:	46 2f       	mov	r20, r22
    2d2c:	47 70       	andi	r20, 0x07	; 7
    2d2e:	40 5d       	subi	r20, 0xD0	; 208
    2d30:	41 93       	st	Z+, r20
    2d32:	b3 e0       	ldi	r27, 0x03	; 3
    2d34:	0f d0       	rcall	.+30     	; 0x2d54 <__ultoa_invert+0x86>
    2d36:	c9 f7       	brne	.-14     	; 0x2d2a <__ultoa_invert+0x5c>
    2d38:	f6 cf       	rjmp	.-20     	; 0x2d26 <__ultoa_invert+0x58>
    2d3a:	46 2f       	mov	r20, r22
    2d3c:	4f 70       	andi	r20, 0x0F	; 15
    2d3e:	40 5d       	subi	r20, 0xD0	; 208
    2d40:	4a 33       	cpi	r20, 0x3A	; 58
    2d42:	18 f0       	brcs	.+6      	; 0x2d4a <__ultoa_invert+0x7c>
    2d44:	49 5d       	subi	r20, 0xD9	; 217
    2d46:	31 fd       	sbrc	r19, 1
    2d48:	40 52       	subi	r20, 0x20	; 32
    2d4a:	41 93       	st	Z+, r20
    2d4c:	02 d0       	rcall	.+4      	; 0x2d52 <__ultoa_invert+0x84>
    2d4e:	a9 f7       	brne	.-22     	; 0x2d3a <__ultoa_invert+0x6c>
    2d50:	ea cf       	rjmp	.-44     	; 0x2d26 <__ultoa_invert+0x58>
    2d52:	b4 e0       	ldi	r27, 0x04	; 4
    2d54:	a6 95       	lsr	r26
    2d56:	97 95       	ror	r25
    2d58:	87 95       	ror	r24
    2d5a:	77 95       	ror	r23
    2d5c:	67 95       	ror	r22
    2d5e:	ba 95       	dec	r27
    2d60:	c9 f7       	brne	.-14     	; 0x2d54 <__ultoa_invert+0x86>
    2d62:	00 97       	sbiw	r24, 0x00	; 0
    2d64:	61 05       	cpc	r22, r1
    2d66:	71 05       	cpc	r23, r1
    2d68:	08 95       	ret
    2d6a:	9b 01       	movw	r18, r22
    2d6c:	ac 01       	movw	r20, r24
    2d6e:	0a 2e       	mov	r0, r26
    2d70:	06 94       	lsr	r0
    2d72:	57 95       	ror	r21
    2d74:	47 95       	ror	r20
    2d76:	37 95       	ror	r19
    2d78:	27 95       	ror	r18
    2d7a:	ba 95       	dec	r27
    2d7c:	c9 f7       	brne	.-14     	; 0x2d70 <__ultoa_invert+0xa2>
    2d7e:	62 0f       	add	r22, r18
    2d80:	73 1f       	adc	r23, r19
    2d82:	84 1f       	adc	r24, r20
    2d84:	95 1f       	adc	r25, r21
    2d86:	a0 1d       	adc	r26, r0
    2d88:	08 95       	ret

00002d8a <eeprom_read_word>:
    2d8a:	a8 e1       	ldi	r26, 0x18	; 24
    2d8c:	b0 e0       	ldi	r27, 0x00	; 0
    2d8e:	42 e0       	ldi	r20, 0x02	; 2
    2d90:	50 e0       	ldi	r21, 0x00	; 0
    2d92:	05 c0       	rjmp	.+10     	; 0x2d9e <eeprom_read_blraw>

00002d94 <eeprom_write_word>:
    2d94:	12 d0       	rcall	.+36     	; 0x2dba <eeprom_write_byte>
    2d96:	27 2f       	mov	r18, r23
    2d98:	11 c0       	rjmp	.+34     	; 0x2dbc <eeprom_write_r18>

00002d9a <eeprom_read_block>:
    2d9a:	dc 01       	movw	r26, r24
    2d9c:	cb 01       	movw	r24, r22

00002d9e <eeprom_read_blraw>:
    2d9e:	fc 01       	movw	r30, r24
    2da0:	f9 99       	sbic	0x1f, 1	; 31
    2da2:	fe cf       	rjmp	.-4      	; 0x2da0 <eeprom_read_blraw+0x2>
    2da4:	06 c0       	rjmp	.+12     	; 0x2db2 <eeprom_read_blraw+0x14>
    2da6:	f2 bd       	out	0x22, r31	; 34
    2da8:	e1 bd       	out	0x21, r30	; 33
    2daa:	f8 9a       	sbi	0x1f, 0	; 31
    2dac:	31 96       	adiw	r30, 0x01	; 1
    2dae:	00 b4       	in	r0, 0x20	; 32
    2db0:	0d 92       	st	X+, r0
    2db2:	41 50       	subi	r20, 0x01	; 1
    2db4:	50 40       	sbci	r21, 0x00	; 0
    2db6:	b8 f7       	brcc	.-18     	; 0x2da6 <eeprom_read_blraw+0x8>
    2db8:	08 95       	ret

00002dba <eeprom_write_byte>:
    2dba:	26 2f       	mov	r18, r22

00002dbc <eeprom_write_r18>:
    2dbc:	f9 99       	sbic	0x1f, 1	; 31
    2dbe:	fe cf       	rjmp	.-4      	; 0x2dbc <eeprom_write_r18>
    2dc0:	92 bd       	out	0x22, r25	; 34
    2dc2:	81 bd       	out	0x21, r24	; 33
    2dc4:	20 bd       	out	0x20, r18	; 32
    2dc6:	0f b6       	in	r0, 0x3f	; 63
    2dc8:	f8 94       	cli
    2dca:	fa 9a       	sbi	0x1f, 2	; 31
    2dcc:	f9 9a       	sbi	0x1f, 1	; 31
    2dce:	0f be       	out	0x3f, r0	; 63
    2dd0:	01 96       	adiw	r24, 0x01	; 1
    2dd2:	08 95       	ret

00002dd4 <_exit>:
    2dd4:	f8 94       	cli

00002dd6 <__stop_program>:
    2dd6:	ff cf       	rjmp	.-2      	; 0x2dd6 <__stop_program>
